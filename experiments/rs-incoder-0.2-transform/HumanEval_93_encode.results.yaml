language: rs
name: HumanEval_93_encode
results:
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_index\
    \ = 0;\n    let mut letters_index = 0;\n    let mut current_letter = String::new();\n\
    \    let mut current_vowel = String::new();\n    let mut current_vowel_pos = 0;\n\
    \    let mut current_letter_pos = 0;\n    for letter in message {\n        if\
    \ letter == ' ' {\n            result.push_str(&current_letter);\n           \
    \ current_letter = String::new();\n            current_letter_pos = 0;\n     \
    \   } else {\n            current_letter.push_str(&letters[letters_index]);\n\
    \            current_letter_pos += 1;\n        }\n        if letter in vowels\
    \ {\n            if current_vowel_pos == 0 {\n                current_vowel.push_str(&vowels[vowels_index]);\n\
    \                current_vowel_pos = 1;\n            } else {\n              \
    \  current_vowel.push_str(&vowels[vowels_index]);\n                current_vowel_pos\
    \ += 1;\n            }\n        } else {\n            if current_vowel_pos ==\
    \ 0 {\n                current_vowel.push_str(&vowels[vowels_index]);\n      \
    \          current_vowel_pos = 1;\n            } else {\n                current_vowel.push_str(&vowels[vowels_index]);\n\
    \                current_vowel_pos += 1;\n            }\n        }\n        if\
    \ letters_index == letters.len() - 1 {\n            result.push_str(&current_vowel);\n\
    \            current_vowel = String::new();\n            current_vowel_pos = 0;\n\
    \        } else {\n            current_vowel.push_str(&vowels[vowels_index]);\n\
    \            current_vowel_pos += 1;\n        }\n        letters_index += 1;\n\
    \    }\n    if current_vowel_pos != 0 {\n        result.push_str(&current_vowel);\n\
    \    }\n    if current_letter_pos != 0 {\n        result.push_str(&current_letter);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp1_ft9qkq.rs:30:19\n\
    \   |\n30 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp1_ft9qkq.rs:21:19\n\
    \   |\n21 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    while i < message.len() {\n  \
    \      if let Some(letter) = message.chars().nth(i) {\n            if let Some(vowel)\
    \ = vowels.iter().position(|&x| x == letter) {\n                result.push((letters[vowel]\
    \ + letters[vowel + 1]).to_string());\n                i += 2;\n            }\
    \ else {\n                result.push(letter);\n                i += 1;\n    \
    \        }\n        } else {\n            result.push('_');\n            i +=\
    \ 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpv13m7ski.rs:19:45\n\
    \   |\n19 |                 result.push((letters[vowel] + letters[vowel + 1]).to_string());\n\
    \   |                              -------------- ^ ------------------ char\n\
    \   |                              |\n   |                              char\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message {\n        if letter == ' ' {\n            result.push_str(\"\
    \ \");\n        } else {\n            result.push_str(&vowels[vowels_index]);\n\
    \            result.push_str(&vowels[vowels_index + 1]);\n            result.push_str(&vowels[vowels_index\
    \ + 2]);\n            result.push_str(&vowels[vowels_index + 3]);\n          \
    \  result.push_str(&vowels[vowels_index + 4]);\n            result.push_str(&vowels[vowels_index\
    \ + 5]);\n            result.push_str(&vowels[vowels_index + 6]);\n          \
    \  result.push_str(&vowels[vowels_index + 7]);\n            result.push_str(&vowels[vowels_index\
    \ + 8]);\n            result.push_str(&vowels[vowels_index + 9]);\n          \
    \  result.push_str(&vowels[vowels_index + 10]);\n            result.push_str(&vowels[vowels_index\
    \ + 11]);\n            result.push_str(&vowels[vowels_index + 12]);\n        \
    \    result.push_str(&vowels[vowels_index + 13]);\n            result.push_str(&vowels[vowels_index\
    \ + 14]);\n            result.push_str(&vowels[vowels_index + 15]);\n        \
    \    result.push_str(&vowels[vowels_index + 16]);\n            result.push_str(&vowels[vowels_index\
    \ + 17]);\n            result.push_str(&vowels[vowels_index + 18]);\n        \
    \    result.push_str(&vowels[vowels_index + 19]);\n            result.push_str(&vowels[vowels_index\
    \ + 20]);\n            result.push_str(&vowels[vowels_index + 21]);\n        \
    \    result.push_str(&vowels[vowels_index + 22]);\n            result.push_str(&vowels[vowels_index\
    \ + 23]);\n            result.push_str(&vowels[vowels_index + 24]);\n        \
    \    result.push_str(&vowels[vowels_index + 25]);\n            result.push_str(&vowels[vowels_index\
    \ + 26]);\n            result.push_str(&vowels[vowels_index + 27]);\n        \
    \    result.push_str(&vowels[vowels_index + 28]);\n            result.push_str(&vowels[vowels_index\
    \ + 29]);\n            result.push_str(&vowels[vowels_index + 30]);\n        \
    \    result.push_str(&vowels[vowels_index + 31]);\n            result.push_str(&vowels[vowels_index\
    \ + 32]);\n            result.push_str(&vowels[vowels_index + 33]);\n        \
    \    result.push_str(&vowels[vowels_index + 34]);\n            result.push_str(&vowels[vowels_index\
    \ + 35]);\n            result.push_str(&vowels[vowels_index + 36]);\n        \
    \    result.push_str(&vowel\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpoin2t6tc.rs:67:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n16 |     for letter in message {\n\
    \   |                           - unclosed delimiter\n...\n19 |         } else\
    \ {\n   |                - this delimiter might not be properly closed...\n...\n\
    58 | }\n   | - ...as it matches this but it has different indentation\n...\n67\
    \ | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpoin2t6tc.rs:57:28\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n57 |     \
    \        result.push_str(&vowel\n   |                            ^ unclosed delimiter\n\
    58 | }\n   | ^ mismatched closing delimiter\n\nerror[E0425]: cannot find value\
    \ `vowel` in this scope\n  --> /tmp/tmpoin2t6tc.rs:57:30\n   |\n57 |         \
    \    result.push_str(&vowel\n   |                              ^^^^^ help: a local\
    \ variable with a similar name exists: `vowels`\n\nerror[E0277]: `String` is not\
    \ an iterator\n  --> /tmp/tmpoin2t6tc.rs:16:19\n   |\n16 |     for letter in message\
    \ {\n   |                   ^^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoin2t6tc.rs:20:29\n\
    \   |\n20 |             result.push_str(&vowels[vowels_index]);\n   |        \
    \                     ^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpoin2t6tc.rs:21:29\n   |\n21 |\
    \             result.push_str(&vowels[vowels_index + 1]);\n   |              \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tm"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = HashSet::new();\n    let mut vowels_counter2 = HashSet::new();\n\
    \    let mut vowels_counter3 = HashSet::new();\n    let mut vowels_counter4 =\
    \ HashSet::new();\n    let mut vowels_counter5 = HashSet::new();\n    let mut\
    \ vowels_counter6 = HashSet::new();\n    let mut vowels_counter7 = HashSet::new();\n\
    \    let mut vowels_counter8 = HashSet::new();\n    let mut vowels_counter9 =\
    \ HashSet::new();\n    let mut vowels_counter10 = HashSet::new();\n    let mut\
    \ vowels_counter11 = HashSet::new();\n    let mut vowels_counter12 = HashSet::new();\n\
    \    let mut vowels_counter13 = HashSet::new();\n    let mut vowels_counter14\
    \ = HashSet::new();\n    let mut vowels_counter15 = HashSet::new();\n    let mut\
    \ vowels_counter16 = HashSet::new();\n    let mut vowels_counter17 = HashSet::new();\n\
    \    let mut vowels_counter18 = HashSet::new();\n    let mut vowels_counter19\
    \ = HashSet::new();\n    let mut vowels_counter20 = HashSet::new();\n    let mut\
    \ vowels_counter21 = HashSet::new();\n    let mut vowels_counter22 = HashSet::new();\n\
    \    let mut vowels_counter23 = HashSet::new();\n    let mut vowels_counter24\
    \ = HashSet::new();\n    let mut vowels_counter25 = HashSet::new();\n    let mut\
    \ vowels_counter26 = HashSet::new();\n    let mut vowels_counter27 = HashSet::new();\n\
    \    let mut vowels_counter28 = HashSet::new();\n    let mut vowels_counter29\
    \ = HashSet::new();\n    let mut vowels_counter30 = HashSet::new();\n    let mut\
    \ vowels_counter31 = HashSet::new();\n    let mut vowels_counter32 = HashSet::new();\n\
    \    let mut vowels_counter33 = HashSet::new();\n    let mut vowels_counter34\
    \ = HashSet::new();\n    let mut vowels_counter35 = HashSet::new();\n    let mut\
    \ vowels_counter36 = HashSet::new();\n\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpnyp8oang.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpnyp8oang.rs:14:30\n\
    \   |\n14 |     let mut vowels_counter = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpnyp8oang.rs:15:31\n\
    \   |\n15 |     let mut vowels_counter2 = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpnyp8oang.rs:16:31\n\
    \   |\n16 |     let mut vowels_counter3 = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpnyp8oang.rs:17:31\n\
    \   |\n17 |     let mut vowels_counter4 = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpnyp8oang.rs:18:31\n\
    \   |\n18 |     let mut vowels_counter5 = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpnyp8oang.rs:19:31\n\
    \   |\n19 |     let mut vowels_counter6 = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found i"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letter_counter = vec!['Z', 'Y', 'X', 'W',\
    \ 'V', 'U', 'T', 'S', 'R', 'Q', 'P', 'O', 'N', 'M', 'L', 'D', 'G', 'F', 'B', 'H',\
    \ 'J', 'K', 'J', 'I', 'D', 'Z', 'Y', 'X', 'W', 'V', 'U', 'T', 'S', 'R', 'Q', 'P',\
    \ 'O', 'N', 'M', 'L', 'D', 'G', 'F', 'B', 'H', 'J', 'K', 'J', 'I', 'D'];\n   \
    \ let mut letter_counter2 = vec!['Z', 'Y', 'X', 'W', 'V', 'U', 'T', 'S', 'R',\
    \ 'Q', 'P', 'O', 'N', 'M', 'L', 'D', 'G', 'F', 'B', 'H', 'J', 'K', 'J', 'I', 'D',\
    \ 'Z', 'Y', 'X', 'W', 'V', 'U', 'T', 'S', 'R', 'Q', 'P', 'O', 'N', 'M', 'L', 'D',\
    \ 'G', 'F', 'B', 'H', 'J', 'K', 'J', 'I', 'D'];\n    let mut letter_counter3 =\
    \ vec!['Z', 'Y', 'X', 'W', 'V', 'U', 'T', 'S', 'R', 'Q', 'P', 'O', 'N', 'M', 'L',\
    \ 'D', 'G', 'F', 'B', 'H', 'J', 'K', 'J', 'I', 'D', 'Z', 'Y', 'X', 'W', 'V', 'U',\
    \ 'T', 'S', 'R', 'Q', 'P', 'O', 'N', 'M', 'L', 'D', 'G', 'F', 'B', 'H', 'J', 'K',\
    \ 'J', 'I', 'D'];\n    let mut letter_counter4 = vec!['Z', 'Y', 'X', 'W', 'V',\
    \ 'U', 'T', 'S', 'R', 'Q', 'P', 'O', 'N', 'M', 'L', 'D', 'G', 'F', 'B', 'H', 'J',\
    \ 'K', 'J', 'I', 'D', 'Z', 'Y', 'X', 'W', 'V', 'U', 'T', 'S', 'R', 'Q', 'P', 'O',\
    \ 'N', 'M', 'L', 'D', 'G', 'F', 'B', 'H', 'J', 'K', 'J', 'I', 'D'];\n    let mut\
    \ letter_counter5 = vec!['Z', 'Y', 'X', 'W', 'V', 'U', 'T', 'S', 'R', 'Q', 'P',\
    \ 'O', 'N', 'M', 'L', 'D', 'G', 'F', 'B', 'H', 'J', 'K', 'J', 'I', 'D', 'Z', 'Y',\
    \ 'X', 'W', 'V', 'U', 'T', 'S', 'R', 'Q', 'P', 'O', 'N', 'M', 'L', 'D', 'G', 'F',\
    \ 'B', 'H', 'J', 'K', 'J', 'I', 'D'];\n    let mut letter_counter6 = vec!['Z',\
    \ 'Y', 'X', 'W', 'V\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp3vfl0gv9.rs:20:1\n   |\n20 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp3vfl0gv9.rs:19:35\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n19 |     let mut letter_counter6 = vec!['Z', 'Y', 'X', 'W', 'V\n\
    \   |                                   ^ unclosed delimiter\n20 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letter_pairs = vec!['AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmp4tmr1lfu.rs:14:33\n\
    \   |\n14 |     let mut letter_pairs = vec!['AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIO...\n   | \
    \                                ^^^^^^^^\n   |\nhelp: if you meant to write a\
    \ `str` literal, use double quotes\n   |\n14 |     let mut letter_pairs = vec![\"\
    AEIOUY\", 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY\n   |  \
    \                               ~~~~~~~~\n\nerror: character literal may only\
    \ contain one codepoint\n  --> /tmp/tmp4tmr1lfu.rs:14:43\n   |\n14 |     let mut\
    \ letter_pairs = vec!['AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY',\
    \ 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIO...\n   |                     \
    \                      ^^^^^^^^\n   |\nhelp: if you meant to write a `str` literal,\
    \ use double quotes\n   |\n14 |     let mut letter_pairs = vec!['AEIOUY', \"AEIOUY\"\
    , 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AEIOUY', 'AE"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.binary_search(&letter) {\n          \
    \  encoded.push_str(&letters[vowel]);\n            vowels.remove(vowel);\n   \
    \     } else {\n            encoded.push_str(&letters[letter]);\n        }\n \
    \   }\n    for vowel in vowels {\n        encoded.push_str(&vowels[vowel]);\n\
    \    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgwu6emk1.rs:17:16\n   |\n\
    17 |         if let Some(vowel) = vowels.binary_search(&letter) {\n   |      \
    \          ^^^^^^^^^^^   ----------------------------- this expression has type\
    \ `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror[E0271]: type mismatch\
    \ resolving `<usize as SliceIndex<[char]>>::Output == str`\n  --> /tmp/tmpgwu6emk1.rs:18:31\n\
    \   |\n18 |             encoded.push_str(&letters[vowel]);\n   |             \
    \                  ^^^^^^^^^^^^^^ expected `char`, found `str`\n\nerror[E0277]:\
    \ the type `[char]` cannot be indexed by `char`\n  --> /tmp/tmpgwu6emk1.rs:21:31\n\
    \   |\n21 |             encoded.push_str(&letters[letter]);\n   |            \
    \                   ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[char]>` is not implemented\
    \ for `char`\n   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<char>`\n\nerror[E0277]: the type `[char]` cannot be indexed by `char`\n\
    \  --> /tmp/tmpgwu6emk1.rs:25:27\n   |\n25 |         encoded.push_str(&vowels[vowel]);\n\
    \   |                           ^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[char]>` is not\
    \ implemented for `char`\n   = note: required because of the requirements on the\
    \ impl of `Index<char>` for `Vec<char>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0271, E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::new();\n\
    \    let mut vowels_encoded = String::new();\n    let mut vowels_encoded1 = String::new();\n\
    \    let mut vowels_encoded2 = String::new();\n    let mut vowels_encoded3 = String::new();\n\
    \    let mut vowels_encoded4 = String::new();\n    let mut vowels_encoded5 = String::new();\n\
    \    let mut vowels_encoded6 = String::new();\n    let mut vowels_encoded7 = String::new();\n\
    \    let mut vowels_encoded8 = String::new();\n    let mut vowels_encoded9 = String::new();\n\
    \    let mut vowels_encoded10 = String::new();\n    let mut vowels_encoded11 =\
    \ String::new();\n    let mut vowels_encoded12 = String::new();\n    let mut vowels_encoded13\
    \ = String::new();\n    let mut vowels_encoded14 = String::new();\n    let mut\
    \ vowels_encoded15 = String::new();\n    let mut vowels_encoded16 = String::new();\n\
    \    let mut vowels_encoded17 = String::new();\n    let mut vowels_encoded18 =\
    \ String::new();\n    let mut vowels_encoded19 = String::new();\n    let mut vowels_encoded20\
    \ = String::new();\n    let mut vowels_encoded21 = String::new();\n    let mut\
    \ vowels_encoded22 = String::new();\n    let mut vowels_encoded23 = String::new();\n\
    \    let mut vowels_encoded24 = String::new();\n    let mut vowels_encoded25 =\
    \ String::new();\n    let mut vowels_encoded26 = String::new();\n    let mut vowels_encoded27\
    \ = String::new();\n    let mut vowels_encoded28 = String::new();\n    let mut\
    \ vowels_encoded29 = String::new();\n    let mut vowels_encoded30 = String::new();\n\
    \    let mut vowels_encoded31 = String::new();\n    let mut vowels_encoded32 =\
    \ String::new();\n    let mut vowels_encoded33 = String::new();\n    let mut vowels_encoded34\
    \ = String::new();\n    let mut vowels_encoded35 = String::new();\n    let mut\
    \ vowels_encoded36 = String::new();\n    let mut vowels_encoded37 = String::new();\n\
    \    let mut vowels_encoded38 = String::new\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp03qeqrs6.rs:52:43\n   |\n\
    52 |     let mut vowels_encoded38 = String::new\n   |                        \
    \                   ^ help: add `;` here\n53 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp03qeqrs6.rs:11:31\n   |\n11 | fn\
    \ encode(message: String) -> String {\n   |    ------                     ^^^^^^\
    \ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    for c in message.chars() {\n     \
    \   if c.is_uppercase() {\n            letters.insert(c.to_lowercase());\n   \
    \     } else {\n            letters.insert(c.to_uppercase());\n        }\n   \
    \ }\n    for c in letters.iter() {\n        if vowels.contains(&c) {\n       \
    \     result.push(c);\n        } else {\n            result.push(c.to_ascii_lowercase().to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp76ukg50z.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp76ukg50z.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp76ukg50z.rs:26:25\n   |\n26 |             result.push(c.to_ascii_lowercase().to_string());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut letters = \"bcdfghjklmnpqrstvwxyz\".to_string();\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    for c in\
    \ message.chars() {\n        if let Some(vowel) = vowels.chars().position(|c|\
    \ *c == c) {\n            vowel_counter += 1;\n            if vowel_counter ==\
    \ 2 {\n                result.push(*vowel);\n                vowel_counter = 0;\n\
    \            }\n        } else {\n            if letter_counter == 2 && letter_counter\
    \ < message.len() {\n                result.push(*letters.chars().position(|c|\
    \ *c == c).unwrap());\n                letter_counter = 0;\n            } else\
    \ {\n                result.push(c);\n                letter_counter += 1;\n \
    \           }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpdmj8hv6y.rs:18:58\n\
    \   |\n18 |         if let Some(vowel) = vowels.chars().position(|c| *c == c)\
    \ {\n   |                                                          ^^\n\nerror[E0614]:\
    \ type `usize` cannot be dereferenced\n  --> /tmp/tmpdmj8hv6y.rs:21:29\n   |\n\
    21 |                 result.push(*vowel);\n   |                             ^^^^^^\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpdmj8hv6y.rs:26:59\n\
    \   |\n26 |                 result.push(*letters.chars().position(|c| *c == c).unwrap());\n\
    \   |                                                           ^^\n\nerror[E0614]:\
    \ type `usize` cannot be dereferenced\n  --> /tmp/tmpdmj8hv6y.rs:26:29\n   |\n\
    26 |                 result.push(*letters.chars().position(|c| *c == c).unwrap());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut index = 0;\n    let mut current_letter = 0;\n \
    \   let mut current_vowel = 0;\n    let mut current_index = 0;\n    let mut current_vowel_letter\
    \ = 0;\n    let mut current_vowel_letter_count = 0;\n    let mut current_vowel_letter_count_index\
    \ = 0;\n    let mut current_vowel_letter_count_index2 = 0;\n    let mut current_vowel_letter_count_index3\
    \ = 0;\n    let mut current_vowel_letter_count_index4 = 0;\n    let mut current_vowel_letter_count_index5\
    \ = 0;\n    let mut current_vowel_letter_count_index6 = 0;\n    let mut current_vowel_letter_count_index7\
    \ = 0;\n    let mut current_vowel_letter_count_index8 = 0;\n    let mut current_vowel_letter_count_index9\
    \ = 0;\n    let mut current_vowel_letter_count_index10 = 0;\n    let mut current_vowel_letter_count_index11\
    \ = 0;\n    let mut current_vowel_letter_count_index12 = 0;\n    let mut current_vowel_letter_count_index13\
    \ = 0;\n    let mut current_vowel_letter_count_index14 = 0;\n    let mut current_vowel_letter_count_index15\
    \ = 0;\n    let mut current_vowel_letter_count_index16 = 0;\n    let mut current_vowel_letter_count_index17\
    \ = 0;\n    let mut current_vowel_letter_count_index18 = 0;\n    let mut current_vowel_letter_count_index19\
    \ = 0;\n    let mut current_vowel_letter_count_index20 = 0;\n    let mut current_vowel_letter_count_index21\
    \ = 0;\n    let mut current_vowel_letter_count_index22 = 0;\n    let mut current_vowel_letter_count_index23\
    \ = 0;\n    let mut current_vowel_letter_count_index24 = 0;\n    let mut current_vowel_letter_count_index25\
    \ = 0;\n    let mut current_vowel_letter_count_index26 = 0;\n    let mut current_vowel_letter_count_index27\
    \ = 0;\n    let mut current_\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqsd7b57a.rs:48:21\n   |\n\
    48 |     let mut current_\n   |                     ^ help: add `;` here\n49 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqsd7b57a.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_2 = \"AEIOU\";\n    let mut vowels_3 = String::from(\"AEIOUaeiou\"\
    );\n    let mut vowels_4 = String::from(\"AEIOUaeiouAEIOU\");\n    let mut vowels_5\
    \ = String::from(\"AEIOUaeiouAEIOUaeiouAEIOU\");\n    let mut vowels_6 = String::from(\"\
    AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\");\n    let mut vowels_7 = String::from(\"\
    AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\");\n    let mut vowels_8 = String::from(\"\
    AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\");\n    let mut vowels_9\
    \ = String::from(\"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    );\n    let mut vowels_10 = String::from(\"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    );\n    let mut vowels_11 = String::from(\"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    );\n    let mut vowels_12 = String::from(\"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    );\n    let mut vowels_13 = String::from(\"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    );\n    let mut vowels_14 = String::from(\"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmppa_ovlnx.rs:35:109\n\
    \   |\n35 |       assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\"\
    )), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n   |  _____________________________________________________________________________________________________________^\n\
    36 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_encoded = HashSet::new();\n    let mut vowels_encoded_count\
    \ = 1;\n    let mut vowels_encoded_count_index = 0;\n    let mut vowels_encoded_count_index2\
    \ = 0;\n    let mut vowels_encoded_count_index3 = 0;\n    let mut vowels_encoded_count_index4\
    \ = 0;\n    let mut vowels_encoded_count_index5 = 0;\n    let mut vowels_encoded_count_index6\
    \ = 0;\n    let mut vowels_encoded_count_index7 = 0;\n    let mut vowels_encoded_count_index8\
    \ = 0;\n    let mut vowels_encoded_count_index9 = 0;\n    let mut vowels_encoded_count_index10\
    \ = 0;\n    let mut vowels_encoded_count_index11 = 0;\n    let mut vowels_encoded_count_index12\
    \ = 0;\n    let mut vowels_encoded_count_index13 = 0;\n    let mut vowels_encoded_count_index14\
    \ = 0;\n    let mut vowels_encoded_count_index15 = 0;\n    let mut vowels_encoded_count_index16\
    \ = 0;\n    let mut vowels_encoded_count_index17 = 0;\n    let mut vowels_encoded_count_index18\
    \ = 0;\n    let mut vowels_encoded_count_index19 = 0;\n    let mut vowels_encoded_count_index20\
    \ = 0;\n    let mut vowels_encoded_count_index21 = 0;\n    let mut vowels_encoded_count_index22\
    \ = 0;\n    let mut vowels_encoded_count_index23 = 0;\n    let mut vowels_encoded_count_index24\
    \ = 0;\n    let mut vowels_encoded_count_index25 = 0;\n    let mut vowels_encoded_count_index26\
    \ = 0;\n    let mut vowels_encoded_count_index27 = 0;\n    let mut vowels_encoded_count_index28\
    \ = 0;\n    let mut vowels_encoded_count_index29 = 0;\n    let mut vowels_encoded_count_index30\
    \ = 0;\n    let mut vowels_encoded_count_index31 = 0;\n    let mut vowels_encoded_count_index32\
    \ = 0;\n    let mut vowels_encoded_count_index33 = 0;\n    let mut vowels_encoded_count_index34\
    \ = 0;\n    let mut vowels_encoded_count_index35 = 0;\n    let mut vowels_encoded_count_index36\
    \ = 0;\n    let mut vowels_encoded_count_index37 = 0;\n    let mut vowels_encoded_count_index38\
    \ = 0;\n    let mut vowels_encoded_count_index39 = 0;\n    let mut vowels_\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxes8n66m.rs:55:20\n   |\n\
    55 |     let mut vowels_\n   |                    ^ help: add `;` here\n56 | }\n\
    \   | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmpxes8n66m.rs:13:22\n   |\n13 |     let mut vowels\
    \ = HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpxes8n66m.rs:14:30\n   |\n14 |     let mut vowels_encoded = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxes8n66m.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_counts = vec![];\n    let mut letter_counts_index = vec![];\n   \
    \ let mut letter_counts_index = vec![];\n    let mut letter_counts_index = vec![];\n\
    \    let mut letter_counts_index = vec![];\n    let mut letter_counts_index =\
    \ vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mut letter_counts_index\
    \ = vec![];\n    let mut letter_counts_index = vec![];\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpligw8vf5.rs:58:11\n   |\n\
    58 |     let mu\n   |           ^ help: add `;` here\n59 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpligw8vf5.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    \n    for letter in message\
    \ {\n        if letter == ' ' {\n            encoded.push_str(\" \");\n      \
    \      continue;\n        }\n        if letter == 'a' {\n            encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n            index += 1;\n            continue;\n        }\n\
    \        if letter == 'e' {\n            encoded.push_str(&vowels[index % vowels.len()]);\n\
    \            index += 1;\n            continue;\n        }\n        if letter\
    \ == 'i' {\n            encoded.push_str(&vowels[index % vowels.len()]);\n   \
    \         index += 1;\n            continue;\n        }\n        if letter ==\
    \ 'o' {\n            encoded.push_str(&vowels[index % vowels.len()]);\n      \
    \      index += 1;\n            continue;\n        }\n        if letter == 'u'\
    \ {\n            encoded.push_str(&vowels[index % vowels.len()]);\n          \
    \  index += 1;\n            continue;\n        }\n        if letter == 'A' {\n\
    \            encoded.push_str(&letters[index % letters.len()]);\n            index\
    \ += 1;\n            continue;\n        }\n        if letter == 'E' {\n      \
    \      encoded.push_str(&letters[index % letters.len()]);\n            index +=\
    \ 1;\n            continue;\n        }\n        if letter == 'I' {\n         \
    \   encoded.push_str(&letters[index % letters.len()]);\n            index += 1;\n\
    \            continue;\n        }\n        if letter == 'O' {\n            encoded.push_str(&letters[index\
    \ % letters.len()]);\n            index += 1;\n            continue;\n       \
    \ }\n        if letter == 'U' {\n            encoded.push_str(&letters[index %\
    \ letters.len()]);\n            index += 1;\n            continue;\n        }\n\
    \        encoded.push_str(&letter);\n    }\n    encoded\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmplx130e34.rs:17:19\n\
    \   |\n17 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplx130e34.rs:23:30\n   |\n23 |             encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplx130e34.rs:28:30\n   |\n28 |             encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplx130e34.rs:33:30\n   |\n33 |             encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplx130e34.rs:38:30\n   |\n38 |             encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplx130e34.rs:43:30\n   |\n43 |             encoded.push_str(&vowels[index\
    \ % vowels.len()]);\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplx130e34.rs:48:30\n   |\n48 |             encoded.push_str(&letters[index\
    \ % letters.len()]);\n  "
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message.chars() {\n        if letter == ' ' {\n    \
    \        result.push_str(\" \");\n        } else {\n            if letter_counter\
    \ < 2 {\n                if vowel_counter < 2 {\n                    result.push_str(&vowels[vowel_counter]);\n\
    \                } else {\n                    result.push_str(&letters[letter_counter]);\n\
    \                }\n            } else {\n                if vowel_counter < 2\
    \ {\n                    result.push_str(&letters[letter_counter]);\n        \
    \        } else {\n                    result.push_str(&vowels[vowel_counter]);\n\
    \                }\n            }\n            vowel_counter += 1;\n         \
    \   letter_counter += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe229bhkb.rs:23:37\n   |\n\
    23 |                     result.push_str(&vowels[vowel_counter]);\n   |      \
    \                               ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe229bhkb.rs:25:37\n   |\n25 |\
    \                     result.push_str(&letters[letter_counter]);\n   |       \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe229bhkb.rs:29:37\n\
    \   |\n29 |                     result.push_str(&letters[letter_counter]);\n \
    \  |                                     ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe229bhkb.rs:31:37\n\
    \   |\n31 |                     result.push_str(&vowels[vowel_counter]);\n   |\
    \                                     ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\
    \ 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,\
    \ 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,\
    \ 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut vowels_index_3\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28, 29, 30, 31, 32, 33, \n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpm9l4m8g3.rs:18:1\n   |\n18 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpm9l4m8g3.rs:17:34\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n17 |     let mut vowels_index_4 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 2...\n   |                                  ^ unclosed delimiter\n18 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut vowels_counter2 = 0;\n    let mut\
    \ vowels_counter3 = 0;\n    let mut vowels_counter4 = 0;\n    let mut vowels_counter5\
    \ = 0;\n    let mut vowels_counter6 = 0;\n    let mut vowels_counter7 = 0;\n \
    \   let mut vowels_counter8 = 0;\n    let mut vowels_counter9 = 0;\n    let mut\
    \ vowels_counter10 = 0;\n    let mut vowels_counter11 = 0;\n    let mut vowels_counter12\
    \ = 0;\n    let mut vowels_counter13 = 0;\n    let mut vowels_counter14 = 0;\n\
    \    let mut vowels_counter15 = 0;\n    let mut vowels_counter16 = 0;\n    let\
    \ mut vowels_counter17 = 0;\n    let mut vowels_counter18 = 0;\n    let mut vowels_counter19\
    \ = 0;\n    let mut vowels_counter20 = 0;\n    let mut vowels_counter21 = 0;\n\
    \    let mut vowels_counter22 = 0;\n    let mut vowels_counter23 = 0;\n    let\
    \ mut vowels_counter24 = 0;\n    let mut vowels_counter25 = 0;\n    let mut vowels_counter26\
    \ = 0;\n    let mut vowels_counter27 = 0;\n    let mut vowels_counter28 = 0;\n\
    \    let mut vowels_counter29 = 0;\n    let mut vowels_counter30 = 0;\n    let\
    \ mut vowels_counter31 = 0;\n    let mut vowels_counter32 = 0;\n    let mut vowels_counter33\
    \ = 0;\n    let mut vowels_counter34 = 0;\n    let mut vowels_counter35 = 0;\n\
    \    let mut vowels_counter36 = 0;\n    let mut vowels_counter37 = 0;\n    let\
    \ mut vowels_counter38 = 0;\n    let mut vowels_counter39 = 0;\n    let mut vowels_counter40\
    \ = 0;\n    let mut vowels_counter41 = 0;\n    let mut vowels_counter42 = 0;\n\
    \    let mut vowels_counter43 = 0;\n    let mut vowels_counter44 = 0;\n    let\
    \ mut vowels_counter45 = 0;\n    let mut vowels_counter46 = 0;\n    let mut vowels_counter47\
    \ = 0;\n    let mut vowels_counter48 = 0;\n    let mut vowels_counter49 = 0;\n\
    \    let mut vowels_counter50 = 0;\n    let mut vowels_counter51 = 0;\n    let\
    \ mut vowels_counter52 = 0;\n    let mut vowels_counter53 = 0;\n    let mut vowels_counter54\
    \ = 0;\n    let mut vowels_counter55 = 0;\n    let \n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpvrbq16ke.rs:70:1\n  \
    \ |\n70 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmpvrbq16ke.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_count = vec![0];\n    let mut letter = String::new();\n    let mut\
    \ letter_index = String::new();\n    let mut letter_counts = vec![0];\n    let\
    \ mut letters = vec!['S', 'T', 'H', 'K', 'C', 'G', 'G', 'M', 'S', 'C', 'G', 'G',\
    \ 'G'];\n    let mut letter_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15];\n    let mut letter_counts = vec![0];\n    let mut vowel_counts\
    \ = vec![0];\n    let mut vowels = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut\
    \ vowel_index = vec![0, 1, 2, 3, 4];\n    let mut vowel_count = vec![0];\n   \
    \ let mut letter = String::new();\n    let mut letter_index = String::new();\n\
    \    let mut letter_counts = vec![0];\n    let mut letters = vec!['S', 'T', 'H',\
    \ 'K', 'C', 'G', 'G', 'M', 'S', 'C', 'G', 'G', 'G'];\n    let mut letter_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\n    let mut letter_counts\
    \ = vec![0];\n    let mut vowel_counts = vec![0];\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowel_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut vowel_count = vec![0];\n    let mut letter = String::new();\n    let mut\
    \ letter_index = String::new();\n    let mut letter_counts = vec![0];\n    let\
    \ mut letters = vec!['S', 'T', 'H', 'K', 'C', 'G', 'G', 'M', 'S', 'C', 'G', 'G',\
    \ 'G'];\n    let mut letter_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15];\n    let mut letter_counts = vec![0];\n    let mut vowel_counts\
    \ = vec![0];\n    let mut vowels = vec!['A', 'E', 'I', 'O', 'U'];\n    let mut\
    \ vowel_index = vec![0, 1, 2, 3, 4];\n    let mut vowel_count = vec![0];\n   \
    \ let mut letter = String::new();\n    let mut letter_index = String::new();\n\
    \    let mut letter_counts = vec![0];\n    let mut letters = vec!['S', 'T', 'H',\
    \ 'K', 'C', 'G', 'G', 'M', 'S', 'C', 'G', 'G', 'G'];\n\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb21jcjz8.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_case = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K',\
    \ 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut letter_case_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\
    \ 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\
    \ 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,\
    \ 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69,\
    \ 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,\
    \ 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106,\
    \ 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,\
    \ 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138,\
    \ 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154,\
    \ 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170,\
    \ 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186,\
    \ 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202,\
    \ 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218,\
    \ 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234,\
    \ 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 24\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpkabfyc8d.rs:17:1\n   |\n17 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpkabfyc8d.rs:16:37\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n16 |     let mut letter_case_index = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\
    \ 27...\n   |                                     ^ unclosed delimiter\n17 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut letters = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message {\n        if letter == letters[letter_counter]\
    \ {\n            letter_counter += 1;\n        } else {\n            letter_counter\
    \ = 0;\n        }\n        if letter == vowels[vowel_counter] {\n            vowel_counter\
    \ += 1;\n        } else {\n            vowel_counter = 0;\n        }\n       \
    \ if vowel_counter == 2 {\n            result.push_str(vowels[vowel_counter -\
    \ 1]);\n            vowel_counter -= 1;\n        } else {\n            result.push_str(letter);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmptdx1sc0u.rs:17:19\n\
    \   |\n17 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_encoded = HashSet::new();\n    let mut vowels_encoded_len\
    \ = 0;\n    let mut vowels_encoded_len2 = 0;\n    let mut vowels_encoded_len3\
    \ = 0;\n    let mut vowels_encoded_len4 = 0;\n    let mut vowels_encoded_len5\
    \ = 0;\n    let mut vowels_encoded_len6 = 0;\n    let mut vowels_encoded_len7\
    \ = 0;\n    let mut vowels_encoded_len8 = 0;\n    let mut vowels_encoded_len9\
    \ = 0;\n    let mut vowels_encoded_len10 = 0;\n    let mut vowels_encoded_len11\
    \ = 0;\n    let mut vowels_encoded_len12 = 0;\n    let mut vowels_encoded_len13\
    \ = 0;\n    let mut vowels_encoded_len14 = 0;\n    let mut vowels_encoded_len15\
    \ = 0;\n    let mut vowels_encoded_len16 = 0;\n    let mut vowels_encoded_len17\
    \ = 0;\n    let mut vowels_encoded_len18 = 0;\n    let mut vowels_encoded_len19\
    \ = 0;\n    let mut vowels_encoded_len20 = 0;\n    let mut vowels_encoded_len21\
    \ = 0;\n    let mut vowels_encoded_len22 = 0;\n    let mut vowels_encoded_len23\
    \ = 0;\n    let mut vowels_encoded_len24 = 0;\n    let mut vowels_encoded_len25\
    \ = 0;\n    let mut vowels_encoded_len26 = 0;\n    let mut vowels_encoded_len27\
    \ = 0;\n    let mut vowels_encoded_len28 = 0;\n    let mut vowels_encoded_len29\
    \ = 0;\n    let mut vowels_encoded_len30 = 0;\n    let mut vowels_encoded_len31\
    \ = 0;\n    let mut vowels_encoded_len32 = 0;\n    let mut vowels_encoded_len33\
    \ = 0;\n    let mut vowels_encoded_len34 = 0;\n    let mut vowels_encoded_len35\
    \ = 0;\n    let mut vowels_encoded_len36 = 0;\n    let mut vowels_encoded_len37\
    \ = 0;\n    let mut vowels_encoded_len38 = 0;\n    let mut vowels_encoded_len39\
    \ = 0;\n    let mut vowels_encoded_len40 = 0;\n    let mut vowels_encoded_len41\
    \ = 0;\n    let mut vowels_encoded_len42 = 0;\n    let mut vowels_encoded_len43\
    \ = 0;\n    let mut vowels_encoded_len44 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpb04dxviy.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpb04dxviy.rs:14:30\n\
    \   |\n14 |     let mut vowels_encoded = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb04dxviy.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::new();\n\
    \    let mut letters = String::new();\n    let mut index = 0;\n    \n    for letter\
    \ in message.chars() {\n        if letter.is_uppercase() {\n            letters.push_str(&letter.to_lowercase());\n\
    \        } else {\n            letters.push_str(&letter.to_uppercase());\n   \
    \     }\n        \n        if index == 0 {\n            vowels.push_str(&\"AEIOU\"\
    .to_string());\n        } else {\n            vowels.push_str(&\"AEIOU\".to_string());\n\
    \        }\n        \n        index += 1;\n    }\n    \n    for vowel in vowels.chars()\
    \ {\n        let mut index = vowels.find(vowel);\n        while index != String::npos\
    \ && index != 0 {\n            encoded.push_str(&letters[(index - 2) as usize]);\n\
    \            index = vowels.find(vowel, index + 1);\n        }\n    }\n    \n\
    \    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpedg7wrw0.rs:19:30\n   |\n\
    19 |             letters.push_str(&letter.to_lowercase());\n   |             \
    \                 ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpedg7wrw0.rs:21:30\n   |\n21 |\
    \             letters.push_str(&letter.to_uppercase());\n   |                \
    \              ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0599]: no function or associated item named `npos` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpedg7wrw0.rs:35:32\n   |\n35 |         while\
    \ index != String::npos && index != 0 {\n   |                                ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpedg7wrw0.rs:35:49\n   |\n35 |         while index != String::npos\
    \ && index != 0 {\n   |                                                 ^ expected\
    \ enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n35 |         while index != String::npos && index != Some(0) {\n   |  \
    \                                               +++++ +\n\nerror[E0369]: cannot\
    \ subtract `{integer}` from `Option<usize>`\n  --> /tmp/tmpedg7wrw0.rs:36:46\n\
    \   |\n36 |             encoded.push_str(&letters[(index - 2) as usize]);\n  \
    \ |                                        ----- ^ - {integer}\n   |         \
    \                               |\n   |                                      \
    \  Option<usize>\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpedg7wrw0.rs:37:46\n   |\n37 |             index = vowels.find(vowel,\
    \ index + 1);\n   |                                        ----- ^ - {integer}\n\
    \   |                                        |\n   |                         \
    \               Option<usize>"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut vowels_counter = vec![0];\n   \
    \ for letter in message.chars() {\n        if let Some(index) = vowels.iter().position(|x|\
    \ x == letter) {\n            vowels_counter[index] += 1;\n        }\n    }\n\
    \    for vowel in vowels {\n        if vowels_counter[vowel] == 2 {\n        \
    \    result.push_str(&vowels[vowels_counter.iter().position(|x| x == vowel).unwrap()\
    \ + 1]);\n        } else {\n            result.push_str(&vowel);\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&str` with `char`\n  --> /tmp/tmp0idcrslp.rs:16:59\n\
    \   |\n16 |         if let Some(index) = vowels.iter().position(|x| x == letter)\
    \ {\n   |                                                           ^^ no implementation\
    \ for `&&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: the type\
    \ `[{integer}]` cannot be indexed by `&str`\n  --> /tmp/tmp0idcrslp.rs:21:12\n\
    \   |\n21 |         if vowels_counter[vowel] == 2 {\n   |            ^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[{integer}]>` is not implemented for `&str`\n   = note: required\
    \ because of the requirements on the impl of `Index<&str>` for `Vec<{integer}>`\n\
    \nerror[E0277]: can't compare `{integer}` with `str`\n  --> /tmp/tmp0idcrslp.rs:22:74\n\
    \   |\n22 |             result.push_str(&vowels[vowels_counter.iter().position(|x|\
    \ x == vowel).unwrap() + 1]);\n   |                                          \
    \                                ^^ no implementation for `{integer} == str`\n\
    \   |\n   = help: the trait `PartialEq<str>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n   = note: required because of the requirements on the impl of\
    \ `PartialEq<&str>` for `&{integer}`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    for letter in message.chars() {\n        if letter == ' ' {\n  \
    \          result.push_str(\" \");\n        } else {\n            if letter ==\
    \ vowels[j] {\n                result.push_str(vowels[j]);\n                j\
    \ += 2;\n            } else {\n                result.push_str(letters[letters.len()\
    \ - j]);\n                j += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3bg5f0i9.rs:22:33\n   |\n\
    22 |                 result.push_str(vowels[j]);\n   |                       \
    \          ^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3bg5f0i9.rs:25:33\n   |\n25 |                 result.push_str(letters[letters.len()\
    \ - j]);\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&str`, found `char`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_counter =\
    \ 0;\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',\
    \ 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',\
    \ 'Z'];\n    let mut letters_counter = 0;\n    for letter in message {\n     \
    \   if letter == letters[letters_counter] {\n            letters_counter++;\n\
    \        } else {\n            letters_counter = 0;\n        }\n        if letter\
    \ == vowels[vowels_counter] {\n            vowels_counter++;\n        } else {\n\
    \            vowels_counter = 0;\n        }\n        if letter == letters[letters_counter]\
    \ {\n            letters_counter++;\n        } else {\n            letters_counter\
    \ = 0;\n        }\n        if letter == vowels[vowels_counter] {\n           \
    \ vowels_counter++;\n        } else {\n            vowels_counter = 0;\n     \
    \   }\n        if letter == letters[letters_counter] {\n            letters_counter++;\n\
    \        } else {\n            letters_counter = 0;\n        }\n        if letter\
    \ == vowels[vowels_counter] {\n            vowels_counter++;\n        } else {\n\
    \            vowels_counter = 0;\n        }\n        if letter == letters[letters_counter]\
    \ {\n            letters_counter++;\n        } else {\n            letters_counter\
    \ = 0;\n        }\n        if letter == vowels[vowels_counter] {\n           \
    \ vowels_counter++;\n        } else {\n            vowels_counter = 0;\n     \
    \   }\n        if letter == letters[letters_counter] {\n            letters_counter++;\n\
    \        } else {\n            letters_counter = 0;\n        }\n        if letter\
    \ == vowels[vowels_counter] {\n            vowels_counter++;\n        } else {\n\
    \            vowels_counter = 0;\n        }\n        if letter == letters[letters_counter]\
    \ {\n            letters_counter++;\n        } else {\n            letters_counter\
    \ = 0;\n        }\n        if letter == vowels[vowels_counter] {\n           \
    \ vowels_counter++;\n        } else {\n            vowels_counter = 0;\n     \
    \   }\n        if letter == letters[letters_counter] {\n            letters_counter++;\n\
    \        } else {\n            letters_counter = 0;\n        }\n        if letter\
    \ == vowels[vowels_counter] {\n            vowels_counter++;\n        } else {\n\
    \            vowels_counter = 0;\n        }\n        if letter == letters[letters_counter]\
    \ {\n            letters_counter++;\n\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpz_jbpa18.rs:100:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n17  |     for letter in message\
    \ {\n    |                           - unclosed delimiter\n...\n88  |        \
    \ if letter == letters[letters_counter] {\n    |                             \
    \                  - this delimiter might not be properly closed...\n...\n91 \
    \ | }\n    | - ...as it matches this but it has different indentation\n...\n100\
    \ | }\n    |   ^\n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpz_jbpa18.rs:19:28\n\
    \   |\n19 |             letters_counter++;\n   |                            ^^\
    \ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n19 |   \
    \          { let tmp = letters_counter; letters_counter += 1; tmp };\n   |   \
    \          +++++++++++                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n19 -    \
    \         letters_counter++;\n19 +             letters_counter += 1;\n   | \n\n\
    error: Rust has no postfix increment operator\n  --> /tmp/tmpz_jbpa18.rs:24:27\n\
    \   |\n24 |             vowels_counter++;\n   |                           ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n24 |       \
    \      { let tmp = vowels_counter; vowels_counter += 1; tmp };\n   |         \
    \    +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n24 -            \
    \ vowels_counter++;\n24 +             vowels_counter += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmpz_jbpa18.rs:29:28\n   |\n29\
    \ |             letters_counter++;\n   |                            ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n29 |             { let\
    \ tmp = letters_counter; letters_counter += 1; tmp };\n   |             +++++++++++\
    \                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n29 -             letters_counter++;\n\
    29 +             letters_counter += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpz_jbpa18.rs:34:27\n   |\n34 |             vowels_counter++;\n\
    \   |                           ^^ not a valid p"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for c in message.chars() {\n        if c.is_uppercase()\
    \ {\n            letters.insert(c.to_lowercase());\n        } else {\n       \
    \     letters.insert(c.to_uppercase());\n        }\n    }\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            if letters.contains(c.to_lowercase())\
    \ {\n                encoded.push(c);\n                letter_counter += 1;\n\
    \            } else {\n                encoded.push(c);\n                vowel_counter\
    \ += 1;\n            }\n        } else {\n            if letters.contains(c.to_uppercase())\
    \ {\n                encoded.push(c);\n                letter_counter += 1;\n\
    \            } else {\n                encoded.push(c);\n                vowel_counter\
    \ += 1;\n            }\n        }\n    }\n    if vowel_counter > 0 {\n       \
    \ for vowel in vowels.iter() {\n            encoded.push(vowel);\n        }\n\
    \    }\n    if letter_counter > 0 {\n        for letter in letters.iter() {\n\
    \            encoded.push(letter);\n        }\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpaty41poz.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpaty41poz.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    alphabet.insert(String::from('a'));\n\
    \    alphabet.insert(String::from('e'));\n    alphabet.insert(String::from('i'));\n\
    \    alphabet.insert(String::from('o'));\n    alphabet.insert(String::from('u'));\n\
    \    alphabet.insert(String::from('y'));\n    alphabet.insert(String::from('A'));\n\
    \    alphabet.insert(String::from('E'));\n    alphabet.insert(String::from('I'));\n\
    \    alphabet.insert(String::from('O'));\n    alphabet.insert(String::from('U'));\n\
    \    alphabet.insert(String::from('Y'));\n    alphabet.insert(String::from('0'));\n\
    \    alphabet.insert(String::from('1'));\n    alphabet.insert(String::from('2'));\n\
    \    alphabet.insert(String::from('3'));\n    alphabet.insert(String::from('4'));\n\
    \    alphabet.insert(String::from('5'));\n    alphabet.insert(String::from('6'));\n\
    \    alphabet.insert(String::from('7'));\n    alphabet.insert(String::from('8'));\n\
    \    alphabet.insert(String::from('9'));\n    alphabet.insert(String::from('.'));\n\
    \    alphabet.insert(String::from(','));\n    alphabet.insert(String::from('-'));\n\
    \    alphabet.insert(String::from('/'));\n    alphabet.insert(String::from(';'));\n\
    \    alphabet.insert(String::from('('));\n    alphabet.insert(String::from(')'));\n\
    \    alphabet.insert(String::from(';'));\n    alphabet.insert(String::from('.'));\n\
    \    alphabet.insert(String::from(','));\n    alphabet.insert(String::from('-'));\n\
    \    alphabet.insert(String::from('/'));\n    alphabet.insert(String::from(';'));\n\
    \    alphabet.insert(String::from('('));\n    alphabet.insert(String::from(')'));\n\
    \    alphabet.insert(String::from(';'));\n    alphabet.insert(String::from('.'));\n\
    \    alphabet.insert(String::from(','));\n    alphabet.insert(String::from('-'));\n\
    \    alphabet.insert(String::from('/'));\n    alphabet.insert(String::from(';'));\n\
    \    alphabet.insert(String::from('('));\n    alphabet.insert(String\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpybw73jfm.rs:59:20\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n59 |     alphabet.insert(String\n\
    \   |                    ^ unclosed delimiter\n60 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmpybw73jfm.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpybw73jfm.rs:14:24\n\
    \   |\n14 |     let mut alphabet = HashSet::new();\n   |                     \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0423]: expected value,\
    \ found struct `String`\n   --> /tmp/tmpybw73jfm.rs:59:21\n    |\n59  |      \
    \ alphabet.insert(String\n    |                       ^^^^^^ help: use struct\
    \ literal syntax instead: `String { vec: val }`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0423, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0423`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message {\n       \
    \ if letter in vowels {\n            vowel_counter += 1;\n            if vowel_counter\
    \ == 2 && letter_counter < 2 {\n                result += letters[letter_counter];\n\
    \                letter_counter += 1;\n            }\n        } else {\n     \
    \       letter_counter += 1;\n            if letter_counter == 2 && vowel_counter\
    \ < 2 {\n                result += letters[letter_counter];\n                letter_counter\
    \ += 1;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpolneda_8.rs:18:19\n\
    \   |\n18 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpolneda_8.rs:17:19\n\
    \   |\n17 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"AEIOUaeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for c in message.chars() {\n    \
    \    if vowels.contains(&c) {\n            vowel_counter += 1;\n        }\n  \
    \      if letters.contains(&c) {\n            letter_counter += 1;\n        }\n\
    \    }\n    for c in message.chars() {\n        if vowels.contains(&c) {\n   \
    \         if letter_counter == 2 {\n                result.push((letters[letter_counter\
    \ - 2] + letters[letter_counter - 1]).to_string());\n                letter_counter\
    \ -= 1;\n            } else {\n                result.push((letters[letter_counter\
    \ - 1] + letters[letter_counter]).to_string());\n                letter_counter\
    \ -= 1;\n            }\n        } else {\n            if letter_counter == 2 {\n\
    \                result.push((letters[letter_counter - 2] + letters[letter_counter\
    \ - 1]).to_string());\n                letter_counter -= 1;\n            } else\
    \ {\n                result.push((letters[letter_counter - 1] + letters[letter_counter]).to_string());\n\
    \                letter_counter -= 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp1f_7k9cp.rs:18:28\n\
    \     |\n18   |         if vowels.contains(&c) {\n     |                   --------\
    \ ^^ expected an `Fn<(char,)>` closure, found `char`\n     |                 \
    \  |\n     |                   required by a bound introduced by this call\n \
    \    |\n     = help: the trait `Fn<(char,)>` is not implemented for `char`\n \
    \    = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n18   |         if vowels.contains(*&c)\
    \ {\n     |                            +\n\nerror[E0277]: expected a `Fn<(char,)>`\
    \ closure, found `char`\n    --> /tmp/tmp1f_7k9cp.rs:21:29\n     |\n21   |   \
    \      if letters.contains(&c) {\n     |                    -------- ^^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n     |                    |\n     |\
    \                    required by a bound introduced by this call\n     |\n   \
    \  = help: the trait `Fn<(char,)>` is not implemented for `char`\n     = note:\
    \ required because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n21   |         if letters.contains(*&c)\
    \ {\n     |                             +\n\nerror[E0277]: expected a `Fn<(char,)>`\
    \ closure, found `char`\n    --> /tmp/tmp1f_7k9cp.rs:26:28\n     |\n26   |   \
    \      if vowels.contains(&c) {\n     |                   -------- ^^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n     |                   |\n     | \
    \                  required by a bound introduced by this call\n     |\n     =\
    \ help: the trait `Fn<(char,)>` is not implemented for `char`\n     = note: required\
    \ because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n \
    \    = note: require"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_idx = 0;\n    let mut vowels_idx_2 = 3;\n    let mut letters\
    \ = HashSet::new();\n    let mut letters_idx = 0;\n    let mut letters_idx_2 =\
    \ 3;\n    for letter in message.chars() {\n        if letter == ' ' {\n      \
    \      result.push_str(&\" \");\n        } else {\n            if letter in letters\
    \ {\n                result.push_str(&\"T\");\n                letters_idx +=\
    \ 1;\n            } else {\n                result.push_str(&\"T\");\n       \
    \         letters.insert(letter);\n                letters_idx += 1;\n       \
    \     }\n        }\n    }\n    for letter in message.chars() {\n        if letter\
    \ == ' ' {\n            result.push_str(&\" \");\n        } else {\n         \
    \   if letter in vowels {\n                result.push_str(&\"K\");\n        \
    \        vowels_idx += 1;\n            } else {\n                result.push_str(&\"\
    K\");\n                vowels.insert(letter);\n                vowels_idx += 1;\n\
    \            }\n        }\n    }\n    for letter in message.chars() {\n      \
    \  if letter == ' ' {\n            result.push_str(&\" \");\n        } else {\n\
    \            if letter in vowels {\n                result.push_str(&\"S\");\n\
    \                vowels_idx_2 += 1;\n            } else {\n                result.push_str(&\"\
    S\");\n                vowels.insert(letter);\n                vowels_idx_2 +=\
    \ 1;\n            }\n        }\n    }\n    for letter in message.chars() {\n \
    \       if letter == ' ' {\n            result.push_str(&\" \");\n        } else\
    \ {\n            if letter in vowels {\n                result.push_str(&\"C\"\
    );\n                vowels_idx_2 += 1;\n            } else {\n               \
    \ result.push_str(&\"C\");\n                vowels.insert(letter);\n         \
    \       vowels_idx_2 += 1;\n            }\n        }\n    }\n    for letter in\
    \ message.chars() {\n        if letter == ' ' {\n            result.push_str(&\"\
    \ \");\n        } else {\n            if letter in vowels {\n                result.push_str(&\"\
    M\");\n                vowels_idx_2 += 1;\n            } else {\n            \
    \    result.push_str(&\"M\");\n                vowels.insert(letter);\n      \
    \          vowels_idx_2 += 1;\n            }\n        }\n    }\n    for letter\
    \ in message.chars() {\n        if letter == ' ' {\n            result.push_str(&\"\
    \ \");\n        } else {\n            if letter in vowels {\n                result.push_str(&\"\
    G\");\n                vowels_idx_2 += 1;\n            } else {\n            \
    \    result.push_str(&\"G\");\n                vowels.insert(\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpr7tmr6bg.rs:108:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n89  |     for letter in message.chars()\
    \ {\n    |                                   - unclosed delimiter\n...\n92  |\
    \         } else {\n    |                - unclosed delimiter\n...\n96  |    \
    \         } else {\n    |                    - this delimiter might not be properly\
    \ closed...\n...\n99  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n108 | }\n    |   ^\n\nerror: expected `{`, found keyword `in`\n\
    \  --> /tmp/tmpr7tmr6bg.rs:23:23\n   |\n23 |             if letter in letters\
    \ {\n   |             --        ^^ expected `{`\n   |             |\n   |    \
    \         this `if` expression has a condition, but no block\n\nerror: expected\
    \ `{`, found keyword `in`\n  --> /tmp/tmpr7tmr6bg.rs:37:23\n   |\n37 |       \
    \      if letter in vowels {\n   |             --        ^^ expected `{`\n   |\
    \             |\n   |             this `if` expression has a condition, but no\
    \ block\n\nerror: expected `{`, found keyword `in`\n  --> /tmp/tmpr7tmr6bg.rs:51:23\n\
    \   |\n51 |             if letter in vowels {\n   |             --        ^^ expected\
    \ `{`\n   |             |\n   |             this `if` expression has a condition,\
    \ but no block\n\nerror: expected `{`, found keyword `in`\n  --> /tmp/tmpr7tmr6bg.rs:65:23\n\
    \   |\n65 |             if letter in vowels {\n   |             --        ^^ expected\
    \ `{`\n   |             |\n   |             this `if` expression has a condition,\
    \ but no block\n\nerror: expected `{`, found keyword `in`\n  --> /tmp/tmpr7tmr6bg.rs:79:23\n\
    \   |\n79 |             if letter in vowels {\n   |             --        ^^ expected\
    \ `{`\n   |             |\n   |             this `if` expression has a condition,\
    \ but no block\n\nerror: expected `{`, found keyword `in`\n  --> /tmp/tmpr7tmr6bg.rs:93:23\n\
    \   |\n93 |             if letter in vowels {\n   |             --        ^^ expected\
    \ `{`\n   |             |\n   |             this `if` expression has a condition,\
    \ but "
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut letter_counter = 0;\n    let mut letter_counter2 =\
    \ 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4 = 0;\n   \
    \ let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n    let mut\
    \ letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut letter_counter9\
    \ = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11 = 0;\n\
    \    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n    let\
    \ mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let mut letter_counter16\
    \ = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18 = 0;\n\
    \    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n    let\
    \ mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let mut letter_counter23\
    \ = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25 = 0;\n\
    \    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n    let\
    \ mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let mut letter_counter30\
    \ = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32 = 0;\n\
    \    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n    let\
    \ mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let mut letter_counter37\
    \ = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39 = 0;\n\
    \    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n    let\
    \ mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let mut letter_counter44\
    \ = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46 = 0;\n\
    \    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n    let\
    \ mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let mut letter_counter51\
    \ = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53 = 0;\n\
    \    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n    let\
    \ mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let mut letter_counter58\
    \ = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60 = 0;\n\
    \    let mut letter_counter61 = 0;\n    let mut letter_counter62\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp92b0fhgf.rs:75:29\n   |\n\
    75 |     let mut letter_counter62\n   |                             ^ help: add\
    \ `;` here\n76 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp92b0fhgf.rs:11:31\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |    ------                     ^^^^^^ expected struct `String`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    \n    for letter in message.chars() {\n        if let Some(vowel) = vowels.binary_search(&letter)\
    \ {\n            encoded.push_str(&letters[vowel]);\n            vowels.remove(vowel);\n\
    \        } else {\n            encoded.push_str(&letters[letter]);\n        }\n\
    \    }\n    \n    for vowel in vowels {\n        encoded.push_str(&letters[vowel]);\n\
    \    }\n    \n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp65cbycav.rs:18:51\n   |\n\
    18 |         if let Some(vowel) = vowels.binary_search(&letter) {\n   |      \
    \                                             ^^^^^^^ expected `&str`, found `char`\n\
    \   |\n   = note: expected reference `&&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp65cbycav.rs:18:16\n   |\n18 |\
    \         if let Some(vowel) = vowels.binary_search(&letter) {\n   |         \
    \       ^^^^^^^^^^^   ----------------------------- this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0271]: type mismatch resolving\
    \ `<usize as SliceIndex<[&str]>>::Output == str`\n  --> /tmp/tmp65cbycav.rs:19:31\n\
    \   |\n19 |             encoded.push_str(&letters[vowel]);\n   |             \
    \                  ^^^^^^^^^^^^^^ expected `&str`, found `str`\n\nerror[E0277]:\
    \ the type `[&str]` cannot be indexed by `char`\n  --> /tmp/tmp65cbycav.rs:22:31\n\
    \   |\n22 |             encoded.push_str(&letters[letter]);\n   |            \
    \                   ^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[&str]>` is not implemented\
    \ for `char`\n   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<&str>`\n\nerror[E0277]: the type `[&str]` cannot be indexed by `&str`\n\
    \  --> /tmp/tmp65cbycav.rs:27:27\n   |\n27 |         encoded.push_str(&letters[vowel]);\n\
    \   |                           ^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[&str]>` is not\
    \ implemented for `&str`\n   = note: required because of the requirements on the\
    \ impl of `Index<&str>` for `Vec<&str>`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0271, E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            vowels_counter += 1;\n        }\n        if letter_counter <\
    \ 2 {\n            result += &letter;\n        } else {\n            result +=\
    \ &vowels[vowels_counter];\n            vowels_counter += 1;\n        }\n    \
    \    letter_counter += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfjv9_r4g.rs:21:23\n   |\n\
    21 |             result += &letter;\n   |                       ^^^^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfjv9_r4g.rs:23:23\n\
    \   |\n23 |             result += &vowels[vowels_counter];\n   |             \
    \          ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    for c in message.chars() {\n \
    \       if let Some(vowel) = vowels.binary_search(&c) {\n            result.push_str(&letters[vowel\
    \ + 2]);\n        } else {\n            result.push_str(&letters[c]);\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0pp69g_s.rs:17:16\n   |\n\
    17 |         if let Some(vowel) = vowels.binary_search(&c) {\n   |           \
    \     ^^^^^^^^^^^   ------------------------ this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0277]: the type `[char]` cannot\
    \ be indexed by `char`\n  --> /tmp/tmp0pp69g_s.rs:20:30\n   |\n20 |          \
    \   result.push_str(&letters[c]);\n   |                              ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[char]>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `Index<char>` for `Vec<char>`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n\
    \    let mut letter_counter = 0;\n    for letter in message.chars() {\n      \
    \  if letter == ' ' {\n            result.push_str(\" \");\n        } else {\n\
    \            if letter == vowels[vowel_counter] {\n                vowel_counter\
    \ = vowel_counter + 1;\n            } else {\n                vowel_counter =\
    \ 0;\n            }\n            if letter == letters[letter_counter] {\n    \
    \            letter_counter = letter_counter + 1;\n            } else {\n    \
    \            letter_counter = 0;\n            }\n            result.push_str(&letters[letter_counter]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy46y6h4m.rs:31:29\n   |\n\
    31 |             result.push_str(&letters[letter_counter]);\n   |            \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut vowels_index = String::new();\n    let mut vowels_index_2\
    \ = String::new();\n    let mut vowels_index_3 = String::new();\n    let mut vowels_index_4\
    \ = String::new();\n    let mut vowels_index_5 = String::new();\n    let mut vowels_index_6\
    \ = String::new();\n    let mut vowels_index_7 = String::new();\n    let mut vowels_index_8\
    \ = String::new();\n    let mut vowels_index_9 = String::new();\n    let mut vowels_index_10\
    \ = String::new();\n    let mut vowels_index_11 = String::new();\n    let mut\
    \ vowels_index_12 = String::new();\n    let mut vowels_index_13 = String::new();\n\
    \    let mut vowels_index_14 = String::new();\n    let mut vowels_index_15 = String::new();\n\
    \    let mut vowels_index_16 = String::new();\n    let mut vowels_index_17 = String::new();\n\
    \    let mut vowels_index_18 = String::new();\n    let mut vowels_index_19 = String::new();\n\
    \    let mut vowels_index_20 = String::new();\n    let mut vowels_index_21 = String::new();\n\
    \    let mut vowels_index_22 = String::new();\n    let mut vowels_index_23 = String::new();\n\
    \    let mut vowels_index_24 = String::new();\n    let mut vowels_index_25 = String::new();\n\
    \    let mut vowels_index_26 = String::new();\n    let mut vowels_index_27 = String::new();\n\
    \    let mut vowels_index_28 = String::new();\n    let mut vowels_index_29 = String::new();\n\
    \    let mut vowels_index_30 = String::new();\n    let mut vowels_index_31 = String::new();\n\
    \    let mut vowels_index_32 = String::new();\n    let mut vowels_index_33 = String::new();\n\
    \    let mut vowels_index_34 = String::new();\n    let mut vowels_index_35 = String::new();\n\
    \    let mut vowels_index_36 = String::new();\n    let mut vowels_index_37 = String::new();\n\
    \    let mut vowels_index_38 = String::new();\n    let mut vowels_index_39 = \n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpmp0r3lx6.rs:53:1\n\
    \   |\n53 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_map = HashMap::new();\n    let mut letter_map_index = HashMap::new();\n\
    \    let mut letter_map_reverse = HashMap::new();\n    let mut letter_map_reverse_index\
    \ = HashMap::new();\n    let mut letter_map_reverse2 = HashMap::new();\n    let\
    \ mut letter_map_reverse2_index = HashMap::new();\n    let mut letter_map_reverse3\
    \ = HashMap::new();\n    let mut letter_map_reverse3_index = HashMap::new();\n\
    \    let mut letter_map_reverse4 = HashMap::new();\n    let mut letter_map_reverse4_index\
    \ = HashMap::new();\n    let mut letter_map_reverse5 = HashMap::new();\n    let\
    \ mut letter_map_reverse5_index = HashMap::new();\n    let mut letter_map_reverse6\
    \ = HashMap::new();\n    let mut letter_map_reverse6_index = HashMap::new();\n\
    \    let mut letter_map_reverse7 = HashMap::new();\n    let mut letter_map_reverse7_index\
    \ = HashMap::new();\n    let mut letter_map_reverse8 = HashMap::new();\n    let\
    \ mut letter_map_reverse8_index = HashMap::new();\n    let mut letter_map_reverse9\
    \ = HashMap::new();\n    let mut letter_map_reverse9_index = HashMap::new();\n\
    \    let mut letter_map_reverse10 = HashMap::new();\n    let mut letter_map_reverse10_index\
    \ = HashMap::new();\n    let mut letter_map_reverse11 = HashMap::new();\n    let\
    \ mut letter_map_reverse11_index = HashMap::new();\n    let mut letter_map_reverse12\
    \ = HashMap::new();\n    let mut letter_map_reverse12_index = HashMap::new();\n\
    \    let mut letter_map_reverse13 = HashMap::new();\n    let mut letter_map_reverse13_index\
    \ = HashMap::new();\n    let mut letter_map_reverse14 = HashMap::new();\n    let\
    \ mut letter_map_reverse14_index = HashMap::new();\n    let mut letter_map_reverse15\
    \ = HashMap::new();\n    let mut letter_map_reverse15_index = HashMap::new();\n\
    \    let mut letter_map_reverse16 = HashMap::new();\n    let mut letter_map_reverse16_index\
    \ = HashMap::new();\n    let mut letter_map_reverse17 = HashMap::new();\n    let\
    \ \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp8hxvb44h.rs:51:1\n  \
    \ |\n51 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashMap`\n  --> /tmp/tmp8hxvb44h.rs:15:26\n   |\n15 |     let\
    \ mut letter_map = HashMap::new();\n   |                          ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashMap`\n  --> /tmp/tmp8hxvb44h.rs:16:32\n   |\n16 |  \
    \   let mut letter_map_index = HashMap::new();\n   |                         \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp8hxvb44h.rs:17:34\n   |\n17\
    \ |     let mut letter_map_reverse = HashMap::new();\n   |                   \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp8hxvb44h.rs:18:40\n\
    \   |\n18 |     let mut letter_map_reverse_index = HashMap::new();\n   |     \
    \                                   ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp8hxvb44h.rs:19:35\n   |\n19 |     let mut letter_map_reverse2 =\
    \ HashMap::new();\n   |                                   ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp8hxvb44h.rs:20:41\n   |\n20 |     let mut letter_map_reverse2_index\
    \ = HashMap::new();\n   |                                         ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of u"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut index = 0;\n    let mut i\
    \ = 0;\n    let mut j = 0;\n    let mut k = 0;\n    while i < message.len() {\n\
    \        if message.chars().nth(i).unwrap() == 'a' {\n            alphabet.insert(message.chars().nth(i).unwrap());\n\
    \            i += 1;\n        }\n        if message.chars().nth(i).unwrap() ==\
    \ 'e' {\n            alphabet.insert(message.chars().nth(i).unwrap());\n     \
    \       i += 1;\n        }\n        if message.chars().nth(i).unwrap() == 'i'\
    \ {\n            alphabet.insert(message.chars().nth(i).unwrap());\n         \
    \   i += 1;\n        }\n        if message.chars().nth(i).unwrap() == 'o' {\n\
    \            alphabet.insert(message.chars().nth(i).unwrap());\n            i\
    \ += 1;\n        }\n        if message.chars().nth(i).unwrap() == 'u' {\n    \
    \        alphabet.insert(message.chars().nth(i).unwrap());\n            i += 1;\n\
    \        }\n        if message.chars().nth(i).unwrap() == 'A' {\n            alphabet.insert(message.chars().nth(i).unwrap());\n\
    \            i += 1;\n        }\n        if message.chars().nth(i).unwrap() ==\
    \ 'E' {\n            alphabet.insert(message.chars().nth(i).unwrap());\n     \
    \       i += 1;\n        }\n        if message.chars().nth(i).unwrap() == 'I'\
    \ {\n            alphabet.insert(message.chars().nth(i).unwrap());\n         \
    \   i += 1;\n        }\n        if message.chars().nth(i).unwrap() == 'O' {\n\
    \            alphabet.insert(message.chars().nth(i).unwrap());\n            i\
    \ += 1;\n        }\n        if message.chars().nth(i).unwrap() == 'U' {\n    \
    \        alphabet.insert(message.chars().nth(i).unwrap());\n            i += 1;\n\
    \        }\n        if message.chars().nth(i).unwrap() == 'a' {\n            alphabet.insert(message.chars().nth(i).unwrap());\n\
    \            i += 1;\n        }\n        if message.chars().nth(i).unwrap() ==\
    \ 'e' {\n            alphabet.insert(message.chars().nth(i).unwrap());\n     \
    \       i += 1;\n        }\n        if message.chars().nth(i).unwrap() == 'i'\
    \ {\n            alphabet.insert(message.chars().nth(i).unwrap());\n         \
    \   i += 1;\n        }\n        if message.chars().nth(i).unwrap() == 'o' {\n\
    \            alphabet.insert(message.chars().nth(i).unwrap());\n            i\
    \ += 1;\n        }\n        if message.chars().\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpac5qw4xf.rs:86:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n19 |     while i < message.len()\
    \ {\n   |                             - this delimiter might not be properly closed...\n\
    ...\n77 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    86 | }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpac5qw4xf.rs:77:1\n\
    \   |\n77 | }\n   | ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpac5qw4xf.rs:77:1\n\
    \   |\n76 |         if message.chars().\n   |         -- this `if` expression\
    \ has a condition, but no block\n77 | }\n   | ^ expected `{`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpac5qw4xf.rs:13:22\n\
    \   |\n13 |     let mut vowels = HashSet::new();\n   |                      ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpac5qw4xf.rs:14:24\n   |\n14\
    \ |     let mut alphabet = HashSet::new();\n   |                        ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpac5qw4xf.rs:11:31\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |    ------                     ^^^^^^ expected struct `String`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_counts = vec![0, 1, 2, 3, 4, 5];\n    let mut letter_counts_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6];\n    let mut letter_counts_index2 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8];\n    let mut letter_counts_index3 = vec![0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9, 10];\n    let mut letter_counts_index4 = vec![0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9, 10, 11];\n    let mut letter_counts_index5 = vec![0, 1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9, 10, 11, 12];\n    let mut letter_counts_index6 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];\n    let mut letter_counts_index7 =\
    \ vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14];\n    let mut letter_counts_index8\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\n    let mut letter_counts_index9\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\n    let mut\
    \ letter_counts_index10 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\
    \ 15, 16, 17];\n    let mut letter_counts_index11 = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18];\n    let mut letter_counts_index12\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];\n\
    \    let mut letter_counts_index13 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20];\n    let mut letter_counts_index14 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21];\n\
    \    let mut letter_counts_index15 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22];\n    let mut letter_counts_index16\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23];\n    let mut letter_counts_index17 = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24];\n \
    \   let mut letter_counts_index18 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25];\n    let mut letter_counts_index19\
    \ = vec![0, 1, 2, 3, 4, 5, \n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmps16i3l34.rs:35:1\n   |\n35 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmps16i3l34.rs:34:41\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n34 |     let mut letter_counts_index19 = vec![0, 1, 2, 3, 4,\
    \ 5, \n   |                                         ^ unclosed delimiter\n35 |\
    \ }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letter_pairs = vec!['b', 'c', 'd', 'f', 'g',\
    \ 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut letter_pairs2 = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l',\
    \ 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut letter_pairs3\
    \ = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r',\
    \ 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut letter_pairs4 = vec!['b', 'c',\
    \ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut letter_pairs5 = vec!['b', 'c', 'd', 'f', 'g', 'h',\
    \ 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut letter_pairs6 = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l',\
    \ 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut letter_pairs7\
    \ = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r',\
    \ 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut letter_pairs8 = vec!['b', 'c',\
    \ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut letter_pairs9 = vec!['b', 'c', 'd', 'f', 'g', 'h',\
    \ 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut letter_pairs10 = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l',\
    \ 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut letter_pairs11\
    \ = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r',\
    \ 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut letter_pairs12 = vec!['b',\
    \ 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    let mut letter_pairs13 = vec!['b', 'c', 'd', 'f',\
    \ 'g', 'h', 'j\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpz_6jeq5x.rs:27:1\n   |\n27 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpz_6jeq5x.rs:26:34\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n26 |     let mut letter_pairs13 = vec!['b', 'c', 'd', 'f', 'g',\
    \ 'h', 'j\n   |                                  ^ unclosed delimiter\n27 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashMap::new();\n\
    \    let mut vowels_encoded = HashMap::new();\n    let mut vowels_encoded1 = HashMap::new();\n\
    \    let mut vowels_encoded2 = HashMap::new();\n    let mut vowels_encoded3 =\
    \ HashMap::new();\n    let mut vowels_encoded4 = HashMap::new();\n    let mut\
    \ vowels_encoded5 = HashMap::new();\n    let mut vowels_encoded6 = HashMap::new();\n\
    \    let mut vowels_encoded7 = HashMap::new();\n    let mut vowels_encoded8 =\
    \ HashMap::new();\n    let mut vowels_encoded9 = HashMap::new();\n    let mut\
    \ vowels_encoded10 = HashMap::new();\n    let mut vowels_encoded11 = HashMap::new();\n\
    \    let mut vowels_encoded12 = HashMap::new();\n    let mut vowels_encoded13\
    \ = HashMap::new();\n    let mut vowels_encoded14 = HashMap::new();\n    let mut\
    \ vowels_encoded15 = HashMap::new();\n    let mut vowels_encoded16 = HashMap::new();\n\
    \    let mut vowels_encoded17 = HashMap::new();\n    let mut vowels_encoded18\
    \ = HashMap::new();\n    let mut vowels_encoded19 = HashMap::new();\n    let mut\
    \ vowels_encoded20 = HashMap::new();\n    let mut vowels_encoded21 = HashMap::new();\n\
    \    let mut vowels_encoded22 = HashMap::new();\n    let mut vowels_encoded23\
    \ = HashMap::new();\n    let mut vowels_encoded24 = HashMap::new();\n    let mut\
    \ vowels_encoded25 = HashMap::new();\n    let mut vowels_encoded26 = HashMap::new();\n\
    \    let mut vowels_encoded27 = HashMap::new();\n    let mut vowels_encoded28\
    \ = HashMap::new();\n    let mut vowels_encoded29 = HashMap::new();\n    let mut\
    \ vowels_encoded30 = HashMap::new();\n    let mut vowels_encoded31 = HashMap::new();\n\
    \    let mut vowels_encoded32 = HashMap::new();\n    let mut vowels_encoded33\
    \ = HashMap::new();\n    let mut vowels_encoded34 = HashMap::new();\n    let mut\
    \ vowels_encoded35 = HashMap::new();\n\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp7ralphtz.rs:13:22\n   |\n13 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp7ralphtz.rs:14:30\n\
    \   |\n14 |     let mut vowels_encoded = HashMap::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp7ralphtz.rs:15:31\n\
    \   |\n15 |     let mut vowels_encoded1 = HashMap::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp7ralphtz.rs:16:31\n\
    \   |\n16 |     let mut vowels_encoded2 = HashMap::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp7ralphtz.rs:17:31\n\
    \   |\n17 |     let mut vowels_encoded3 = HashMap::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp7ralphtz.rs:18:31\n\
    \   |\n18 |     let mut vowels_encoded4 = HashMap::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp7ralphtz.rs:19:31\n\
    \   |\n19 |     let mut vowels_encoded5 = HashMap::new();\n   |              \
    \                 ^^^^^^^ not found i"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashMap::new();\n\
    \    vowels.insert(String::from(\"a\"), String::from(\"A\"));\n    vowels.insert(String::from(\"\
    e\"), String::from(\"E\"));\n    vowels.insert(String::from(\"i\"), String::from(\"\
    I\"));\n    vowels.insert(String::from(\"o\"), String::from(\"O\"));\n    vowels.insert(String::from(\"\
    u\"), String::from(\"U\"));\n    vowels.insert(String::from(\"y\"), String::from(\"\
    Y\"));\n    for letter in message.chars() {\n        let mut replacement = String::new();\n\
    \        if let Some(vowel) = vowels.get(&letter) {\n            replacement =\
    \ vowels[vowel];\n        }\n        result.push((letter + replacement).to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpvrlvxeqo.rs:13:22\n   |\n13 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0369]:\
    \ cannot add `String` to `char`\n  --> /tmp/tmpvrlvxeqo.rs:25:29\n   |\n25 | \
    \        result.push((letter + replacement).to_string());\n   |              \
    \        ------ ^ ----------- String\n   |                      |\n   |      \
    \                char\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0369, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n    let \n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpy47w3a24.rs:77:1\n  \
    \ |\n77 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmpy47w3a24.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_index = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count = vec![0];\n    let mut letters_count\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut letters_count_index\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut letters_count_index\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut letters_count_index\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut letters_count_index\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut letters_count_index\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut letters_count_index\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut letters_count_index\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut letters_count_index\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut letters_count_index\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut letters_count_index\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut letters_count_index\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut letters_count_index\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut letters_count_index\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut letters_count_index\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut letters_count_index\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut letters_count_index\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut letters_count_index\
    \ = vec![0];\n    let mut vowels_count_index = vec![0];\n    let mut letters_\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp39qu3q_6.rs:54:21\n   |\n\
    54 |     let mut letters_\n   |                     ^ help: add `;` here\n55 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp39qu3q_6.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_count = vec![0];\n    let mut letter_count_index = vec![0];\n   \
    \ let mut letter_count_index2 = vec![0];\n    let mut letter_count_index3 = vec![0];\n\
    \    let mut letter_count_index4 = vec![0];\n    let mut letter_count_index5 =\
    \ vec![0];\n    let mut letter_count_index6 = vec![0];\n    let mut letter_count_index7\
    \ = vec![0];\n    let mut letter_count_index8 = vec![0];\n    let mut letter_count_index9\
    \ = vec![0];\n    let mut letter_count_index10 = vec![0];\n    let mut letter_count_index11\
    \ = vec![0];\n    let mut letter_count_index12 = vec![0];\n    let mut letter_count_index13\
    \ = vec![0];\n    let mut letter_count_index14 = vec![0];\n    let mut letter_count_index15\
    \ = vec![0];\n    let mut letter_count_index16 = vec![0];\n    let mut letter_count_index17\
    \ = vec![0];\n    let mut letter_count_index18 = vec![0];\n    let mut letter_count_index19\
    \ = vec![0];\n    let mut letter_count_index20 = vec![0];\n    let mut letter_count_index21\
    \ = vec![0];\n    let mut letter_count_index22 = vec![0];\n    let mut letter_count_index23\
    \ = vec![0];\n    let mut letter_count_index24 = vec![0];\n    let mut letter_count_index25\
    \ = vec![0];\n    let mut letter_count_index26 = vec![0];\n    let mut letter_count_index27\
    \ = vec![0];\n    let mut letter_count_index28 = vec![0];\n    let mut letter_count_index29\
    \ = vec![0];\n    let mut letter_count_index30 = vec![0];\n    let mut letter_count_index31\
    \ = vec![0];\n    let mut letter_count_index32 = vec![0];\n    let mut letter_count_index33\
    \ = vec![0];\n    let mut letter_count_index34 = vec![0];\n    let mut letter_count_index35\
    \ = vec![0];\n    let mut letter_count_index36 = vec![0];\n    let mut letter_count_index37\
    \ = vec![0];\n    let mut letter_count_index38 = vec![0];\n    let mut letter_count_index39\
    \ = vec![0];\n    let mut letter_count_index40 = vec!\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `}`\n  --> /tmp/tmpwzd1ao45.rs:56:1\n\
    \   |\n55 |     let mut letter_count_index40 = vec!\n   |                    \
    \                    - expected one of `(`, `[`, or `{`\n56 | }\n   | ^ unexpected\
    \ token\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    alphabet.insert(String::from(\"a\"\
    ));\n    alphabet.insert(String::from(\"b\"));\n    alphabet.insert(String::from(\"\
    c\"));\n    alphabet.insert(String::from(\"d\"));\n    alphabet.insert(String::from(\"\
    e\"));\n    alphabet.insert(String::from(\"f\"));\n    alphabet.insert(String::from(\"\
    g\"));\n    alphabet.insert(String::from(\"h\"));\n    alphabet.insert(String::from(\"\
    i\"));\n    alphabet.insert(String::from(\"j\"));\n    alphabet.insert(String::from(\"\
    k\"));\n    alphabet.insert(String::from(\"l\"));\n    alphabet.insert(String::from(\"\
    m\"));\n    alphabet.insert(String::from(\"n\"));\n    alphabet.insert(String::from(\"\
    o\"));\n    alphabet.insert(String::from(\"p\"));\n    alphabet.insert(String::from(\"\
    q\"));\n    alphabet.insert(String::from(\"r\"));\n    alphabet.insert(String::from(\"\
    s\"));\n    alphabet.insert(String::from(\"t\"));\n    alphabet.insert(String::from(\"\
    u\"));\n    alphabet.insert(String::from(\"v\"));\n    alphabet.insert(String::from(\"\
    w\"));\n    alphabet.insert(String::from(\"x\"));\n    alphabet.insert(String::from(\"\
    y\"));\n    alphabet.insert(String::from(\"z\"));\n    alphabet.insert(String::from(\"\
    A\"));\n    alphabet.insert(String::from(\"B\"));\n    alphabet.insert(String::from(\"\
    C\"));\n    alphabet.insert(String::from(\"D\"));\n    alphabet.insert(String::from(\"\
    E\"));\n    alphabet.insert(String::from(\"F\"));\n    alphabet.insert(String::from(\"\
    G\"));\n    alphabet.insert(String::from(\"H\"));\n    alphabet.insert(String::from(\"\
    I\"));\n    alphabet.insert(String::from(\"J\"));\n    alphabet.insert(String::from(\"\
    K\"));\n    alphabet.insert(String::from(\"L\"));\n    alphabet.insert(String::from(\"\
    M\"));\n    alphabet.insert(String::from(\"N\"));\n    alphabet.insert(String::from(\"\
    O\"));\n    alphabet.insert(String::from(\"P\"));\n    alphabet.insert(String::from(\"\
    Q\"));\n    alphabet.insert(String::from(\"\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp56v77b50.rs:67:109\n\
    \   |\n67 |       assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\"\
    )), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n   |  _____________________________________________________________________________________________________________^\n\
    68 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    for letter in message.chars() {\n        if let Some(vowel) = vowels.binary_search(&letter)\
    \ {\n            result.push_str(&letters[vowel]);\n            index = vowel\
    \ + 1;\n        } else {\n            result.push_str(&letters[letter]);\n   \
    \         index = letter + 1;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ufbo22b.rs:17:51\n   |\n\
    17 |         if let Some(vowel) = vowels.binary_search(&letter) {\n   |      \
    \                                             ^^^^^^^ expected `&str`, found `char`\n\
    \   |\n   = note: expected reference `&&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2ufbo22b.rs:17:16\n   |\n17 |\
    \         if let Some(vowel) = vowels.binary_search(&letter) {\n   |         \
    \       ^^^^^^^^^^^   ----------------------------- this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0277]: the type `[&str]` cannot\
    \ be indexed by `char`\n  --> /tmp/tmp2ufbo22b.rs:21:30\n   |\n21 |          \
    \   result.push_str(&letters[letter]);\n   |                              ^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[&str]>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `Index<char>` for `Vec<&str>`\n\n\
    error[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmp2ufbo22b.rs:22:28\n\
    \   |\n22 |             index = letter + 1;\n   |                     ------ ^\
    \ - {integer}\n   |                     |\n   |                     char\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0369.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if vowels.contains(&letter) {\n            result.push_str(&vowels[vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()]].to_string());\n        } else {\n            result.push_str(&letter.to_string());\n\
    \        }\n        letter_counter += 1;\n        if letter_counter == 2 && vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()] == 0 {\n            vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()] = vowels_index[vowels.iter().position(|x| x == letter).unwrap()]\
    \ + 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps9nyb8n4.rs:17:28\n   |\n\
    17 |         if vowels.contains(&letter) {\n   |                            ^^^^^^^\
    \ expected `&str`, found `char`\n   |\n   = note: expected reference `&&str`\n\
    \              found reference `&char`\n\nerror[E0277]: can't compare `&&str`\
    \ with `char`\n  --> /tmp/tmps9nyb8n4.rs:18:79\n   |\n18 |             result.push_str(&vowels[vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()]].to_string());\n   |                                \
    \                                               ^^ no implementation for `&&str\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&&str` with `char`\n  --> /tmp/tmps9nyb8n4.rs:23:77\n   |\n23 |         if\
    \ letter_counter == 2 && vowels_index[vowels.iter().position(|x| x == letter).unwrap()]\
    \ == 0 {\n   |                                                               \
    \              ^^ no implementation for `&&str == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `&&str` with `char`\n \
    \ --> /tmp/tmps9nyb8n4.rs:24:55\n   |\n24 | ."
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    vowels.insert(String::from('a'));\n    vowels.insert(String::from('e'));\n\
    \    vowels.insert(String::from('i'));\n    vowels.insert(String::from('o'));\n\
    \    vowels.insert(String::from('u'));\n    vowels.insert(String::from('y'));\n\
    \    vowels.insert(String::from('A'));\n    vowels.insert(String::from('E'));\n\
    \    vowels.insert(String::from('I'));\n    vowels.insert(String::from('O'));\n\
    \    vowels.insert(String::from('U'));\n    vowels.insert(String::from('Y'));\n\
    \    vowels.insert(String::from('0'));\n    vowels.insert(String::from('1'));\n\
    \    vowels.insert(String::from('2'));\n    vowels.insert(String::from('3'));\n\
    \    vowels.insert(String::from('4'));\n    vowels.insert(String::from('5'));\n\
    \    vowels.insert(String::from('6'));\n    vowels.insert(String::from('7'));\n\
    \    vowels.insert(String::from('8'));\n    vowels.insert(String::from('9'));\n\
    \    vowels.insert(String::from('.'));\n    vowels.insert(String::from('!'));\n\
    \    vowels.insert(String::from('?'));\n    vowels.insert(String::from('('));\n\
    \    vowels.insert(String::from(')'));\n    vowels.insert(String::from(','));\n\
    \    vowels.insert(String::from('-'));\n    vowels.insert(String::from(';'));\n\
    \    vowels.insert(String::from(':'));\n    vowels.insert(String::from(';'));\n\
    \    vowels.insert(String::from('!'));\n    vowels.insert(String::from('?'));\n\
    \    vowels.insert(String::from('.'));\n    vowels.insert(String::from(','));\n\
    \    vowels.insert(String::from('-'));\n    vowels.insert(String::from(';'));\n\
    \    vowels.insert(String::from(':'));\n    vowels.insert(String::from(';'));\n\
    \    vowels.insert(String::from('!'));\n    vowels.insert(String::from('?'));\n\
    \    vowels.insert(String::from('.'));\n    vowels.insert(String::from(','));\n\
    \    vowels.insert(String::from('-'));\n    vowels.\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp9l072m7g.rs:60:1\n   |\n60\
    \ | }\n   | ^\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmp9l072m7g.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for c in message.chars() {\n    \
    \    if vowels.contains(&c) {\n            vowel_counter += 1;\n        }\n  \
    \      if alphabet.contains(&c) {\n            letter_counter += 1;\n        }\n\
    \    }\n    for c in message.chars() {\n        if vowels.contains(&c) {\n   \
    \         if vowel_counter == 2 {\n                result.push((&alphabet[alphabet.index(&c)\
    \ + 1]).to_string());\n                vowel_counter = 0;\n            } else\
    \ {\n                result.push((&alphabet[alphabet.index(&c)]).to_string());\n\
    \            }\n        } else {\n            if letter_counter == 2 {\n     \
    \           result.push((&alphabet[alphabet.index(&c) - 1]).to_string());\n  \
    \              letter_counter = 0;\n            } else {\n                result.push((&alphabet[alphabet.index(&c)]).to_string());\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpheibspi4.rs:18:28\n\
    \     |\n18   |         if vowels.contains(&c) {\n     |                   --------\
    \ ^^ expected an `Fn<(char,)>` closure, found `char`\n     |                 \
    \  |\n     |                   required by a bound introduced by this call\n \
    \    |\n     = help: the trait `Fn<(char,)>` is not implemented for `char`\n \
    \    = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n18   |         if vowels.contains(*&c)\
    \ {\n     |                            +\n\nerror[E0277]: expected a `Fn<(char,)>`\
    \ closure, found `char`\n    --> /tmp/tmpheibspi4.rs:21:30\n     |\n21   |   \
    \      if alphabet.contains(&c) {\n     |                     -------- ^^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n     |                     |\n     |\
    \                     required by a bound introduced by this call\n     |\n  \
    \   = help: the trait `Fn<(char,)>` is not implemented for `char`\n     = note:\
    \ required because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n21   |         if alphabet.contains(*&c)\
    \ {\n     |                              +\n\nerror[E0277]: expected a `Fn<(char,)>`\
    \ closure, found `char`\n    --> /tmp/tmpheibspi4.rs:26:28\n     |\n26   |   \
    \      if vowels.contains(&c) {\n     |                   -------- ^^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n     |                   |\n     | \
    \                  required by a bound introduced by this call\n     |\n     =\
    \ help: the trait `Fn<(char,)>` is not implemented for `char`\n     = note: required\
    \ because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n \
    \    = note: r"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut vowels_index = String::new();\n    let mut vowels_index2\
    \ = String::new();\n    let mut vowels_index3 = String::new();\n    let mut vowels_index4\
    \ = String::new();\n    let mut vowels_index5 = String::new();\n    let mut vowels_index6\
    \ = String::new();\n    let mut vowels_index7 = String::new();\n    let mut vowels_index8\
    \ = String::new();\n    let mut vowels_index9 = String::new();\n    let mut vowels_index10\
    \ = String::new();\n    let mut vowels_index11 = String::new();\n    let mut vowels_index12\
    \ = String::new();\n    let mut vowels_index13 = String::new();\n    let mut vowels_index14\
    \ = String::new();\n    let mut vowels_index15 = String::new();\n    let mut vowels_index16\
    \ = String::new();\n    let mut vowels_index17 = String::new();\n    let mut vowels_index18\
    \ = String::new();\n    let mut vowels_index19 = String::new();\n    let mut vowels_index20\
    \ = String::new();\n    let mut vowels_index21 = String::new();\n    let mut vowels_index22\
    \ = String::new();\n    let mut vowels_index23 = String::new();\n    let mut vowels_index24\
    \ = String::new();\n    let mut vowels_index25 = String::new();\n    let mut vowels_index26\
    \ = String::new();\n    let mut vowels_index27 = String::new();\n    let mut vowels_index28\
    \ = String::new();\n    let mut vowels_index29 = String::new();\n    let mut vowels_index30\
    \ = String::new();\n    let mut vowels_index31 = String::new();\n    let mut vowels_index32\
    \ = String::new();\n    let mut vowels_index33 = String::new();\n    let mut vowels_index34\
    \ = String::new();\n    let mut vowels_index35 = String::new();\n    let mut vowels_index36\
    \ = String::new();\n    let mut vowels_index37 = String::new();\n    let mut vowels_index38\
    \ = String::new();\n    let mut vowels_index39 = \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpp6xsoj3u.rs:53:1\n\
    \   |\n53 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letter_map = HashMap::new();\n\
    \    let mut letter_counter = 0;\n    let mut letter_counter2 = 0;\n    let mut\
    \ letter_counter3 = 0;\n    let mut letter_counter4 = 0;\n    let mut letter_counter5\
    \ = 0;\n    let mut letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n \
    \   let mut letter_counter8 = 0;\n    let mut letter_counter9 = 0;\n    let mut\
    \ letter_counter10 = 0;\n    let mut letter_counter11 = 0;\n    let mut letter_counter12\
    \ = 0;\n    let mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n\
    \    let mut letter_counter15 = 0;\n    let mut letter_counter16 = 0;\n    let\
    \ mut letter_counter17 = 0;\n    let mut letter_counter18 = 0;\n    let mut letter_counter19\
    \ = 0;\n    let mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n\
    \    let mut letter_counter22 = 0;\n    let mut letter_counter23 = 0;\n    let\
    \ mut letter_counter24 = 0;\n    let mut letter_counter25 = 0;\n    let mut letter_counter26\
    \ = 0;\n    let mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n\
    \    let mut letter_counter29 = 0;\n    let mut letter_counter30 = 0;\n    let\
    \ mut letter_counter31 = 0;\n    let mut letter_counter32 = 0;\n    let mut letter_counter33\
    \ = 0;\n    let mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n\
    \    let mut letter_counter36 = 0;\n    let mut letter_counter37 = 0;\n    let\
    \ mut letter_counter38 = 0;\n    let mut letter_counter39 = 0;\n    let mut letter_counter40\
    \ = 0;\n    let mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n\
    \    let mut letter_counter43 = 0;\n    let mut letter_counter44 = 0;\n    let\
    \ mut letter_counter45 = 0;\n    let mut letter_counter46 = 0;\n    let mut letter_counter47\
    \ = 0;\n    let mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n\
    \    let mut letter_counter50 = 0;\n    let mut letter_counter51 = 0;\n    let\
    \ mut letter_counter52 = 0;\n    let mut letter_counter53 = 0;\n    let mut letter_counter54\
    \ = 0;\n    let mut letter_counter55 = 0;\n    let mut letter_counter56 = 0;\n\
    \    let mut letter_counter57 = 0;\n    let mut letter_counter58 = 0;\n    let\
    \ mut letter_counter59 = 0;\n    let mut letter_counter60 = 0;\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpls2g5ia3.rs:14:26\n   |\n14 |     let mut letter_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpls2g5ia3.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    for letter in message.chars() {\n\
    \        if letter.is_uppercase() {\n            letters.insert(letter);\n   \
    \     } else {\n            vowels.insert(letter);\n        }\n    }\n    for\
    \ vowel in vowels.iter() {\n        for letter in letters.iter() {\n         \
    \   let index = vowel.as_bytes().position(vowel.as_bytes());\n            result.push((letters[letter].as_bytes()[index\
    \ + 1]).to_ascii_lowercase());\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmplfhsl6q9.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmplfhsl6q9.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    for c in message.chars() {\n        if c.is_uppercase() {\n            result.push(c);\n\
    \        } else {\n            if vowels.contains(&c.to_ascii_lowercase()) {\n\
    \                result.push(c);\n            } else {\n                result.push((&c.to_ascii_lowercase()[..2]\
    \ + &c.to_ascii_lowercase()[3..]).to_ascii_lowercase());\n                vowels.insert(c.to_ascii_lowercase());\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpgc7xoihg.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0608]:\
    \ cannot index into a value of type `char`\n  --> /tmp/tmpgc7xoihg.rs:21:31\n\
    \   |\n21 |                 result.push((&c.to_ascii_lowercase()[..2] + &c.to_ascii_lowercase()[3..]).to_ascii_lowercase());\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `char`\n  --> /tmp/tmpgc7xoihg.rs:21:62\n\
    \   |\n21 |                 result.push((&c.to_ascii_lowercase()[..2] + &c.to_ascii_lowercase()[3..]).to_ascii_lowercase());\n\
    \   |                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0608.\nFor more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_index = HashSet::new();\n    let mut vowels_index2 = HashSet::new();\n\
    \    let mut vowels_index3 = HashSet::new();\n    let mut vowels_index4 = HashSet::new();\n\
    \    let mut vowels_index5 = HashSet::new();\n    let mut vowels_index6 = HashSet::new();\n\
    \    let mut vowels_index7 = HashSet::new();\n    let mut vowels_index8 = HashSet::new();\n\
    \    let mut vowels_index9 = HashSet::new();\n    let mut vowels_index10 = HashSet::new();\n\
    \    let mut vowels_index11 = HashSet::new();\n    let mut vowels_index12 = HashSet::new();\n\
    \    let mut vowels_index13 = HashSet::new();\n    let mut vowels_index14 = HashSet::new();\n\
    \    let mut vowels_index15 = HashSet::new();\n    let mut vowels_index16 = HashSet::new();\n\
    \    let mut vowels_index17 = HashSet::new();\n    let mut vowels_index18 = HashSet::new();\n\
    \    let mut vowels_index19 = HashSet::new();\n    let mut vowels_index20 = HashSet::new();\n\
    \    let mut vowels_index21 = HashSet::new();\n    let mut vowels_index22 = HashSet::new();\n\
    \    let mut vowels_index23 = HashSet::new();\n    let mut vowels_index24 = HashSet::new();\n\
    \    let mut vowels_index25 = HashSet::new();\n    let mut vowels_index26 = HashSet::new();\n\
    \    let mut vowels_index27 = HashSet::new();\n    let mut vowels_index28 = HashSet::new();\n\
    \    let mut vowels_index29 = HashSet::new();\n    let mut vowels_index30 = HashSet::new();\n\
    \    let mut vowels_index31 = HashSet::new();\n    let mut vowels_index32 = HashSet::new();\n\
    \    let mut vowels_index33 = HashSet::new();\n    let mut vowels_index34 = HashSet::new();\n\
    \    let mut vowels_index35 = HashSet::new();\n    let mut vowels_index36 = HashSet::new();\n\
    \    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp6k7vrakn.rs:51:1\n  \
    \ |\n51 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmp6k7vrakn.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6k7vrakn.rs:14:28\n   |\n14 |     let mut vowels_index = HashSet::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6k7vrakn.rs:15:29\n   |\n15 |     let mut vowels_index2 = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6k7vrakn.rs:16:29\n   |\n16 |     let mut vowels_index3 = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6k7vrakn.rs:17:29\n   |\n17 |     let mut vowels_index4 = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6k7vrakn.rs:18:29\n   |\n18 |     let mut vowels_index5 = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6k7vrakn.rs:19:29\n   |\n19 |     let mut vowel"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if let Some(vowel) = vowels.find(letter) {\n            if letter_counter\
    \ == 0 {\n                letter_counter = vowel;\n            }\n           \
    \ if letter_counter == vowel {\n                vowel_counter = vowel;\n     \
    \       }\n        }\n        if let Some(letter) = alphabet.find(letter) {\n\
    \            if letter_counter == 0 {\n                letter_counter = letter;\n\
    \            }\n            if letter_counter == letter {\n                vowel_counter\
    \ = letter;\n            }\n        }\n        if vowel_counter != 0 {\n     \
    \       result.push((vowel_counter + vowel_counter).to_string());\n          \
    \  vowel_counter = 0;\n        }\n        if letter_counter != 0 {\n         \
    \   result.push((letter_counter + letter_counter).to_string());\n            letter_counter\
    \ = 0;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmgfjzdkw.rs:35:25\n   |\n\
    35 |             result.push((vowel_counter + vowel_counter).to_string());\n \
    \  |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmgfjzdkw.rs:39:25\n\
    \   |\n39 |             result.push((letter_counter + letter_counter).to_string());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letter_pairs = vec!['AA',\
    \ 'BB', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN',\
    \ 'OO', 'PP', 'QQ', 'RR', 'SS', 'TT', 'UU', 'VV', 'WW', 'XX', 'YY', 'ZZ'];\n \
    \   let mut letter_pairs_reverse = vec!['ZZ', 'VV', 'UU', 'TT', 'RR', 'QQ', 'PP',\
    \ 'OO', 'NN', 'MM', 'LL', 'KK', 'JJ', 'II', 'HH', 'GG', 'FF', 'DD', 'CC', 'BB',\
    \ 'AA'];\n    let mut letter_pairs_reverse2 = vec!['ZZ', 'VV', 'UU', 'TT', 'RR',\
    \ 'QQ', 'PP', 'OO', 'NN', 'MM', 'LL', 'KK', 'JJ', 'II', 'HH', 'GG', 'FF', 'DD',\
    \ 'CC', 'BB', 'AA'];\n    let mut letter_pairs_reverse3 = vec!['ZZ', 'VV', 'UU',\
    \ 'TT', 'RR', 'QQ', 'PP', 'OO', 'NN', 'MM', 'LL', 'KK', 'JJ', 'II', 'HH', 'GG',\
    \ 'FF', 'DD', 'CC', 'BB', 'AA'];\n    let mut letter_pairs_reverse4 = vec!['ZZ',\
    \ 'VV', 'UU', 'TT', 'RR', 'QQ', 'PP', 'OO', 'NN', 'MM', 'LL', 'KK', 'JJ', 'II',\
    \ 'HH', 'GG', 'FF', 'DD', 'CC', 'BB', 'AA'];\n    let mut letter_pairs_reverse5\
    \ = vec!['ZZ', 'VV', 'UU', 'TT', 'RR', 'QQ', 'PP', 'OO', 'NN', 'MM', 'LL', 'KK',\
    \ 'JJ', 'II', 'HH', 'GG', 'FF', 'DD', 'CC', 'BB', 'AA'];\n    let mut letter_pairs_reverse6\
    \ = vec!['ZZ', 'VV', 'UU', 'TT', 'RR', 'QQ', 'PP', 'OO', 'NN', 'MM', 'LL', 'KK',\
    \ 'JJ', 'II', 'HH', 'GG', 'FF', 'DD', 'CC', 'BB', 'AA'];\n    let mut letter_pairs_reverse7\
    \ = vec!['ZZ', 'VV', 'UU', 'TT', 'RR', 'QQ', 'PP', 'OO', 'NN', 'MM', 'LL', 'KK',\
    \ 'JJ', 'II', 'HH', 'GG', 'FF', 'DD', 'CC', 'BB\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmp189dm37j.rs:14:33\n\
    \   |\n14 |     let mut letter_pairs = vec!['AA', 'BB', 'CC', 'DD', 'EE', 'FF',\
    \ 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN', 'OO', 'PP', 'QQ', 'RR...\n \
    \  |                                 ^^^^\n   |\nhelp: if you meant to write a\
    \ `str` literal, use double quotes\n   |\n14 |     let mut letter_pairs = vec![\"\
    AA\", 'BB', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM',\
    \ 'NN', 'OO', 'PP', 'QQ', 'RR', 'SS', 'TT', 'UU', 'VV', 'WW', 'XX', 'YY', 'ZZ'];\n\
    \   |                                 ~~~~\n\nerror: character literal may only\
    \ contain one codepoint\n  --> /tmp/tmp189dm37j.rs:14:39\n   |\n14 |     let mut\
    \ letter_pairs = vec!['AA', 'BB', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ',\
    \ 'KK', 'LL', 'MM', 'NN', 'OO', 'PP', 'QQ', 'RR...\n   |                     \
    \                  ^^^^\n   |\nhelp: if you meant to write a `str` literal, use\
    \ double quotes\n   |\n14 |     let mut letter_pairs = vec!['AA', \"BB\", 'CC',\
    \ 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN', 'OO', 'PP',\
    \ 'QQ', 'RR', 'SS', 'TT', 'UU', 'VV', 'WW', 'XX', 'YY', 'ZZ'];\n   |         \
    \                              ~~~~\n\nerror: character literal may only contain\
    \ one codepoint\n  --> /tmp/tmp189dm37j.rs:14:45\n   |\n14 |     let mut letter_pairs\
    \ = vec!['AA', 'BB', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL',\
    \ 'MM', 'NN', 'OO', 'PP', 'QQ', 'RR...\n   |                                 \
    \            ^^^^\n   |\nhelp: if you meant to write a `str` literal, use double\
    \ quotes\n   |\n14 |     let mut letter_pairs = vec!['AA', 'BB', \"CC\", 'DD',\
    \ 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN', 'OO', 'PP', 'QQ',\
    \ 'RR', 'SS', 'TT', 'UU', 'VV', 'WW', 'XX', 'YY', 'ZZ'];\n   |               \
    \                              ~~~~\n\nerror: character literal may only contain\
    \ one codepoint\n  --> /tmp/tmp189dm37j.rs:14:51\n   |\n14 |     let mut letter_pairs\
    \ = vec!['AA', 'BB', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL',\
    \ 'MM', 'NN', 'OO', 'PP', 'QQ', 'RR...\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_pos = 0;\n    let mut letter_pos_index = 0;\n    let mut letter_pos_index2\
    \ = 0;\n    let mut letter_pos_index3 = 0;\n    let mut letter_pos_index4 = 0;\n\
    \    let mut letter_pos_index5 = 0;\n    let mut letter_pos_index6 = 0;\n    let\
    \ mut letter_pos_index7 = 0;\n    let mut letter_pos_index8 = 0;\n    let mut\
    \ letter_pos_index9 = 0;\n    let mut letter_pos_index10 = 0;\n    let mut letter_pos_index11\
    \ = 0;\n    let mut letter_pos_index12 = 0;\n    let mut letter_pos_index13 =\
    \ 0;\n    let mut letter_pos_index14 = 0;\n    let mut letter_pos_index15 = 0;\n\
    \    let mut letter_pos_index16 = 0;\n    let mut letter_pos_index17 = 0;\n  \
    \  let mut letter_pos_index18 = 0;\n    let mut letter_pos_index19 = 0;\n    let\
    \ mut letter_pos_index20 = 0;\n    let mut letter_pos_index21 = 0;\n    let mut\
    \ letter_pos_index22 = 0;\n    let mut letter_pos_index23 = 0;\n    let mut letter_pos_index24\
    \ = 0;\n    let mut letter_pos_index25 = 0;\n    let mut letter_pos_index26 =\
    \ 0;\n    let mut letter_pos_index27 = 0;\n    let mut letter_pos_index28 = 0;\n\
    \    let mut letter_pos_index29 = 0;\n    let mut letter_pos_index30 = 0;\n  \
    \  let mut letter_pos_index31 = 0;\n    let mut letter_pos_index32 = 0;\n    let\
    \ mut letter_pos_index33 = 0;\n    let mut letter_pos_index34 = 0;\n    let mut\
    \ letter_pos_index35 = 0;\n    let mut letter_pos_index36 = 0;\n    let mut letter_pos_index37\
    \ = 0;\n    let mut letter_pos_index38 = 0;\n    let mut letter_pos_index39 =\
    \ 0;\n    let mut letter_pos_index40 = 0;\n    let mut letter_pos_index41 = 0;\n\
    \    let mut letter_pos_index42 = 0;\n    let mut letter_pos_index43 = 0;\n  \
    \  let mut letter_pos_index44 = 0;\n    let mut letter_pos_index45 = 0;\n    let\
    \ mut letter_pos_index46 = 0;\n    let mut letter_pos_index47 = 0;\n    let mut\
    \ letter_pos_index48 = 0;\n    let mut letter_pos_index49 = 0;\n    let mut letter_pos_index50\
    \ = 0;\n    let mut letter_pos_index51 = 0;\n    let mut letter_pos_index52 =\
    \ 0;\n    let mut letter_\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo5r_1lk3.rs:68:20\n   |\n\
    68 |     let mut letter_\n   |                    ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo5r_1lk3.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_index\
    \ = 0;\n    let mut letters_index = 0;\n    for letter in message.chars() {\n\
    \        if letter == ' ' {\n            result.push_str(\" \");\n        } else\
    \ {\n            result.push_str(&letters[letters_index]);\n            if letter\
    \ == vowels[vowels_index] {\n                vowels_index += 1;\n            }\
    \ else {\n                letters_index += 1;\n            }\n        }\n    }\n\
    \    if vowels_index != 0 {\n        result.push_str(&vowels[vowels_index]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnq7y9pbw.rs:22:26\n   |\n\
    22 |             if letter == vowels[vowels_index] {\n   |                   \
    \       ^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&str`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut current_letter = 0;\n\
    \    let mut current_vowel = 0;\n    for c in message.chars() {\n        if index\
    \ == 0 {\n            result += letters[c];\n            current_letter = c;\n\
    \            current_vowel = 0;\n            index = 1;\n        } else {\n  \
    \          if c == current_letter {\n                current_vowel += 1;\n   \
    \         } else {\n                if current_vowel == 2 {\n                \
    \    result += letters[current_letter];\n                    current_letter =\
    \ c;\n                    current_vowel = 0;\n                    index = 1;\n\
    \                } else {\n                    result += letters[c];\n       \
    \             current_letter = c;\n                    current_vowel = 0;\n  \
    \                  index = 1;\n                }\n            }\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[char]` cannot be indexed by `char`\n  --> /tmp/tmpy4spcvim.rs:20:23\n\
    \   |\n20 |             result += letters[c];\n   |                       ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[char]>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `Index<char>` for `Vec<char>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpy4spcvim.rs:21:30\n   |\n16 |  \
    \   let mut current_letter = 0;\n   |                              - expected\
    \ due to this value\n...\n21 |             current_letter = c;\n   |         \
    \                     ^ expected integer, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpy4spcvim.rs:25:21\n   |\n25 |             if c == current_letter\
    \ {\n   |                     ^^^^^^^^^^^^^^ expected `char`, found integer\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpy4spcvim.rs:29:31\n   |\n29 |  \
    \                   result += letters[current_letter];\n   |                 \
    \              ^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy4spcvim.rs:30:38\n   |\n16 |     let mut current_letter\
    \ = 0;\n   |                              - expected due to this value\n...\n\
    30 |                     current_letter = c;\n   |                           \
    \           ^ expected `usize`, found `char`\n\nerror[E0277]: the type `[char]`\
    \ cannot be indexed by `char`\n  --> /tmp/tmpy4spcvim.rs:34:31\n   |\n34 |   \
    \                  result += letters[c];\n   |                               ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[char]>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `Index<char>` for `Vec<char>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpy4spcvim.rs:35:38\n   |\n16 |  \
    \   let mut current_letter = 0;\n   |                              - expected\
    \ due to this value\n...\n35 |                     current_letter = c;\n   | \
    \                                     ^ e"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n            vowels.insert(letter);\n\
    \            vowel_counter += 1;\n        }\n        if letter == 'A' || letter\
    \ == 'E' || letter == 'I' || letter == 'O' || letter == 'U' {\n            vowels.insert(letter);\n\
    \            vowel_counter += 1;\n        }\n        if letter == 'b' || letter\
    \ == 'c' || letter == 'd' || letter == 'f' || letter == 'g' || letter == 'h' ||\
    \ letter == 'j' || letter == 'k' || letter == 'l' || letter == 'm' || letter ==\
    \ 'n' || letter == 'p' || letter == 'q' || letter == 'r' || letter == 's' || letter\
    \ == 't' || letter == 'v' || letter == 'w' || letter == 'x' || letter == 'y' ||\
    \ letter == 'z' {\n            vowels.insert(letter);\n            vowel_counter\
    \ += 1;\n        }\n        if letter == 'B' || letter == 'C' || letter == 'D'\
    \ || letter == 'F' || letter == 'G' || letter == 'H' || letter == 'J' || letter\
    \ == 'K' || letter == 'L' || letter == 'M' || letter == 'N' || letter == 'P' ||\
    \ letter == 'Q' || letter == 'R' || letter == 'S' || letter == 'T' || letter ==\
    \ 'V' || letter == 'W' || letter == 'X' || letter == 'Y' || letter == 'Z' {\n\
    \            vowels.insert(letter);\n            vowel_counter += 1;\n       \
    \ }\n        if letter == '0' {\n            vowels.insert(letter);\n        \
    \    vowel_counter += 1;\n        }\n        if letter == '1' {\n            vowels.insert(letter);\n\
    \            vowel_counter += 1;\n        }\n        if letter == '2' {\n    \
    \        vowels.insert(letter);\n            vowel_counter += 1;\n        }\n\
    \        if letter == '3' {\n            vowels.insert(letter);\n            vowel_counter\
    \ += 1;\n        }\n        if letter == '4' {\n            vowels.insert(letter);\n\
    \            vowel_counter += 1;\n        }\n        if letter == '5' {\n    \
    \        vowels.insert(letter);\n            vowel_counter += 1;\n        }\n\
    \        if letter == '6' {\n            vowels.insert(letter);\n            vowel_counter\
    \ += 1;\n        }\n        if letter == '7' {\n            vowels.insert(letter);\n\
    \            vowel_counter += 1;\n        }\n        if letter == '8\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: lifetimes cannot start with a number\n  --> /tmp/tmphs47gcgj.rs:65:22\n\
    \   |\n65 |         if letter == '8\n   |                      ^^\n\nerror: this\
    \ file contains an unclosed delimiter\n  --> /tmp/tmphs47gcgj.rs:75:3\n   |\n\
    11 | fn encode(message: String) -> String {\n   |                            \
    \          - unclosed delimiter\n...\n16 |     for letter in message.chars() {\n\
    \   |                                   - this delimiter might not be properly\
    \ closed...\n...\n66 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n75 | }\n   |   ^\n\nerror: expected `while`, `for`, `loop` or `{` after a\
    \ label\n  --> /tmp/tmphs47gcgj.rs:66:1\n   |\n66 | }\n   | ^ expected `while`,\
    \ `for`, `loop` or `{` after a label\n\nerror: expected expression, found `}`\n\
    \  --> /tmp/tmphs47gcgj.rs:66:1\n   |\n66 | }\n   | ^ expected expression\n\n\
    error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmphs47gcgj.rs:13:22\n\
    \   |\n13 |     let mut vowels = HashSet::new();\n   |                      ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphs47gcgj.rs:11:31\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |    ------                     ^^^^^^ expected struct `String`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"AEIOU\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    for c in message.chars()\
    \ {\n        if let Some(index) = vowels.binary_search(&c) {\n            result.push_str(&letters[(index\
    \ + 1) % letters.len()]);\n        } else {\n            result.push_str(&c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `binary_search` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpx3dqagke.rs:16:37\n   |\n16 |         if\
    \ let Some(index) = vowels.binary_search(&c) {\n   |                         \
    \            ^^^^^^^^^^^^^ method not found in `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx3dqagke.rs:19:29\n   |\n19 |             result.push_str(&c);\n\
    \   |                             ^^ expected `str`, found `char`\n   |\n   =\
    \ note: expected reference `&str`\n              found reference `&char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = 0;\n    let mut letter_count = 1;\n    let mut letter_count_index\
    \ = 0;\n    let mut letter_count_index2 = 0;\n    let mut letter_count_index3\
    \ = 0;\n    let mut letter_count_index4 = 0;\n    let mut letter_count_index5\
    \ = 0;\n    let mut letter_count_index6 = 0;\n    let mut letter_count_index7\
    \ = 0;\n    let mut letter_count_index8 = 0;\n    let mut letter_count_index9\
    \ = 0;\n    let mut letter_count_index10 = 0;\n    let mut letter_count_index11\
    \ = 0;\n    let mut letter_count_index12 = 0;\n    let mut letter_count_index13\
    \ = 0;\n    let mut letter_count_index14 = 0;\n    let mut letter_count_index15\
    \ = 0;\n    let mut letter_count_index16 = 0;\n    let mut letter_count_index17\
    \ = 0;\n    let mut letter_count_index18 = 0;\n    let mut letter_count_index19\
    \ = 0;\n    let mut letter_count_index20 = 0;\n    let mut letter_count_index21\
    \ = 0;\n    let mut letter_count_index22 = 0;\n    let mut letter_count_index23\
    \ = 0;\n    let mut letter_count_index24 = 0;\n    let mut letter_count_index25\
    \ = 0;\n    let mut letter_count_index26 = 0;\n    let mut letter_count_index27\
    \ = 0;\n    let mut letter_count_index28 = 0;\n    let mut letter_count_index29\
    \ = 0;\n    let mut letter_count_index30 = 0;\n    let mut letter_count_index31\
    \ = 0;\n    let mut letter_count_index32 = 0;\n    let mut letter_count_index33\
    \ = 0;\n    let mut letter_count_index34 = 0;\n    let mut letter_count_index35\
    \ = 0;\n    let mut letter_count_index36 = 0;\n    let mut letter_count_index37\
    \ = 0;\n    let mut letter_count_index38 = 0;\n    let mut letter_count_index39\
    \ = 0;\n    let mut letter_count_index40 = 0;\n    let mut letter_count_index41\
    \ = 0;\n    let mut letter_count_index42 = 0;\n    let mut letter_count_index43\
    \ = 0;\n    let mut letter_count_index44 = 0;\n    let mut letter_count_index45\
    \ = 0;\n    let mut letter_count_index46 = 0;\n    let mut letter_count_index47\
    \ = 0;\n    let mut letter_count_index48 = 0;\n    let mut letter_count_index49\
    \ = 0;\n    let mut letter_count_index50 = 0;\n    let mut letter_count_index51\
    \ = 0;\n    let mut letter_count_index52 = 0;\n    let mut letter_count_index53\
    \ = 0;\n    let mut letter_count_index\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_well7tn.rs:69:31\n   |\n\
    69 |     let mut letter_count_index\n   |                               ^ help:\
    \ add `;` here\n70 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_well7tn.rs:11:31\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |    ------                     ^^^^^^ expected struct `String`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['b', 'c', 'd', 'f', 'g', 'h',\
    \ 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ current_letter = String::new();\n    let mut current_vowel = String::new();\n\
    \    for letter in message.chars() {\n        if vowels.contains(letter) {\n \
    \           if vowel_counter < 2 {\n                current_vowel = letter;\n\
    \                vowel_counter += 1;\n            } else {\n                current_vowel\
    \ = vowels[vowel_counter - 2];\n                vowel_counter -= 2;\n        \
    \    }\n        } else {\n            if letter_counter < 2 {\n              \
    \  current_letter = letter;\n                letter_counter += 1;\n          \
    \  } else {\n                current_letter = letters[letter_counter - 2];\n \
    \               letter_counter -= 2;\n            }\n        }\n        result.push_str(current_vowel);\n\
    \        result.push_str(current_letter);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfcy4p8au.rs:20:28\n   |\n\
    20 |         if vowels.contains(letter) {\n   |                            ^^^^^^\n\
    \   |                            |\n   |                            expected `&char`,\
    \ found `char`\n   |                            help: consider borrowing here:\
    \ `&letter`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfcy4p8au.rs:22:33\n\
    \   |\n18 |     let mut current_vowel = String::new();\n   |                 \
    \            ------------- expected due to this value\n...\n22 |             \
    \    current_vowel = letter;\n   |                                 ^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \         |\n   |                                 expected struct `String`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfcy4p8au.rs:25:33\n\
    \   |\n18 |     let mut current_vowel = String::new();\n   |                 \
    \            ------------- expected due to this value\n...\n25 |             \
    \    current_vowel = vowels[vowel_counter - 2];\n   |                        \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                 |\n   |                                \
    \ expected struct `String`, found `char`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpfcy4p8au.rs:30:34\n   |\n17 |     let mut current_letter = String::new();\n\
    \   |                              ------------- expected due to this value\n\
    ...\n30 |                 current_letter = letter;\n   |                     \
    \             ^^^^^^- help: try using a conversion method: `.to_string()`\n  \
    \ |                                  |\n   |                                 \
    \ expected struct `String`, found `char`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpfcy4p8au.rs:33:34\n   |\n17 |     let mut current_letter = String::new();\n\
    \   |                              ------------- expected due to this value\n\
    ...\n33 |                 current_letter = letters[letter_counter - 2];\n   |\
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letters = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\
    \ 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,\
    \ 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\
    \ 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82,\
    \ 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101,\
    \ 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,\
    \ 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,\
    \ 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,\
    \ 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165,\
    \ 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181,\
    \ 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197,\
    \ 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213,\
    \ 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229,\
    \ 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245,\
    \ 246, 247, 248, 249, 250, 251, 25\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp90qy_z4w.rs:17:1\n   |\n17 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp90qy_z4w.rs:16:33\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n16 |     let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28...\n   |                                 ^ unclosed delimiter\n17 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut i = 0;\n    let mut j = 0;\n    while i < message.len()\
    \ {\n        if message[i] == letters[j] {\n            result.push((message[i..].chars().skip(1).collect::<String>().to_owned()[..1]));\n\
    \            i += 1;\n            j += 1;\n        } else {\n            result.push((message[i..].chars().skip(1).collect::<String>().to_owned()[..]));\n\
    \            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpqm5gkc0m.rs:19:25\n\
    \   |\n19 |             result.push((message[i..].chars().skip(1).collect::<String>().to_owned()[..1]));\n\
    \   |                         ^                                              \
    \                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n19 -             result.push((message[i..].chars().skip(1).collect::<String>().to_owned()[..1]));\n\
    19 +             result.push(message[i..].chars().skip(1).collect::<String>().to_owned()[..1]);\n\
    \   | \n\nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpqm5gkc0m.rs:23:25\n\
    \   |\n23 |             result.push((message[i..].chars().skip(1).collect::<String>().to_owned()[..]));\n\
    \   |                         ^                                              \
    \                 ^\n   |\nhelp: remove these parentheses\n   |\n23 -        \
    \     result.push((message[i..].chars().skip(1).collect::<String>().to_owned()[..]));\n\
    23 +             result.push(message[i..].chars().skip(1).collect::<String>().to_owned()[..]);\n\
    \   | \n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmpqm5gkc0m.rs:18:12\n   |\n18 |         if message[i] == letters[j] {\n\
    \   |            ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqm5gkc0m.rs:19:25\n   |\n19 |             result.push((message[i..].chars().skip(1).collect::<String>().to_owned()[..1]));\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ e"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnkrmhr1k.rs:47:20\n   |\n\
    47 |     let mut vowels_\n   |                    ^ help: add `;` here\n48 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnkrmhr1k.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = vowels.len();\n    let mut letter_counter = 0;\n\
    \    let mut letter_counter_index = 0;\n    let mut letter_counter_index2 = 0;\n\
    \    let mut letter_counter_index3 = 0;\n    let mut letter_counter_index4 = 0;\n\
    \    let mut letter_counter_index5 = 0;\n    let mut letter_counter_index6 = 0;\n\
    \    let mut letter_counter_index7 = 0;\n    let mut letter_counter_index8 = 0;\n\
    \    let mut letter_counter_index9 = 0;\n    let mut letter_counter_index10 =\
    \ 0;\n    let mut letter_counter_index11 = 0;\n    let mut letter_counter_index12\
    \ = 0;\n    let mut letter_counter_index13 = 0;\n    let mut letter_counter_index14\
    \ = 0;\n    let mut letter_counter_index15 = 0;\n    let mut letter_counter_index16\
    \ = 0;\n    let mut letter_counter_index17 = 0;\n    let mut letter_counter_index18\
    \ = 0;\n    let mut letter_counter_index19 = 0;\n    let mut letter_counter_index20\
    \ = 0;\n    let mut letter_counter_index21 = 0;\n    let mut letter_counter_index22\
    \ = 0;\n    let mut letter_counter_index23 = 0;\n    let mut letter_counter_index24\
    \ = 0;\n    let mut letter_counter_index25 = 0;\n    let mut letter_counter_index26\
    \ = 0;\n    let mut letter_counter_index27 = 0;\n    let mut letter_counter_index28\
    \ = 0;\n    let mut letter_counter_index29 = 0;\n    let mut letter_counter_index30\
    \ = 0;\n    let mut letter_counter_index31 = 0;\n    let mut letter_counter_index32\
    \ = 0;\n    let mut letter_counter_index33 = 0;\n    let mut letter_counter_index34\
    \ = 0;\n    let mut letter_counter_index35 = 0;\n    let mut letter_counter_index36\
    \ = 0;\n    let mut letter_counter_index37 = 0;\n    let mut letter_counter_index38\
    \ = 0;\n    let mut letter_counter_index39 = 0;\n    let mut letter_counter_index40\
    \ = 0;\n    let mut letter_counter_index41 = 0;\n    let mut letter_counter_index42\
    \ = 0;\n    let mut letter_counter_index43 = 0;\n    let mut letter_counter_index44\
    \ = 0;\n    let mut letter_counter_index45 = 0;\n    let mut letter_counter_index46\
    \ = 0;\n    let mut letter_counter_index47 = 0;\n    let mut letter_counter_index48\
    \ = 0;\n    let mut letter_counter_index49 = 0;\n    let mut letter_counter_index50\
    \ = 0;\n    let mut letter_counter_index51 = 0;\n    let mut letter_counter_index52\
    \ = 0;\n    let mut letter_counter_index53 = 0;\n    let mut letter_\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7g6t_tkg.rs:69:20\n   |\n\
    69 |     let mut letter_\n   |                    ^ help: add `;` here\n70 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7g6t_tkg.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut i = 0;\n    \n    for letter\
    \ in message.chars() {\n        if letter.is_uppercase() {\n            letters.insert(letter);\n\
    \        }\n        if letter.is_lowercase() {\n            letters.insert(letter);\n\
    \        }\n    }\n    \n    for letter in letters.iter() {\n        encoded.push_str(&format!(\"\
    {}{}\", letter.to_ascii_lowercase(), vowels.contains(&letter) ? vowels.iter().next().unwrap().to_ascii_lowercase()\
    \ : letter.to_ascii_lowercase()));\n    }\n    \n    for letter in vowels.iter()\
    \ {\n        encoded.push_str(&format!(\"{}\", letter.to_ascii_lowercase()));\n\
    \    }\n    \n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `,`, `.`, `?`, or an operator, found `vowels`\n\
    \  --> /tmp/tmpyeyynivj.rs:27:99\n   |\n27 | ..._lowercase(), vowels.contains(&letter)\
    \ ? vowels.iter().next().unwrap().to_ascii_lowercase() : letter.to_ascii_lowercase()));\n\
    \   |                                             ^^^^^^ expected one of `,`,\
    \ `.`, `?`, or an operator\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmpyeyynivj.rs:13:22\n   |\n13 |     let mut vowels\
    \ = HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpyeyynivj.rs:14:23\n   |\n14 |     let mut letters = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowel_counter = 0;\n    for c in message.chars()\
    \ {\n        if vowels.contains(&c) {\n            vowel_counter += 2;\n     \
    \   }\n        if vowel_counter > 2 {\n            result.push(c);\n         \
    \   vowel_counter -= 2;\n        } else {\n            result.push(vowels[vowel_counter]);\n\
    \            vowel_counter += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"aeiT\"`,\n right: `\"tgst\"`', /tmp/tmp53c_xz05.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if vowels.contains(&letter) {\n            result.push(*letters[letter_counter]);\n\
    \            vowel_counter += 1;\n        } else {\n            result.push(*letters[letter_counter]);\n\
    \            letter_counter += 1;\n        }\n    }\n    if vowel_counter > 0\
    \ {\n        result.push(*letters[letter_counter]);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5bcuc3r6.rs:18:28\n   |\n\
    18 |         if vowels.contains(&letter) {\n   |                            ^^^^^^^\
    \ expected `&str`, found `char`\n   |\n   = note: expected reference `&&str`\n\
    \              found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5bcuc3r6.rs:19:25\n   |\n19 |             result.push(*letters[letter_counter]);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5bcuc3r6.rs:22:25\n \
    \  |\n22 |             result.push(*letters[letter_counter]);\n   |          \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5bcuc3r6.rs:27:21\n   |\n27 |         result.push(*letters[letter_counter]);\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `str`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::new();\n\
    \    let mut index = 0;\n    let mut letter = String::new();\n    let mut vowel\
    \ = String::new();\n    let mut vowel_pos = 0;\n    \n    for letter in message.chars()\
    \ {\n        if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o'\
    \ || letter == 'u' {\n            vowels.push(letter);\n            vowel_pos\
    \ = index;\n        }\n        \n        if letter == 'A' || letter == 'E' ||\
    \ letter == 'I' || letter == 'O' || letter == 'U' {\n            vowels.push(letter);\n\
    \            vowel_pos = index;\n        }\n        \n        if letter == 'b'\
    \ || letter == 'c' || letter == 'd' || letter == 'f' || letter == 'g' || letter\
    \ == 'h' || letter == 'j' || letter == 'k' || letter == 'l' || letter == 'm' ||\
    \ letter == 'n' || letter == 'p' || letter == 'q' || letter == 'r' || letter ==\
    \ 's' || letter == 't' || letter == 'v' || letter == 'w' || letter == 'x' || letter\
    \ == 'y' || letter == 'z' {\n            vowels.push(letter);\n            vowel_pos\
    \ = index;\n        }\n        \n        if letter == 'B' || letter == 'C' ||\
    \ letter == 'D' || letter == 'F' || letter == 'G' || letter == 'H' || letter ==\
    \ 'J' || letter == 'K' || letter == 'L' || letter == 'M' || letter == 'N' || letter\
    \ == 'P' || letter == 'Q' || letter == 'R' || letter == 'S' || letter == 'T' ||\
    \ letter == 'V' || letter == 'W' || letter == 'X' || letter == 'Y' || letter ==\
    \ 'Z' {\n            vowels.push(letter);\n            vowel_pos = index;\n  \
    \      }\n        \n        if letter == '0' {\n            vowels.push(letter);\n\
    \            vowel_pos = index;\n        }\n        \n        if letter == '1'\
    \ {\n            vowels.push(letter);\n            vowel_pos = index;\n      \
    \  }\n        \n        if letter == '2' {\n            vowels.push(letter);\n\
    \            vowel_pos = index;\n        }\n        \n        if letter == '3'\
    \ {\n            vowels.push(letter);\n            vowel_pos = index;\n      \
    \  }\n        \n        if letter == '4' {\n            vowels.push(letter);\n\
    \            vowel_pos = index;\n        }\n        \n        if letter == '5'\
    \ {\n            vowels.push(letter);\n            vowel_pos = index;\n      \
    \  }\n        \n        if letter == '6' {\n            vowels.push(letter);\n\
    \            vowel_pos = index;\n        }\n        \n        if letter == '7'\
    \ {\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpk93dgw1z.rs:85:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n19 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n...\n75 |  \
    \       if letter == '7' {\n   |                          - this delimiter might\
    \ not be properly closed...\n76 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n85 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpk93dgw1z.rs:19:5\n   |\n11 |   fn encode(message: String) -> String\
    \ {\n   |                                 ------ expected `String` because of\
    \ return type\n...\n19 | /     for letter in message.chars() {\n20 | |       \
    \  if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter\
    \ == 'u' {\n21 | |             vowels.push(letter);\n22 | |             vowel_pos\
    \ = index;\n...  |\n84 | |     assert_eq!(candidate(String::from(\"I DoNt KnOw\
    \ WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n85 | | }\n\
    \   | |__^ expected struct `String`, found `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\
    \ 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\
    \ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,\
    \ 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,\
    \ 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut letters_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ let mut vowels_index_2 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\
    \ 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\
    \ 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, \n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpmr8hpmkh.rs:18:1\n   |\n18 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpmr8hpmkh.rs:17:34\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n17 |     let mut vowels_index_2 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 2...\n   |                                  ^ unclosed delimiter\n18 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmr8hpmkh.rs:16:424\n\
    \   |\n16 | ..., 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 'A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',...\n \
    \  |                                                      ^^^ expected integer,\
    \ found `char`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_index = 0;\n    let mut index = 0;\n    let mut current_letter\
    \ = String::new();\n    let mut next_letter = String::new();\n    let mut next_letter_2\
    \ = String::new();\n    for letter in message.chars() {\n        if letter ==\
    \ 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n\
    \            result.push(*letter);\n        } else {\n            if vowels.contains(&letter)\
    \ {\n                vowels_index += 1;\n                vowels.insert(letter);\n\
    \                result.push(*letter);\n            } else {\n               \
    \ if vowels_index == 2 {\n                    result.push(*letter);\n        \
    \            vowels_index = 0;\n                    vowels.insert(letter);\n \
    \               } else {\n                    result.push(*letter);\n        \
    \            vowels_index = 0;\n                    vowels.insert(letter);\n \
    \               }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpvbi6iz54.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpvbi6iz54.rs:21:25\n   |\n\
    21 |             result.push(*letter);\n   |                         ^^^^^^^\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpvbi6iz54.rs:26:29\n\
    \   |\n26 |                 result.push(*letter);\n   |                      \
    \       ^^^^^^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpvbi6iz54.rs:29:33\n\
    \   |\n29 |                     result.push(*letter);\n   |                  \
    \               ^^^^^^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpvbi6iz54.rs:33:33\n   |\n33 |                     result.push(*letter);\n\
    \   |                                 ^^^^^^^\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0433, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    for c in message.chars() {\n        if c.is_uppercase() {\n            result.push_str(&c.to_lowercase());\n\
    \        } else {\n            result.push_str(&c.to_uppercase());\n        }\n\
    \        if !vowels.contains(&c) {\n            vowels.insert(c);\n        }\n\
    \    }\n    for vowel in vowels.iter() {\n        let index = vowels.iter().position(|&x|\
    \ x == vowel).unwrap();\n        result.push_str(&vowels[(index + 1)..].to_lowercase());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpalzzes2z.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpalzzes2z.rs:16:29\n   |\n16 |             result.push_str(&c.to_lowercase());\n\
    \   |                             ^^^^^^^^^^^^^^^^^ expected `str`, found struct\
    \ `ToLowercase`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&ToLowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpalzzes2z.rs:18:29\n\
    \   |\n18 |             result.push_str(&c.to_uppercase());\n   |            \
    \                 ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashMap::new();\n\
    \    let mut alphabet = HashMap::new();\n    let mut i = 0;\n    for c in message.chars()\
    \ {\n        if !vowels.contains_key(&c) {\n            vowels.insert(c, i);\n\
    \            alphabet.insert(c, c);\n            i += 1;\n        }\n    }\n \
    \   for c in message.chars() {\n        if let Some(pos) = vowels.get(&c) {\n\
    \            result.push_str(&alphabet.get(&c).unwrap().to_string());\n      \
    \      result.push_str(&alphabet.get(&pos).unwrap().to_string());\n        } else\
    \ {\n            result.push_str(&alphabet.get(&c).unwrap().to_string());\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp9rj0o92m.rs:13:22\n   |\n13 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp9rj0o92m.rs:14:24\n\
    \   |\n14 |     let mut alphabet = HashMap::new();\n   |                     \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letter_counter = vec!['Z', 'Y', 'X', 'W',\
    \ 'V', 'U', 'T', 'S', 'R', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'P', 'N', 'O',\
    \ 'Q', 'M', 'L', 'K', 'J', 'I', 'H', 'G', 'Y', 'W', 'X', 'V', 'U', 'T', 'S', 'R',\
    \ 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'P', 'N', 'O', 'Q', 'M', 'L', 'K', 'J',\
    \ 'I', 'H', 'G', 'Y', 'W', 'X', 'V', 'U', 'T', 'S', 'R', 'D', 'F', 'G', 'H', 'J',\
    \ 'K', 'L', 'M', 'P', 'N', 'O', 'Q', 'M', 'L', 'K', 'J', 'I', 'H', 'G', 'Y', 'W',\
    \ 'X', 'V', 'U', 'T', 'S', 'R', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'P', 'N',\
    \ 'O', 'Q', 'M', 'L', 'K', 'J', 'I', 'H', 'G', 'Y', 'W', 'X', 'V', 'U', 'T', 'S',\
    \ 'R', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'P', 'N', 'O', 'Q', 'M', 'L', 'K',\
    \ 'J', 'I', 'H', 'G', 'Y', 'W', 'X', 'V', 'U', 'T', 'S', 'R', 'D', 'F', 'G', 'H',\
    \ 'J', 'K', 'L', 'M', 'P', 'N', 'O', 'Q', 'M', 'L', 'K', 'J', 'I', 'H', 'G', 'Y',\
    \ 'W', 'X', 'V', 'U', 'T', 'S', 'R', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'P',\
    \ 'N', 'O', 'Q', 'M', 'L', 'K', 'J', 'I', 'H', 'G', 'Y', 'W', 'X', 'V', 'U', 'T',\
    \ 'S', 'R', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'P', 'N', 'O', 'Q', 'M', 'L',\
    \ 'K', 'J', 'I', 'H', 'G', 'Y', 'W', 'X', 'V', 'U', 'T', 'S', 'R', 'D', 'F', 'G',\
    \ 'H', 'J', 'K', 'L', 'M', 'P', 'N', 'O', 'Q', 'M', 'L', 'K', 'J', 'I', 'H', 'G',\
    \ 'Y', 'W', 'X', 'V', 'U', 'T', 'S', 'R', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M',\
    \ 'P', 'N', 'O', 'Q', 'M', 'L', 'K', 'J', 'I', 'H', 'G', 'Y', 'W', 'X', 'V', 'U',\
    \ 'T', 'S', 'R', 'D', 'F', 'G\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmprjbwjeuf.rs:15:1\n   |\n15 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmprjbwjeuf.rs:14:34\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n14 |     let mut letter_counter = vec!['Z', 'Y', 'X', 'W', 'V',\
    \ 'U', 'T', 'S', 'R', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'P', 'N', 'O', 'Q'...\n\
    \   |                                  ^ unclosed delimiter\n15 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    for c in message.chars() {\n \
    \       if vowels.contains(&c) {\n            result.push_str(&alphabet[alphabet.len()\
    \ - vowels.iter().position(|&x| x == c).unwrap() + 1]);\n        } else {\n  \
    \          result.push_str(&alphabet[alphabet.len() - vowels.iter().position(|&x|\
    \ x == c).unwrap()]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb7036aoj.rs:18:29\n   |\n\
    18 |             result.push_str(&alphabet[alphabet.len() - vowels.iter().position(|&x|\
    \ x == c).unwrap() + 1]);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpb7036aoj.rs:20:29\n   |\n20 |             result.push_str(&alphabet[alphabet.len()\
    \ - vowels.iter().position(|&x| x == c).unwrap()]);\n   |                    \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    for c in message.chars() {\n     \
    \   if c.is_uppercase() {\n            letters.insert(c.to_lowercase());\n   \
    \     } else {\n            letters.insert(c.to_uppercase());\n        }\n   \
    \ }\n    for c in letters.iter() {\n        if vowels.contains(&c) {\n       \
    \     result.push(c);\n        } else {\n            result.push((&c + &c.to_lowercase()).to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpy7sntw1j.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpy7sntw1j.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0369]: cannot add `&ToLowercase`\
    \ to `&char`\n  --> /tmp/tmpy7sntw1j.rs:26:29\n   |\n26 |             result.push((&c\
    \ + &c.to_lowercase()).to_string());\n   |                          -- ^ -----------------\
    \ &ToLowercase\n   |                          |\n   |                        \
    \  &char\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0369, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message {\n       \
    \ if vowels.contains(&letter) {\n            result.push((&alphabet[vowel_counter]).to_string());\n\
    \            vowel_counter = vowel_counter + 1;\n        } else {\n          \
    \  result.push((&alphabet[letter_counter]).to_string());\n            letter_counter\
    \ = letter_counter + 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpksd_bo1h.rs:17:19\n\
    \   |\n17 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpksd_bo1h.rs:19:27\n\
    \   |\n19 |             result.push((&alphabet[vowel_counter]).to_string());\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpksd_bo1h.rs:22:27\n\
    \   |\n22 |             result.push((&alphabet[letter_counter]).to_string());\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_counter = 0;\n    for letter in message {\n        if letter == '\
    \ ' {\n            result.push_str(\" \");\n        } else {\n            result.push_str(&vowels[vowels_index[letter_counter]]);\n\
    \            result.push_str(&vowels[vowels_index[letter_counter + 1]]);\n   \
    \         result.push_str(&letter);\n            letter_counter += 2;\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp3_c9mcbt.rs:16:19\n\
    \   |\n16 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3_c9mcbt.rs:20:29\n   |\n20 |             result.push_str(&vowels[vowels_index[letter_counter]]);\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3_c9mcbt.rs:21:29\n\
    \   |\n21 |             result.push_str(&vowels[vowels_index[letter_counter +\
    \ 1]]);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0277]: the size for values of\
    \ type `str` cannot be known at compilation time\n  --> /tmp/tmp3_c9mcbt.rs:16:9\n\
    \   |\n16 |     for letter in message {\n   |         ^^^^^^ doesn't have a size\
    \ known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\n\nerror[E0277]: the\
    \ size for values of type `str` cannot be known at compilation time\n   --> /tmp/tmp3_c9mcbt.rs:16:19\n\
    \    |\n16  |     for letter in message {\n    |                   ^^^^^^^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `Option`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp3_c9mcbt.rs:16:5\n    |\n16  | /     for letter in message {\n17  |\
    \ |         if letter == ' ' {\n18  | |             result.push_str(\" \");\n\
    19  | |         } else {\n...   |\n24  | |         }\n25"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_map = HashMap::new();\n\
    \    for vowel in vowels {\n        vowels_map.insert(vowel, vowel);\n    }\n\
    \    for letter in message.chars() {\n        let mut new_letter = letter;\n \
    \       let mut new_vowel = vowels_map.get(&new_letter);\n        while new_vowel\
    \ != Some(&new_letter) {\n            new_letter = vowels_map.get(&new_letter).unwrap();\n\
    \            new_vowel = vowels_map.get(&new_letter).unwrap();\n        }\n  \
    \      result.push(new_letter);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpwsemchzc.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    \n    for c in message.chars() {\n\
    \        if !alphabet.contains(c) { \n            alphabet.insert(c);\n      \
    \  }\n    }\n    \n    for c in alphabet.chars() {\n        if !vowels.contains(c)\
    \ {\n            vowels.insert(c);\n        }\n    }\n    \n    for c in message.chars()\
    \ {\n        if !vowels.contains(c) {\n            result.push(c);\n        }\
    \ else {\n            let mut i = 0;\n            while i < vowels.len() {\n \
    \               if c == vowels.get(i) {\n                    result.push(vowels.get(i\
    \ + 2));\n                    break;\n                }\n                i +=\
    \ 1;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmphz177hxc.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmphz177hxc.rs:14:24\n\
    \   |\n14 |     let mut alphabet = HashSet::new();\n   |                     \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_counter = 0;\n    let mut letter_counter_index = 0;\n    let mut\
    \ letter_counter_index2 = 0;\n    let mut letter_counter_index3 = 0;\n    let\
    \ mut letter_counter_index4 = 0;\n    let mut letter_counter_index5 = 0;\n   \
    \ let mut letter_counter_index6 = 0;\n    let mut letter_counter_index7 = 0;\n\
    \    let mut letter_counter_index8 = 0;\n    let mut letter_counter_index9 = 0;\n\
    \    let mut letter_counter_index10 = 0;\n    let mut letter_counter_index11 =\
    \ 0;\n    let mut letter_counter_index12 = 0;\n    let mut letter_counter_index13\
    \ = 0;\n    let mut letter_counter_index14 = 0;\n    let mut letter_counter_index15\
    \ = 0;\n    let mut letter_counter_index16 = 0;\n    let mut letter_counter_index17\
    \ = 0;\n    let mut letter_counter_index18 = 0;\n    let mut letter_counter_index19\
    \ = 0;\n    let mut letter_counter_index20 = 0;\n    let mut letter_counter_index21\
    \ = 0;\n    let mut letter_counter_index22 = 0;\n    let mut letter_counter_index23\
    \ = 0;\n    let mut letter_counter_index24 = 0;\n    let mut letter_counter_index25\
    \ = 0;\n    let mut letter_counter_index26 = 0;\n    let mut letter_counter_index27\
    \ = 0;\n    let mut letter_counter_index28 = 0;\n    let mut letter_counter_index29\
    \ = 0;\n    let mut letter_counter_index30 = 0;\n    let mut letter_counter_index31\
    \ = 0;\n    let mut letter_counter_index32 = 0;\n    let mut letter_counter_index33\
    \ = 0;\n    let mut letter_counter_index34 = 0;\n    let mut letter_counter_index35\
    \ = 0;\n    let mut letter_counter_index36 = 0;\n    let mut letter_counter_index37\
    \ = 0;\n    let mut letter_counter_index38 = 0;\n    let mut letter_counter_index39\
    \ = 0;\n    let mut letter_counter_index40 = 0;\n    let mut letter_counter_index41\
    \ = 0;\n    let mut letter_counter_index42 = 0;\n    let mut letter_counter_index43\
    \ = 0;\n    let mut letter_counter_index44 = 0;\n    let mut letter_counter_index45\
    \ = 0;\n    let mut letter_counter_index46 = 0;\n    let mut letter_counter_index47\
    \ = 0;\n    let mut letter_counter_index48 = 0;\n    let mut letter_counter_index49\
    \ = 0;\n    let mut letter_counter_index50 = 0;\n    let mut letter_counter_index51\
    \ = 0;\n    let mut letter_counter_index52 = 0;\n    let mut letter_\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpn3ss3tqa.rs:68:20\n   |\n\
    68 |     let mut letter_\n   |                    ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn3ss3tqa.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            result.push((vowels[vowel_counter] + letter).to_string());\n\
    \            vowel_counter = vowel_counter + 1;\n        } else {\n          \
    \  result.push((letter + vowels[letter_counter]).to_string());\n            letter_counter\
    \ = letter_counter + 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpxsqf61_d.rs:18:48\n\
    \   |\n18 |             result.push((vowels[vowel_counter] + letter).to_string());\n\
    \   |                          --------------------- ^ ------ char\n   |     \
    \                     |\n   |                          char\n\nerror[E0369]: cannot\
    \ add `char` to `char`\n  --> /tmp/tmpxsqf61_d.rs:21:33\n   |\n21 |          \
    \   result.push((letter + vowels[letter_counter]).to_string());\n   |        \
    \                  ------ ^ ---------------------- char\n   |                \
    \          |\n   |                          char\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut l = message.chars().enumerate().filter(|&(_,\
    \ c)| c.is_letter()).count();\n    let mut vowel = String::from(\"a\");\n    let\
    \ mut vowel_pos = 0;\n    let mut vowel_pos_prev = 0;\n    let mut vowel_pos_next\
    \ = 0;\n    let mut vowel_pos_next2 = 0;\n    let mut vowel_pos_next3 = 0;\n \
    \   let mut vowel_pos_next4 = 0;\n    let mut vowel_pos_next5 = 0;\n    let mut\
    \ vowel_pos_next6 = 0;\n    let mut vowel_pos_next7 = 0;\n    let mut vowel_pos_next8\
    \ = 0;\n    let mut vowel_pos_next9 = 0;\n    let mut vowel_pos_next10 = 0;\n\
    \    let mut vowel_pos_next11 = 0;\n    let mut vowel_pos_next12 = 0;\n    let\
    \ mut vowel_pos_next13 = 0;\n    let mut vowel_pos_next14 = 0;\n    let mut vowel_pos_next15\
    \ = 0;\n    let mut vowel_pos_next16 = 0;\n    let mut vowel_pos_next17 = 0;\n\
    \    let mut vowel_pos_next18 = 0;\n    let mut vowel_pos_next19 = 0;\n    let\
    \ mut vowel_pos_next20 = 0;\n    let mut vowel_pos_next21 = 0;\n    let mut vowel_pos_next22\
    \ = 0;\n    let mut vowel_pos_next23 = 0;\n    let mut vowel_pos_next24 = 0;\n\
    \    let mut vowel_pos_next25 = 0;\n    let mut vowel_pos_next26 = 0;\n    let\
    \ mut vowel_pos_next27 = 0;\n    let mut vowel_pos_next28 = 0;\n    let mut vowel_pos_next29\
    \ = 0;\n    let mut vowel_pos_next30 = 0;\n    let mut vowel_pos_next31 = 0;\n\
    \    let mut vowel_pos_next32 = 0;\n    let mut vowel_pos_next33 = 0;\n    let\
    \ mut vowel_pos_next34 = 0;\n    let mut vowel_pos_next35 = 0;\n    let mut vowel_pos_next36\
    \ = 0;\n    let mut vowel_pos_next37 = 0;\n    let mut vowel_pos_next38 = 0;\n\
    \    let mut vowel_pos_next39 = 0;\n    let mut vowel_pos_next40 = 0;\n    let\
    \ mut vowel_pos_next41 = 0;\n    let mut vowel_pos_next\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptkre6t3b.rs:63:27\n   |\n\
    63 |     let mut vowel_pos_next\n   |                           ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmptkre6t3b.rs:13:22\n   |\n13 |  \
    \   let mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmptkre6t3b.rs:14:23\n   |\n14 |     let mut letters = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0599]:\
    \ no method named `is_letter` found for type `char` in the current scope\n  -->\
    \ /tmp/tmptkre6t3b.rs:18:64\n   |\n18 |     let mut l = message.chars().enumerate().filter(|&(_,\
    \ c)| c.is_letter()).count();\n   |                                          \
    \                      ^^^^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptkre6t3b.rs:11:31\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowels_map = HashMap::new();\n    for vowel\
    \ in vowels {\n        vowels_map.insert(vowel.to_string(), vowel);\n    }\n \
    \   for letter in message.chars() {\n        let mut new_letter = letter;\n  \
    \      let mut new_vowel = vowels_map.get(&new_letter).unwrap();\n        for\
    \ vowel in vowels {\n            if new_letter == vowel {\n                new_vowel\
    \ = vowels_map.get(&new_letter + &vowel).unwrap();\n            }\n        }\n\
    \        result.push(new_vowel);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpus65xzjo.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0369]:\
    \ cannot add `&char` to `&char`\n  --> /tmp/tmpus65xzjo.rs:23:56\n   |\n23 | \
    \                new_vowel = vowels_map.get(&new_letter + &vowel).unwrap();\n\
    \   |                                            ----------- ^ ------ &char\n\
    \   |                                            |\n   |                     \
    \                       &char\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0369, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowels_idx = 0;\n    let mut\
    \ letters_idx = 0;\n    for c in message.chars() {\n        if letters.contains(&c)\
    \ {\n            result.push(c);\n            letters.insert(c);\n           \
    \ letters_idx += 1;\n        } else {\n            result.push(c);\n         \
    \   vowels.insert(c);\n            vowels_idx += 1;\n        }\n    }\n    if\
    \ letters_idx < 2 {\n        result.push(c);\n    }\n    if vowels_idx < 2 {\n\
    \        result.push(c);\n    }\n    if letters_idx > 2 {\n        result.push(c);\n\
    \    }\n    if vowels_idx > 2 {\n        result.push(c);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp49rscf60.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp49rscf60.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find\
    \ value `c` in this scope\n  --> /tmp/tmp49rscf60.rs:29:21\n   |\n29 |       \
    \  result.push(c);\n   |                     ^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `c` in this scope\n  --> /tmp/tmp49rscf60.rs:32:21\n   |\n\
    32 |         result.push(c);\n   |                     ^ not found in this scope\n\
    \nerror[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmp49rscf60.rs:35:21\n\
    \   |\n35 |         result.push(c);\n   |                     ^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmp49rscf60.rs:38:21\n\
    \   |\n38 |         result.push(c);\n   |                     ^ not found in this\
    \ scope\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::new();\n\
    \    let mut letters = String::new();\n    let mut index = 0;\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for c in message.chars() {\n    \
    \    if c.is_uppercase() {\n            letters.push_str(&c.to_lowercase());\n\
    \            letter_counter += 1;\n        } else {\n            letters.push_str(&c.to_uppercase());\n\
    \            letter_counter += 1;\n        }\n        if letter_counter == 2 &&\
    \ vowel_counter < 2 {\n            vowels.push_str(&c.to_lowercase());\n     \
    \       vowel_counter += 1;\n        } else {\n            vowels.push_str(&c.to_uppercase());\n\
    \            vowel_counter += 1;\n        }\n        if letter_counter == 2 &&\
    \ vowel_counter == 2 {\n            encoded.push_str(&letters);\n            encoded.push_str(&vowels);\n\
    \            index += 1;\n            letters = String::new();\n            vowels\
    \ = String::new();\n            letter_counter = 0;\n            vowel_counter\
    \ = 0;\n        }\n    }\n    encoded.push_str(&letters);\n    encoded.push_str(&vowels);\n\
    \    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptv9fneej.rs:20:30\n   |\n\
    20 |             letters.push_str(&c.to_lowercase());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptv9fneej.rs:23:30\n   |\n23 |\
    \             letters.push_str(&c.to_uppercase());\n   |                     \
    \         ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptv9fneej.rs:27:29\n   |\n27 |\
    \             vowels.push_str(&c.to_lowercase());\n   |                      \
    \       ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n   |\n \
    \  = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptv9fneej.rs:30:29\n   |\n30 |\
    \             vowels.push_str(&c.to_uppercase());\n   |                      \
    \       ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n   |\n \
    \  = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if letter == ' ' {\n            result.push_str(\" \");\n        } else\
    \ {\n            if vowels.contains(&letter) {\n                vowel_counter++;\n\
    \                result.push_str(&vowels[vowel_counter]);\n            } else\
    \ {\n                letter_counter++;\n                result.push_str(&letters[letter_counter]);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpnth7kifr.rs:22:30\n\
    \   |\n22 |                 vowel_counter++;\n   |                           \
    \   ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n22\
    \ |                 { let tmp = vowel_counter; vowel_counter += 1; tmp };\n  \
    \ |                 +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n22 -\
    \                 vowel_counter++;\n22 +                 vowel_counter += 1;\n\
    \   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpnth7kifr.rs:25:31\n\
    \   |\n25 |                 letter_counter++;\n   |                          \
    \     ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    25 |                 { let tmp = letter_counter; letter_counter += 1; tmp };\n\
    \   |                 +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    25 -                 letter_counter++;\n25 +                 letter_counter +=\
    \ 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnth7kifr.rs:21:32\n\
    \   |\n21 |             if vowels.contains(&letter) {\n   |                  \
    \              ^^^^^^^ expected `&str`, found `char`\n   |\n   = note: expected\
    \ reference `&&str`\n              found reference `&char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_count = vec![0];\n    let mut letter = String::new();\n    let mut\
    \ letter_index = String::new();\n    let mut vowel_position = String::new();\n\
    \    let mut vowel_position_index = String::new();\n    let mut vowel_position\
    \ = String::new();\n    let mut vowel_position_index = String::new();\n    let\
    \ mut vowel_position = String::new();\n    let mut vowel_position_index = String::new();\n\
    \    let mut vowel_position = String::new();\n    let mut vowel_position_index\
    \ = String::new();\n    let mut vowel_position = String::new();\n    let mut vowel_position_index\
    \ = String::new();\n    let mut vowel_position = String::new();\n    let mut vowel_position_index\
    \ = String::new();\n    let mut vowel_position = String::new();\n    let mut vowel_position_index\
    \ = String::new();\n    let mut vowel_position = String::new();\n    let mut vowel_position_index\
    \ = String::new();\n    let mut vowel_position = String::new();\n    let mut vowel_position_index\
    \ = String::new();\n    let mut vowel_position = String::new();\n    let mut vowel_position_index\
    \ = String::new();\n    let mut vowel_position = String::new();\n    let mut vowel_position_index\
    \ = String::new();\n    let mut vowel_position = String::new();\n    let mut vowel_position_index\
    \ = String::new();\n    let mut vowel_position = String::new();\n    let mut vowel_position_index\
    \ = String::new();\n    let mut vowel_position = String::new();\n    let mut vowel_position_index\
    \ = String::new();\n    let mut vowel_position = String::new();\n    let mut vowel_position_index\
    \ = String::new();\n    let mut vowel_position = String::new();\n    let mut vowel_position_index\
    \ = String::new();\n    let mut vowel_position = String::new();\n    let mut vowel_position_index\
    \ = String::new();\n    let mut vowel_position = String::new();\n    let mut vowel_position_index\
    \ = String::new();\n    let mut vowel_position = String::new();\n    let mut vowel_position_index\
    \ = String::new();\n    let mut vowel_position = String\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprsprpztl.rs:56:36\n   |\n\
    56 |     let mut vowel_position = String\n   |                               \
    \     ^ help: add `;` here\n57 | }\n   | - unexpected token\n\nerror[E0423]: expected\
    \ value, found struct `String`\n   --> /tmp/tmprsprpztl.rs:56:30\n    |\n56  |\
    \       let mut vowel_position = String\n    |                               \
    \ ^^^^^^ help: use struct literal syntax instead: `String { vec: val }`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprsprpztl.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    let mut letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n \
    \   let mut letter_counter4 = 0;\n    let mut letter_counter5 = 0;\n    let mut\
    \ letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n    let mut letter_counter8\
    \ = 0;\n    let mut letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n\
    \    let mut letter_counter11 = 0;\n    let mut letter_counter12 = 0;\n    let\
    \ mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n    let mut letter_counter15\
    \ = 0;\n    let mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n\
    \    let mut letter_counter18 = 0;\n    let mut letter_counter19 = 0;\n    let\
    \ mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n    let mut letter_counter22\
    \ = 0;\n    let mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n\
    \    let mut letter_counter25 = 0;\n    let mut letter_counter26 = 0;\n    let\
    \ mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n    let mut letter_counter29\
    \ = 0;\n    let mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n\
    \    let mut letter_counter32 = 0;\n    let mut letter_counter33 = 0;\n    let\
    \ mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n    let mut letter_counter36\
    \ = 0;\n    let mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n\
    \    let mut letter_counter39 = 0;\n    let mut letter_counter40 = 0;\n    let\
    \ mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n    let mut letter_counter43\
    \ = 0;\n    let mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n\
    \    let mut letter_counter46 = 0;\n    let mut letter_counter47 = 0;\n    let\
    \ mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n    let mut letter_counter50\
    \ = 0;\n    let mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n\
    \    let mut letter_counter53 = 0;\n    let mut letter_counter54 = 0;\n    let\
    \ mu\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0dmh3obl.rs:70:11\n   |\n\
    70 |     let mu\n   |           ^ help: add `;` here\n71 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0dmh3obl.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut index2 = 0;\n    let\
    \ mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n    let mut\
    \ index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9\
    \ = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12\
    \ = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15\
    \ = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18\
    \ = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21\
    \ = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24\
    \ = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27\
    \ = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30\
    \ = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33\
    \ = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36\
    \ = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39\
    \ = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42\
    \ = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45\
    \ = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48\
    \ = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51\
    \ = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n    let mut index54\
    \ = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n    let mut index57\
    \ = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n    let mut index60\
    \ = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n    let mut index63\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpqusy8jzq.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut vowels_index = String::new();\n    let mut vowels_index2\
    \ = String::new();\n    let mut vowels_index3 = String::new();\n    let mut vowels_index4\
    \ = String::new();\n    let mut vowels_index5 = String::new();\n    let mut vowels_index6\
    \ = String::new();\n    let mut vowels_index7 = String::new();\n    let mut vowels_index8\
    \ = String::new();\n    let mut vowels_index9 = String::new();\n    let mut vowels_index10\
    \ = String::new();\n    let mut vowels_index11 = String::new();\n    let mut vowels_index12\
    \ = String::new();\n    let mut vowels_index13 = String::new();\n    let mut vowels_index14\
    \ = String::new();\n    let mut vowels_index15 = String::new();\n    let mut vowels_index16\
    \ = String::new();\n    let mut vowels_index17 = String::new();\n    let mut vowels_index18\
    \ = String::new();\n    let mut vowels_index19 = String::new();\n    let mut vowels_index20\
    \ = String::new();\n    let mut vowels_index21 = String::new();\n    let mut vowels_index22\
    \ = String::new();\n    let mut vowels_index23 = String::new();\n    let mut vowels_index24\
    \ = String::new();\n    let mut vowels_index25 = String::new();\n    let mut vowels_index26\
    \ = String::new();\n    let mut vowels_index27 = String::new();\n    let mut vowels_index28\
    \ = String::new();\n    let mut vowels_index29 = String::new();\n    let mut vowels_index30\
    \ = String::new();\n    let mut vowels_index31 = String::new();\n    let mut vowels_index32\
    \ = String::new();\n    let mut vowels_index33 = String::new();\n    let mut vowels_index34\
    \ = String::new();\n    let mut vowels_index35 = String::new();\n    let mut vowels_index36\
    \ = String::new();\n    let mut vowels_index37 = String::new();\n    let mut vowels_index38\
    \ = String::new();\n    let mut vowels_index39 = \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpp6xsoj3u.rs:53:1\n\
    \   |\n53 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\
    \ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,\
    \ 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52,\
    \ 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,\
    \ 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,\
    \ 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut vowels_counter = 0;\n    let\
    \ mut letters_counter = 0;\n    let mut vowels_index = 0;\n    let mut letters_index\
    \ = 0;\n    let mut vowels_counter = 0;\n    let mut letters_counter = 0;\n  \
    \  let mut vowels_index = 0;\n    let mut letters_index = 0;\n    let mut vowels_counter\
    \ = 0;\n    let mut letters_counter = 0;\n    let mut vowels_index = 0;\n    let\
    \ mut letters_index = 0;\n    let mut vowels_counter = 0;\n    let mut letters_counter\
    \ = 0;\n    let mut vowels_index = 0;\n    let mut letters_index = 0;\n    let\
    \ mut vowels_counter = 0;\n    let mut letters_counter = 0;\n    let mut vowels_index\
    \ = 0;\n    let mut letters_index = 0;\n    let mut vowels_counter = 0;\n    let\
    \ mut letters_counter = 0;\n    let mut vowels_index = 0;\n    let mut letters_index\
    \ = 0;\n    let mut vowels_counter = 0;\n    let mut letters_counter = 0;\n  \
    \  let mut vowels_index = 0;\n    let mut letters_index = 0;\n    let mut vowels_counter\
    \ = 0;\n    let mut letters_counter = 0;\n    let mut vowels_index = 0;\n    let\
    \ mut letters_index = 0;\n    let mut vowels_counter = 0;\n    let mut letters_counter\
    \ = 0;\n    let mut vowels_index = 0;\n    let mut letters_index = 0;\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbtdt9cno.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut letters = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut vowels_index = 0;\n    let mut letters_index\
    \ = 0;\n    for letter in message.chars() {\n        if letter == ' ' {\n    \
    \        result.push_str(\" \");\n        } else {\n            result.push_str(&letters[letters_index]);\n\
    \            letters_index += 1;\n            if letters_index == 3 {\n      \
    \          letters_index = 0;\n                result.push_str(&vowels[vowels_index]);\n\
    \                vowels_index += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"aeiAa\"`,\n right: `\"tgst\"`', /tmp/tmpeyoet2k2.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    for letter in message.chars() {\n\
    \        if letter.is_uppercase() {\n            letters.insert(letter);\n   \
    \     } else {\n            vowels.insert(letter);\n        }\n    }\n    for\
    \ vowel in vowels.iter() {\n        let mut index = vowels.iter().position(|&x|\
    \ x == vowel).unwrap();\n        result.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \    }\n    for letter in letters.iter() {\n        result.push_str(&letter);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp9y3zc5m3.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp9y3zc5m3.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n  --> /tmp/tmp9y3zc5m3.rs:26:9\n\
    \   |\n26 |     for letter in letters.iter() {\n   |         ^^^^^^ doesn't have\
    \ a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\n\nerror[E0277]: the\
    \ size for values of type `str` cannot be known at compilation time\n   --> /tmp/tmp9y3zc5m3.rs:26:19\n\
    \    |\n26  |     for letter in letters.iter() {\n    |                   ^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Option`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp9y3zc5m3.rs:26:5\n    |\n26  | /     for letter in letters.iter() {\n\
    27  | |         result.push_str(&letter);\n28  | |     }\n    | |_____^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `None`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0433.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for c in message.chars() {\n    \
    \    if vowels.contains(&c) {\n            vowel_counter += 1;\n        }\n  \
    \      if letters.contains(&c) {\n            letter_counter += 1;\n        }\n\
    \        if vowel_counter > 2 {\n            result.push(c);\n            vowel_counter\
    \ = 0;\n        }\n        if letter_counter > 2 {\n            result.push(c);\n\
    \            letter_counter = 0;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpw4uzkuiq.rs:18:28\n\
    \     |\n18   |         if vowels.contains(&c) {\n     |                   --------\
    \ ^^ expected an `Fn<(char,)>` closure, found `char`\n     |                 \
    \  |\n     |                   required by a bound introduced by this call\n \
    \    |\n     = help: the trait `Fn<(char,)>` is not implemented for `char`\n \
    \    = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n18   |         if vowels.contains(*&c)\
    \ {\n     |                            +\n\nerror[E0277]: expected a `Fn<(char,)>`\
    \ closure, found `char`\n    --> /tmp/tmpw4uzkuiq.rs:21:29\n     |\n21   |   \
    \      if letters.contains(&c) {\n     |                    -------- ^^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n     |                    |\n     |\
    \                    required by a bound introduced by this call\n     |\n   \
    \  = help: the trait `Fn<(char,)>` is not implemented for `char`\n     = note:\
    \ required because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n21   |         if letters.contains(*&c)\
    \ {\n     |                             +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    let mut i = 0;\n    while i < message.len() {\n        if message.chars().nth(i).unwrap()\
    \ == 'a' {\n            result.push_str(&vowels[index % vowels.len()]);\n    \
    \        i += 1;\n            index /= vowels.len();\n        } else if message.chars().nth(i).unwrap()\
    \ == 'e' {\n            result.push_str(&vowels[index % vowels.len()]);\n    \
    \        i += 1;\n            index /= vowels.len();\n        } else if message.chars().nth(i).unwrap()\
    \ == 'i' {\n            result.push_str(&vowels[index % vowels.len()]);\n    \
    \        i += 1;\n            index /= vowels.len();\n        } else if message.chars().nth(i).unwrap()\
    \ == 'o' {\n            result.push_str(&vowels[index % vowels.len()]);\n    \
    \        i += 1;\n            index /= vowels.len();\n        } else if message.chars().nth(i).unwrap()\
    \ == 'u' {\n            result.push_str(&vowels[index % vowels.len()]);\n    \
    \        i += 1;\n            index /= vowels.len();\n        } else {\n     \
    \       result.push_str(&letters[index % letters.len()]);\n            i += 1;\n\
    \            index /= letters.len();\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"bbbb\"`,\n right: `\"tgst\"`', /tmp/tmpzb82ugi1.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut vowels_map = HashMap::new();\n\
    \    for vowel in vowels {\n        vowels_map.insert(vowel, vowel);\n    }\n\
    \    for c in message.chars() {\n        if let Some(vowel) = vowels_map.get(&c)\
    \ {\n            result.push_str(&vowels[vowels.iter().position(|&x| x == &vowel).unwrap()\
    \ + 1]);\n        } else {\n            result.push_str(&c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpxa0hjjsg.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxa0hjjsg.rs:22:29\n   |\n22 |             result.push_str(&c);\n\
    \   |                             ^^ expected `str`, found `char`\n   |\n   =\
    \ note: expected reference `&str`\n              found reference `&char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            result.push_str(\" \");\n       \
    \ } else {\n            result.push_str(&letters[letter - 'A']);\n        }\n\
    \        if letter == vowels[i as usize] {\n            result.push_str(&vowels[(i\
    \ + 1) as usize]);\n            i += 2;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmp3ywng6fr.rs:20:45\n\
    \   |\n20 |             result.push_str(&letters[letter - 'A']);\n   |       \
    \                               ------ ^ --- char\n   |                      \
    \                |\n   |                                      char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3ywng6fr.rs:23:29\n   |\n23 |             result.push_str(&vowels[(i\
    \ + 1) as usize]);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message {\n        if letter == ' ' {\n            result.push_str(&format!(\"\
    {}\", letter));\n        } else {\n            result.push_str(&format!(\"{}{}\"\
    , \n                letter, \n                vowels[vowels_index].to_string()));\n\
    \            vowels_index = (vowels_index + 1) % vowels.len();\n            letter_counter\
    \ += 1;\n        }\n    }\n    if letter_counter > 0 {\n        result.push_str(&format!(\"\
    {}\", \n            vowels[vowels_index].to_string()));\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp63h8uwht.rs:16:19\n\
    \   |\n16 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashMap::new();\n\
    \    vowels.insert(String::from(\"a\"), String::from(\"A\"));\n    vowels.insert(String::from(\"\
    e\"), String::from(\"E\"));\n    vowels.insert(String::from(\"i\"), String::from(\"\
    I\"));\n    vowels.insert(String::from(\"o\"), String::from(\"O\"));\n    vowels.insert(String::from(\"\
    u\"), String::from(\"U\"));\n    vowels.insert(String::from(\"y\"), String::from(\"\
    Y\"));\n    vowels.insert(String::from(\"A\"), String::from(\"a\"));\n    vowels.insert(String::from(\"\
    E\"), String::from(\"e\"));\n    vowels.insert(String::from(\"I\"), String::from(\"\
    i\"));\n    vowels.insert(String::from(\"O\"), String::from(\"o\"));\n    vowels.insert(String::from(\"\
    U\"), String::from(\"u\"));\n    vowels.insert(String::from(\"Y\"), String::from(\"\
    y\"));\n    vowels.insert(String::from(\"a\"), String::from(\"A\"));\n    vowels.insert(String::from(\"\
    e\"), String::from(\"E\"));\n    vowels.insert(String::from(\"i\"), String::from(\"\
    I\"));\n    vowels.insert(String::from(\"o\"), String::from(\"O\"));\n    vowels.insert(String::from(\"\
    u\"), String::from(\"U\"));\n    vowels.insert(String::from(\"y\"), String::from(\"\
    Y\"));\n    vowels.insert(String::from(\"A\"), String::from(\"a\"));\n    vowels.insert(String::from(\"\
    E\"), String::from(\"e\"));\n    vowels.insert(String::from(\"I\"), String::from(\"\
    i\"));\n    vowels.insert(String::from(\"O\"), String::from(\"o\"));\n    vowels.insert(String::from(\"\
    U\"), String::from(\"u\"));\n    vowels.insert(String::from(\"Y\"), String::from(\"\
    y\"));\n    vowels.insert(String::from(\"a\"), String::from(\"A\"));\n    vowels.insert(String::from(\"\
    e\"), String::from(\"E\"));\n    vowels.insert(String::from(\"i\"), String::from(\"\
    I\"));\n    vowels.insert(String::from(\"o\"), String::from(\"O\"));\n    vowels.insert(String::from(\"\
    u\"), String::from(\"U\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp6f_b1tl6.rs:51:109\n\
    \   |\n51 |       assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\"\
    )), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n   |  _____________________________________________________________________________________________________________^\n\
    52 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = 0;\n    let mut\
    \ letter_counter = 0;\n    let mut letter_counter2 = 0;\n    let mut letter_counter3\
    \ = 0;\n    let mut letter_counter4 = 0;\n    let mut letter_counter5 = 0;\n \
    \   let mut letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n    let mut\
    \ letter_counter8 = 0;\n    let mut letter_counter9 = 0;\n    let mut letter_counter10\
    \ = 0;\n    let mut letter_counter11 = 0;\n    let mut letter_counter12 = 0;\n\
    \    let mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n    let\
    \ mut letter_counter15 = 0;\n    let mut letter_counter16 = 0;\n    let mut letter_counter17\
    \ = 0;\n    let mut letter_counter18 = 0;\n    let mut letter_counter19 = 0;\n\
    \    let mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n    let\
    \ mut letter_counter22 = 0;\n    let mut letter_counter23 = 0;\n    let mut letter_counter24\
    \ = 0;\n    let mut letter_counter25 = 0;\n    let mut letter_counter26 = 0;\n\
    \    let mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n    let\
    \ mut letter_counter29 = 0;\n    let mut letter_counter30 = 0;\n    let mut letter_counter31\
    \ = 0;\n    let mut letter_counter32 = 0;\n    let mut letter_counter33 = 0;\n\
    \    let mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n    let\
    \ mut letter_counter36 = 0;\n    let mut letter_counter37 = 0;\n    let mut letter_counter38\
    \ = 0;\n    let mut letter_counter39 = 0;\n    let mut letter_counter40 = 0;\n\
    \    let mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n    let\
    \ mut letter_counter43 = 0;\n    let mut letter_counter44 = 0;\n    let mut letter_counter45\
    \ = 0;\n    let mut letter_counter46 = 0;\n    let mut letter_counter47 = 0;\n\
    \    let mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n    let\
    \ mut letter_counter50 = 0;\n    let mut letter_counter51 = 0;\n    let mut letter_counter52\
    \ = 0;\n    let mut letter_counter53 = 0;\n    let mut letter_counter54 = 0;\n\
    \    let mut letter_counter55 = 0;\n    let mut letter_counter56 = 0;\n    let\
    \ mut letter_counter57 = 0;\n    let mut letter_counter58 = 0;\n    let mut letter_counter59\
    \ = 0;\n    let mut letter_counter60 = 0;\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjt6r_obc.rs:75:11\n   |\n\
    75 |     let mu\n   |           ^ help: add `;` here\n76 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjt6r_obc.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_index = HashSet::new();\n    let mut vowels_index2 = HashSet::new();\n\
    \    let mut vowels_index3 = HashSet::new();\n    let mut vowels_index4 = HashSet::new();\n\
    \    let mut vowels_index5 = HashSet::new();\n    let mut vowels_index6 = HashSet::new();\n\
    \    let mut vowels_index7 = HashSet::new();\n    let mut vowels_index8 = HashSet::new();\n\
    \    let mut vowels_index9 = HashSet::new();\n    let mut vowels_index10 = HashSet::new();\n\
    \    let mut vowels_index11 = HashSet::new();\n    let mut vowels_index12 = HashSet::new();\n\
    \    let mut vowels_index13 = HashSet::new();\n    let mut vowels_index14 = HashSet::new();\n\
    \    let mut vowels_index15 = HashSet::new();\n    let mut vowels_index16 = HashSet::new();\n\
    \    let mut vowels_index17 = HashSet::new();\n    let mut vowels_index18 = HashSet::new();\n\
    \    let mut vowels_index19 = HashSet::new();\n    let mut vowels_index20 = HashSet::new();\n\
    \    let mut vowels_index21 = HashSet::new();\n    let mut vowels_index22 = HashSet::new();\n\
    \    let mut vowels_index23 = HashSet::new();\n    let mut vowels_index24 = HashSet::new();\n\
    \    let mut vowels_index25 = HashSet::new();\n    let mut vowels_index26 = HashSet::new();\n\
    \    let mut vowels_index27 = HashSet::new();\n    let mut vowels_index28 = HashSet::new();\n\
    \    let mut vowels_index29 = HashSet::new();\n    let mut vowels_index30 = HashSet::new();\n\
    \    let mut vowels_index31 = HashSet::new();\n    let mut vowels_index32 = HashSet::new();\n\
    \    let mut vowels_index33 = HashSet::new();\n    let mut vowels_index34 = HashSet::new();\n\
    \    let mut vowels_index35 = HashSet::new();\n    let mut vowels_index36 = HashSet::new();\n\
    \    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp6k7vrakn.rs:51:1\n  \
    \ |\n51 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmp6k7vrakn.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6k7vrakn.rs:14:28\n   |\n14 |     let mut vowels_index = HashSet::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6k7vrakn.rs:15:29\n   |\n15 |     let mut vowels_index2 = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6k7vrakn.rs:16:29\n   |\n16 |     let mut vowels_index3 = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6k7vrakn.rs:17:29\n   |\n17 |     let mut vowels_index4 = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6k7vrakn.rs:18:29\n   |\n18 |     let mut vowels_index5 = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6k7vrakn.rs:19:29\n   |\n19 |     let mut vowel"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    let mut i = 0;\n    let mut j = 0;\n    let mut k\
    \ = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut\
    \ o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let\
    \ mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n   \
    \ let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n\
    \    let mut a = 0;\n    let mut b = 0;\n    let mut c = 0;\n    let mut d = 0;\n\
    \    let mut e = 0;\n    let mut f = 0;\n    let mut g = 0;\n    let mut h = 0;\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n\
    \    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n\
    \    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n\
    \    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n\
    \    let mut y = 0;\n    let mut z = 0;\n    let mut a = 0;\n    let mut b = 0;\n\
    \    let mut c = 0;\n    let mut d = 0;\n    let mut e = 0;\n    let mut f = 0;\n\
    \    let mut g = 0;\n    let mut h = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n\
    \    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n\
    \    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n\
    \    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n\
    \    let mut a = 0;\n    let mut b = 0;\n    let mut c = 0;\n    let mut d = 0;\n\
    \    let mut e = 0;\n    let mut f\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfon1mq5l.rs:90:14\n   |\n\
    90 |     let mut f\n   |              ^ help: add `;` here\n91 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfon1mq5l.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = -1;\n    let mut vowels_index2 = -1;\n    let mut\
    \ vowels_index3 = -1;\n    let mut vowels_index4 = -1;\n    let mut vowels_index5\
    \ = -1;\n    let mut vowels_index6 = -1;\n    let mut vowels_index7 = -1;\n  \
    \  let mut vowels_index8 = -1;\n    let mut vowels_index9 = -1;\n    let mut vowels_index10\
    \ = -1;\n    let mut vowels_index11 = -1;\n    let mut vowels_index12 = -1;\n\
    \    let mut vowels_index13 = -1;\n    let mut vowels_index14 = -1;\n    let mut\
    \ vowels_index15 = -1;\n    let mut vowels_index16 = -1;\n    let mut vowels_index17\
    \ = -1;\n    let mut vowels_index18 = -1;\n    let mut vowels_index19 = -1;\n\
    \    let mut vowels_index20 = -1;\n    let mut vowels_index21 = -1;\n    let mut\
    \ vowels_index22 = -1;\n    let mut vowels_index23 = -1;\n    let mut vowels_index24\
    \ = -1;\n    let mut vowels_index25 = -1;\n    let mut vowels_index26 = -1;\n\
    \    let mut vowels_index27 = -1;\n    let mut vowels_index28 = -1;\n    let mut\
    \ vowels_index29 = -1;\n    let mut vowels_index30 = -1;\n    let mut vowels_index31\
    \ = -1;\n    let mut vowels_index32 = -1;\n    let mut vowels_index33 = -1;\n\
    \    let mut vowels_index34 = -1;\n    let mut vowels_index35 = -1;\n    let mut\
    \ vowels_index36 = -1;\n    let mut vowels_index37 = -1;\n    let mut vowels_index38\
    \ = -1;\n    let mut vowels_index39 = -1;\n    let mut vowels_index40 = -1;\n\
    \    let mut vowels_index41 = -1;\n    let mut vowels_index42 = -1;\n    let mut\
    \ vowels_index43 = -1;\n    let mut vowels_index44 = -1;\n    let mut vowels_index45\
    \ = -1;\n    let mut vowels_index46 = -1;\n    let mut vowels_index47 = -1;\n\
    \    let mut vowels_index48 = -1;\n    let mut vowels_index49 = -1;\n    let mut\
    \ vowels_index50 = -1;\n    let mut vowels_index5\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_gdl15jc.rs:64:26\n   |\n\
    64 |     let mut vowels_index5\n   |                          ^ help: add `;`\
    \ here\n65 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_gdl15jc.rs:11:31\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |    ------                     ^^^^^^ expected struct `String`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut index =\
    \ 0;\n    let mut current_letter = String::new();\n    let mut current_vowel =\
    \ String::new();\n    let mut current_vowel_pos = 0;\n    let mut current_letter_pos\
    \ = 0;\n    for c in message.chars() {\n        if let Some(vowel) = vowels.find(c)\
    \ {\n            if current_vowel_pos == 0 {\n                current_vowel =\
    \ vowel;\n                current_vowel_pos = 0;\n            }\n            current_vowel.push_str(&letters[current_vowel_pos]);\n\
    \            current_vowel_pos += 1;\n        } else if let Some(letter) = letters.find(c)\
    \ {\n            if current_letter_pos == 0 {\n                current_letter\
    \ = letter;\n                current_letter_pos = 0;\n            }\n        \
    \    current_letter.push_str(&vowels[current_letter_pos]);\n            current_letter_pos\
    \ += 1;\n        } else {\n            result.push_str(&c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf8i6vh87.rs:23:33\n   |\n\
    17 |     let mut current_vowel = String::new();\n   |                        \
    \     ------------- expected due to this value\n...\n23 |                 current_vowel\
    \ = vowel;\n   |                                 ^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                 |\n   |       \
    \                          expected struct `String`, found `usize`\n\nerror[E0277]:\
    \ the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpf8i6vh87.rs:26:37\n\
    \   |\n26 |             current_vowel.push_str(&letters[current_vowel_pos]);\n\
    \   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices\
    \ are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf8i6vh87.rs:30:34\n   |\n16 |\
    \     let mut current_letter = String::new();\n   |                          \
    \    ------------- expected due to this value\n...\n30 |                 current_letter\
    \ = letter;\n   |                                  ^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                  |\n   |      \
    \                            expected struct `String`, found `usize`\n\nerror[E0277]:\
    \ the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpf8i6vh87.rs:33:38\n\
    \   |\n33 |             current_letter.push_str(&vowels[current_letter_pos]);\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices\
    \ are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for "
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_2 = \"AEIOU\";\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    let mut letters_2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut k = 0;\n    let mut l = message.len();\n    while\
    \ i < l {\n        if message[i] == vowels.chars().nth(0) {\n            result.push(*(vowels_2.chars().nth(j).unwrap()));\n\
    \            i += 1;\n            j += 1;\n        }\n        if message[i] ==\
    \ vowels.chars().nth(1) {\n            result.push(*(vowels_2.chars().nth(k).unwrap()));\n\
    \            i += 1;\n            k += 1;\n        }\n        if message[i] ==\
    \ vowels.chars().nth(2) {\n            result.push(*(vowels_2.chars().nth(l).unwrap()));\n\
    \            i += 1;\n            l += 1;\n        }\n        if message[i] ==\
    \ letters.chars().nth(0) {\n            result.push(*(letters_2.chars().nth(j).unwrap()));\n\
    \            i += 1;\n            j += 1;\n        }\n        if message[i] ==\
    \ letters.chars().nth(1) {\n            result.push(*(letters_2.chars().nth(k).unwrap()));\n\
    \            i += 1;\n            k += 1;\n        }\n        if message[i] ==\
    \ letters.chars().nth(2) {\n            result.push(*(letters_2.chars().nth(l).unwrap()));\n\
    \            i += 1;\n            l += 1;\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphhtm8ri6.rs:22:12\n\
    \   |\n22 |         if message[i] == vowels.chars().nth(0) {\n   |           \
    \ ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmphhtm8ri6.rs:23:25\n\
    \   |\n23 |             result.push(*(vowels_2.chars().nth(j).unwrap()));\n  \
    \ |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphhtm8ri6.rs:27:12\n\
    \   |\n27 |         if message[i] == vowels.chars().nth(1) {\n   |           \
    \ ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmphhtm8ri6.rs:28:25\n\
    \   |\n28 |             result.push(*(vowels_2.chars().nth(k).unwrap()));\n  \
    \ |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphhtm8ri6.rs:32:12\n\
    \   |\n32 |         if message[i] == vowels.chars().nth(2) {\n   |           \
    \ ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   ="
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut i = 0;\n    while i < message.len() {\n       \
    \ if message[i] == ' ' {\n            result.push('_');\n        } else {\n  \
    \          result.push(letters[message[i] - 'A']);\n        }\n        i += 1;\n\
    \    }\n    for i in 0..vowels.len() {\n        result.push(vowels[(i + 2) % vowels.len()]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv9e0a35u.rs:17:12\n\
    \   |\n17 |         if message[i] == ' ' {\n   |            ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpv9e0a35u.rs:20:33\n   |\n20 |             result.push(letters[message[i]\
    \ - 'A']);\n   |                                 ^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut i = 0;\n    \n    for letter\
    \ in message.chars() {\n        if letter.is_uppercase() {\n            result.push_str(&format!(\"\
    {}{}\", letter.to_lowercase(), i));\n        } else {\n            result.push_str(&format!(\"\
    {}{}\", letter, i));\n        }\n        i += 1;\n    }\n    \n    for letter\
    \ in result.chars() {\n        if letter.is_uppercase() {\n            if let\
    \ Some(vowel) = vowels.iter().position(|&x| x == letter) {\n                result.push_str(&format!(\"\
    {}{}\", letter.to_lowercase(), vowel));\n            } else {\n              \
    \  result.push_str(&format!(\"{}{}\", letter.to_lowercase(), letters.len() + 1));\n\
    \                letters.insert(letter);\n            }\n        } else {\n  \
    \          if let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n \
    \               result.push_str(&format!(\"{}{}\", letter, vowel));\n        \
    \    } else {\n                result.push_str(&format!(\"{}{}\", letter, letters.len()\
    \ + 1));\n                letters.insert(letter);\n            }\n        }\n\
    \    }\n    \n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpzvgzv3ic.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpzvgzv3ic.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\
    \ 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,\
    \ 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,\
    \ 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut vowels_index_3\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28, 29, 30, 31, 32, 33, \n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpm9l4m8g3.rs:18:1\n   |\n18 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpm9l4m8g3.rs:17:34\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n17 |     let mut vowels_index_4 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 2...\n   |                                  ^ unclosed delimiter\n18 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counter = 0;\n    for letter in message {\n        if\
    \ letter_counter < vowels.len() {\n            result.push((&vowels[vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()]][..]).to_lowercase());\n        } else {\n          \
    \  result.push((&vowels[vowels_index[vowels.iter().position(|x| x == letter).unwrap()]\
    \ + 2][..]).to_lowercase());\n        }\n        letter_counter += 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp7zvrcrd5.rs:16:19\n\
    \   |\n16 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7zvrcrd5.rs:18:25\n   |\n18 |             result.push((&vowels[vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()]][..]).to_lowercase());\n   |                        \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp7zvrcrd5.rs:20:25\n   |\n20 |             result.push((&vowels[vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()] + 2][..]).to_lowercase());\n   |                    \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message {\n       \
    \ if letter == letters[letter_counter] {\n            letter_counter += 1;\n \
    \       } else {\n            letter_counter = 0;\n        }\n        if vowels[vowel_counter]\
    \ == letters[letter_counter] {\n            vowel_counter += 1;\n        } else\
    \ {\n            vowel_counter = 0;\n        }\n        result.push(letters[letter_counter]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpt8wv_dg4.rs:17:19\n\
    \   |\n17 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt8wv_dg4.rs:28:21\n   |\n28 |         result.push(letters[letter_counter]);\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&str`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for c in message.chars() {\n    \
    \    if letters.contains(&c) {\n            result.push(c);\n            letter_counter\
    \ += 1;\n        } else {\n            if vowels.contains(&c) {\n            \
    \    result.push(c);\n                vowel_counter += 1;\n            } else\
    \ {\n                if vowel_counter > 2 {\n                    result.push(letters[letter_counter\
    \ - 2]);\n                    letter_counter -= 2;\n                } else {\n\
    \                    result.push(letters[letter_counter - 1]);\n             \
    \       letter_counter -= 1;\n                }\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppmmxbsij.rs:18:29\n   |\n\
    18 |         if letters.contains(&c) {\n   |                             ^^ expected\
    \ `&str`, found `char`\n   |\n   = note: expected reference `&&str`\n        \
    \      found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppmmxbsij.rs:22:32\n\
    \   |\n22 |             if vowels.contains(&c) {\n   |                       \
    \         ^^ expected `&str`, found `char`\n   |\n   = note: expected reference\
    \ `&&str`\n              found reference `&char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmppmmxbsij.rs:27:33\n   |\n27 |                     result.push(letters[letter_counter\
    \ - 2]);\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppmmxbsij.rs:30:33\n\
    \   |\n30 |                     result.push(letters[letter_counter - 1]);\n  \
    \ |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut index2 = 0;\n    let\
    \ mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n    let mut\
    \ index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9\
    \ = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12\
    \ = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15\
    \ = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18\
    \ = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21\
    \ = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24\
    \ = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27\
    \ = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30\
    \ = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33\
    \ = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36\
    \ = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39\
    \ = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42\
    \ = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45\
    \ = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48\
    \ = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51\
    \ = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n    let mut index54\
    \ = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n    let mut index57\
    \ = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n    let mut index60\
    \ = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n    let mut index63\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpch3tbgp5.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_index = 0;\n    let mut letter_counter = 0;\n    let mut letter_counter_index\
    \ = 0;\n    for letter in message.chars() {\n        if letter == ' ' {\n    \
    \        result.push_str(\" \");\n            continue;\n        }\n        if\
    \ let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n            result.push_str(&message[vowels_index..letter_counter_index]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_str(&message[vowels_index..letter_counter_index + 2]);\n\
    \            result.push_\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpdrmcldg2.rs:58:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n17 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n...\n22 |  \
    \       if let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n   |\
    \                                                                       - this\
    \ delimiter might not be properly closed...\n...\n49 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n58 | }\n   |   ^\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpdrmcldg2.rs:13:22\n\
    \   |\n13 |     let mut vowels = HashSet::new();\n   |                      ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0609]: no field `push_` on\
    \ type `String`\n  --> /tmp/tmpdrmcldg2.rs:48:20\n   |\n48 |             result.push_\n\
    \   |                    ^^^^^ unknown field\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdrmcldg2.rs:17:5\n   |\n11 |   fn encode(message: String) -> String\
    \ {\n   |                                 ------ expected `String` because of\
    \ return type\n...\n17 | /     for letter in message.chars() {\n18 | |       \
    \  if letter == ' ' {\n19 | |             result.push_str(\" \");\n20 | |    \
    \         continue;\n...  |\n57 | |     assert_eq!(candidate(String::from(\"I\
    \ DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    58 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0433,\
    \ E0609.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = 0;\n    let mut\
    \ letter_count = 1;\n    for letter in message.chars() {\n        if let Some(vowel)\
    \ = vowels[vowels_index] {\n            if letter_count == 2 {\n             \
    \   result.push_str(&vowel);\n                letter_count = 1;\n            }\
    \ else {\n                result.push_str(&vowel);\n                letter_count\
    \ += 1;\n            }\n        } else {\n            result.push_str(&letter);\n\
    \            letter_count += 1;\n        }\n        vowels_index += 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf5x5l43_.rs:17:16\n   |\n\
    17 |         if let Some(vowel) = vowels[vowels_index] {\n   |               \
    \ ^^^^^^^^^^^   -------------------- this expression has type `&str`\n   |   \
    \             |\n   |                expected `str`, found enum `Option`\n   |\n\
    \   = note: expected type `str`\n              found enum `Option<_>`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpf5x5l43_.rs:17:16\n    |\n17  |         if let Some(vowel) = vowels[vowels_index]\
    \ {\n    |                ^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `Some`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf5x5l43_.rs:26:29\n\
    \   |\n26 |             result.push_str(&letter);\n   |                      \
    \       ^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut i = 0;\n    for letter in message.chars() {\n \
    \       if letter == ' ' {\n            result.push_str(\" \");\n        } else\
    \ {\n            result.push_str(&letters[letters.iter().position(|&x| x == letter).unwrap()\
    \ + 1]);\n        }\n    }\n    for vowel in vowels {\n        result.push_str(&vowels[vowels.iter().position(|&x|\
    \ x == vowel).unwrap() + 1]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjaaj53z5.rs:20:29\n   |\n\
    20 |             result.push_str(&letters[letters.iter().position(|&x| x == letter).unwrap()\
    \ + 1]);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjaaj53z5.rs:24:25\n   |\n24 |         result.push_str(&vowels[vowels.iter().position(|&x|\
    \ x == vowel).unwrap() + 1]);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\
    \ 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,\
    \ 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,\
    \ 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut vowels_index_3\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28, 29, 30, 31, 32, 33, \n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpm9l4m8g3.rs:18:1\n   |\n18 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpm9l4m8g3.rs:17:34\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n17 |     let mut vowels_index_4 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 2...\n   |                                  ^ unclosed delimiter\n18 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n    let \n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpy47w3a24.rs:77:1\n  \
    \ |\n77 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmpy47w3a24.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n    let \n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpy47w3a24.rs:77:1\n  \
    \ |\n77 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmpy47w3a24.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowels_2 = vec!['b', 'c', 'd', 'f', 'g', 'h',\
    \ 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n   \
    \ let mut vowels_3 = vec!['b', 'c', 'd', 'f', 'g', 'h', 'k', 'l', 'm', 'n', 'p',\
    \ 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowels_4 = vec!['b',\
    \ 'c', 'd', 'f', 'g', 'h', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut vowels_5 = vec!['b', 'c', 'd', 'f', 'g', 'h', 'k',\
    \ 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut\
    \ vowels_6 = vec!['b', 'c', 'd', 'f', 'g', 'h', 'k', 'l', 'm', 'n', 'p', 'q',\
    \ 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowels_7 = vec!['b', 'c',\
    \ 'd', 'f', 'g', 'h', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x',\
    \ 'y', 'z'];\n    let mut vowels_8 = vec!['b', 'c', 'd', 'f', 'g', 'h', 'k', 'l',\
    \ 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowels_9\
    \ = vec!['b', 'c', 'd', 'f', 'g', 'h', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's',\
    \ 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowels_10 = vec!['b', 'c', 'd',\
    \ 'f', 'g', 'h', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y',\
    \ 'z'];\n    let mut vowels_11 = vec!['b', 'c', 'd', 'f', 'g', 'h', 'k', 'l',\
    \ 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowels_12\
    \ = vec!['b', 'c', 'd', 'f', 'g', 'h', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's',\
    \ 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowels_13 = vec!['b', 'c', 'd',\
    \ 'f', 'g', 'h', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y',\
    \ 'z'];\n    let mut vowels_14 = vec!['b', 'c', 'd', 'f', 'g', 'h', 'k', 'l',\
    \ 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut vowels_15\
    \ = vec!['b', 'c', 'd', 'f', 'g', '\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp408hlok3.rs:27:55\n\
    \   |\n27 |     let mut vowels_15 = vec!['b', 'c', 'd', 'f', 'g', '\n   |    \
    \                                                   ^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut i = 0;\n \
    \   while i < message.len() {\n        let mut j = i;\n        while j < message.len()\
    \ {\n            if message[j] == vowels[i as usize] {\n                result.push((letters[i\
    \ as usize] + letters[i as usize + 1]).to_string());\n                i += 2;\n\
    \                break;\n            }\n            j += 1\n        }\n      \
    \  i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppevpjylp.rs:19:16\n\
    \   |\n19 |             if message[j] == vowels[i as usize] {\n   |          \
    \      ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot add `&str` to `&str`\n  --> /tmp/tmppevpjylp.rs:20:50\n\
    \   |\n20 |                 result.push((letters[i as usize] + letters[i as usize\
    \ + 1]).to_string());\n   |                              ------------------- ^\
    \ ----------------------- &str\n   |                              |          \
    \         |\n   |                              |                   `+` cannot\
    \ be used to concatenate two `&str` strings\n   |                            \
    \  &str\n   |\n   = note: string concatenation requires an owned `String` on the\
    \ left\nhelp: create an owned `String` from a string reference\n   |\n20 |   \
    \              result.push((letters[i as usize].to_owned() + letters[i as usize\
    \ + 1]).to_string());\n   |                                                 +++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut index = 0;\n    let mut current_letter = String::new();\n    let\
    \ mut next_letter = String::new();\n    \n    for letter in message {\n      \
    \  if letter == ' ' {\n            result.push_str(current_letter);\n        \
    \    current_letter = String::new();\n        } else {\n            current_letter.push_str(letter);\n\
    \        }\n    }\n    \n    for letter in vowels {\n        index = message.find(letter);\n\
    \        if index != String::npos {\n            next_letter = message[index +\
    \ 2];\n            result.push_str(letter);\n            result.push_str(next_letter);\n\
    \        }\n    }\n    \n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2yw8tlcm.rs:18:19\n\
    \   |\n18 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2yw8tlcm.rs:20:29\n   |\n20 |             result.push_str(current_letter);\n\
    \   |                             ^^^^^^^^^^^^^^\n   |                       \
    \      |\n   |                             expected `&str`, found struct `String`\n\
    \   |                             help: consider borrowing here: `&current_letter`\n\
    \nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmp2yw8tlcm.rs:19:19\n\
    \   |\n19 |         if letter == ' ' {\n   |                   ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: `&str` is\
    \ not an iterator\n  --> /tmp/tmp2yw8tlcm.rs:27:19\n   |\n27 |     for letter\
    \ in vowels {\n   |                   ^^^^^^ `&str` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&str`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2yw8tlcm.rs:28:17\n\
    \   |\n14 |     let mut index = 0;\n   |                     - expected due to\
    \ this value\n...\n28 |         index = message.find(letter);\n   |          \
    \       ^^^^^^^^^^^^^^^^^^^^ expected integer, fo"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    for c in message.chars()\
    \ {\n        if let Some(index) = vowels.find(c) {\n            encoded.push_str(&letters[(index\
    \ + 1) % letters.len()]);\n        } else {\n            encoded.push_str(&c);\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpem5v4fhj.rs:17:31\n\
    \   |\n17 |             encoded.push_str(&letters[(index + 1) % letters.len()]);\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpem5v4fhj.rs:19:30\n\
    \   |\n19 |             encoded.push_str(&c);\n   |                          \
    \    ^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.binary_search(&letter) {\n          \
    \  result.push_str(&letters[vowel + 2]);\n        } else {\n            result.push_str(&letters[index]);\n\
    \        }\n        index += 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw0mcwbvz.rs:17:16\n   |\n\
    17 |         if let Some(vowel) = vowels.binary_search(&letter) {\n   |      \
    \          ^^^^^^^^^^^   ----------------------------- this expression has type\
    \ `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw0mcwbvz.rs:20:29\n   |\n20 |             result.push_str(&letters[index]);\n\
    \   |                             ^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_seen = HashSet::new();\n    let mut letters = HashSet::new();\n\
    \    let mut letters_seen = HashSet::new();\n    \n    for c in message.chars()\
    \ {\n        if letters.contains(&c) {\n            letters.insert(c);\n     \
    \       letters_seen.insert(c);\n        }\n        if vowels.contains(&c) {\n\
    \            vowels.insert(c);\n            vowels_seen.insert(c);\n        }\n\
    \    }\n    \n    for c in message.chars() {\n        if letters_seen.contains(&c)\
    \ {\n            result.push(c);\n        }\n        if vowels_seen.contains(&c)\
    \ {\n            result.push(c);\n        }\n    }\n    \n    for c in message.chars()\
    \ {\n        if letters.contains(&c) {\n            result.push(c);\n        }\n\
    \        if vowels.contains(&c) {\n            result.push(c);\n        }\n  \
    \  }\n    \n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpyks0qx_p.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpyks0qx_p.rs:14:27\n\
    \   |\n14 |     let mut vowels_seen = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpyks0qx_p.rs:15:23\n\
    \   |\n15 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpyks0qx_p.rs:16:28\n   |\n16\
    \ |     let mut letters_seen = HashSet::new();\n   |                         \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_count = vec![0];\n    let mut letter_count_index = vec![0];\n   \
    \ let mut letter_count_index2 = vec![0];\n    let mut letter_count_index3 = vec![0];\n\
    \    let mut letter_count_index4 = vec![0];\n    let mut letter_count_index5 =\
    \ vec![0];\n    let mut letter_count_index6 = vec![0];\n    let mut letter_count_index7\
    \ = vec![0];\n    let mut letter_count_index8 = vec![0];\n    let mut letter_count_index9\
    \ = vec![0];\n    let mut letter_count_index10 = vec![0];\n    let mut letter_count_index11\
    \ = vec![0];\n    let mut letter_count_index12 = vec![0];\n    let mut letter_count_index13\
    \ = vec![0];\n    let mut letter_count_index14 = vec![0];\n    let mut letter_count_index15\
    \ = vec![0];\n    let mut letter_count_index16 = vec![0];\n    let mut letter_count_index17\
    \ = vec![0];\n    let mut letter_count_index18 = vec![0];\n    let mut letter_count_index19\
    \ = vec![0];\n    let mut letter_count_index20 = vec![0];\n    let mut letter_count_index21\
    \ = vec![0];\n    let mut letter_count_index22 = vec![0];\n    let mut letter_count_index23\
    \ = vec![0];\n    let mut letter_count_index24 = vec![0];\n    let mut letter_count_index25\
    \ = vec![0];\n    let mut letter_count_index26 = vec![0];\n    let mut letter_count_index27\
    \ = vec![0];\n    let mut letter_count_index28 = vec![0];\n    let mut letter_count_index29\
    \ = vec![0];\n    let mut letter_count_index30 = vec![0];\n    let mut letter_count_index31\
    \ = vec![0];\n    let mut letter_count_index32 = vec![0];\n    let mut letter_count_index33\
    \ = vec![0];\n    let mut letter_count_index34 = vec![0];\n    let mut letter_count_index35\
    \ = vec![0];\n    let mut letter_count_index36 = vec![0];\n    let mut letter_count_index37\
    \ = vec![0];\n    let mut letter_count_index38 = vec![0];\n    let mut letter_count_index39\
    \ = vec![0];\n    let mut letter_count_index40 = vec!\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `}`\n  --> /tmp/tmpwzd1ao45.rs:56:1\n\
    \   |\n55 |     let mut letter_count_index40 = vec!\n   |                    \
    \                    - expected one of `(`, `[`, or `{`\n56 | }\n   | ^ unexpected\
    \ token\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut letters = HashSet::new();\n    let\
    \ mut letters_counter = 0;\n    let mut letters_counter2 = 0;\n    let mut letters_counter3\
    \ = 0;\n    let mut letters_counter4 = 0;\n    let mut letters_counter5 = 0;\n\
    \    let mut letters_counter6 = 0;\n    let mut letters_counter7 = 0;\n    let\
    \ mut letters_counter8 = 0;\n    let mut letters_counter9 = 0;\n    let mut letters_counter10\
    \ = 0;\n    let mut letters_counter11 = 0;\n    let mut letters_counter12 = 0;\n\
    \    let mut letters_counter13 = 0;\n    let mut letters_counter14 = 0;\n    let\
    \ mut letters_counter15 = 0;\n    let mut letters_counter16 = 0;\n    let mut\
    \ letters_counter17 = 0;\n    let mut letters_counter18 = 0;\n    let mut letters_counter19\
    \ = 0;\n    let mut letters_counter20 = 0;\n    let mut letters_counter21 = 0;\n\
    \    let mut letters_counter22 = 0;\n    let mut letters_counter23 = 0;\n    let\
    \ mut letters_counter24 = 0;\n    let mut letters_counter25 = 0;\n    let mut\
    \ letters_counter26 = 0;\n    let mut letters_counter27 = 0;\n    let mut letters_counter28\
    \ = 0;\n    let mut letters_counter29 = 0;\n    let mut letters_counter30 = 0;\n\
    \    let mut letters_counter31 = 0;\n    let mut letters_counter32 = 0;\n    let\
    \ mut letters_counter33 = 0;\n    let mut letters_counter34 = 0;\n    let mut\
    \ letters_counter35 = 0;\n    let mut letters_counter36 = 0;\n    let mut letters_counter37\
    \ = 0;\n    let mut letters_counter38 = 0;\n    let mut letters_counter39 = 0;\n\
    \    let mut letters_counter40 = 0;\n    let mut letters_counter41 = 0;\n    let\
    \ mut letters_counter42 = 0;\n    let mut letters_counter43 = 0;\n    let mut\
    \ letters_counter44 = 0;\n    let mut letters_counter45 = 0;\n    let mut letters_counter46\
    \ = 0;\n    let mut letters_counter47 = 0;\n    let mut letters_counter48 = 0;\n\
    \    let mut letters_counter49 = 0;\n    let mut letters_counter50 = 0;\n    let\
    \ mut letters_counter51 = 0;\n    let mut letters_counter52 = 0;\n    let mut\
    \ letters_counter53 = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp_3ta05lv.rs:70:1\n  \
    \ |\n70 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmp_3ta05lv.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp_3ta05lv.rs:15:23\n   |\n15 |     let mut letters = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut letter_pairs = vec![\"B\", \"C\"\
    , \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"P\", \"Q\"\
    , \"R\", \"S\", \"T\", \"V\", \"W\", \"X\", \"Y\", \"Z\"];\n    let mut letter_pairs2\
    \ = vec![\"B\", \"C\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\"\
    , \"N\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"V\", \"W\", \"X\", \"Y\", \"Z\"\
    ];\n    let mut letter_pairs3 = vec![\"B\", \"C\", \"D\", \"F\", \"G\", \"H\"\
    , \"J\", \"K\", \"L\", \"M\", \"N\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"V\"\
    , \"W\", \"X\", \"Y\", \"Z\"];\n    let mut letter_pairs4 = vec![\"B\", \"C\"\
    , \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"P\", \"Q\"\
    , \"R\", \"S\", \"T\", \"V\", \"W\", \"X\", \"Y\", \"Z\"];\n    let mut letter_pairs5\
    \ = vec![\"B\", \"C\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\"\
    , \"N\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"V\", \"W\", \"X\", \"Y\", \"Z\"\
    ];\n    let mut letter_pairs6 = vec![\"B\", \"C\", \"D\", \"F\", \"G\", \"H\"\
    , \"J\", \"K\", \"L\", \"M\", \"N\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"V\"\
    , \"W\", \"X\", \"Y\", \"Z\"];\n    let mut letter_pairs7 = vec![\"B\", \"C\"\
    , \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"P\", \"Q\"\
    , \"R\", \"S\", \"T\", \"V\", \"W\", \"X\", \"Y\", \"Z\"];\n    let mut letter_pairs8\
    \ = vec![\"B\", \"C\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\"\
    , \"N\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"V\", \"W\", \"X\", \"Y\", \"Z\"\
    ];\n    let mut letter_pairs9 = vec![\"B\", \"C\", \"D\", \"F\", \"G\", \"H\"\
    , \"J\", \"K\", \"L\", \"M\", \"N\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"V\"\
    , \"W\", \"X\", \"Y\", \"Z\"];\n    let mut letter_pairs10 = vec![\"B\", \"C\"\
    , \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"P\", \"Q\"\
    , \"R\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpr8c71pzn.rs:32:109\n\
    \   |\n32 |       assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt tO WrItE\"\
    )), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n   |  _____________________________________________________________________________________________________________^\n\
    33 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['b', 'c', 'd', 'f', 'g', 'h',\
    \ 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut i = 0;\n    for letter in message.chars() {\n        if letter ==\
    \ ' ' {\n            result.push_str(\" \");\n        } else {\n            if\
    \ let Some(vowel) = vowels.binary_search(&letter) {\n                result.push_str(&letters[vowel\
    \ + 2]);\n            } else {\n                result.push_str(&letters[letter]);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy1vrla7d.rs:20:20\n   |\n\
    20 |             if let Some(vowel) = vowels.binary_search(&letter) {\n   |  \
    \                  ^^^^^^^^^^^   ----------------------------- this expression\
    \ has type `Result<usize, usize>`\n   |                    |\n   |           \
    \         expected enum `Result`, found enum `Option`\n   |\n   = note: expected\
    \ enum `Result<usize, usize>`\n              found enum `Option<_>`\n\nerror[E0277]:\
    \ the type `[char]` cannot be indexed by `char`\n  --> /tmp/tmpy1vrla7d.rs:23:34\n\
    \   |\n23 |                 result.push_str(&letters[letter]);\n   |         \
    \                         ^^^^^^^^^^^^^^^ slice indices are of type `usize` or\
    \ ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[char]>` is not implemented\
    \ for `char`\n   = note: required because of the requirements on the impl of `Index<char>`\
    \ for `Vec<char>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut index = 0;\n    for c in message.chars()\
    \ {\n        if let Some(vowel) = vowels.lookup(&c) {\n            encoded.push_str(&vowels[vowel]);\n\
    \        } else {\n            if let Some(letter) = letters.lookup(&index) {\n\
    \                encoded.push_str(&letters[letter]);\n            } else {\n \
    \               encoded.push_str(&c);\n            }\n            letters.insert(index);\n\
    \            vowels.insert(c);\n        }\n        index += 1;\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpm58qgo33.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpm58qgo33.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpm58qgo33.rs:23:34\n   |\n23 |                 encoded.push_str(&c);\n\
    \   |                                  ^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants = vec!['b',\
    \ 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let mut consonant_counter\
    \ = 0;\n    for c in message.chars() {\n        if vowels.contains(&c) {\n   \
    \         vowel_counter += 2;\n            result.push(c);\n        } else {\n\
    \            consonant_counter += 1;\n            result.push(consonants[consonant_counter]);\n\
    \            result.push(c);\n        }\n    }\n    if vowel_counter > 0 {\n \
    \       result.push(vowels[vowel_counter]);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TESTI\"`,\n right: `\"tgst\"`', /tmp/tmprbvsr7gg.rs:35:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowels_idx = 0;\n    let mut\
    \ letters_idx = 0;\n    let mut vowels_idx2 = 0;\n    let mut letters_idx2 = 0;\n\
    \    for c in message.chars() {\n        if c.is_uppercase() {\n            letters.insert(c.to_lowercase());\n\
    \            letters_idx += 1;\n        } else {\n            letters.insert(c.to_uppercase());\n\
    \            letters_idx += 1;\n        }\n        if letters_idx == 2 {\n   \
    \         letters_idx2 = 0;\n        }\n        if letters_idx == 3 {\n      \
    \      letters_idx2 = 0;\n        }\n        if letters_idx2 == 0 {\n        \
    \    vowels.insert(c.to_lowercase());\n            vowels_idx += 1;\n        }\
    \ else {\n            vowels.insert(c.to_uppercase());\n            vowels_idx\
    \ += 1;\n        }\n        if vowels_idx == 2 {\n            vowels_idx2 = 0;\n\
    \        }\n        if vowels_idx == 3 {\n            vowels_idx2 = 0;\n     \
    \   }\n        if vowels_idx2 == 0 {\n            vowels.insert(c.to_lowercase());\n\
    \            vowels_idx += 1;\n        } else {\n            vowels.insert(c.to_uppercase());\n\
    \            vowels_idx += 1;\n        }\n        if vowels_idx == 2 {\n     \
    \       vowels_idx2 = 0;\n        }\n        if vowels_idx == 3 {\n          \
    \  vowels_idx2 = 0;\n        }\n        if vowels_idx2 == 0 {\n            vowels.insert(c.to_lowercase());\n\
    \            vowels_idx += 1;\n        } else {\n            vowels.insert(c.to_uppercase());\n\
    \            vowels_idx += 1;\n        }\n        if vowels_idx == 2 {\n     \
    \       vowels_idx2 = 0;\n        }\n        if vowels_idx == 3 {\n          \
    \  vowels_idx2 = 0;\n        }\n        if vowels_idx2 == 0 {\n            vowels.insert(c.to_lowercase());\n\
    \            vowels_idx += 1;\n        } else {\n            vowels.insert(c.to_uppercase());\n\
    \            vowels_idx += 1;\n        }\n        if vowels_idx == 2 {\n     \
    \       vowels_idx2 = 0;\n        }\n        if vowels_idx == 3 {\n          \
    \  vowels_idx2 = 0;\n        }\n        if vowels_idx2 == 0 {\n            vowels.insert(c.to_lowercase());\n\
    \            vowels_idx += 1;\n        } else {\n            vowels.insert(c.to_uppercase());\n\
    \            vowels_idx += 1;\n        }\n        if vowels_idx == 2 {\n     \
    \       vowels_idx2 = 0;\n        }\n        if vowels_idx == 3 {\n          \
    \  vowels_idx2 = 0;\n        }\n        if vowels_idx2 == \n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpk1gveoy8.rs:108:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n19  |     for c in message.chars()\
    \ {\n    |                              - this delimiter might not be properly\
    \ closed...\n...\n99  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n108 | }\n    |   ^\n\nerror: expected expression, found `}`\n\
    \  --> /tmp/tmpk1gveoy8.rs:99:1\n   |\n99 | }\n   | ^ expected expression\n\n\
    error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpk1gveoy8.rs:13:22\n\
    \   |\n13 |     let mut vowels = HashSet::new();\n   |                      ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpk1gveoy8.rs:14:23\n   |\n14\
    \ |     let mut letters = HashSet::new();\n   |                       ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpk1gveoy8.rs:11:31\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |    ------                     ^^^^^^ expected struct `String`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            result.push_str(\" \");\n       \
    \ } else {\n            result.push_str(&letters[letter - 'A']);\n        }\n\
    \        if letter == vowels[i as usize] {\n            result.push_str(&vowels[(i\
    \ + 1) as usize]);\n            i += 2;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmp3ywng6fr.rs:20:45\n\
    \   |\n20 |             result.push_str(&letters[letter - 'A']);\n   |       \
    \                               ------ ^ --- char\n   |                      \
    \                |\n   |                                      char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3ywng6fr.rs:23:29\n   |\n23 |             result.push_str(&vowels[(i\
    \ + 1) as usize]);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut vowels_index = String::new();\n    let mut vowels_index_2 = String::new();\n\
    \    let mut vowels_index_3 = String::new();\n    let mut vowels_index_4 = String::new();\n\
    \    let mut vowels_index_5 = String::new();\n    let mut vowels_index_6 = String::new();\n\
    \    let mut vowels_index_7 = String::new();\n    let mut vowels_index_8 = String::new();\n\
    \    let mut vowels_index_9 = String::new();\n    let mut vowels_index_10 = String::new();\n\
    \    let mut vowels_index_11 = String::new();\n    let mut vowels_index_12 = String::new();\n\
    \    let mut vowels_index_13 = String::new();\n    let mut vowels_index_14 = String::new();\n\
    \    let mut vowels_index_15 = String::new();\n    let mut vowels_index_16 = String::new();\n\
    \    let mut vowels_index_17 = String::new();\n    let mut vowels_index_18 = String::new();\n\
    \    let mut vowels_index_19 = String::new();\n    let mut vowels_index_20 = String::new();\n\
    \    let mut vowels_index_21 = String::new();\n    let mut vowels_index_22 = String::new();\n\
    \    let mut vowels_index_23 = String::new();\n    let mut vowels_index_24 = String::new();\n\
    \    let mut vowels_index_25 = String::new();\n    let mut vowels_index_26 = String::new();\n\
    \    let mut vowels_index_27 = String::new();\n    let mut vowels_index_28 = String::new();\n\
    \    let mut vowels_index_29 = String::new();\n    let mut vowels_index_30 = String::new();\n\
    \    let mut vowels_index_31 = String::new();\n    let mut vowels_index_32 = String::new();\n\
    \    let mut vowels_index_33 = String::new();\n    let mut vowels_index_34 = String::new();\n\
    \    let mut vowels_index_35 = String::new();\n    let mut vowels_index_36 = String::new();\n\
    \    let mut vowels_index_37 = String::new();\n    let mut vowels_index_38 = String::new();\n\
    \    let mut vowels_index_39 = String::\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp6tl6uzwu.rs:53:1\n\
    \   |\n53 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    while i < message.len() {\n  \
    \      let mut j = i;\n        while j < message.len() {\n            let mut\
    \ k = j;\n            while k < message.len() {\n                if message[j]\
    \ == message[k] {\n                    k = j;\n                } else {\n    \
    \                break;\n                }\n            }\n            if k ==\
    \ j {\n                result.push((message[j]).to_string());\n              \
    \  j = k;\n            } else {\n                break;\n            }\n     \
    \   }\n        if j == i {\n            result.push((message[i]).to_string());\n\
    \            i += 1;\n        } else {\n            break;\n        }\n    }\n\
    \    let mut i = 0;\n    while i < result.len() {\n        let mut j = i;\n  \
    \      while j < result.len() {\n            let mut k = j;\n            while\
    \ k < result.len() {\n                if result[j] == result[k] {\n          \
    \          k = j;\n                } else {\n                    break;\n    \
    \            }\n            }\n            if k == j {\n                result[j]\
    \ = vowels[i % vowels.len()];\n                j = k;\n            } else {\n\
    \                break;\n            }\n        }\n        if j == i {\n     \
    \       result[j] = letters[i % letters.len()];\n            i += 1;\n       \
    \ } else {\n            break;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp58cj9rdl.rs:21:20\n\
    \   |\n21 |                 if message[j] == message[k] {\n   |              \
    \      ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp58cj9rdl.rs:21:34\n   |\n21 |                 if message[j] ==\
    \ message[k] {\n   |                                  ^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp58cj9rdl.rs:28:29\n   |\n28 |                 result.push((message[j]).to_string());\n\
    \   |                             ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \          "
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    for c in message.chars() {\n     \
    \   if c.is_uppercase() {\n            letters.insert(c.to_lowercase());\n   \
    \     } else {\n            letters.insert(c.to_uppercase());\n        }\n   \
    \ }\n    for c in letters.iter() {\n        if vowels.contains(&c) {\n       \
    \     result.push(c);\n        } else {\n            result.push(c.to_ascii_lowercase().to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp76ukg50z.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp76ukg50z.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp76ukg50z.rs:26:25\n   |\n26 |             result.push(c.to_ascii_lowercase().to_string());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    for letter in message.chars() {\n        if letter.is_uppercase() {\n   \
    \         result.push_str(&format!(\"{}{}\", letter.to_lowercase(), vowels.next().unwrap()));\n\
    \        } else {\n            result.push_str(&format!(\"{}{}\", letter, vowels.next().unwrap()));\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp01wyktp3.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut index = 0;\n    let mut index2 = 0;\n    let mut\
    \ index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n    let mut index6\
    \ = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9 =\
    \ 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12\
    \ = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15\
    \ = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18\
    \ = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21\
    \ = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24\
    \ = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27\
    \ = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30\
    \ = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33\
    \ = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36\
    \ = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39\
    \ = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42\
    \ = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45\
    \ = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48\
    \ = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51\
    \ = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n    let mu\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphoiicu0e.rs:68:11\n   |\n\
    68 |     let mu\n   |           ^ help: add `;` here\n69 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphoiicu0e.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n\
    \    let mut letter_counter = 0;\n    for c in message.chars() {\n        if letters[letter_counter]\
    \ == c {\n            letter_counter += 1;\n        } else {\n            letter_counter\
    \ = 0;\n        }\n        if vowels[vowel_counter] == c {\n            vowel_counter\
    \ += 1;\n        } else {\n            vowel_counter = 0;\n        }\n       \
    \ if letter_counter == 2 {\n            result += letters[letter_counter];\n \
    \           letter_counter = 0;\n        }\n        if vowel_counter == 2 {\n\
    \            result += vowels[vowel_counter];\n            vowel_counter = 0;\n\
    \        }\n        result += c;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwjdi7uey.rs:29:23\n   |\n\
    29 |             result += letters[letter_counter];\n   |                    \
    \   ^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwjdi7uey.rs:33:23\n   |\n33 |             result += vowels[vowel_counter];\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwjdi7uey.rs:36:19\n   |\n36 |\
    \         result += c;\n   |                   ^ expected `&str`, found `char`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n            vowels.insert(letter);\n\
    \            vowels_counter += 1;\n        }\n        if letter == 'A' || letter\
    \ == 'E' || letter == 'I' || letter == 'O' || letter == 'U' {\n            vowels.insert(letter);\n\
    \            vowels_counter += 1;\n        }\n        if letter_counter == 2 {\n\
    \            encoded.push_str(vowels.clone());\n            vowels_counter = 0;\n\
    \        }\n        letter_counter += 1;\n    }\n    if vowels_counter > 0 {\n\
    \        encoded.push_str(vowels.clone());\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmptcji9vhe.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    for c in message.chars() {\n        if !vowels.contains(&c.to_ascii_lowercase())\
    \ {\n            vowels.insert(c.to_ascii_lowercase());\n            result.push(c);\n\
    \        }\n    }\n    for c in vowels.iter() {\n        for d in &[c.to_ascii_lowercase(),\
    \ c.to_ascii_lowercase().rev()] {\n            result.push(d);\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpizturlgm.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowels_index = 0;\n    let\
    \ mut letters_index = 0;\n    let mut vowels_index2 = 0;\n    let mut letters_index2\
    \ = 0;\n    let mut vowels_index3 = 0;\n    let mut letters_index3 = 0;\n    let\
    \ mut vowels_index4 = 0;\n    let mut letters_index4 = 0;\n    let mut vowels_index5\
    \ = 0;\n    let mut letters_index5 = 0;\n    let mut vowels_index6 = 0;\n    let\
    \ mut letters_index6 = 0;\n    let mut vowels_index7 = 0;\n    let mut letters_index7\
    \ = 0;\n    let mut vowels_index8 = 0;\n    let mut letters_index8 = 0;\n    let\
    \ mut vowels_index9 = 0;\n    let mut letters_index9 = 0;\n    let mut vowels_index10\
    \ = 0;\n    let mut letters_index10 = 0;\n    let mut vowels_index11 = 0;\n  \
    \  let mut letters_index11 = 0;\n    let mut vowels_index12 = 0;\n    let mut\
    \ letters_index12 = 0;\n    let mut vowels_index13 = 0;\n    let mut letters_index13\
    \ = 0;\n    let mut vowels_index14 = 0;\n    let mut letters_index14 = 0;\n  \
    \  let mut vowels_index15 = 0;\n    let mut letters_index15 = 0;\n    let mut\
    \ vowels_index16 = 0;\n    let mut letters_index16 = 0;\n    let mut vowels_index17\
    \ = 0;\n    let mut letters_index17 = 0;\n    let mut vowels_index18 = 0;\n  \
    \  let mut letters_index18 = 0;\n    let mut vowels_index19 = 0;\n    let mut\
    \ letters_index19 = 0;\n    let mut vowels_index20 = 0;\n    let mut letters_index20\
    \ = 0;\n    let mut vowels_index21 = 0;\n    let mut letters_index21 = 0;\n  \
    \  let mut vowels_index22 = 0;\n    let mut letters_index22 = 0;\n    let mut\
    \ vowels_index23 = 0;\n    let mut letters_index23 = 0;\n    let mut vowels_index24\
    \ = 0;\n    let mut letters_index24 = 0;\n    let mut vowels_index25 = 0;\n  \
    \  let mut letters_index25 = 0;\n    let mut vowels_index26 = 0;\n    let mut\
    \ letters_index26 = 0;\n    let mut vowels_index27 = 0;\n    let mut letters_index27\
    \ = 0;\n    let mut vowels_\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9co6rb6k.rs:69:20\n   |\n\
    69 |     let mut vowels_\n   |                    ^ help: add `;` here\n70 | }\n\
    \   | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmp9co6rb6k.rs:13:22\n   |\n13 |     let mut vowels\
    \ = HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp9co6rb6k.rs:14:23\n   |\n14 |     let mut letters = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9co6rb6k.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_index = HashSet::new();\n    let mut vowels_index2 = HashSet::new();\n\
    \    let mut vowels_index3 = HashSet::new();\n    let mut vowels_index4 = HashSet::new();\n\
    \    let mut vowels_index5 = HashSet::new();\n    let mut vowels_index6 = HashSet::new();\n\
    \    let mut vowels_index7 = HashSet::new();\n    let mut vowels_index8 = HashSet::new();\n\
    \    let mut vowels_index9 = HashSet::new();\n    let mut vowels_index10 = HashSet::new();\n\
    \    let mut vowels_index11 = HashSet::new();\n    let mut vowels_index12 = HashSet::new();\n\
    \    let mut vowels_index13 = HashSet::new();\n    let mut vowels_index14 = HashSet::new();\n\
    \    let mut vowels_index15 = HashSet::new();\n    let mut vowels_index16 = HashSet::new();\n\
    \    let mut vowels_index17 = HashSet::new();\n    let mut vowels_index18 = HashSet::new();\n\
    \    let mut vowels_index19 = HashSet::new();\n    let mut vowels_index20 = HashSet::new();\n\
    \    let mut vowels_index21 = HashSet::new();\n    let mut vowels_index22 = HashSet::new();\n\
    \    let mut vowels_index23 = HashSet::new();\n    let mut vowels_index24 = HashSet::new();\n\
    \    let mut vowels_index25 = HashSet::new();\n    let mut vowels_index26 = HashSet::new();\n\
    \    let mut vowels_index27 = HashSet::new();\n    let mut vowels_index28 = HashSet::new();\n\
    \    let mut vowels_index29 = HashSet::new();\n    let mut vowels_index30 = HashSet::new();\n\
    \    let mut vowels_index31 = HashSet::new();\n    let mut vowels_index32 = HashSet::new();\n\
    \    let mut vowels_index33 = HashSet::new();\n    let mut vowels_index34 = HashSet::new();\n\
    \    let mut vowels_index35 = HashSet::new();\n    let mut vowels_index36 = HashSet::new();\n\
    \    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp6k7vrakn.rs:51:1\n  \
    \ |\n51 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmp6k7vrakn.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6k7vrakn.rs:14:28\n   |\n14 |     let mut vowels_index = HashSet::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6k7vrakn.rs:15:29\n   |\n15 |     let mut vowels_index2 = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6k7vrakn.rs:16:29\n   |\n16 |     let mut vowels_index3 = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6k7vrakn.rs:17:29\n   |\n17 |     let mut vowels_index4 = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6k7vrakn.rs:18:29\n   |\n18 |     let mut vowels_index5 = HashSet::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6k7vrakn.rs:19:29\n   |\n19 |     let mut vowel"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpabxcstxy.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpabxcstxy.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut letters = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut index = 0;\n    let mut count = 1;\n    let mut\
    \ current_letter = String::new();\n    let mut current_vowel = String::new();\n\
    \    for letter in message {\n        if letter == ' ' {\n            result.push_str(current_letter);\n\
    \            current_letter = String::new();\n            count = 1;\n       \
    \ } else {\n            if count > 2 {\n                result.push_str(current_vowel);\n\
    \                current_vowel = String::new();\n                count = 1;\n\
    \            }\n            current_letter.push_str(letters[letters.len() - index]);\n\
    \            count += 1;\n        }\n        index += 1;\n    }\n    if count\
    \ > 2 {\n        result.push_str(current_vowel);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpa28xavrd.rs:19:19\n\
    \   |\n19 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa28xavrd.rs:21:29\n   |\n21 |             result.push_str(current_letter);\n\
    \   |                             ^^^^^^^^^^^^^^\n   |                       \
    \      |\n   |                             expected `&str`, found struct `String`\n\
    \   |                             help: consider borrowing here: `&current_letter`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpa28xavrd.rs:26:33\n   |\n26 |\
    \                 result.push_str(current_vowel);\n   |                      \
    \           ^^^^^^^^^^^^^\n   |                                 |\n   |      \
    \                           expected `&str`, found struct `String`\n   |     \
    \                            help: consider borrowing here: `&current_vowel`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpa28xavrd.rs:36:25\n   |\n36 |\
    \         result.push_str(current_vowel);\n   |                         ^^^^^^^^^^^^^\n\
    \   |                         |\n   |                         expected `&str`,\
    \ found struct `String`\n   |                         help: consider borrowing\
    \ here: `&current_vowel`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for c in message.chars() {\n    \
    \    if letters.contains(&c.to_ascii_lowercase()) {\n            letter_counter\
    \ += 1;\n            if letter_counter == 2 && vowels.contains(&c.to_ascii_lowercase())\
    \ {\n                vowel_counter += 1;\n            }\n            result.push(c);\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    if vowel_counter\
    \ > 1 {\n        result.push(*vowels.chars().nth(vowel_counter - 1).unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp1rikfpj0.rs:18:29\n\
    \     |\n18   |         if letters.contains(&c.to_ascii_lowercase()) {\n     |\
    \                    -------- ^^^^^^^^^^^^^^^^^^^^^^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                    |\n     |                 \
    \   required by a bound introduced by this call\n     |\n     = help: the trait\
    \ `Fn<(char,)>` is not implemented for `char`\n     = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&char`\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&char`\n\
    note: required by a bound in `core::str::<impl str>::contains`\nhelp: consider\
    \ dereferencing here\n     |\n18   |         if letters.contains(*&c.to_ascii_lowercase())\
    \ {\n     |                             +\n\nerror[E0277]: expected a `Fn<(char,)>`\
    \ closure, found `char`\n    --> /tmp/tmp1rikfpj0.rs:20:55\n     |\n20   |   \
    \          if letter_counter == 2 && vowels.contains(&c.to_ascii_lowercase())\
    \ {\n     |                                              -------- ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an `Fn<(char,)>` closure, found `char`\n     |                    \
    \                          |\n     |                                         \
    \     required by a bound introduced by this call\n     |\n     = help: the trait\
    \ `Fn<(char,)>` is not implemented for `char`\n     = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&char`\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `&char`\n\
    note: required by a bound in `core::str::<impl str>::contains`\nhelp: consider\
    \ dereferencing here\n     |\n20   |             if letter_counter == 2 && vowels.contains(*&c.to_ascii_lowercase())\
    \ {\n     |                                                       +\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp1rikfpj0.rs:29:21\n   |\n\
    29 |         result.push(*vowels.chars().nth(vowel_counter - 1).unwrap());\n \
    \  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashMap::new();\n\
    \    vowels.insert(String::from(\"a\"), String::from(\"A\"));\n    vowels.insert(String::from(\"\
    e\"), String::from(\"E\"));\n    vowels.insert(String::from(\"i\"), String::from(\"\
    I\"));\n    vowels.insert(String::from(\"o\"), String::from(\"O\"));\n    vowels.insert(String::from(\"\
    u\"), String::from(\"U\"));\n    vowels.insert(String::from(\"y\"), String::from(\"\
    Y\"));\n    for c in message.chars() {\n        if let Some(vowel) = vowels.get(c)\
    \ {\n            result.push_str(vowel);\n        } else {\n            result.push_str(c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpin7ey3ah.rs:13:22\n   |\n13 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpin7ey3ah.rs:24:29\n   |\n24 |             result.push_str(c);\n\
    \   |                             ^ expected `&str`, found `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashMap::new();\n\
    \    let mut vowels_encoded = HashMap::new();\n    let mut vowels_encoded1 = HashMap::new();\n\
    \    let mut vowels_encoded2 = HashMap::new();\n    let mut vowels_encoded3 =\
    \ HashMap::new();\n    let mut vowels_encoded4 = HashMap::new();\n    let mut\
    \ vowels_encoded5 = HashMap::new();\n    let mut vowels_encoded6 = HashMap::new();\n\
    \    let mut vowels_encoded7 = HashMap::new();\n    let mut vowels_encoded8 =\
    \ HashMap::new();\n    let mut vowels_encoded9 = HashMap::new();\n    let mut\
    \ vowels_encoded10 = HashMap::new();\n    let mut vowels_encoded11 = HashMap::new();\n\
    \    let mut vowels_encoded12 = HashMap::new();\n    let mut vowels_encoded13\
    \ = HashMap::new();\n    let mut vowels_encoded14 = HashMap::new();\n    let mut\
    \ vowels_encoded15 = HashMap::new();\n    let mut vowels_encoded16 = HashMap::new();\n\
    \    let mut vowels_encoded17 = HashMap::new();\n    let mut vowels_encoded18\
    \ = HashMap::new();\n    let mut vowels_encoded19 = HashMap::new();\n    let mut\
    \ vowels_encoded20 = HashMap::new();\n    let mut vowels_encoded21 = HashMap::new();\n\
    \    let mut vowels_encoded22 = HashMap::new();\n    let mut vowels_encoded23\
    \ = HashMap::new();\n    let mut vowels_encoded24 = HashMap::new();\n    let mut\
    \ vowels_encoded25 = HashMap::new();\n    let mut vowels_encoded26 = HashMap::new();\n\
    \    let mut vowels_encoded27 = HashMap::new();\n    let mut vowels_encoded28\
    \ = HashMap::new();\n    let mut vowels_encoded29 = HashMap::new();\n    let mut\
    \ vowels_encoded30 = HashMap::new();\n    let mut vowels_encoded31 = HashMap::new();\n\
    \    let mut vowels_encoded32 = HashMap::new();\n    let mut vowels_encoded33\
    \ = HashMap::new();\n    let mut vowels_encoded34 = HashMap::new();\n    let mut\
    \ vowels_encoded35 = HashMap::new();\n\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp7ralphtz.rs:13:22\n   |\n13 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp7ralphtz.rs:14:30\n\
    \   |\n14 |     let mut vowels_encoded = HashMap::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp7ralphtz.rs:15:31\n\
    \   |\n15 |     let mut vowels_encoded1 = HashMap::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp7ralphtz.rs:16:31\n\
    \   |\n16 |     let mut vowels_encoded2 = HashMap::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp7ralphtz.rs:17:31\n\
    \   |\n17 |     let mut vowels_encoded3 = HashMap::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp7ralphtz.rs:18:31\n\
    \   |\n18 |     let mut vowels_encoded4 = HashMap::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp7ralphtz.rs:19:31\n\
    \   |\n19 |     let mut vowels_encoded5 = HashMap::new();\n   |              \
    \                 ^^^^^^^ not found i"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut i = 0;\n \
    \   let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n\
    \    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n\
    \    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut v = 0;\n\
    \    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n\
    \    let mut a = 0;\n    let mut e = 0;\n    let mut i = 0;\n    let mut o = 0;\n\
    \    let mut u = 0;\n    let mut b = 0;\n    let mut c = 0;\n    let mut d = 0;\n\
    \    let mut f = 0;\n    let mut g = 0;\n    let mut h = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n\
    \    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n\
    \    let mut t = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n\
    \    let mut y = 0;\n    let mut z = 0;\n    let mut a = 0;\n    let mut e = 0;\n\
    \    let mut i = 0;\n    let mut o = 0;\n    let mut u = 0;\n    let mut b = 0;\n\
    \    let mut c = 0;\n    let mut d = 0;\n    let mut f = 0;\n    let mut g = 0;\n\
    \    let mut h = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n\
    \    let mut m = 0;\n    let mut n = 0;\n    let mut p = 0;\n    let mut q = 0;\n\
    \    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut v = 0;\n\
    \    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n\
    \    let mut a = 0;\n    let mut e = 0;\n    let mut i = 0;\n    let mut o = 0;\n\
    \    let mut u = 0;\n    let mut b = 0;\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwp3uuz1c.rs:90:11\n   |\n\
    90 |     let mu\n   |           ^ help: add `;` here\n91 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwp3uuz1c.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['b', 'c', 'd', 'f', 'g', 'h',\
    \ 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    for c in\
    \ message.chars() {\n        if c == ' ' {\n            result.push_str(\" \"\
    );\n        } else {\n            if vowels.contains(&c) {\n                result.push_str(&vowels[vowel_counter]);\n\
    \                vowel_counter += 1;\n            } else {\n                result.push_str(&letters[letter_counter]);\n\
    \                letter_counter += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp50krhjho.rs:22:33\n   |\n\
    22 |                 result.push_str(&vowels[vowel_counter]);\n   |          \
    \                       ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp50krhjho.rs:25:33\n   |\n25 |\
    \                 result.push_str(&letters[letter_counter]);\n   |           \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_idx = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_pairs = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"];\n    let mut letter_pairs_idx = vec![0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\
    \ 26];\n    let mut letter_pairs_idx_2 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\
    \ 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];\n    let mut\
    \ letter_pairs_idx_3 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\
    \ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];\n    let mut letter_pairs_idx_4\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26];\n    let mut letter_pairs_idx_5 = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\
    \ 24, 25, 26];\n    let mut letter_pairs_idx_6 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];\n\
    \    let mut letter_pairs_idx_7 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\
    \ 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];\n    let mut letter_pairs_idx_8\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26];\n    let mut letter_pairs_idx_9 = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\
    \ 24, 25, 26];\n    let mut letter_pairs_idx_10 = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];\n\
    \    let mut letter_pairs_idx_11 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];\n    let mut letter_pairs_idx_12\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26];\n    let mut letter_pairs_idx_13 = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\
    \ 24, 25, 26];\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjfhvys77.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut index = 0;\n    let mut vowel_index = 0;\n    let mut vowel_counter\
    \ = 0;\n    for c in message.chars() {\n        if vowels.contains(&c) {\n   \
    \         vowel_counter++;\n        }\n        if vowel_counter == 2 {\n     \
    \       vowel_index += 2;\n            vowel_counter = 0;\n        }\n       \
    \ if vowel_index < 0 {\n            vowel_index += vowels.len();\n        }\n\
    \        if vowel_index >= vowels.len() {\n            vowel_index -= vowels.len();\n\
    \        }\n        if vowel_index < 0 {\n            vowel_index += vowels.len();\n\
    \        }\n        if vowel_index >= vowels.len() {\n            vowel_index\
    \ -= vowels.len();\n        }\n        if vowel_index < 0 {\n            vowel_index\
    \ += vowels.len();\n        }\n        if vowel_index >= vowels.len() {\n    \
    \        vowel_index -= vowels.len();\n        }\n        if vowel_index < 0 {\n\
    \            vowel_index += vowels.len();\n        }\n        if vowel_index >=\
    \ vowels.len() {\n            vowel_index -= vowels.len();\n        }\n      \
    \  if vowel_index < 0 {\n            vowel_index += vowels.len();\n        }\n\
    \        if vowel_index >= vowels.len() {\n            vowel_index -= vowels.len();\n\
    \        }\n        if vowel_index < 0 {\n            vowel_index += vowels.len();\n\
    \        }\n        if vowel_index >= vowels.len() {\n            vowel_index\
    \ -= vowels.len();\n        }\n        if vowel_index < 0 {\n            vowel_index\
    \ += vowels.len();\n        }\n        if vowel_index >= vowels.len() {\n    \
    \        vowel_index -= vowels.len();\n        }\n        if vowel_index < 0 {\n\
    \            vowel_index += vowels.len();\n        }\n        if vowel_index >=\
    \ vowels.len() {\n            vowel_index -= vowels.len();\n        }\n      \
    \  if vowel_index < 0 {\n            vowel_index += vowels.len();\n        }\n\
    \        if vowel_index >= vowels.len() {\n            vowel_index -= vowels.len();\n\
    \        }\n        if vowel_index < 0 {\n            vowel_index += vowels.len();\n\
    \        }\n        if vowel_index >= vowels.len() {\n            vowel_index\
    \ -= vowels.len();\n        }\n        if vowel_index < 0 {\n            vowel_index\
    \ += vowels.len();\n        }\n        if vowel_index >= vowels.len() {\n    \
    \        vowel_index -= vowels.len();\n        }\n        if vowel_index < 0 {\n\
    \            vowel_index += vowels.len();\n        }\n        if vowel_index >=\
    \ \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp77kx4k6m.rs:104:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n17  |     for c in message.chars()\
    \ {\n    |                              - this delimiter might not be properly\
    \ closed...\n...\n95  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n104 | }\n    |   ^\n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmp77kx4k6m.rs:19:26\n   |\n19 |             vowel_counter++;\n\
    \   |                          ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n19 |             { let tmp = vowel_counter; vowel_counter\
    \ += 1; tmp };\n   |             +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    19 -             vowel_counter++;\n19 +             vowel_counter += 1;\n   |\
    \ \n\nerror: expected expression, found `}`\n  --> /tmp/tmp77kx4k6m.rs:95:1\n\
    \   |\n95 | }\n   | ^ expected expression\n\nerror[E0277]: expected a `Fn<(char,)>`\
    \ closure, found `char`\n    --> /tmp/tmp77kx4k6m.rs:18:28\n     |\n18   |   \
    \      if vowels.contains(&c) {\n     |                   -------- ^^ expected\
    \ an `Fn<(char,)>` closure, found `char`\n     |                   |\n     | \
    \                  required by a bound introduced by this call\n     |\n     =\
    \ help: the trait `Fn<(char,)>` is not implemented for `char`\n     = note: required\
    \ because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n \
    \    = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n18   |         if vowels.contains(*&c)\
    \ {\n     |                            +\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp77kx4k6m.rs:11:31\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |    ------                     ^^^^^^ expected struct `String`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 5 previous errors\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants = vec!['b',\
    \ 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E',\
    \ 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\
    \ 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_counter = 0;\n    let mut consonants_counter\
    \ = 0;\n    let mut letters_counter = 0;\n    for letter in message.chars() {\n\
    \        if letter == ' ' {\n            result.push_str(\" \");\n        } else\
    \ {\n            if letter == vowels[vowels_counter] {\n                vowels_counter++;\n\
    \                if vowels_counter == 2 {\n                    result.push_str(vowels[vowels_counter\
    \ - 2]);\n                }\n            } else {\n                vowels_counter\
    \ = 0;\n            }\n            if letter == consonants[consonants_counter]\
    \ {\n                consonants_counter++;\n                if consonants_counter\
    \ == 2 {\n                    result.push_str(consonants[consonants_counter -\
    \ 2]);\n                }\n            } else {\n                consonants_counter\
    \ = 0;\n            }\n            if letter == letters[letters_counter] {\n \
    \               letters_counter++;\n                if letters_counter == 2 {\n\
    \                    result.push_str(letters[letters_counter - 2]);\n        \
    \        }\n            } else {\n                letters_counter = 0;\n     \
    \       }\n            result.push_str(letter);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpm1wkhnwx.rs:24:31\n\
    \   |\n24 |                 vowels_counter++;\n   |                          \
    \     ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    24 |                 { let tmp = vowels_counter; vowels_counter += 1; tmp };\n\
    \   |                 +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    24 -                 vowels_counter++;\n24 +                 vowels_counter +=\
    \ 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpm1wkhnwx.rs:32:35\n\
    \   |\n32 |                 consonants_counter++;\n   |                      \
    \             ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n32 |                 { let tmp = consonants_counter; consonants_counter\
    \ += 1; tmp };\n   |                 +++++++++++                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    32 -                 consonants_counter++;\n32 +                 consonants_counter\
    \ += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpm1wkhnwx.rs:40:32\n\
    \   |\n40 |                 letters_counter++;\n   |                         \
    \       ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    40 |                 { let tmp = letters_counter; letters_counter += 1; tmp };\n\
    \   |                 +++++++++++                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    40 -                 letters_counter++;\n40 +                 letters_counter\
    \ += 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm1wkhnwx.rs:47:29\n\
    \   |\n47 |             result.push_str(letter);\n   |                       \
    \      ^^^^^^ expected `&str`, found `char`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letter_pairs = vec![\"b\", \"c\"\
    , \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut letter_pairs2\
    \ = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    let mut letter_pairs = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\",\
    \ \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"];\n    let mut letter_pairs2 = vec![\"b\", \"c\"\
    , \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut letter_pairs\
    \ = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    let mut letter_pairs2 = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"];\n    let mut letter_pairs = vec![\"b\", \"c\",\
    \ \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut letter_pairs2\
    \ = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    let mut letter_pairs = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\",\
    \ \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"];\n    let mut letter_pairs2 = vec![\"b\", \"c\"\
    , \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut letter_pairs\
    \ = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmphx22lf7c.rs:26:1\n  \
    \ |\n26 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for c in message.chars() {\n        if vowels.contains(&c) {\n   \
    \         vowel_counter += 1;\n        }\n        if letters.contains(&c) {\n\
    \            letter_counter += 1;\n        }\n    }\n    for c in message.chars()\
    \ {\n        if vowels.contains(&c) {\n            if vowel_counter > 2 {\n  \
    \              result.push((letters[letter_counter - 2] + letters[letter_counter\
    \ - 1]).to_string());\n                vowel_counter -= 2;\n                letter_counter\
    \ -= 2;\n            } else {\n                result.push((letters[letter_counter\
    \ - 1] + letters[letter_counter]).to_string());\n                vowel_counter\
    \ -= 1;\n                letter_counter -= 1;\n            }\n        } else {\n\
    \            result.push((letters[letter_counter] + letters[letter_counter + 1]).to_string());\n\
    \            vowel_counter += 1;\n            letter_counter += 1;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpw0kfpnvb.rs:28:58\n\
    \   |\n28 |                 result.push((letters[letter_counter - 2] + letters[letter_counter\
    \ - 1]).to_string());\n   |                              ---------------------------\
    \ ^ --------------------------- char\n   |                              |\n  \
    \ |                              char\n\nerror[E0369]: cannot add `char` to `char`\n\
    \  --> /tmp/tmpw0kfpnvb.rs:32:58\n   |\n32 |                 result.push((letters[letter_counter\
    \ - 1] + letters[letter_counter]).to_string());\n   |                        \
    \      --------------------------- ^ ----------------------- char\n   |      \
    \                        |\n   |                              char\n\nerror[E0369]:\
    \ cannot add `char` to `char`\n  --> /tmp/tmpw0kfpnvb.rs:37:50\n   |\n37 |   \
    \          result.push((letters[letter_counter] + letters[letter_counter + 1]).to_string());\n\
    \   |                          ----------------------- ^ ---------------------------\
    \ char\n   |                          |\n   |                          char\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    for c in message.chars() {\n        if c.is_uppercase() {\n            result.push(c);\n\
    \        } else {\n            if let Some(vowel) = vowels.iter().position(|&x|\
    \ x == c) {\n                result.push((&vowels[vowel] + 1).to_string());\n\
    \            } else {\n                result.push(c);\n            }\n      \
    \  }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpz_hyep2s.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    while i < message.len() {\n  \
    \      let mut j = 0;\n        while j < message.len() {\n            if message[j]\
    \ == vowels[i] {\n                encoded.push((letters[i as usize] + letters[i\
    \ as usize + 1]).to_string());\n                i += 2;\n                break;\n\
    \            }\n            encoded.push(message[j]);\n            j += 1\n  \
    \      }\n        i += 1;\n    }\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppeop5urp.rs:19:16\n\
    \   |\n19 |             if message[j] == vowels[i] {\n   |                ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot add `char` to `char`\n  --> /tmp/tmppeop5urp.rs:20:51\n\
    \   |\n20 |                 encoded.push((letters[i as usize] + letters[i as usize\
    \ + 1]).to_string());\n   |                               -------------------\
    \ ^ ----------------------- char\n   |                               |\n   | \
    \                              char\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmppeop5urp.rs:24:26\n   |\n24 |         \
    \    encoded.push(message[j]);\n   |                          ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::from(\"\
    aeiou\");\n    let mut letters = String::from(\"abcdefghijklmnopqrstuvwxyz\");\n\
    \    for c in message.chars() {\n        if let Some(vowel) = vowels.chars().position(|x|\
    \ x == c) {\n            encoded.push_str(&letters[vowels.chars().position(|x|\
    \ x == c).unwrap() + 1]);\n        } else {\n            encoded.push_str(&letters[letters.chars().position(|x|\
    \ x == c).unwrap() + 1]);\n        }\n    }\n    encoded\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpx8jj3xus.rs:17:31\n\
    \   |\n17 |             encoded.push_str(&letters[vowels.chars().position(|x|\
    \ x == c).unwrap() + 1]);\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpx8jj3xus.rs:19:31\n   |\n19 |             encoded.push_str(&letters[letters.chars().position(|x|\
    \ x == c).unwrap() + 1]);\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = -1;\n    let mut letter_positions = HashMap::new();\n\
    \    let mut letter_positions_index = -1;\n    let mut letter_positions_length\
    \ = message.chars().count();\n    let mut letter_positions_index = 0;\n    let\
    \ mut letter_positions_index2 = 0;\n    let mut letter_positions_index3 = 0;\n\
    \    let mut letter_positions_index4 = 0;\n    let mut letter_positions_index5\
    \ = 0;\n    let mut letter_positions_index6 = 0;\n    let mut letter_positions_index7\
    \ = 0;\n    let mut letter_positions_index8 = 0;\n    let mut letter_positions_index9\
    \ = 0;\n    let mut letter_positions_index10 = 0;\n    let mut letter_positions_index11\
    \ = 0;\n    let mut letter_positions_index12 = 0;\n    let mut letter_positions_index13\
    \ = 0;\n    let mut letter_positions_index14 = 0;\n    let mut letter_positions_index15\
    \ = 0;\n    let mut letter_positions_index16 = 0;\n    let mut letter_positions_index17\
    \ = 0;\n    let mut letter_positions_index18 = 0;\n    let mut letter_positions_index19\
    \ = 0;\n    let mut letter_positions_index20 = 0;\n    let mut letter_positions_index21\
    \ = 0;\n    let mut letter_positions_index22 = 0;\n    let mut letter_positions_index23\
    \ = 0;\n    let mut letter_positions_index24 = 0;\n    let mut letter_positions_index25\
    \ = 0;\n    let mut letter_positions_index26 = 0;\n    let mut letter_positions_index27\
    \ = 0;\n    let mut letter_positions_index28 = 0;\n    let mut letter_positions_index29\
    \ = 0;\n    let mut letter_positions_index30 = 0;\n    let mut letter_positions_index31\
    \ = 0;\n    let mut letter_positions_index32 = 0;\n    let mut letter_positions_index33\
    \ = 0;\n    let mut letter_positions_index34 = 0;\n    let mut letter_positions_index35\
    \ = 0;\n    let mut letter_positions_index36 = 0;\n    let mut letter_positions_index37\
    \ = 0;\n    let mut letter_positions_index38 = 0;\n    let mut letter_positions_index39\
    \ = 0;\n    let mut letter_positions_index40 = 0;\n    let mut letter_positions_index41\
    \ = 0;\n    let mut letter_positions_index42 = 0;\n    let mut letter_positions_index43\
    \ = 0;\n    let mut letter_positions_index44 = 0;\n    let mut letter_positions_index45\
    \ = 0;\n    let mut letter_positions_index\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjnflncin.rs:63:35\n   |\n\
    63 |     let mut letter_positions_index\n   |                                \
    \   ^ help: add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpjnflncin.rs:15:32\n\
    \   |\n15 |     let mut letter_positions = HashMap::new();\n   |             \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjnflncin.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for c in message.chars() {\n    \
    \    if vowels.contains(&c) {\n            if vowel_counter < 2 {\n          \
    \      result.push(c);\n                vowel_counter += 1;\n            } else\
    \ {\n                result.push(letters[letter_counter]);\n                letter_counter\
    \ += 1;\n            }\n        } else {\n            result.push(c);\n      \
    \      letter_counter += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsqmec2yf.rs:18:28\n   |\n\
    18 |         if vowels.contains(&c) {\n   |                            ^^ expected\
    \ `&str`, found `char`\n   |\n   = note: expected reference `&&str`\n        \
    \      found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsqmec2yf.rs:23:29\n\
    \   |\n23 |                 result.push(letters[letter_counter]);\n   |      \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `&str`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::new();\n\
    \    let mut letters = String::new();\n    let mut index = 0;\n    let mut count\
    \ = 0;\n    \n    for letter in message.chars() {\n        if letter == 'a' ||\
    \ letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n       \
    \     vowels.push(letter);\n        } else {\n            letters.push(letter);\n\
    \        }\n    }\n    \n    for vowel in vowels.chars() {\n        index = vowels.find(vowel);\n\
    \        count += 1;\n        encoded.push_str(&letters[(index - count) % letters.len()]);\n\
    \    }\n    \n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2x7qo4is.rs:27:17\n   |\n\
    15 |     let mut index = 0;\n   |                     - expected due to this value\n\
    ...\n27 |         index = vowels.find(vowel);\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmp2x7qo4is.rs:29:27\n   |\n29 |         encoded.push_str(&letters[(index\
    \ - count) % letters.len()]);\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut letters = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            vowel_counter = vowel_counter + 1;\n        }\n        if letters.contains(&letter)\
    \ {\n            letter_counter = letter_counter + 1;\n        }\n        if vowel_counter\
    \ == 2 && letter_counter == 2 {\n            result.push((letters[letter_counter\
    \ - 1] + letters[letter_counter - 2]).to_string());\n            vowel_counter\
    \ = 0;\n            letter_counter = 0;\n        }\n        result.push(letter);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdx8pqt6e.rs:18:28\n   |\n\
    18 |         if vowels.contains(&letter) {\n   |                            ^^^^^^^\
    \ expected `&str`, found `char`\n   |\n   = note: expected reference `&&str`\n\
    \              found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdx8pqt6e.rs:21:29\n   |\n21 |         if letters.contains(&letter) {\n\
    \   |                             ^^^^^^^ expected `&str`, found `char`\n   |\n\
    \   = note: expected reference `&&str`\n              found reference `&char`\n\
    \nerror[E0369]: cannot add `&str` to `&str`\n  --> /tmp/tmpdx8pqt6e.rs:25:54\n\
    \   |\n25 |             result.push((letters[letter_counter - 1] + letters[letter_counter\
    \ - 2]).to_string());\n   |                          ---------------------------\
    \ ^ --------------------------- &str\n   |                          |        \
    \                   |\n   |                          |                       \
    \    `+` cannot be used to concatenate two `&str` strings\n   |              \
    \            &str\n   |\n   = note: string concatenation requires an owned `String`\
    \ on the left\nhelp: create an owned `String` from a string reference\n   |\n\
    25 |             result.push((letters[letter_counter - 1].to_owned() + letters[letter_counter\
    \ - 2]).to_string());\n   |                                                  \
    \   +++++++++++\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0369.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_positions\
    \ = vec![];\n    let mut letter_positions = vec![];\n    let mut current_letter\
    \ = String::new();\n    let mut current_vowel = String::new();\n    let mut current_letter_position\
    \ = 0;\n    let mut current_vowel_position = 0;\n    let mut current_letter_index\
    \ = 0;\n    let mut current_vowel_index = 0;\n    let mut current_letter_length\
    \ = 0;\n    let mut current_vowel_length = 0;\n    let mut current_letter_letter_position\
    \ = 0;\n    let mut current_vowel_letter_position = 0;\n    let mut current_letter_vowel_position\
    \ = 0;\n    let mut current_vowel_vowel_position = 0;\n    let mut current_letter_letter_length\
    \ = 0;\n    let mut current_vowel_letter_length = 0;\n    let mut current_letter_vowel_length\
    \ = 0;\n    let mut current_vowel_vowel_length = 0;\n    let mut current_letter_letter_letter_position\
    \ = 0;\n    let mut current_vowel_letter_letter_position = 0;\n    let mut current_letter_vowel_letter_position\
    \ = 0;\n    let mut current_vowel_vowel_letter_position = 0;\n    let mut current_letter_letter_vowel_position\
    \ = 0;\n    let mut current_vowel_letter_vowel_position = 0;\n    let mut current_vowel_vowel_vowel_position\
    \ = 0;\n    let mut current_letter_letter_letter_vowel_position = 0;\n    let\
    \ mut current_vowel_letter_letter_vowel_position = 0;\n    let mut current_letter_vowel_vowel_vowel_position\
    \ = 0;\n    let mut current_vowel_vowel_letter_vowel_position = 0;\n    let mut\
    \ current_letter_letter_vowel_vowel_position = 0;\n    let mut current_vowel_vowel_vowel_vowel_position\
    \ = 0;\n    let mut current_letter_letter_letter_vowel_vowel_position = 0;\n \
    \   let mut current_vowel_letter_letter_vowel_vowel_position = 0;\n    let mut\
    \ current_letter_vowel_vowel_vowel_vowel_position = 0;\n    let mut current_vowel_vowel_letter_letter_vowel_position\
    \ = 0;\n    let mut current_vowel_vowel_vowel_letter_letter_position = 0;\n  \
    \  let mut current_vowel_vowel_vowel_vowel_letter_position = 0;\n    let mut current_letter_letter_letter_vowel_vowel_vowel_position\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp3_c7jbol.rs:54:1\n  \
    \ |\n54 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut vowels_counter2 = 0;\n    let mut\
    \ vowels_counter3 = 0;\n    let mut vowels_counter4 = 0;\n    let mut vowels_counter5\
    \ = 0;\n    let mut vowels_counter6 = 0;\n    let mut vowels_counter7 = 0;\n \
    \   let mut vowels_counter8 = 0;\n    let mut vowels_counter9 = 0;\n    let mut\
    \ vowels_counter10 = 0;\n    let mut vowels_counter11 = 0;\n    let mut vowels_counter12\
    \ = 0;\n    let mut vowels_counter13 = 0;\n    let mut vowels_counter14 = 0;\n\
    \    let mut vowels_counter15 = 0;\n    let mut vowels_counter16 = 0;\n    let\
    \ mut vowels_counter17 = 0;\n    let mut vowels_counter18 = 0;\n    let mut vowels_counter19\
    \ = 0;\n    let mut vowels_counter20 = 0;\n    let mut vowels_counter21 = 0;\n\
    \    let mut vowels_counter22 = 0;\n    let mut vowels_counter23 = 0;\n    let\
    \ mut vowels_counter24 = 0;\n    let mut vowels_counter25 = 0;\n    let mut vowels_counter26\
    \ = 0;\n    let mut vowels_counter27 = 0;\n    let mut vowels_counter28 = 0;\n\
    \    let mut vowels_counter29 = 0;\n    let mut vowels_counter30 = 0;\n    let\
    \ mut vowels_counter31 = 0;\n    let mut vowels_counter32 = 0;\n    let mut vowels_counter33\
    \ = 0;\n    let mut vowels_counter34 = 0;\n    let mut vowels_counter35 = 0;\n\
    \    let mut vowels_counter36 = 0;\n    let mut vowels_counter37 = 0;\n    let\
    \ mut vowels_counter38 = 0;\n    let mut vowels_counter39 = 0;\n    let mut vowels_counter40\
    \ = 0;\n    let mut vowels_counter41 = 0;\n    let mut vowels_counter42 = 0;\n\
    \    let mut vowels_counter43 = 0;\n    let mut vowels_counter44 = 0;\n    let\
    \ mut vowels_counter45 = 0;\n    let mut vowels_counter46 = 0;\n    let mut vowels_counter47\
    \ = 0;\n    let mut vowels_counter48 = 0;\n    let mut vowels_counter49 = 0;\n\
    \    let mut vowels_counter50 = 0;\n    let mut vowels_counter51 = 0;\n    let\
    \ mut vowels_counter52 = 0;\n    let mut vowels_counter53 = 0;\n    let mut vowels_counter54\
    \ = 0;\n    let mut vowels_counter55 = 0;\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkumsi8c2.rs:69:11\n   |\n\
    69 |     let mu\n   |           ^ help: add `;` here\n70 | }\n   | - unexpected\
    \ token\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmpkumsi8c2.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkumsi8c2.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letters = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"\
    g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut letters_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26];\n    let mut index = 0;\n    let mut current_letter\
    \ = String::new();\n    let mut current_vowel = String::new();\n    let mut current_letter_index\
    \ = String::new();\n    let mut current_vowel_index = String::new();\n    let\
    \ mut current_letter_index2 = String::new();\n    let mut current_vowel_index2\
    \ = String::new();\n    let mut current_letter_index3 = String::new();\n    let\
    \ mut current_vowel_index3 = String::new();\n    let mut current_letter_index4\
    \ = String::new();\n    let mut current_vowel_index4 = String::new();\n    let\
    \ mut current_letter_index5 = String::new();\n    let mut current_vowel_index5\
    \ = String::new();\n    let mut current_letter_index6 = String::new();\n    let\
    \ mut current_vowel_index6 = String::new();\n    let mut current_letter_index7\
    \ = String::new();\n    let mut current_vowel_index7 = String::new();\n    let\
    \ mut current_letter_index8 = String::new();\n    let mut current_vowel_index8\
    \ = String::new();\n    let mut current_letter_index9 = String::new();\n    let\
    \ mut current_vowel_index9 = String::new();\n    let mut current_letter_index10\
    \ = String::new();\n    let mut current_vowel_index10 = String::new();\n    let\
    \ mut current_letter_index11 = String::new();\n    let mut current_vowel_index11\
    \ = String::new();\n    let mut current_letter_index12 = String::new();\n    let\
    \ mut current_vowel_index12 = String::new();\n    let mut current_letter_index13\
    \ = String::new();\n    let mut current_vowel_index13 = String::new();\n    let\
    \ mut current_letter_index14 = String::new();\n    let mut current_vowel_index14\
    \ = String::new();\n    let mut current_letter_index15 = String::new();\n    let\
    \ mut current_vowel_index15 = String::\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpp0zmle8u.rs:50:1\n\
    \   |\n50 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut letters = \"bcdfghjklmnpqrstvwxyz\".to_string();\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if let Some(vowel) = vowels.chars().position(|c|\
    \ c == letter) {\n            vowel_counter += 1;\n            letter = vowels[vowel_counter];\n\
    \        }\n        if let Some(letter) = letters.chars().position(|c| c == letter)\
    \ {\n            letter_counter += 1;\n            letter = letters[letter_counter];\n\
    \        }\n        result.push(*letter);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpdaz6z37y.rs:20:22\n   |\n20 |             letter = vowels[vowel_counter];\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpdaz6z37y.rs:24:22\n   |\n24 |             letter = letters[letter_counter];\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpdaz6z37y.rs:26:21\n\
    \   |\n26 |         result.push(*letter);\n   |                     ^^^^^^^\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0614.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let\
    \ mut last = 0;\n    let mut index2 = 0;\n    let mut last2 = 0;\n    for c in\
    \ message.chars() {\n        if index == 0 {\n            encoded.push(c);\n \
    \           index = last;\n            last = index;\n        } else {\n     \
    \       encoded.push(c);\n            index = last;\n            last = index;\n\
    \        }\n    }\n    for c in message.chars() {\n        if index2 == 0 {\n\
    \            encoded.push(c);\n            index2 = last2;\n            last2\
    \ = index2;\n        } else {\n            encoded.push(c);\n            index2\
    \ = last2;\n            last2 = index2;\n        }\n    }\n    for c in vowels.iter().rev()\
    \ {\n        if index == 0 {\n            encoded.push(c);\n            index\
    \ = last;\n            last = index;\n        } else {\n            encoded.push(c);\n\
    \            index = last;\n            last = index;\n        }\n    }\n    for\
    \ c in vowels.iter().rev() {\n        if index2 == 0 {\n            encoded.push(c);\n\
    \            index2 = last2;\n            last2 = index2;\n        } else {\n\
    \            encoded.push(c);\n            index2 = last2;\n            last2\
    \ = index2;\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8cu05fu_.rs:42:26\n   |\n\
    42 |             encoded.push(c);\n   |                          ^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n42 |   \
    \          encoded.push(*c);\n   |                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8cu05fu_.rs:46:26\n   |\n46 |             encoded.push(c);\n\
    \   |                          ^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n46 |             encoded.push(*c);\n   |   \
    \                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8cu05fu_.rs:53:26\n\
    \   |\n53 |             encoded.push(c);\n   |                          ^ expected\
    \ `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    53 |             encoded.push(*c);\n   |                          +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8cu05fu_.rs:57:26\n   |\n57 |             encoded.push(c);\n\
    \   |                          ^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n57 |             encoded.push(*c);\n   |   \
    \                       +\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.binary_search(&letter) {\n          \
    \  result.push_str(&letters[vowel + index]);\n        } else {\n            result.push_str(&letters[letter\
    \ - 'A']);\n        }\n        index += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3lf9r_yl.rs:17:16\n   |\n\
    17 |         if let Some(vowel) = vowels.binary_search(&letter) {\n   |      \
    \          ^^^^^^^^^^^   ----------------------------- this expression has type\
    \ `Result<usize, usize>`\n   |                |\n   |                expected\
    \ enum `Result`, found enum `Option`\n   |\n   = note: expected enum `Result<usize,\
    \ usize>`\n              found enum `Option<_>`\n\nerror[E0369]: cannot subtract\
    \ `char` from `char`\n  --> /tmp/tmp3lf9r_yl.rs:20:45\n   |\n20 |            \
    \ result.push_str(&letters[letter - 'A']);\n   |                             \
    \         ------ ^ --- char\n   |                                      |\n   |\
    \                                      char\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    vowels.insert(String::from('a'));\n    vowels.insert(String::from('e'));\n\
    \    vowels.insert(String::from('i'));\n    vowels.insert(String::from('o'));\n\
    \    vowels.insert(String::from('u'));\n    vowels.insert(String::from('y'));\n\
    \    vowels.insert(String::from('A'));\n    vowels.insert(String::from('E'));\n\
    \    vowels.insert(String::from('I'));\n    vowels.insert(String::from('O'));\n\
    \    vowels.insert(String::from('U'));\n    vowels.insert(String::from('Y'));\n\
    \    vowels.insert(String::from('0'));\n    vowels.insert(String::from('1'));\n\
    \    vowels.insert(String::from('2'));\n    vowels.insert(String::from('3'));\n\
    \    vowels.insert(String::from('4'));\n    vowels.insert(String::from('5'));\n\
    \    vowels.insert(String::from('6'));\n    vowels.insert(String::from('7'));\n\
    \    vowels.insert(String::from('8'));\n    vowels.insert(String::from('9'));\n\
    \    vowels.insert(String::from('!'));\n    vowels.insert(String::from('?'));\n\
    \    vowels.insert(String::from('.'));\n    vowels.insert(String::from(','));\n\
    \    vowels.insert(String::from(';'));\n    vowels.insert(String::from(':'));\n\
    \    vowels.insert(String::from(';'));\n    vowels.insert(String::from('('));\n\
    \    vowels.insert(String::from(')'));\n    vowels.insert(String::from(','));\n\
    \    vowels.insert(String::from(';'));\n    vowels.insert(String::from(';'));\n\
    \    vowels.insert(String::from(';'));\n    vowels.insert(String::from(';'));\n\
    \    vowels.insert(String::from(';'));\n    vowels.insert(String::from(';'));\n\
    \    vowels.insert(String::from(';'));\n    vowels.insert(String::from(';'));\n\
    \    vowels.insert(String::from(';'));\n    vowels.insert(String::from(';'));\n\
    \    vowels.insert(String::from(';'));\n    vowels.insert(String::from(';'));\n\
    \    vowels.insert(String::from(';'));\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp32hjgleu.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp32hjgleu.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut vowels_index = String::new();\n    let mut letter_count\
    \ = String::new();\n    let mut letter_count_index = String::new();\n    let mut\
    \ letter_count_index2 = String::new();\n    let mut letter_count_index3 = String::new();\n\
    \    let mut letter_count_index4 = String::new();\n    let mut letter_count_index5\
    \ = String::new();\n    let mut letter_count_index6 = String::new();\n    let\
    \ mut letter_count_index7 = String::new();\n    let mut letter_count_index8 =\
    \ String::new();\n    let mut letter_count_index9 = String::new();\n    let mut\
    \ letter_count_index10 = String::new();\n    let mut letter_count_index11 = String::new();\n\
    \    let mut letter_count_index12 = String::new();\n    let mut letter_count_index13\
    \ = String::new();\n    let mut letter_count_index14 = String::new();\n    let\
    \ mut letter_count_index15 = String::new();\n    let mut letter_count_index16\
    \ = String::new();\n    let mut letter_count_index17 = String::new();\n    let\
    \ mut letter_count_index18 = String::new();\n    let mut letter_count_index19\
    \ = String::new();\n    let mut letter_count_index20 = String::new();\n    let\
    \ mut letter_count_index21 = String::new();\n    let mut letter_count_index22\
    \ = String::new();\n    let mut letter_count_index23 = String::new();\n    let\
    \ mut letter_count_index24 = String::new();\n    let mut letter_count_index25\
    \ = String::new();\n    let mut letter_count_index26 = String::new();\n    let\
    \ mut letter_count_index27 = String::new();\n    let mut letter_count_index28\
    \ = String::new();\n    let mut letter_count_index29 = String::new();\n    let\
    \ mut letter_count_index30 = String::new();\n    let mut letter_count_index31\
    \ = String::new();\n    let mut letter_count_index32 = String::new();\n    let\
    \ mut letter_count_index33 = String::new();\n    let mut letter_count_index34\
    \ = String::new();\n    let mut letter_count_index35 = String::new();\n    let\
    \ mut letter_count_index36 = String::new();\n    let mut letter_count_index37\
    \ = String::new();\n\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwgoetxzl.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letter_pairs = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair_count = HashSet::new();\n    let mut letter_pair_counts\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted = HashSet::new();\n\
    \    let mut letter_pair_counts_sorted_reversed = HashSet::new();\n    let mut\
    \ letter_pair_counts_sorted_reversed_sorted = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_sorted_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_sorted_reversed_sorted\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted\
    \ = HashSet::new();\n    let mut letter_pair_counts_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpldz0tokb.rs:34:135\n   |\n\
    34 |     let mut letter_pair_counts_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_reversed_sorted_\n\
    \   |                                                                        \
    \                                                               ^ help: add `;`\
    \ here\n35 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpldz0tokb.rs:13:22\n   |\n13 |  \
    \   let mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpldz0tokb.rs:14:28\n   |\n14 |     let mut letter_pairs = HashSet::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpldz0tokb.rs:15:27\n   |\n15 |     let mut letter_pair = HashSet::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpldz0tokb.rs:16:33\n\
    \   |\n16 |     let mut letter_pair_count = HashSet::new();\n   |            \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpldz0tokb.rs:17:34\n\
    \   |\n17 |     let mut letter_pair_counts = HashSet::new();\n   |           \
    \                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpldz0tokb.rs:18:41\n\
    \   |\n18 |     let mut"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letter_pairs = vec!['b', 'c', 'd', 'f', 'g',\
    \ 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut letter_pairs2 = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l',\
    \ 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut letter_pair3\
    \ = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r',\
    \ 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut letter_pair4 = vec!['b', 'c',\
    \ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut letter_pair5 = vec!['b', 'c', 'd', 'f', 'g', 'h',\
    \ 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut letter_pair6 = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l',\
    \ 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut letter_pair7\
    \ = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r',\
    \ 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut letter_pair8 = vec!['b', 'c',\
    \ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut letter_pair9 = vec!['b', 'c', 'd', 'f', 'g', 'h',\
    \ 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut letter_pair10 = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l',\
    \ 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut letter_pair11\
    \ = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r',\
    \ 's', 't', 'v', 'w', 'x', 'y', 'z'];\n    let mut letter_pair12 = vec!['b', 'c',\
    \ 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut letter_pair13 = vec!['b', 'c', 'd', 'f', 'g', 'h',\
    \ 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', '\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpoislvsta.rs:26:114\n\
    \   |\n26 |     let mut letter_pair13 = vec!['b', 'c', 'd', 'f', 'g', 'h', 'j',\
    \ 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', '\n   |                       \
    \                                                                            \
    \               ^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    vowels.insert(String::from('a'));\n    vowels.insert(String::from('e'));\n\
    \    vowels.insert(String::from('i'));\n    vowels.insert(String::from('o'));\n\
    \    vowels.insert(String::from('u'));\n    vowels.insert(String::from('y'));\n\
    \    vowels.insert(String::from('A'));\n    vowels.insert(String::from('E'));\n\
    \    vowels.insert(String::from('I'));\n    vowels.insert(String::from('O'));\n\
    \    vowels.insert(String::from('U'));\n    vowels.insert(String::from('Y'));\n\
    \    vowels.insert(String::from('0'));\n    vowels.insert(String::from('1'));\n\
    \    vowels.insert(String::from('2'));\n    vowels.insert(String::from('3'));\n\
    \    vowels.insert(String::from('4'));\n    vowels.insert(String::from('5'));\n\
    \    vowels.insert(String::from('6'));\n    vowels.insert(String::from('7'));\n\
    \    vowels.insert(String::from('8'));\n    vowels.insert(String::from('9'));\n\
    \    vowels.insert(String::from('.'));\n    vowels.insert(String::from(','));\n\
    \    vowels.insert(String::from(';'));\n    vowels.insert(String::from(':'));\n\
    \    vowels.insert(String::from(';'));\n    vowels.insert(String::from('!'));\n\
    \    vowels.insert(String::from('?'));\n    vowels.insert(String::from('('));\n\
    \    vowels.insert(String::from(')'));\n    vowels.insert(String::from('['));\n\
    \    vowels.insert(String::from(']'));\n    vowels.insert(String::from('{'));\n\
    \    vowels.insert(String::from('}'));\n    vowels.insert(String::from(';'));\n\
    \    vowels.insert(String::from(':'));\n    vowels.insert(String::from(';'));\n\
    \    vowels.insert(String::from('!'));\n    vowels.insert(String::from('?'));\n\
    \    vowels.insert(String::from('('));\n    vowels.insert(String::from(')'));\n\
    \    vowels.insert(String::from('['));\n    vowels.insert(String::from(']'));\n\
    \    vowels.insert(String::from('{'));\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpqi7dw0ev.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqi7dw0ev.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut i = 0;\n \
    \   for letter in message {\n        if letter == letters.len() - 1 {\n      \
    \      result.push_str(&vowels[i as usize]);\n            i += 1;\n        } else\
    \ {\n            result.push_str(&letters[i as usize]);\n            i += 1;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpcm67vz8e.rs:16:19\n\
    \   |\n16 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    for\
    \ c in message.chars() {\n        if index == 0 {\n            result.push(c);\n\
    \        } else {\n            if c == vowels[index] {\n                result.push(c);\n\
    \            } else {\n                let index = index - 1;\n              \
    \  result.push(letters[index]);\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"TEST\"`,\n right: `\"tgst\"`', /tmp/tmpg26pet9x.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    for c in message.chars()\
    \ {\n        if let Some(index) = vowels.find(c) {\n            result.push_str(&letters[(index\
    \ + 1) % letters.len()]);\n        } else {\n            result.push_str(&c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpy7pd5a8n.rs:17:30\n\
    \   |\n17 |             result.push_str(&letters[(index + 1) % letters.len()]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy7pd5a8n.rs:19:29\n\
    \   |\n19 |             result.push_str(&c);\n   |                           \
    \  ^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    for letter in message {\n    \
    \    if letter == letters.last() {\n            result.push_str(&vowels[i as usize]);\n\
    \            i += 1;\n        } else {\n            result.push_str(&letters[i\
    \ as usize]);\n            i += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp8k48usyw.rs:16:19\n\
    \   |\n16 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8k48usyw.rs:18:29\n   |\n18 |             result.push_str(&vowels[i\
    \ as usize]);\n   |                             ^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8k48usyw.rs:21:29\n\
    \   |\n21 |             result.push_str(&letters[i as usize]);\n   |         \
    \                    ^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut i = 0;\n\
    \    \n    for c in message.chars() {\n        if vowels.contains(&c) {\n    \
    \        result.push(c);\n            i += 1;\n        } else {\n            result.push(alphabet[alphabet.index(&c)\
    \ + i]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpwf8o9ilx.rs:18:28\n\
    \     |\n18   |         if vowels.contains(&c) {\n     |                   --------\
    \ ^^ expected an `Fn<(char,)>` closure, found `char`\n     |                 \
    \  |\n     |                   required by a bound introduced by this call\n \
    \    |\n     = help: the trait `Fn<(char,)>` is not implemented for `char`\n \
    \    = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n18   |         if vowels.contains(*&c)\
    \ {\n     |                            +\n\nerror[E0599]: no method named `index`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpwf8o9ilx.rs:22:43\n\
    \   |\n22 |             result.push(alphabet[alphabet.index(&c) + i]);\n   | \
    \                                          ^^^^^ method not found in `&str`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashMap::new();\n\
    \    vowels.insert(\"a\".to_string(), 0);\n    vowels.insert(\"e\".to_string(),\
    \ 1);\n    vowels.insert(\"i\".to_string(), 2);\n    vowels.insert(\"o\".to_string(),\
    \ 3);\n    vowels.insert(\"u\".to_string(), 4);\n    vowels.insert(\"y\".to_string(),\
    \ 5);\n    vowels.insert(\"A\".to_string(), 0);\n    vowels.insert(\"E\".to_string(),\
    \ 1);\n    vowels.insert(\"I\".to_string(), 2);\n    vowels.insert(\"O\".to_string(),\
    \ 3);\n    vowels.insert(\"U\".to_string(), 4);\n    vowels.insert(\"Y\".to_string(),\
    \ 5);\n    for letter in message.chars() {\n        if let Some(index) = vowels.get(&letter)\
    \ {\n            result.push_str(&message[index..index + 2]);\n            result.push_str(&vowels.get(&letter).unwrap());\n\
    \        } else {\n            result.push_str(&letter);\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpyxvakrm6.rs:13:22\n   |\n13 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyxvakrm6.rs:31:29\n   |\n31 |             result.push_str(&letter);\n\
    \   |                             ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashMap::new();\n\
    \    let mut vowels_counter = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if let Some(vowel) = vowels.get(&letter) {\n \
    \           vowels_counter += 1;\n            result.push(*vowel);\n        }\
    \ else {\n            vowels.insert(letter, letter_counter);\n            result.push(*letter);\n\
    \            letter_counter += 1;\n        }\n    }\n    if vowels_counter > 2\
    \ {\n        result.push(*vowels.get(&'a' + 1));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp800vqck_.rs:13:22\n   |\n13 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp800vqck_.rs:22:25\n   |\n\
    22 |             result.push(*letter);\n   |                         ^^^^^^^\n\
    \nerror[E0369]: cannot add `{integer}` to `&char`\n  --> /tmp/tmp800vqck_.rs:27:38\n\
    \   |\n27 |         result.push(*vowels.get(&'a' + 1));\n   |                \
    \                 ---- ^ - {integer}\n   |                                 |\n\
    \   |                                 &char\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0369, E0433, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpe3dnb81x.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe3dnb81x.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut index = 0;\n    let mut index2 = 0;\n    let mut\
    \ index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n    let mut index6\
    \ = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9 =\
    \ 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12\
    \ = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15\
    \ = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18\
    \ = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21\
    \ = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24\
    \ = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27\
    \ = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30\
    \ = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33\
    \ = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36\
    \ = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39\
    \ = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42\
    \ = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45\
    \ = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48\
    \ = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51\
    \ = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n    let mu\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphoiicu0e.rs:68:11\n   |\n\
    68 |     let mu\n   |           ^ help: add `;` here\n69 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphoiicu0e.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut index = 0;\n    \n    for letter in message {\n        if letter\
    \ in vowels {\n            result.push_str(&vowels[index % vowels.len()]);\n \
    \           index += 1;\n        } else {\n            result.push_str(&letter);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpjblq_tqa.rs:17:19\n\
    \   |\n17 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpjblq_tqa.rs:16:19\n\
    \   |\n16 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    let mut index2 = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n \
    \   let mut index5 = 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n  \
    \  let mut index8 = 0;\n    let mut index9 = 0;\n    let mut index10 = 0;\n  \
    \  let mut index11 = 0;\n    let mut index12 = 0;\n    let mut index13 = 0;\n\
    \    let mut index14 = 0;\n    let mut index15 = 0;\n    let mut index16 = 0;\n\
    \    let mut index17 = 0;\n    let mut index18 = 0;\n    let mut index19 = 0;\n\
    \    let mut index20 = 0;\n    let mut index21 = 0;\n    let mut index22 = 0;\n\
    \    let mut index23 = 0;\n    let mut index24 = 0;\n    let mut index25 = 0;\n\
    \    let mut index26 = 0;\n    let mut index27 = 0;\n    let mut index28 = 0;\n\
    \    let mut index29 = 0;\n    let mut index30 = 0;\n    let mut index31 = 0;\n\
    \    let mut index32 = 0;\n    let mut index33 = 0;\n    let mut index34 = 0;\n\
    \    let mut index35 = 0;\n    let mut index36 = 0;\n    let mut index37 = 0;\n\
    \    let mut index38 = 0;\n    let mut index39 = 0;\n    let mut index40 = 0;\n\
    \    let mut index41 = 0;\n    let mut index42 = 0;\n    let mut index43 = 0;\n\
    \    let mut index44 = 0;\n    let mut index45 = 0;\n    let mut index46 = 0;\n\
    \    let mut index47 = 0;\n    let mut index48 = 0;\n    let mut index49 = 0;\n\
    \    let mut index50 = 0;\n    let mut index51 = 0;\n    let mut index52 = 0;\n\
    \    let mut index53 = 0;\n    let mut index54 = 0;\n    let mut index55 = 0;\n\
    \    let mut index56 = 0;\n    let mut index57 = 0;\n    let mut index58 = 0;\n\
    \    let mut index59 = 0;\n    let mut index60 = 0;\n    let mut index61 = 0;\n\
    \    let mut index62 = 0;\n    let mut index63 = 0;\n    let mut index64 = 0;\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7tvoi91z.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letter_map = HashMap::new();\n\
    \    let mut i = 0;\n    for letter in message.chars() {\n        if let Some(vowel)\
    \ = vowels.binary_search(&letter) {\n            let mut new_letter = letter;\n\
    \            let mut new_vowel = vowels[vowel];\n            for _ in 0..2 {\n\
    \                new_letter = letter_map.entry(new_vowel).or_insert(new_letter);\n\
    \                new_vowel = vowels[vowels.binary_search(&new_letter)];\n    \
    \        }\n            result.push_str(&new_letter);\n        } else {\n    \
    \        result.push_str(&letter);\n        }\n        i += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpk29fv2p3.rs:14:26\n   |\n14 |     let mut letter_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk29fv2p3.rs:17:51\n   |\n17 |         if let\
    \ Some(vowel) = vowels.binary_search(&letter) {\n   |                        \
    \                           ^^^^^^^ expected `&str`, found `char`\n   |\n   =\
    \ note: expected reference `&&str`\n              found reference `&char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpk29fv2p3.rs:17:16\n   |\n17 |  \
    \       if let Some(vowel) = vowels.binary_search(&letter) {\n   |           \
    \     ^^^^^^^^^^^   ----------------------------- this expression has type `Result<usize,\
    \ usize>`\n   |                |\n   |                expected enum `Result`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Result<usize, usize>`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpk29fv2p3.rs:22:57\n   |\n22 |                 new_vowel = vowels[vowels.binary_search(&new_letter)];\n\
    \   |                                                         ^^^^^^^^^^^ expected\
    \ `&str`, found `char`\n   |\n   = note: expected reference `&&str`\n        \
    \      found reference `&char`\n\nerror[E0277]: the type `[&str]` cannot be indexed\
    \ by `Result<usize, usize>`\n  --> /tmp/tmpk29fv2p3.rs:22:29\n   |\n22 |     \
    \            new_vowel = vowels[vowels.binary_search(&new_letter)];\n   |    \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[&str]>`\
    \ is not implemented for `Result<usize, usize>`\n   = note: required because of\
    \ the requirements on the impl of `Index<Result<usize, usize>>` for `Vec<&str>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpk29fv2p3.rs:24:29\n   |\n24 |\
    \             result.push_str(&new_letter);\n   |                            \
    \ ^^^^^^^^^^^ expec"
  stdout: ''
  timestamp: 1660009143
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99];\n    let mut letter_count = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\
    \ 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,\
    \ 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,\
    \ 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut letter_count_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut letter_count_index2 = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\
    \ 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp97b5af87.rs:18:1\n   |\n18 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp97b5af87.rs:17:39\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n17 |     let mut letter_count_index2 = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\
    \ 26, ...\n   |                                       ^ unclosed delimiter\n18\
    \ | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut index = 0;\n    let mut current = 0;\n    let mut next = String::new();\n\
    \    let mut next = String::new();\n    let mut next = String::new();\n    let\
    \ mut next = String::new();\n    let mut next = String::new();\n    let mut next\
    \ = String::new();\n    let mut next = String::new();\n    let mut next = String::new();\n\
    \    let mut next = String::new();\n    let mut next = String::new();\n    let\
    \ mut next = String::new();\n    let mut next = String::new();\n    let mut next\
    \ = String::new();\n    let mut next = String::new();\n    let mut next = String::new();\n\
    \    let mut next = String::new();\n    let mut next = String::new();\n    let\
    \ mut next = String::new();\n    let mut next = String::new();\n    let mut next\
    \ = String::new();\n    let mut next = String::new();\n    let mut next = String::new();\n\
    \    let mut next = String::new();\n    let mut next = String::new();\n    let\
    \ mut next = String::new();\n    let mut next = String::new();\n    let mut next\
    \ = String::new();\n    let mut next = String::new();\n    let mut next = String::new();\n\
    \    let mut next = String::new();\n    let mut next = String::new();\n    let\
    \ mut next = String::new();\n    let mut next = String::new();\n    let mut next\
    \ = String::new();\n    let mut next = String::new();\n    let mut next = String::new();\n\
    \    let mut next = String::new();\n    let mut next = String::new();\n    let\
    \ mut next = String::new();\n    let mut next = String::new();\n    let mut next\
    \ = String::new();\n    let mut next = String::new();\n    let mut next = String::new();\n\
    \    let mut next = String::new();\n    let mut next = String::new();\n    let\
    \ mut next = String::new();\n    let mut next = String::new();\n    let mut next\
    \ = String::new();\n    let mut next = String::new();\n    let mut next = String::new();\n\
    \    let mut next = String::new();\n    let mut next = String::new();\n    let\
    \ mut next = String::new();\n    let mut next = \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpdlqi9z1s.rs:70:1\n\
    \   |\n70 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_encoded = HashSet::new();\n    let mut vowels_encoded1 = HashSet::new();\n\
    \    let mut vowels_encoded2 = HashSet::new();\n    let mut vowels_encoded3 =\
    \ HashSet::new();\n    let mut vowels_encoded4 = HashSet::new();\n    let mut\
    \ vowels_encoded5 = HashSet::new();\n    let mut vowels_encoded6 = HashSet::new();\n\
    \    let mut vowels_encoded7 = HashSet::new();\n    let mut vowels_encoded8 =\
    \ HashSet::new();\n    let mut vowels_encoded9 = HashSet::new();\n    let mut\
    \ vowels_encoded10 = HashSet::new();\n    let mut vowels_encoded11 = HashSet::new();\n\
    \    let mut vowels_encoded12 = HashSet::new();\n    let mut vowels_encoded13\
    \ = HashSet::new();\n    let mut vowels_encoded14 = HashSet::new();\n    let mut\
    \ vowels_encoded15 = HashSet::new();\n    let mut vowels_encoded16 = HashSet::new();\n\
    \    let mut vowels_encoded17 = HashSet::new();\n    let mut vowels_encoded18\
    \ = HashSet::new();\n    let mut vowels_encoded19 = HashSet::new();\n    let mut\
    \ vowels_encoded20 = HashSet::new();\n    let mut vowels_encoded21 = HashSet::new();\n\
    \    let mut vowels_encoded22 = HashSet::new();\n    let mut vowels_encoded23\
    \ = HashSet::new();\n    let mut vowels_encoded24 = HashSet::new();\n    let mut\
    \ vowels_encoded25 = HashSet::new();\n    let mut vowels_encoded26 = HashSet::new();\n\
    \    let mut vowels_encoded27 = HashSet::new();\n    let mut vowels_encoded28\
    \ = HashSet::new();\n    let mut vowels_encoded29 = HashSet::new();\n    let mut\
    \ vowels_encoded30 = HashSet::new();\n    let mut vowels_encoded31 = HashSet::new();\n\
    \    let mut vowels_encoded32 = HashSet::new();\n    let mut vowels_encoded33\
    \ = HashSet::new();\n    let mut vowels_encoded34 = HashSet::new();\n    let mut\
    \ vowels_encoded35 = HashSet::new();\n\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp1z4p5gyd.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp1z4p5gyd.rs:14:30\n\
    \   |\n14 |     let mut vowels_encoded = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp1z4p5gyd.rs:15:31\n\
    \   |\n15 |     let mut vowels_encoded1 = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp1z4p5gyd.rs:16:31\n\
    \   |\n16 |     let mut vowels_encoded2 = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp1z4p5gyd.rs:17:31\n\
    \   |\n17 |     let mut vowels_encoded3 = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp1z4p5gyd.rs:18:31\n\
    \   |\n18 |     let mut vowels_encoded4 = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp1z4p5gyd.rs:19:31\n\
    \   |\n19 |     let mut vowels_encoded5 = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found i"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut index = 0;\n    for c in message.chars() {\n        if let Some(vowel)\
    \ = vowels.iter().position(|&x| x == c) {\n            result.push_str(&vowels[(index\
    \ + 1) % vowels.len()]);\n            index = vowel;\n        } else {\n     \
    \       result.push_str(&c);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpz1gydwch.rs:16:37\n   |\n16 |         if let Some(vowel)\
    \ = vowels.iter().position(|&x| x == c) {\n   |                              \
    \       ^^^^ method not found in `&str`\n   |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n   |\n16 |         if let Some(vowel) = vowels.chars().position(|&x|\
    \ x == c) {\n   |                                     ~~~~~\n\nerror[E0277]: the\
    \ type `str` cannot be indexed by `usize`\n  --> /tmp/tmpz1gydwch.rs:17:30\n \
    \  |\n17 |             result.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices\
    \ are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<usize>`\
    \ for `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz1gydwch.rs:20:29\n\
    \   |\n20 |             result.push_str(&c);\n   |                           \
    \  ^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut current_letter = 0;\n    let mut current_vowel = 0;\n    let\
    \ mut current_vowel_index = 0;\n    let mut current_letter_index = 0;\n    let\
    \ mut current_letter_count = 1;\n    let mut current_vowel_count = 1;\n    let\
    \ mut current_vowel_index = 0;\n    let mut current_letter_index = 0;\n    let\
    \ mut current_letter_count = 1;\n    let mut current_vowel_count = 1;\n    let\
    \ mut current_vowel_index = 0;\n    let mut current_letter_index = 0;\n    let\
    \ mut current_letter_count = 1;\n    let mut current_vowel_count = 1;\n    let\
    \ mut current_vowel_index = 0;\n    let mut current_letter_index = 0;\n    let\
    \ mut current_letter_count = 1;\n    let mut current_vowel_count = 1;\n    let\
    \ mut current_vowel_index = 0;\n    let mut current_letter_index = 0;\n    let\
    \ mut current_letter_count = 1;\n    let mut current_vowel_count = 1;\n    let\
    \ mut current_vowel_index = 0;\n    let mut current_letter_index = 0;\n    let\
    \ mut current_letter_count = 1;\n    let mut current_vowel_count = 1;\n    let\
    \ mut current_vowel_index = 0;\n    let mut current_letter_index = 0;\n    let\
    \ mut current_letter_count = 1;\n    let mut current_vowel_count = 1;\n    let\
    \ mut current_vowel_index = 0;\n    let mut current_letter_index = 0;\n    let\
    \ mut current_letter_count = 1;\n    let mut current_vowel_count = 1;\n    let\
    \ mut current_vowel_index = 0;\n    let mut current_letter_index = 0;\n    let\
    \ mut current_letter_count = 1;\n    let mut current_vowel_count = 1;\n    let\
    \ mut current_vowel_index = 0;\n    let mut current_letter_index = 0;\n    let\
    \ mut current_letter_count = 1;\n    let mut current_vowel_count = 1;\n    let\
    \ mut current_vowel_index = 0;\n    let mut current_letter_index = 0;\n    let\
    \ mut current_letter_count = 1;\n    let mut current_vowel_count = 1;\n    let\
    \ mut current_vowel_index = 0;\n    let mut current_letter_index = 0;\n    let\
    \ mut current_letter_count = 1;\n    let mut current_vowel_count = 1;\n    let\
    \ mut current_vowel_index = 0;\n    let mut current_letter_index = 0;\n    let\
    \ mut current_letter_count = 1;\n    let mut current_vowel_count = 1;\n    let\
    \ mut current_vowel_index = 0;\n    let mut current_letter_index = 0;\n    let\
    \ mut current_letter_count = 1;\n    let mut current_vowel_count = 1;\n    let\
    \ mut current_vowel_index = 0;\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptx46_3io.rs:74:11\n   |\n\
    74 |     let mu\n   |           ^ help: add `;` here\n75 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptx46_3io.rs:11:31\n \
    \  |\n11 | fn encode(message: String) -> String {\n   |    ------            \
    \         ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::new();\n\
    \    let mut letters = String::new();\n    let mut index = 0;\n    let mut vowel_index\
    \ = 0;\n    let mut letter_count = 0;\n    for letter in message.chars() {\n \
    \       if letter == ' ' {\n            encoded.push_str(&vowels);\n         \
    \   vowel_index = 0;\n            letter_count = 0;\n        } else {\n      \
    \      if letter_count > 0 {\n                encoded.push_str(&vowels);\n   \
    \             vowel_index = 0;\n            }\n            encoded.push_str(&letters);\n\
    \            letter_count = 1;\n            vowels.push_str(&vowels[vowel_index]);\n\
    \            vowel_index += 1;\n        }\n        letters.push_str(&letter);\n\
    \        index += 1;\n    }\n    encoded.push_str(&vowels);\n    encoded\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp6if7ok7l.rs:30:30\n   |\n30 |             vowels.push_str(&vowels[vowel_index]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6if7ok7l.rs:33:26\n\
    \   |\n33 |         letters.push_str(&letter);\n   |                         \
    \ ^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_map = HashMap::new();\n    for vowel\
    \ in vowels {\n        vowels_map.insert(vowel, vowel);\n    }\n    for letter\
    \ in message.chars() {\n        if let Some(vowel) = vowels_map.get(letter) {\n\
    \            result.push_str(&vowels[vowel - 'A']);\n        } else {\n      \
    \      result.push_str(&letter);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp79u95w_v.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp79u95w_v.rs:22:29\n   |\n22 |             result.push_str(&letter);\n\
    \   |                             ^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    let mut vowels_index = 0;\n    let mut letters_index\
    \ = 0;\n    for letter in message {\n        if letter == letters[letters_index]\
    \ {\n            letters_index += 1;\n        } else {\n            letters_index\
    \ = 0;\n        }\n        if letter == vowels[vowels_index] {\n            vowels_index\
    \ += 1;\n        } else {\n            vowels_index = 0;\n        }\n        result.push_str(&letters[letters_index]);\n\
    \        result.push_str(&vowels[vowels_index]);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmplr1hvuxc.rs:17:19\n\
    \   |\n17 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplr1hvuxc.rs:28:25\n   |\n28 |         result.push_str(&letters[letters_index]);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplr1hvuxc.rs:29:25\n   |\n29 |\
    \         result.push_str(&vowels[vowels_index]);\n   |                      \
    \   ^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut vowels_counter = 0;\n   \
    \ let mut alphabet_counter = 0;\n    let mut vowels_counter2 = 0;\n    let mut\
    \ alphabet_counter2 = 0;\n    for c in message.chars() {\n        if c.is_uppercase()\
    \ {\n            alphabet.insert(c.to_lowercase());\n            alphabet_counter++;\n\
    \        } else {\n            alphabet.insert(c.to_uppercase());\n          \
    \  alphabet_counter++;\n        }\n        if vowels.contains(&c.to_lowercase())\
    \ {\n            vowels_counter++;\n        } else {\n            vowels.insert(c.to_lowercase());\n\
    \            vowels_counter++;\n        }\n        if vowels.contains(&c.to_uppercase())\
    \ {\n            vowels_counter2++;\n        } else {\n            vowels.insert(c.to_uppercase());\n\
    \            vowels_counter2++;\n        }\n    }\n    let mut i = 0;\n    while\
    \ i < message.len() {\n        if alphabet_counter == 2 {\n            result.push((&alphabet[alphabet_counter2\
    \ - 1]).to_string());\n            alphabet_counter2--;\n            alphabet_counter--;\n\
    \        }\n        if vowels_counter == 2 {\n            result.push((&vowels[vowels_counter2\
    \ - 1]).to_string());\n            vowels_counter2--;\n            vowels_counter--;\n\
    \        }\n        result.push((&message[i..i + 1]).to_string());\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmps0pi4e61.rs:22:29\n\
    \   |\n22 |             alphabet_counter++;\n   |                            \
    \ ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n22 |\
    \             { let tmp = alphabet_counter; alphabet_counter += 1; tmp };\n  \
    \ |             +++++++++++                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n22\
    \ -             alphabet_counter++;\n22 +             alphabet_counter += 1;\n\
    \   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmps0pi4e61.rs:25:29\n\
    \   |\n25 |             alphabet_counter++;\n   |                            \
    \ ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n25 |\
    \             { let tmp = alphabet_counter; alphabet_counter += 1; tmp };\n  \
    \ |             +++++++++++                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n25\
    \ -             alphabet_counter++;\n25 +             alphabet_counter += 1;\n\
    \   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmps0pi4e61.rs:28:27\n\
    \   |\n28 |             vowels_counter++;\n   |                           ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n28 |       \
    \      { let tmp = vowels_counter; vowels_counter += 1; tmp };\n   |         \
    \    +++++++++++               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n28 -            \
    \ vowels_counter++;\n28 +             vowels_counter += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmps0pi4e61.rs:31:27\n   |\n31\
    \ |             vowels_counter++;\n   |                           ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n31 |             { let\
    \ tmp = vowels_counter; vowels_counter += 1; tmp };\n   |             +++++++++++\
    \               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n31 -             vowels_counter++;\n\
    31 +             vowels_counter += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmps0pi4e61.rs:34:28\n   |\n34 |             vowels_counter2++;\n\
    \   |                            ^^ not a valid postfix operator\n   |\nhelp:\
    \ use `+= 1` instead\n   |\n34 |             { let tmp = vowel"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut i = 0;\n    while i < message.len() {\n       \
    \ let mut j = i;\n        while j < message.len() {\n            if message[j]\
    \ == vowels[i] {\n                result.push(*letters[i as usize]);\n       \
    \         i += 1;\n                j += 1;\n            } else {\n           \
    \     result.push(*message[j]);\n                j += 1;\n            }\n    \
    \    }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm9y6vi56.rs:19:16\n\
    \   |\n19 |             if message[j] == vowels[i] {\n   |                ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpm9y6vi56.rs:20:29\n\
    \   |\n20 |                 result.push(*letters[i as usize]);\n   |         \
    \                    ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpm9y6vi56.rs:24:30\n   |\n24 |         \
    \        result.push(*message[j]);\n   |                              ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009142
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut alphabet = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    let mut letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n \
    \   let mut letter_counter4 = 0;\n    let mut letter_counter5 = 0;\n    let mut\
    \ letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n    let mut letter_counter8\
    \ = 0;\n    let mut letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n\
    \    let mut letter_counter11 = 0;\n    let mut letter_counter12 = 0;\n    let\
    \ mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n    let mut letter_counter15\
    \ = 0;\n    let mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n\
    \    let mut letter_counter18 = 0;\n    let mut letter_counter19 = 0;\n    let\
    \ mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n    let mut letter_counter22\
    \ = 0;\n    let mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n\
    \    let mut letter_counter25 = 0;\n    let mut letter_counter26 = 0;\n    let\
    \ mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n    let mut letter_counter29\
    \ = 0;\n    let mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n\
    \    let mut letter_counter32 = 0;\n    let mut letter_counter33 = 0;\n    let\
    \ mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n    let mut letter_counter36\
    \ = 0;\n    let mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n\
    \    let mut letter_counter39 = 0;\n    let mut letter_counter40 = 0;\n    let\
    \ mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n    let mut letter_counter43\
    \ = 0;\n    let mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n\
    \    let mut letter_counter\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptuugju9_.rs:61:27\n   |\n\
    61 |     let mut letter_counter\n   |                           ^ help: add `;`\
    \ here\n62 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmptuugju9_.rs:11:31\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |    ------                     ^^^^^^ expected struct `String`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009142
