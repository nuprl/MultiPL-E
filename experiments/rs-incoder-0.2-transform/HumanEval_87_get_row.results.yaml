language: rs
name: HumanEval_87_get_row
results:
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut col_idx = 0;\n    let mut row_idx2 = 0;\n    let mut col_idx2\
    \ = 0;\n    for row in lst {\n        row_idx += 1;\n        for col in row {\n\
    \            col_idx += 1;\n            if col == x {\n                row.swap(row_idx,\
    \ col_idx);\n                row_idx += 1;\n                col_idx -= 1;\n  \
    \          }\n        }\n    }\n    row.sort_by_key(|&(_, y)| y.cmp(&x));\n  \
    \  row.sort_by_key(|&(_, y)| y.cmp(&x));\n    row\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `row_idx2`\n  --> /tmp/tmp5sqoz32j.rs:20:13\n\
    \   |\n20 |     let mut row_idx2 = 0;\n   |             ^^^^^^^^ help: if this\
    \ is intentional, prefix it with an underscore: `_row_idx2`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `col_idx2`\n\
    \  --> /tmp/tmp5sqoz32j.rs:21:13\n   |\n21 |     let mut col_idx2 = 0;\n   | \
    \            ^^^^^^^^ help: if this is intentional, prefix it with an underscore:\
    \ `_col_idx2`\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmp5sqoz32j.rs:20:9\n\
    \   |\n20 |     let mut row_idx2 = 0;\n   |         ----^^^^^^^^\n   |       \
    \  |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmp5sqoz32j.rs:21:9\n\
    \   |\n21 |     let mut col_idx2 = 0;\n   |         ----^^^^^^^^\n   |       \
    \  |\n   |         help: remove this `mut`\n\nerror[E0596]: cannot borrow `row`\
    \ as mutable, as it is not declared as mutable\n  --> /tmp/tmp5sqoz32j.rs:27:17\n\
    \   |\n22 |     for row in lst {\n   |         --- help: consider changing this\
    \ to be mutable: `mut row`\n...\n27 |                 row.swap(row_idx, col_idx);\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\n\
    error[E0382]: borrow of moved value: `row`\n   --> /tmp/tmp5sqoz32j.rs:27:17\n\
    \    |\n22  |     for row in lst {\n    |         --- move occurs because `row`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n23  |    \
    \     row_idx += 1;\n24  |         for col in row {\n    |                   \
    \ --- `row` moved due to this implicit call to `.into_iter()`\n...\n27  |    \
    \             row.swap(row_idx, col_idx);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `row`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n24\
    \  |         for col in &row {\n    |                    +\n\nerror: aborting\
    \ due to 2 previous errors; 4 warnings emi"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = Vec::new();\n    let mut row_coords = Vec::new();\n    let mut\
    \ col_coords = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted_idx = Vec::new();\n    let\
    \ mut col_sorted_idx = Vec::new();\n    let mut row_sorted_idx_idx = Vec::new();\n\
    \    let mut col_sorted_idx_idx = Vec::new();\n    let mut row_sorted_idx_idx_idx\
    \ = Vec::new();\n    let mut col_sorted_idx_idx_idx = Vec::new();\n    let mut\
    \ row_sorted_idx_idx_idx_idx = Vec::new();\n    let mut col_sorted_idx_idx_idx_idx\
    \ = Vec::new();\n    let mut row_sorted_idx_idx_idx_idx_idx = Vec::new();\n  \
    \  let mut col_sorted_idx_idx_idx_idx_idx = Vec::new();\n    let mut row_sorted_idx_idx_idx_idx_idx_idx\
    \ = Vec::new();\n    let mut col_sorted_idx_idx_idx_idx_idx_idx = Vec::new();\n\
    \    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx = Vec::new();\n    let mut\
    \ col_sorted_idx_idx_idx_idx_idx_idx_idx = Vec::new();\n    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = Vec::new();\n    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx = Vec::new();\n\
    \    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx = Vec::new();\n  \
    \  let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx = Vec::new();\n    let\
    \ mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = Vec::new();\n    let\
    \ mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = Vec::new();\n    let\
    \ mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = Vec::new();\n \
    \   let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = Vec::new();\n\
    \    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = Vec::new();\n\
    \    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx =\
    \ Vec::new();\n    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = Vec::new();\n    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4u0_aoho.rs:49:80\n   |\n\
    49 |     let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_\n\
    \   |                                                                        \
    \        ^ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4u0_aoho.rs:16:47\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |    -------       \
    \                             ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    let mut row_idx = 1;\n    let mut col_idx\
    \ = 1;\n    let mut row_max = lst.len();\n    let mut col_max = lst[0].len();\n\
    \    let mut row_min = row_max - 1;\n    let mut col_min = col_max - 1;\n    let\
    \ mut row_ptr = &mut lst[row_idx];\n    let mut col_ptr = &mut row_ptr[col_idx];\n\
    \    while row_idx < row_max {\n        while col_idx < col_max {\n          \
    \  if *col_ptr == x {\n                result.push((row_idx, col_idx));\n    \
    \            break;\n            }\n            col_idx += 1;\n        }\n   \
    \     col_idx = 1;\n        col_ptr = &mut row_ptr[col_idx];\n        row_idx\
    \ += 1;\n    }\n    result.sort_by_key(|&(x, y)| x.0);\n    result.sort_by_key(|&(x,\
    \ y)| y.0);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmprm8290kx.rs:38:36\n   |\n38 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmprm8290kx.rs:39:36\n\
    \   |\n39 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprm8290kx.rs:40:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n40 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = vec![];\n    for row in lst {\n        let mut row_result\
    \ = vec![];\n        for element in row {\n            if element == x {\n   \
    \             row_result.push((row, element));\n            }\n        }\n   \
    \     result.push(row_result);\n    }\n    result.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    result.sort_by(|a, b| b.1.cmp(&a.1));\n    result\n}\n\nfn main() {\n   \
    \ let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&Vec<(Vec<isize>, isize)>`\n  --> /tmp/tmpvvdxyl6p.rs:27:29\n\
    \   |\n27 |     result.sort_by(|a, b| a.0.cmp(&b.0));\n   |                  \
    \           ^ unknown field\n\nerror[E0609]: no field `0` on type `&Vec<(Vec<isize>,\
    \ isize)>`\n  --> /tmp/tmpvvdxyl6p.rs:27:38\n   |\n27 |     result.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n   |                                      ^ unknown field\n\
    \nerror[E0609]: no field `1` on type `&Vec<(Vec<isize>, isize)>`\n  --> /tmp/tmpvvdxyl6p.rs:28:29\n\
    \   |\n28 |     result.sort_by(|a, b| b.1.cmp(&a.1));\n   |                  \
    \           ^ unknown field\n\nerror[E0609]: no field `1` on type `&Vec<(Vec<isize>,\
    \ isize)>`\n  --> /tmp/tmpvvdxyl6p.rs:28:38\n   |\n28 |     result.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n   |                                      ^ unknown field\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvvdxyl6p.rs:29:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n29 |     result\n   |     ^^^^^^ expected\
    \ tuple, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<(Vec<isize>, isize)>>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0609.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut result = vec![];\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n \
    \   while row_idx < rows {\n        let mut row_result = vec![];\n        while\
    \ col_idx < cols {\n            if row_idx == row_idx {\n                row_result.push((row_idx,\
    \ col_idx));\n            }\n            if row_idx < rows && col_idx < cols {\n\
    \                if lst[row_idx][col_idx] == x {\n                    row_result.push((row_idx,\
    \ col_idx));\n                }\n            }\n            col_idx++;\n     \
    \   }\n        result.push(row_result);\n        row_idx++;\n    }\n    result.sort_by_key(|&(x,\
    \ y)| x.0);\n    result.sort_by_key(|&(x, y)| y.0);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpoyau69xi.rs:33:20\n\
    \   |\n33 |             col_idx++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n33 |             { let tmp =\
    \ col_idx; col_idx += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    33 -             col_idx++;\n33 +             col_idx += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmpoyau69xi.rs:36:16\n   |\n36\
    \ |         row_idx++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n36 |         { let tmp = row_idx; row_idx\
    \ += 1; tmp };\n   |         +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n36 -  \
    \       row_idx++;\n36 +         row_idx += 1;\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoyau69xi.rs:38:26\n   |\n38 |     result.sort_by_key(|&(x,\
    \ y)| x.0);\n   |                          ^^^^^-\n   |                      \
    \    |    |\n   |                          |    expected due to this\n   |   \
    \                       expected struct `Vec`, found tuple\n   |\n   = note: expected\
    \ struct `Vec<(usize, usize)>`\n               found tuple `(_, _)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoyau69xi.rs:39:26\n   |\n39 |     result.sort_by_key(|&(x,\
    \ y)| y.0);\n   |                          ^^^^^-\n   |                      \
    \    |    |\n   |                          |    expected due to this\n   |   \
    \                       expected struct `Vec`, found tuple\n   |\n   = note: expected\
    \ struct `Vec<(usize, usize)>`\n               found tuple `(_, _)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoyau69xi.rs:40:5\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                             ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n40 |     result\n   |     ^^^^^^ expected tuple,\
    \ found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more informatio"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    let mut rows = lst.len();\n    let\
    \ mut cols = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n\
    \    while row_idx < rows {\n        while col_idx < cols {\n            if lst[row_idx][col_idx]\
    \ == x {\n                result.push((row_idx, col_idx));\n                break;\n\
    \            }\n            col_idx += 1;\n        }\n        col_idx = 0;\n \
    \       row_idx += 1;\n    }\n    result.sort_by_key(|&(x, y)| x.0);\n    result.sort_by_key(|&(x,\
    \ y)| y.0);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp76_qpur2.rs:33:36\n   |\n33 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmp76_qpur2.rs:34:36\n\
    \   |\n34 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp76_qpur2.rs:35:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n35 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut col_idx = 0;\n    let mut row_idx2 = 0;\n    let mut col_idx2 = 0;\n\
    \    let mut row_idx3 = 0;\n    let mut col_idx3 = 0;\n    let mut row_idx4 =\
    \ 0;\n    let mut col_idx4 = 0;\n    let mut row_idx5 = 0;\n    let mut col_idx5\
    \ = 0;\n    let mut row_idx6 = 0;\n    let mut col_idx6 = 0;\n    let mut row_idx7\
    \ = 0;\n    let mut col_idx7 = 0;\n    let mut row_idx8 = 0;\n    let mut col_idx8\
    \ = 0;\n    let mut row_idx9 = 0;\n    let mut col_idx9 = 0;\n    let mut row_idx10\
    \ = 0;\n    let mut col_idx10 = 0;\n    let mut row_idx11 = 0;\n    let mut col_idx11\
    \ = 0;\n    let mut row_idx12 = 0;\n    let mut col_idx12 = 0;\n    let mut row_idx13\
    \ = 0;\n    let mut col_idx13 = 0;\n    let mut row_idx14 = 0;\n    let mut col_idx14\
    \ = 0;\n    let mut row_idx15 = 0;\n    let mut col_idx15 = 0;\n    let mut row_idx16\
    \ = 0;\n    let mut col_idx16 = 0;\n    let mut row_idx17 = 0;\n    let mut col_idx17\
    \ = 0;\n    let mut row_idx18 = 0;\n    let mut col_idx18 = 0;\n    let mut row_idx19\
    \ = 0;\n    let mut col_idx19 = 0;\n    let mut row_idx20 = 0;\n    let mut col_idx20\
    \ = 0;\n    let mut row_idx21 = 0;\n    let mut col_idx21 = 0;\n    let mut row_idx22\
    \ = 0;\n    let mut col_idx22 = 0;\n    let mut row_idx23 = 0;\n    let mut col_idx23\
    \ = 0;\n    let mut row_idx24 = 0;\n    let mut col_idx24 = 0;\n    let mut row_idx25\
    \ = 0;\n    let mut col_idx25 = 0;\n    let mut row_idx26 = 0;\n    let mut col_idx26\
    \ = 0;\n    let mut row_idx27 = 0;\n    let mut col_idx27 = 0;\n    let mut row_idx28\
    \ = 0;\n    let mut col_idx28 = 0;\n    let mut row_idx29 = 0;\n    let mut col_idx29\
    \ = 0;\n    let mut row_idx30 = 0;\n    let mut col_idx30 = 0;\n    let mut row_idx31\
    \ = 0;\n    let mut col_idx31 = 0;\n    let mut row_idx32 = 0;\n    let \n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpv_ptqd5a.rs:82:1\n  \
    \ |\n82 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = Vec::new();\n    let mut row_coords = Vec::new();\n    let mut\
    \ col_coords = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp87t1dkxc.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = Vec::new();\n    let mut row_coords = Vec::new();\n    let mut\
    \ col_coords = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp87t1dkxc.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    let mut row_idx =\
    \ 1;\n    let mut col_idx = 1;\n    let mut row_len = 0;\n    let mut col_len\
    \ = 0;\n    let mut row_start = 0;\n    let mut col_start = 0;\n    let mut row_end\
    \ = 0;\n    let mut col_end = 0;\n    let mut row_start = 0;\n    let mut col_start\
    \ = 0;\n    let mut row_end = 0;\n    let mut col_end = 0;\n    let mut row_start\
    \ = 0;\n    let mut col_start = 0;\n    let mut row_end = 0;\n    let mut col_end\
    \ = 0;\n    let mut row_start = 0;\n    let mut col_start = 0;\n    let mut row_end\
    \ = 0;\n    let mut col_end = 0;\n    let mut row_start = 0;\n    let mut col_start\
    \ = 0;\n    let mut row_end = 0;\n    let mut col_end = 0;\n    let mut row_start\
    \ = 0;\n    let mut col_start = 0;\n    let mut row_end = 0;\n    let mut col_end\
    \ = 0;\n    let mut row_start = 0;\n    let mut col_start = 0;\n    let mut row_end\
    \ = 0;\n    let mut col_end = 0;\n    let mut row_start = 0;\n    let mut col_start\
    \ = 0;\n    let mut row_end = 0;\n    let mut col_end = 0;\n    let mut row_start\
    \ = 0;\n    let mut col_start = 0;\n    let mut row_end = 0;\n    let mut col_end\
    \ = 0;\n    let mut row_start = 0;\n    let mut col_start = 0;\n    let mut row_end\
    \ = 0;\n    let mut col_end = 0;\n    let mut row_start = 0;\n    let mut col_start\
    \ = 0;\n    let mut row_end = 0;\n    let mut col_end = 0;\n    let mut row_start\
    \ = 0;\n    let mut col_start = 0;\n    let mut row_end = 0;\n    let mut col_end\
    \ = 0;\n    let mut row_start = 0;\n    let mut col_start = 0;\n    let mut row_end\
    \ = 0;\n    let mut col_end = 0;\n    let mut row_start = 0;\n    let mut col_start\
    \ = 0;\n    let mut row_end = 0;\n    let mut col_end = 0;\n    let mut row_start\
    \ = 0;\n    let mut col_start = 0;\n    let mut row_end = 0;\n    let mut col_end\
    \ = 0;\n    let mut row_start = 0;\n    let mut col_start = 0;\n    let mut row_end\
    \ = 0;\n    let mut col_end = 0;\n    let mut row_start = 0;\n    let mut col_start\
    \ = 0;\n    let mut row_end = 0;\n\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo58geckp.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    for row in lst {\n        let mut col = vec![];\n\
    \        for col in row {\n            if col == x {\n                col.push((row.len(),\
    \ col.len()));\n            }\n        }\n        row_sorted.push(row.iter().cloned().collect::<Vec<_>>());\n\
    \        col_sorted.push(col.iter().cloned().collect::<Vec<_>>());\n    }\n  \
    \  row_sorted.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n    col_sorted.sort_by(|a,\
    \ b| b.iter().cmp(&a.iter()).reverse());\n    vec![row_sorted.iter().cloned().collect::<Vec<_>>(),\
    \ col_sorted.iter().cloned().collect::<Vec<_>>()]\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp6n0b_qii.rs:24:21\n   |\n24 |                 col.push((row.len(),\
    \ col.len()));\n   |                     ^^^^ method not found in `isize`\n\n\
    error[E0599]: no method named `len` found for type `isize` in the current scope\n\
    \  --> /tmp/tmp6n0b_qii.rs:24:42\n   |\n24 |                 col.push((row.len(),\
    \ col.len()));\n   |                                          ^^^ method not found\
    \ in `isize`\n\nerror[E0277]: `&std::slice::Iter<'_, isize>` is not an iterator\n\
    \    --> /tmp/tmp6n0b_qii.rs:30:44\n     |\n30   |     row_sorted.sort_by(|a,\
    \ b| a.iter().cmp(&b.iter()).reverse());\n     |                             \
    \           --- ^^^^^^^^^ `&std::slice::Iter<'_, isize>` is not an iterator\n\
    \     |                                        |\n     |                     \
    \                   required by a bound introduced by this call\n     |\n    \
    \ = help: the trait `Iterator` is not implemented for `&std::slice::Iter<'_, isize>`\n\
    \     = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&std::slice::Iter<'_, isize>`\nnote: required by a bound in `std::iter::Iterator::cmp`\n\
    help: consider dereferencing here\n     |\n30   |     row_sorted.sort_by(|a, b|\
    \ a.iter().cmp(*&b.iter()).reverse());\n     |                               \
    \             +\nhelp: consider removing the leading `&`-reference\n     |\n30\
    \   -     row_sorted.sort_by(|a, b| a.iter().cmp(&b.iter()).reverse());\n30  \
    \ +     row_sorted.sort_by(|a, b| a.iter().cmp(b.iter()).reverse());\n     | \n\
    help: consider changing this borrow's mutability\n     |\n30   |     row_sorted.sort_by(|a,\
    \ b| a.iter().cmp(&mut b.iter()).reverse());\n     |                         \
    \                   ~~~~\n\nerror[E0277]: `&std::slice::Iter<'_, _>` is not an\
    \ iterator\n    --> /tmp/tmp6n0b_qii.rs:31:44\n     |\n31   |     col_sorted.sort_by(|a,\
    \ b| b.iter().cmp(&a.iter()).reverse());\n     |                             \
    \           --- ^^^^^^^^^ `&std::slice::Iter<'_, _>` is not an iterator\n    \
    \ |                     "
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    for row in lst {\n        let mut row_result\
    \ = Vec::new();\n        for cell in row.iter() {\n            if cell == x {\n\
    \                row_result.push((row, cell));\n            }\n        }\n   \
    \     result.push(row_result);\n    }\n    result.sort_by_key(|x| x.0);\n    result.sort_by_key(|x|\
    \ x.1, |a, b| b.1.cmp(&a.1));\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpr3yh8zqz.rs:21:21\n\
    \   |\n21 |             if cell == x {\n   |                     ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0609]: no field `0` on type `&Vec<(Vec<isize>,\
    \ &isize)>`\n  --> /tmp/tmpr3yh8zqz.rs:27:30\n   |\n27 |     result.sort_by_key(|x|\
    \ x.0);\n   |                              ^ unknown field\n\nerror[E0061]: this\
    \ function takes 1 argument but 2 arguments were supplied\n   --> /tmp/tmpr3yh8zqz.rs:28:12\n\
    \    |\n28  |     result.sort_by_key(|x| x.1, |a, b| b.1.cmp(&a.1));\n    |  \
    \          ^^^^^^^^^^^ -------  -------------------- supplied 2 arguments\n  \
    \  |            |\n    |            expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr3yh8zqz.rs:29:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n29 |     result\n   |   \
    \  ^^^^^^ expected tuple, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<(isize, isize)>`\n              found struct `Vec<Vec<(Vec<isize>, &isize)>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0308, E0609.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst.clone();\n    let mut rows = lst.len();\n    let mut\
    \ cols = lst[0].len();\n    let mut coords = Vec::new();\n    let mut row = 0;\n\
    \    let mut col = 0;\n    while row < rows {\n        while col < cols {\n  \
    \          if lst[row][col] == x {\n                coords.push((row, col));\n\
    \                break;\n            }\n            col += 1;\n        }\n   \
    \     row += 1;\n        col = 0;\n    }\n    coords.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    coords.sort_by(|a, b| b.2.cmp(&a.2));\n    coords\n}\n\nfn main() {\n   \
    \ let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `2` on type `&(usize, usize)`\n  --> /tmp/tmpanjfiajj.rs:35:29\n\
    \   |\n35 |     coords.sort_by(|a, b| b.2.cmp(&a.2));\n   |                  \
    \           ^\n\nerror[E0609]: no field `2` on type `&(usize, usize)`\n  --> /tmp/tmpanjfiajj.rs:35:38\n\
    \   |\n35 |     coords.sort_by(|a, b| b.2.cmp(&a.2));\n   |                  \
    \                    ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpanjfiajj.rs:36:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n36 |     coords\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0609.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst.clone();\n    lst.sort_by_key(|row| row.iter().cloned().collect::<Vec<_>>());\n\
    \    lst.sort_by_key(|row| row.iter().cloned().rev().collect::<Vec<_>>());\n \
    \   lst.iter().cloned().enumerate().filter_map(|(i, row)| {\n        if i == x\
    \ {\n            Some((i, row.iter().cloned().rev().collect::<Vec<_>>()))\n  \
    \      } else {\n            None\n        }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfolcmaxh.rs:21:17\n   |\n\
    21 |         if i == x {\n   |                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |         if i == x.try_into().unwrap() {\n   |\
    \                  ++++++++++++++++++++\n\nerror[E0277]: a value of type `Vec<(isize,\
    \ isize)>` cannot be built from an iterator over elements of type `(usize, Vec<isize>)`\n\
    \    --> /tmp/tmpfolcmaxh.rs:26:8\n     |\n26   |     }).collect()\n     |   \
    \     ^^^^^^^ value of type `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=(usize,\
    \ Vec<isize>)>`\n     |\n     = help: the trait `FromIterator<(usize, Vec<isize>)>`\
    \ is not implemented for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_idx2 = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4\
    \ = 0;\n    let mut row_idx5 = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7\
    \ = 0;\n    let mut row_idx8 = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10\
    \ = 0;\n    let mut row_idx11 = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13\
    \ = 0;\n    let mut row_idx14 = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16\
    \ = 0;\n    let mut row_idx17 = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19\
    \ = 0;\n    let mut row_idx20 = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22\
    \ = 0;\n    let mut row_idx23 = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25\
    \ = 0;\n    let mut row_idx26 = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28\
    \ = 0;\n    let mut row_idx29 = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31\
    \ = 0;\n    let mut row_idx32 = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34\
    \ = 0;\n    let mut row_idx35 = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37\
    \ = 0;\n    let mut row_idx38 = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40\
    \ = 0;\n    let mut row_idx41 = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43\
    \ = 0;\n    let mut row_idx44 = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46\
    \ = 0;\n    let mut row_idx47 = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49\
    \ = 0;\n    let mut row_idx50 = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52\
    \ = 0;\n    let mut row_idx53 = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55\
    \ = 0;\n    let mut row_idx56 = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58\
    \ = 0;\n    let mut row_idx59 = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61\
    \ = 0;\n    let mut row_idx62 = 0;\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpy0j02d22.rs:81:1\n\
    \   |\n81 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx: usize\
    \ = 0;\n    let mut row_len: usize = 0;\n    for row in lst {\n        row_len\
    \ += row.len();\n        if row_idx >= row_len {\n            break;\n       \
    \ }\n        let mut row_idx: usize = 0;\n        let mut row_len: usize = 0;\n\
    \        for col in row {\n            row_idx += 1;\n            row_len += 1;\n\
    \            if col == x {\n                break;\n            }\n        }\n\
    \        if row_idx >= row_len {\n            break;\n        }\n    }\n    row.sort_by_key(|&(x,\
    \ y)| x.cmp(y));\n    row.sort_by_key(|&(x, y)| y.cmp(x));\n    row\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxx_vodt7.rs:38:37\n   |\n\
    38 |     row.sort_by_key(|&(x, y)| x.cmp(y));\n   |                          \
    \           ^\n   |                                     |\n   |              \
    \                       expected `&isize`, found `isize`\n   |               \
    \                      help: consider borrowing here: `&y`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxx_vodt7.rs:39:37\n   |\n39 |     row.sort_by_key(|&(x,\
    \ y)| y.cmp(x));\n   |                                     ^\n   |           \
    \                          |\n   |                                     expected\
    \ `&isize`, found `isize`\n   |                                     help: consider\
    \ borrowing here: `&x`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    let mut rows = lst.len();\n    let\
    \ mut cols = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n\
    \    while row_idx < rows {\n        let mut row_result = Vec::new();\n      \
    \  while col_idx < cols {\n            if row_idx == row_idx {\n             \
    \   row_result.push((row_idx, col_idx));\n            }\n            col_idx +=\
    \ 1;\n        }\n        result.push(row_result);\n        row_idx += 1;\n   \
    \ }\n    result.sort_by_key(|&(_, y)| y.cmp(&x));\n    result.sort_by_key(|&(_,\
    \ y)| y.cmp(&-x));\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptlhln0xk.rs:33:26\n   |\n\
    33 |     result.sort_by_key(|&(_, y)| y.cmp(&x));\n   |                      \
    \    ^^^^^-\n   |                          |    |\n   |                      \
    \    |    expected due to this\n   |                          expected struct\
    \ `Vec`, found tuple\n   |\n   = note: expected struct `Vec<(usize, usize)>`\n\
    \               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmptlhln0xk.rs:34:26\n   |\n34 |     result.sort_by_key(|&(_, y)| y.cmp(&-x));\n\
    \   |                          ^^^^^-\n   |                          |    |\n\
    \   |                          |    expected due to this\n   |               \
    \           expected struct `Vec`, found tuple\n   |\n   = note: expected struct\
    \ `Vec<(usize, usize)>`\n               found tuple `(_, _)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptlhln0xk.rs:35:5\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |                  \
    \                             ------------------- expected `Vec<(isize, isize)>`\
    \ because of return type\n...\n35 |     result\n   |     ^^^^^^ expected tuple,\
    \ found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    let mut row = 0;\n    let mut col = 0;\n    while\
    \ row < rows {\n        if col < cols {\n            if lst[row][col] == x {\n\
    \                coords.push((row, col));\n            }\n            col += 1;\n\
    \        } else {\n            row += 1;\n            col = 0;\n        }\n  \
    \  }\n    coords.sort_by_key(|&(x, y)| x.0);\n    coords.sort_by_key(|&(x, y)|\
    \ y.0);\n    coords.reverse();\n    coords\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmphcrdq3g5.rs:33:36\n   |\n33 |     coords.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmphcrdq3g5.rs:34:36\n\
    \   |\n34 |     coords.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphcrdq3g5.rs:36:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n36 |     coords\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    for row in lst {\n\
    \        let mut row_result = Vec::<(isize, isize)>::new();\n        for cell\
    \ in row {\n            if cell == x {\n                row_result.push((cell,\
    \ cell));\n            }\n        }\n        result.push(row_result);\n    }\n\
    \    result.sort_by_key(|row| row.iter().rev().cloned());\n    result.sort_by_key(|row|\
    \ row.iter().cloned());\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcv6soixs.rs:25:21\n   |\n\
    25 |         result.push(row_result);\n   |                     ^^^^^^^^^^ expected\
    \ tuple, found struct `Vec`\n   |\n   = note: expected tuple `(isize, isize)`\n\
    \             found struct `Vec<(isize, isize)>`\n\nerror[E0599]: no method named\
    \ `iter` found for reference `&(isize, isize)` in the current scope\n  --> /tmp/tmpcv6soixs.rs:27:34\n\
    \   |\n27 |     result.sort_by_key(|row| row.iter().rev().cloned());\n   |   \
    \                               ^^^^ method not found in `&(isize, isize)`\n\n\
    error[E0599]: no method named `iter` found for reference `&(isize, isize)` in\
    \ the current scope\n  --> /tmp/tmpcv6soixs.rs:28:34\n   |\n28 |     result.sort_by_key(|row|\
    \ row.iter().cloned());\n   |                                  ^^^^ method not\
    \ found in `&(isize, isize)`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut col_max = 0;\n    for row in lst {\n        let mut col_max\
    \ = 0;\n        for col in row {\n            if col > col_max {\n           \
    \     col_max = col;\n            }\n        }\n        if col_max > x {\n   \
    \         break;\n        }\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n\
    \        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n    \
    \    row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x|\
    \ x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n\
    \        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n    \
    \    row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n\
    \        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n    \
    \    row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x|\
    \ x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n\
    \        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n    \
    \    row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n\
    \        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n    \
    \    row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpm4nmzmkn.rs:77:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n20 |     for row in lst {\n   |                   \
    \ - this delimiter might not be properly closed...\n...\n67 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n77 | }\n   |   ^\n\n\
    error: unexpected token: `}`\n  --> /tmp/tmpm4nmzmkn.rs:67:1\n   |\n67 | }\n \
    \  | ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpm4nmzmkn.rs:30:32\n   |\n30 |         row.sort_by_key(|&x|\
    \ x.0);\n   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpm4nmzmkn.rs:31:32\n  \
    \ |\n31 |         row.sort_by_key(|&x| x.1);\n   |                           \
    \     ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpm4nmzmkn.rs:32:32\n   |\n32 |         row.sort_by_key(|&x|\
    \ x.0);\n   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpm4nmzmkn.rs:33:32\n  \
    \ |\n33 |         row.sort_by_key(|&x| x.1);\n   |                           \
    \     ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpm4nmzmkn.rs:34:32\n   |\n34 |         row.sort_by_key(|&x|\
    \ x.0);\n   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpm4nmzmkn.rs:35:32\n  \
    \ |\n35 |         row.sort_by_key(|&x| x.1);\n   |                           \
    \     ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpm4nmzmkn.rs:36:32\n   |\n36 |         row.sort_by_key(|&x|\
    \ x.0);\n   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpm4nmzmkn.rs:37:32\n  \
    \ |\n37 |         row.sort_by_key(|&x| x.1);\n   |                     "
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = Vec::<(isize, isize)>::new();\n    let mut row_sorted =\
    \ Vec::<(isize, isize)>::new();\n    let mut col_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sort_reverse = Vec::<(isize, isize)>::new();\n    let mut row_sort_reverse\
    \ = Vec::<(isize, isize)>::new();\n    let mut col_sort_reverse_2 = Vec::<(isize,\
    \ isize)>::new();\n    let mut col_sort_reverse_3 = Vec::<(isize, isize)>::new();\n\
    \    let mut row_sort_reverse_2 = Vec::<(isize, isize)>::new();\n    let mut row_sort_reverse_3\
    \ = Vec::<(isize, isize)>::new();\n    let mut col_sort_reverse_4 = Vec::<(isize,\
    \ isize)>::new();\n    let mut row_sort_reverse_4 = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sort_reverse_5 = Vec::<(isize, isize)>::new();\n    let mut row_sort_reverse_5\
    \ = Vec::<(isize, isize)>::new();\n    let mut col_sort_reverse_6 = Vec::<(isize,\
    \ isize)>::new();\n    let mut row_sort_reverse_6 = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sort_reverse_7 = Vec::<(isize, isize)>::new();\n    let mut row_sort_reverse_7\
    \ = Vec::<(isize, isize)>::new();\n    let mut col_sort_reverse_8 = Vec::<(isize,\
    \ isize)>::new();\n    let mut row_sort_reverse_8 = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sort_reverse_9 = Vec::<(isize, isize)>::new();\n    let mut row_sort_reverse_9\
    \ = Vec::<(isize, isize)>::new();\n    let mut col_sort_reverse_10 = Vec::<(isize,\
    \ isize)>::new();\n    let mut row_sort_reverse_10 = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sort_reverse_11 = Vec::<(isize, isize)>::new();\n    let mut\
    \ row_sort_reverse_11 = Vec::<(isize, isize)>::new();\n    let mut col_sort_reverse_12\
    \ = Vec::<(isize, isize)>::new();\n    let mut row_sort_reverse_12 = Vec::<(isize,\
    \ isize)>::new();\n    let mut col_sort_reverse_13 = Vec::<(isize, isize)>::new();\n\
    \    let mut row_sort_reverse_13 = Vec::<(i\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpnldzr9qc.rs:45:41\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ closing delimiter possibly meant for this\n...\n45 |     let mut row_sort_reverse_13\
    \ = Vec::<(i\n   |                                         ^ unclosed delimiter\n\
    46 | }\n   | ^ mismatched closing delimiter\n\nerror: expected one of `,`, `:`,\
    \ `=`, or `>`, found `}`\n  --> /tmp/tmpnldzr9qc.rs:46:1\n   |\n46 | }\n   | ^\
    \ expected one of `,`, `:`, `=`, or `>`\n   |\nhelp: you might have meant to end\
    \ the type parameters here\n   |\n46 | }>\n   |  +\n\nerror: aborting due to 2\
    \ previous errors\n\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut col_pos\
    \ = 0;\n    for row in lst {\n        row_len += row.len();\n        if row_len\
    \ == x {\n            row.sort_by(|a, b| a.cmp(b));\n            row.sort_by(|a,\
    \ b| b.cmp(a));\n            row.sort_by(|a, b| b.cmp(a));\n            row.sort_by(|a,\
    \ b| b.cmp(a));\n            row.sort_by(|a, b| b.cmp(a));\n            row.sort_by(|a,\
    \ b| b.cmp(a));\n            row.sort_by(|a, b| b.cmp(a));\n            row.sort_by(|a,\
    \ b| b.cmp(a));\n            row.sort_by(|a, b| b.cmp(a));\n            row.sort_by(|a,\
    \ b| b.cmp(a));\n            row.sort_by(|a, b| b.cmp(a));\n            row.sort_by(|a,\
    \ b| b.cmp(a));\n            row.sort_by(|a, b| b.cmp(a));\n            row.sort_by(|a,\
    \ b| b.cmp(a));\n            row.sort_by(|a, b| b.cmp(a));\n            row.sort_by(|a,\
    \ b| b.cmp(a));\n            row.sort_by(|a, b| b.cmp(a));\n            row.sort_by(|a,\
    \ b| b.cmp(a));\n            row.sort_by(|a, b| b.cmp(a));\n            row.sort_by(|a,\
    \ b| b.cmp(a));\n            row.sort_by(|a, b| b.cmp(a));\n            row.sort_by(|a,\
    \ b| b.cmp(a));\n            row.sort_by(|a, b| b.cmp(a));\n            row.sort_by(|a,\
    \ b| b.cmp(a));\n            row.sort_by(|a, b| b.cmp(a));\n            row.sort_by(|a,\
    \ b| b.cmp(a));\n            row.sort_by(|a, b| b.cmp(a));\n            row.sort_by(|a,\
    \ b| b.cmp(a));\n            row.sort_by(|a, b| b.cmp(a));\n            row.sort_by(|a,\
    \ b| b.cmp(a));\n            row.sort_by(|a, b| b.cmp(a));\n            row.sort_by(|a,\
    \ b| b.cmp(a));\n            row.sort_by(|a, b| b.cmp(a));\n            row.sort_by(|a,\
    \ b| b.cmp(a));\n            row.sort_by(|a, b| b.cmp(a));\n            row.sort_by(|a,\
    \ b| b.cmp(a));\n            row.sort_by(|a, b| b.cmp(a));\n            \n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpxppmc1km.rs:73:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n22 |     for row in lst {\n   |                   \
    \ - unclosed delimiter\n23 |         row_len += row.len();\n24 |         if row_len\
    \ == x {\n   |                         - this delimiter might not be properly\
    \ closed...\n...\n63 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n73 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxppmc1km.rs:24:23\n\
    \   |\n24 |         if row_len == x {\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n24 |         if row_len == x.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxppmc1km.rs:22:5\n   |\n16 |   fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \              ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n22 | /     for row in lst {\n23 | |         row_len += row.len();\n\
    24 | |         if row_len == x {\n25 | |             row.sort_by(|a, b| a.cmp(b));\n\
    ...  |\n72 | |     assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]],\
    \ 3), vec![(2, 2)]);\n73 | | }\n   | |__^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n           found unit\
    \ type `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    let mut rows = lst.len();\n    let\
    \ mut cols = lst[0].len();\n    let mut row_idx = 1;\n    let mut col_idx = 1;\n\
    \    let mut row_max = rows;\n    let mut col_max = cols;\n    while row_idx <\
    \ rows {\n        while col_idx < cols {\n            if lst[row_idx][col_idx]\
    \ == x {\n                result.push((row_idx, col_idx));\n                row_idx\
    \ += 1;\n                col_idx += 1;\n                break;\n            }\n\
    \            col_idx += 1;\n        }\n        if col_idx >= cols {\n        \
    \    col_idx = 1;\n            row_idx += 1;\n        }\n    }\n    result.sort_by_key(|&(x,\
    \ y)| x.0);\n    result.sort_by_key(|&(x, y)| y.0);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpl_3o1t3y.rs:39:36\n   |\n39 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpl_3o1t3y.rs:40:36\n\
    \   |\n40 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl_3o1t3y.rs:41:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n41 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    let mut rows = lst.len();\n\
    \    let mut cols = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    while row_idx < rows && col_idx < cols {\n        if lst[row_idx][col_idx]\
    \ == x {\n            result.push((row_idx, col_idx));\n            row_idx +=\
    \ 1;\n            col_idx += 1;\n        } else {\n            col_idx += 1;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1xw9jxqz.rs:24:26\n   |\n\
    24 |             result.push((row_idx, col_idx));\n   |                      \
    \    ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n24 |     \
    \        result.push((row_idx.try_into().unwrap(), col_idx));\n   |          \
    \                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1xw9jxqz.rs:24:35\n   |\n24 |             result.push((row_idx,\
    \ col_idx));\n   |                                   ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n24 |             result.push((row_idx,\
    \ col_idx.try_into().unwrap()));\n   |                                       \
    \   ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    for row in lst {\n        let mut row\
    \ = row.clone();\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ x.1);\n        for row in row.iter().rev() {\n            if row.0 == x {\n\
    \                result.push((row.0, row.1));\n                break;\n      \
    \      }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmputftgxuy.rs:20:32\n   |\n20 |         row.sort_by_key(|&x| x.0);\n\
    \   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmputftgxuy.rs:21:32\n  \
    \ |\n21 |         row.sort_by_key(|&x| x.1);\n   |                           \
    \     ^\n\nerror[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmputftgxuy.rs:23:20\n\
    \   |\n23 |             if row.0 == x {\n   |                    ^\n\nerror[E0609]:\
    \ no field `0` on type `&isize`\n  --> /tmp/tmputftgxuy.rs:24:34\n   |\n24 | \
    \                result.push((row.0, row.1));\n   |                          \
    \        ^\n\nerror[E0609]: no field `1` on type `&isize`\n  --> /tmp/tmputftgxuy.rs:24:41\n\
    \   |\n24 |                 result.push((row.0, row.1));\n   |               \
    \                          ^\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0609, E0610.\nFor more information about\
    \ an error, try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = vec![];\n    let mut rows = vec![];\n    let mut cols\
    \ = vec![];\n    for row in lst {\n        cols.push(row.len());\n        rows.push(row);\n\
    \    }\n    for row in rows {\n        let mut col_coords = vec![];\n        for\
    \ col in cols {\n            if col == x {\n                col_coords.push((row,\
    \ col));\n            }\n        }\n        coords.sort_by(|a, b| a.1.cmp(&b.1));\n\
    \        coords.sort_by(|a, b| b.1.cmp(&a.1));\n        coords.sort_by(|a, b|\
    \ b.2.cmp(&a.2));\n        coords.sort_by(|a, b| b.1.cmp(&a.1));\n        coords.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n    }\n    coords\n}\n\nfn main() {\n    let candidate =\
    \ get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl2jnx0yl.rs:27:23\n   |\n\
    27 |             if col == x {\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n27 |             if col == x.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0609]: no field\
    \ `1` on type `&_`\n  --> /tmp/tmpl2jnx0yl.rs:31:33\n   |\n31 |         coords.sort_by(|a,\
    \ b| a.1.cmp(&b.1));\n   |                                 ^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0609.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    for row in lst {\n\
    \        let mut row_result = Vec::<(isize, isize)>::new();\n        for col in\
    \ row.iter().rev() {\n            if col == x {\n                row_result.push((col,\
    \ row.len()));\n            }\n        }\n        result.push(row_result);\n \
    \   }\n    result.sort_by_key(|&(_, len)| len.cmp(&x.cmp(&0)).unwrap());\n   \
    \ result.sort_by_key(|&(_, len)| -len.cmp(&x.cmp(&0)).unwrap());\n    result\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcds2rv57.rs:22:34\n   |\n\
    22 |                 row_result.push((col, row.len()));\n   |                \
    \                  ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |                 row_result.push((*col,\
    \ row.len()));\n   |                                  +\n\nerror[E0277]: can't\
    \ compare `&isize` with `isize`\n  --> /tmp/tmpcds2rv57.rs:21:20\n   |\n21 | \
    \            if col == x {\n   |                    ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcds2rv57.rs:22:39\n\
    \   |\n22 |                 row_result.push((col, row.len()));\n   |         \
    \                              ^^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n22 |                 row_result.push((col, row.len().try_into().unwrap()));\n\
    \   |                                                ++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpcds2rv57.rs:25:21\n   |\n25 |  \
    \       result.push(row_result);\n   |                     ^^^^^^^^^^ expected\
    \ tuple, found struct `Vec`\n   |\n   = note: expected tuple `(isize, isize)`\n\
    \             found struct `Vec<(isize, isize)>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcds2rv57.rs:27:44\n   |\n27 |     result.sort_by_key(|&(_, len)|\
    \ len.cmp(&x.cmp(&0)).unwrap());\n   |                                       \
    \     ^^^^^^^^^^ expected `isize`, found enum `std::cmp::Ordering`\n   |\n   =\
    \ note: expected reference `&isize`\n              found reference `&std::cmp::Ordering`\n\
    \nerror[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering` in\
    \ the current scope\n  --> /tmp/tmpcds2rv57.rs:27:5"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    for row in lst {\n\
    \        let mut row_result = Vec::<(isize, isize)>::new();\n        for col in\
    \ row.iter().rev() {\n            if col == x {\n                row_result.push((row,\
    \ col));\n            }\n        }\n        result.push(row_result);\n    }\n\
    \    result.sort_by(|a, b| a.0.cmp(&b.0));\n    result.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsje4pmul.rs:22:34\n   |\n\
    22 |                 row_result.push((row, col));\n   |                      \
    \            ^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected\
    \ type `isize`\n            found struct `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsje4pmul.rs:22:39\n   |\n22 |                 row_result.push((row,\
    \ col));\n   |                                       ^^^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |        \
    \         row_result.push((row, *col));\n   |                                \
    \       +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpsje4pmul.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpsje4pmul.rs:25:21\n   |\n25 |         result.push(row_result);\n   |\
    \                     ^^^^^^^^^^ expected tuple, found struct `Vec`\n   |\n  \
    \ = note: expected tuple `(isize, isize)`\n             found struct `Vec<(isize,\
    \ isize)>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx\
    \ = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n    let mut\
    \ col_len = lst[0].len();\n    while row_idx < row_len {\n        let mut row:\
    \ Vec<(isize, isize)> = Vec::new();\n        let mut col: Vec<(isize, isize)>\
    \ = Vec::new();\n        let mut row_idx = 0;\n        let mut col_idx = 0;\n\
    \        while col_idx < col_len {\n            let mut col: Vec<(isize, isize)>\
    \ = Vec::new();\n            let mut row_idx = 0;\n            while row_idx <\
    \ row_len {\n                let mut col: Vec<(isize, isize)> = Vec::new();\n\
    \                let mut row_idx = 0;\n                while col_idx < col_len\
    \ {\n                    let mut col: Vec<(isize, isize)> = Vec::new();\n    \
    \                let mut row_idx = 0;\n                    while row_idx < row_len\
    \ {\n                        let mut col: Vec<(isize, isize)> = Vec::new();\n\
    \                        let mut row_idx = 0;\n                        while col_idx\
    \ < col_len {\n                            let mut col: Vec<(isize, isize)> =\
    \ Vec::new();\n                            let mut row_idx = 0;\n            \
    \                while row_idx < row_len {\n                                let\
    \ mut col: Vec<(isize, isize)> = Vec::new();\n                               \
    \ let mut row_idx = 0;\n                                while col_idx < col_len\
    \ {\n                                    let mut col: Vec<(isize, isize)> = Vec::new();\n\
    \                                    let mut row_idx = 0;\n                  \
    \                  while row_idx < row_len {\n                               \
    \         let mut col: Vec<(isize, isize)> = Vec::new();\n                   \
    \                     let mut row_idx = 0;\n                                 \
    \       while col_idx < col_len {\n                                          \
    \  let mut col: Vec<(isize, isize)> = Vec::new();\n                          \
    \                  let mut row_idx = 0;\n                                    \
    \        while row_idx < row_len {\n                                         \
    \       let mut col: Vec<(isize, isize)> = Vec::new();\n                     \
    \                           let mut row_idx = 0;\n                           \
    \                     while col_idx < col_len {\n                            \
    \                        let mut col: Vec<(isize, isize)> = Vec::new();\n    \
    \                                                let mut row_idx = 0;\n      \
    \                                              while row_idx < row_len {\n   \
    \                                                     let \n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpcmpmx1sf.rs:72:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n22 |     while row_idx < row_len {\n   |          \
    \                   - unclosed delimiter\n...\n27 |         while col_idx < col_len\
    \ {\n   |                                 - unclosed delimiter\n...\n30 |    \
    \         while row_idx < row_len {\n   |                                    \
    \ - unclosed delimiter\n...\n33 |                 while col_idx < col_len {\n\
    \   |                                         - unclosed delimiter\n...\n36 |\
    \                     while row_idx < row_len {\n   |                        \
    \                     - unclosed delimiter\n...\n39 |                        \
    \ while col_idx < col_len {\n   |                                            \
    \     - unclosed delimiter\n...\n42 |                             while row_idx\
    \ < row_len {\n   |                                                     - unclosed\
    \ delimiter\n...\n45 |                                 while col_idx < col_len\
    \ {\n   |                                                         - unclosed delimiter\n\
    ...\n48 |                                     while row_idx < row_len {\n   |\
    \                                                             - unclosed delimiter\n\
    ...\n51 |                                         while col_idx < col_len {\n\
    \   |                                                                 - unclosed\
    \ delimiter\n...\n54 |                                             while row_idx\
    \ < row_len {\n   |                                                          \
    \           - unclosed delimiter\n...\n57 |                                  \
    \               while col_idx < col_len {\n   |                              \
    \                                           - unclosed delimiter\n...\n60 |  \
    \                                                   while row_idx < row_len {\n\
    \   |                                                                "
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_idx2 = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4\
    \ = 0;\n    let mut row_idx5 = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7\
    \ = 0;\n    let mut row_idx8 = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10\
    \ = 0;\n    let mut row_idx11 = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13\
    \ = 0;\n    let mut row_idx14 = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16\
    \ = 0;\n    let mut row_idx17 = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19\
    \ = 0;\n    let mut row_idx20 = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22\
    \ = 0;\n    let mut row_idx23 = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25\
    \ = 0;\n    let mut row_idx26 = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28\
    \ = 0;\n    let mut row_idx29 = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31\
    \ = 0;\n    let mut row_idx32 = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34\
    \ = 0;\n    let mut row_idx35 = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37\
    \ = 0;\n    let mut row_idx38 = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40\
    \ = 0;\n    let mut row_idx41 = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43\
    \ = 0;\n    let mut row_idx44 = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46\
    \ = 0;\n    let mut row_idx47 = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49\
    \ = 0;\n    let mut row_idx50 = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52\
    \ = 0;\n    let mut row_idx53 = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55\
    \ = 0;\n    let mut row_idx56 = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58\
    \ = 0;\n    let mut row_idx59 = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61\
    \ = 0;\n    let mut row_idx62 = 0;\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpy0j02d22.rs:81:1\n\
    \   |\n81 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        vec![]\n    } else {\n        let mut row\
    \ = vec![];\n        let mut row_idx = 1;\n        let mut row_len = lst.len();\n\
    \        let mut col_len = lst.first().len();\n        let mut col_pos = 0;\n\
    \        let mut col_max_pos = col_len;\n        let mut row_max_pos = row_len;\n\
    \        let mut row_min_pos = row_len;\n        let mut col_min_pos = col_len;\n\
    \        let mut col_max_val = lst.first().iter().max().unwrap();\n        let\
    \ mut row_max_val = lst.iter().max().unwrap();\n        let mut row_min_val =\
    \ lst.iter().min().unwrap();\n        let mut col_min_val = lst.first().iter().min().unwrap();\n\
    \        let mut col_max_val_pos = col_len;\n        let mut row_max_val_pos =\
    \ row_len;\n        let mut col_min_val_pos = col_len;\n        let mut col_max_val_val\
    \ = lst.first().iter().max().unwrap();\n        let mut row_max_val_val = lst.iter().max().unwrap();\n\
    \        let mut row_min_val_val = lst.iter().min().unwrap();\n        let mut\
    \ col_min_val_val = lst.first().iter().min().unwrap();\n        let mut col_max_val_val_pos\
    \ = col_len;\n        let mut row_max_val_val_pos = row_len;\n        let mut\
    \ col_min_val_val_pos = col_len;\n        let mut col_max_val_val_val = lst.first().iter().max().unwrap();\n\
    \        let mut row_max_val_val_val = lst.iter().max().unwrap();\n        let\
    \ mut row_min_val_val_val = lst.iter().min().unwrap();\n        let mut col_min_val_val_val\
    \ = lst.first().iter().min().unwrap();\n        let mut col_max_val_val_val_pos\
    \ = col_len;\n        let mut row_max_val_val_val_pos = row_len;\n        let\
    \ mut col_min_val_val_val_pos = col_len;\n        let mut col_max_val_val_val_val\
    \ = lst.first().iter().max().unwrap();\n        let mut row_max_val_val_val_val\
    \ = lst.iter().max().unwrap();\n        let mut row_min_val_val_val_val = lst.iter().min().unwrap();\n\
    \        let mut col_min_val_val_val_val = lst.first().iter().min().unwrap();\n\
    \        let mut col_max_val_val_val_val_pos = col_len;\n        let mut row_max_val_val_val_val_pos\
    \ = row_len;\n        let mut col_min_val_val_val_val_pos = col_len;\n\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpq9cpqjtq.rs:68:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n19 |     } else {\n   |            - this delimiter\
    \ might not be properly closed...\n...\n58 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n68 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq9cpqjtq.rs:18:9\n   |\n17 | /     if lst.is_empty() {\n\
    18 | |         vec![]\n   | |         ^^^^^^ expected `()`, found struct `Vec`\n\
    19 | |     } else {\n20 | |         let mut row = vec![];\n...  |\n57 | |\n58\
    \ | | }\n   | |_- expected this to be `()`\n   |\n   = note: expected unit type\
    \ `()`\n                 found struct `Vec<_>`\n   = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\nhelp: consider using a semicolon here\n   |\n58 | };\n   |  +\n\nerror[E0599]:\
    \ no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmpq9cpqjtq.rs:23:39\n\
    \   |\n23 |         let mut col_len = lst.first().len();\n   |               \
    \                        ^^^ method not found in `Option<&Vec<isize>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq9cpqjtq.rs:16:47\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |    -------       \
    \                             ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \           found unit type `()`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = Vec::<(isize, isize)>::new();\n    for row in lst {\n \
    \       let mut col = Vec::<isize>::new();\n        for col in row {\n       \
    \     if col == x {\n                col.push(x);\n                break;\n  \
    \          }\n        }\n        row.push(col);\n    }\n    row.sort_by_key(|&(_,\
    \ y)| y.reverse());\n    row.sort_by_key(|&(_, y)| y.reverse());\n    row\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp_jk36pp4.rs:22:21\n   |\n22 |                 col.push(x);\n\
    \   |                     ^^^^ method not found in `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_jk36pp4.rs:26:18\n   |\n26 |         row.push(col);\n\
    \   |                  ^^^ expected `isize`, found struct `Vec`\n   |\n   = note:\
    \ expected type `isize`\n            found struct `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `reverse` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmp_jk36pp4.rs:28:33\n   |\n28 |     row.sort_by_key(|&(_, y)| y.reverse());\n\
    \   |                                 ^^^^^^^ help: there is an associated function\
    \ with a similar name: `reverse_bits`\n\nerror[E0599]: no method named `reverse`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmp_jk36pp4.rs:29:33\n\
    \   |\n29 |     row.sort_by_key(|&(_, y)| y.reverse());\n   |                \
    \                 ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reverse_bits`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut col_num = 0;\n    let mut col_max = 0;\n    let mut row_max = 0;\n\
    \    let mut row_idx2 = 0;\n    let mut col_num2 = 0;\n    let mut col_max2 =\
    \ 0;\n    let mut row_idx3 = 0;\n    let mut col_num3 = 0;\n    let mut col_max3\
    \ = 0;\n    let mut row_idx4 = 0;\n    let mut col_num4 = 0;\n    let mut col_max4\
    \ = 0;\n    for row in lst {\n        row_max = row.len();\n        row_idx =\
    \ 0;\n        col_num = 0;\n        col_max = 0;\n        for col in row {\n \
    \           col_max = col.len();\n            col_num = 0;\n            col_max\
    \ = 0;\n            for (idx, val) in col.iter().enumerate() {\n             \
    \   if val == x {\n                    row_idx2 = row_idx;\n                 \
    \   col_num2 = col_num;\n                    col_max2 = col_max;\n           \
    \         row_idx3 = row_idx2;\n                    col_num3 = col_num2;\n   \
    \                 col_max3 = col_max2;\n                    row_idx4 = row_idx3;\n\
    \                    col_num4 = col_num3;\n                    col_max4 = col_max3;\n\
    \                    row.insert(idx, (row_idx4, col_num4));\n                \
    \    row.insert(idx, (row_idx3, col_num3));\n                    row.insert(idx,\
    \ (row_idx2, col_num2));\n                    row.insert(idx, (row_idx, col_num));\n\
    \                    row_idx += 1;\n                    col_num += 1;\n      \
    \              col_max += 1;\n                }\n            }\n            col_num\
    \ += 1;\n            col_max += 1;\n        }\n        row_idx += 1;\n       \
    \ col_num += 1;\n        row_max += 1;\n        row.insert(0, (row_idx, col_num));\n\
    \        row.insert(0, (row_max, col_max));\n        row.insert(0, (row_idx, col_num));\n\
    \        row.insert(0, (row_max, col_max));\n    }\n    row\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp7hps8j1u.rs:37:27\n   |\n37 |             col_max = col.len();\n\
    \   |                           ^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `iter` found for type `isize` in the current scope\n  --> /tmp/tmp7hps8j1u.rs:40:35\n\
    \   |\n40 |             for (idx, val) in col.iter().enumerate() {\n   |     \
    \                              ^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7hps8j1u.rs:51:37\n   |\n51 |              \
    \       row.insert(idx, (row_idx4, col_num4));\n   |                         \
    \            ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found tuple\n   |\n   = note:\
    \ expected type `isize`\n             found tuple `({integer}, {integer})`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp7hps8j1u.rs:52:37\n   |\n52 |  \
    \                   row.insert(idx, (row_idx3, col_num3));\n   |             \
    \                        ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found tuple\n\
    \   |\n   = note: expected type `isize`\n             found tuple `({integer},\
    \ {integer})`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7hps8j1u.rs:53:37\n\
    \   |\n53 |                     row.insert(idx, (row_idx2, col_num2));\n   | \
    \                                    ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ tuple\n   |\n   = note: expected type `isize`\n             found tuple `({integer},\
    \ {integer})`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7hps8j1u.rs:54:37\n\
    \   |\n54 |                     row.insert(idx, (row_idx, col_num));\n   |   \
    \                                  ^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ tuple\n   |\n   = note: expected type `isize`\n             found tuple `({integer},\
    \ {integer})`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7hps8j1u.rs:66:23\n\
    \   |\n66 |         row.insert(0, (row_idx, col_num));\n   |                 \
    \      ^^^^^^^^^^^^^^^^^^ expected `isize`, found tuple\n   |\n   = note: expected\
    \ type `isize`\n             found tuple `({integer}, {integer})`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7hps"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_idx2 = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4\
    \ = 0;\n    let mut row_idx5 = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7\
    \ = 0;\n    let mut row_idx8 = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10\
    \ = 0;\n    let mut row_idx11 = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13\
    \ = 0;\n    let mut row_idx14 = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16\
    \ = 0;\n    let mut row_idx17 = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19\
    \ = 0;\n    let mut row_idx20 = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22\
    \ = 0;\n    let mut row_idx23 = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25\
    \ = 0;\n    let mut row_idx26 = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28\
    \ = 0;\n    let mut row_idx29 = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31\
    \ = 0;\n    let mut row_idx32 = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34\
    \ = 0;\n    let mut row_idx35 = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37\
    \ = 0;\n    let mut row_idx38 = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40\
    \ = 0;\n    let mut row_idx41 = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43\
    \ = 0;\n    let mut row_idx44 = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46\
    \ = 0;\n    let mut row_idx47 = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49\
    \ = 0;\n    let mut row_idx50 = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52\
    \ = 0;\n    let mut row_idx53 = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55\
    \ = 0;\n    let mut row_idx56 = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58\
    \ = 0;\n    let mut row_idx59 = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61\
    \ = 0;\n    let mut row_idx62 = 0;\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpy0j02d22.rs:81:1\n\
    \   |\n81 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut result = Vec::new();\n    let mut row_idx = 1;\n    let mut col_idx = 1;\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    while\
    \ row_idx < rows {\n        let mut row_sorted = vec![];\n        let mut col_sorted\
    \ = vec![];\n        while col_idx < cols {\n            if row_idx < rows &&\
    \ col_idx < cols {\n                if lst[row_idx][col_idx] == x {\n        \
    \            row_sorted.push((row_idx, col_idx));\n                    col_sorted.push((row_idx,\
    \ col_idx));\n                }\n                col_idx += 1;\n            }\n\
    \            col_idx += 1;\n        }\n        row_idx += 1;\n        result.push(row_sorted);\n\
    \        result.push(col_sorted);\n    }\n    result.sort_by_key(|&(_, y)| y.0);\n\
    \    result.sort_by_key(|&(_, y)| y.1);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc2wmgp9p.rs:41:26\n   |\n\
    41 |     result.sort_by_key(|&(_, y)| y.0);\n   |                          ^^^^^-\n\
    \   |                          |    |\n   |                          |    expected\
    \ due to this\n   |                          expected struct `Vec`, found tuple\n\
    \   |\n   = note: expected struct `Vec<(usize, usize)>`\n               found\
    \ tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc2wmgp9p.rs:42:26\n\
    \   |\n42 |     result.sort_by_key(|&(_, y)| y.1);\n   |                     \
    \     ^^^^^-\n   |                          |    |\n   |                     \
    \     |    expected due to this\n   |                          expected struct\
    \ `Vec`, found tuple\n   |\n   = note: expected struct `Vec<(usize, usize)>`\n\
    \               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpc2wmgp9p.rs:43:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |                                             \
    \  ------------------- expected `Vec<(isize, isize)>` because of return type\n\
    ...\n43 |     result\n   |     ^^^^^^ expected tuple, found struct `Vec`\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst.clone();\n    let mut rows = lst.len();\n    let mut\
    \ cols = lst[0].len();\n    let mut coords = Vec::new();\n    while rows > 0 ||\
    \ cols > 0 {\n        if rows > 0 {\n            let mut row = lst[rows].clone();\n\
    \            let mut cols = row.len();\n            while cols > 0 {\n       \
    \         let mut col = row[cols].clone();\n                while col > x {\n\
    \                    col -= 1;\n                }\n                coords.push((rows,\
    \ cols));\n                col -= 1;\n            }\n            rows += 1;\n\
    \        }\n        if cols > 0 {\n            let mut row = lst[rows].clone();\n\
    \            let mut cols = row.len();\n            while cols > 0 {\n       \
    \         let mut col = row[cols].clone();\n                while col > x {\n\
    \                    col -= 1;\n                }\n                coords.push((rows,\
    \ cols));\n                col -= 1;\n            }\n            cols += 1;\n\
    \        }\n    }\n    coords.sort_by_key(|&(x, y)| x.0);\n    coords.sort_by_key(|&(x,\
    \ y)| y.0);\n    coords.iter().map(|&(x, y)| {\n        (x, y)\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp303qbukq.rs:49:36\n   |\n49 |     coords.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmp303qbukq.rs:50:36\n\
    \   |\n50 |     coords.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0277]: a value of type `Vec<(isize, isize)>` cannot\
    \ be built from an iterator over elements of type `(usize, usize)`\n    --> /tmp/tmp303qbukq.rs:53:8\n\
    \     |\n53   |     }).collect()\n     |        ^^^^^^^ value of type `Vec<(isize,\
    \ isize)>` cannot be built from `std::iter::Iterator<Item=(usize, usize)>`\n \
    \    |\n     = help: the trait `FromIterator<(usize, usize)>` is not implemented\
    \ for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0610.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_idx2 = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4\
    \ = 0;\n    let mut row_idx5 = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7\
    \ = 0;\n    let mut row_idx8 = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10\
    \ = 0;\n    let mut row_idx11 = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13\
    \ = 0;\n    let mut row_idx14 = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16\
    \ = 0;\n    let mut row_idx17 = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19\
    \ = 0;\n    let mut row_idx20 = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22\
    \ = 0;\n    let mut row_idx23 = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25\
    \ = 0;\n    let mut row_idx26 = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28\
    \ = 0;\n    let mut row_idx29 = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31\
    \ = 0;\n    let mut row_idx32 = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34\
    \ = 0;\n    let mut row_idx35 = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37\
    \ = 0;\n    let mut row_idx38 = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40\
    \ = 0;\n    let mut row_idx41 = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43\
    \ = 0;\n    let mut row_idx44 = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46\
    \ = 0;\n    let mut row_idx47 = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49\
    \ = 0;\n    let mut row_idx50 = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52\
    \ = 0;\n    let mut row_idx53 = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55\
    \ = 0;\n    let mut row_idx56 = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58\
    \ = 0;\n    let mut row_idx59 = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61\
    \ = 0;\n    let mut row_idx62 = 0;\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpy0j02d22.rs:81:1\n\
    \   |\n81 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut col_pos = 0;\n\
    \    let mut row_pos = 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n\
    \    let mut col_pos = 0;\n    let mut row_pos = 0;\n    let mut row_len = 0;\n\
    \    let mut col_len = 0;\n    let mut col_pos = 0;\n    let mut row_pos = 0;\n\
    \    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut col_pos = 0;\n\
    \    let mut row_pos = 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n\
    \    let mut col_pos = 0;\n    let mut row_pos = 0;\n    let mut row_len = 0;\n\
    \    let mut col_len = 0;\n    let mut col_pos = 0;\n    let mut row_pos = 0;\n\
    \    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut col_pos = 0;\n\
    \    let mut row_pos = 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n\
    \    let mut col_pos = 0;\n    let mut row_pos = 0;\n    let mut row_len = 0;\n\
    \    let mut col_len = 0;\n    let mut col_pos = 0;\n    let mut row_pos = 0;\n\
    \    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut col_pos = 0;\n\
    \    let mut row_pos = 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n\
    \    let mut col_pos = 0;\n    let mut row_pos = 0;\n    let mut row_len = 0;\n\
    \    let mut col_len = 0;\n    let mut col_pos = 0;\n    let mut row_pos = 0;\n\
    \    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut col_pos = 0;\n\
    \    let mut row_pos = 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n\
    \    let mut col_pos = 0;\n    let mut row_pos = 0;\n    let mut row_len = 0;\n\
    \    let mut col_len = 0;\n    let mut col_pos = 0;\n    let mut row_pos = 0;\n\
    \    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut col_pos = 0;\n\
    \    let mut row_pos = 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n\
    \    let mut col_pos = 0;\n    let mut row_pos = 0;\n    let mut row_len = 0;\n\
    \    let mut col_len\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9voiidv9.rs:88:20\n   |\n\
    88 |     let mut col_len\n   |                    ^ help: add `;` here\n89 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9voiidv9.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sort = vec![];\n    let mut col_sort = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let\
    \ mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut\
    \ col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx\
    \ = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n\
    \    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let\
    \ mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut\
    \ row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let\
    \ mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut\
    \ col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx\
    \ = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n\
    \    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let\
    \ mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut\
    \ row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let\
    \ mut col_sort_idx = vec![];\n    let mut row_sort_\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxyco2bh0.rs:68:22\n   |\n\
    68 |     let mut row_sort_\n   |                      ^ help: add `;` here\n69\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxyco2bh0.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = vec![];\n    let mut cols = vec![];\n    for row in lst\
    \ {\n        cols.clear();\n        for col in row {\n            if col == x\
    \ {\n                cols.push((row, col));\n            }\n        }\n      \
    \  rows.push(cols);\n    }\n    rows.sort_by(|a, b| a.iter().cmp(b.iter()).reverse());\n\
    \    rows.sort_by(|a, b| b.iter().cmp(a.iter()).reverse());\n    rows\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxgxad1fh.rs:30:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n30 |     rows\n   |     ^^^^ expected\
    \ tuple, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<(Vec<isize>, isize)>>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = vec![];\n    let mut rows = vec![];\n    for row in\
    \ lst {\n        let mut cols = vec![];\n        for col in row {\n          \
    \  if col == x {\n                cols.push((row, col));\n            }\n    \
    \    }\n        rows.push(cols);\n    }\n    coords.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    rows.sort_by(|a, b| b.0.cmp(&a.0));\n    coords\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmpse_7ljn0.rs:28:21\n\
    \   |\n28 |     coords.sort_by(|a, b| a.0.cmp(&b.0));\n   |                  \
    \   ^ consider giving this closure parameter the explicit type `&T`, where the\
    \ type parameter `T` is specified\n   |\n   = note: type must be known at this\
    \ point\n\nerror[E0609]: no field `0` on type `&_`\n  --> /tmp/tmpse_7ljn0.rs:28:29\n\
    \   |\n28 |     coords.sort_by(|a, b| a.0.cmp(&b.0));\n   |                  \
    \           ^\n\nerror[E0609]: no field `0` on type `&Vec<(Vec<isize>, isize)>`\n\
    \  --> /tmp/tmpse_7ljn0.rs:29:27\n   |\n29 |     rows.sort_by(|a, b| b.0.cmp(&a.0));\n\
    \   |                           ^ unknown field\n\nerror[E0609]: no field `0`\
    \ on type `&Vec<(Vec<isize>, isize)>`\n  --> /tmp/tmpse_7ljn0.rs:29:36\n   |\n\
    29 |     rows.sort_by(|a, b| b.0.cmp(&a.0));\n   |                           \
    \         ^ unknown field\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0282, E0609.\nFor more information about\
    \ an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut row_idx2 = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4 =\
    \ 0;\n    let mut row_idx5 = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7\
    \ = 0;\n    let mut row_idx8 = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10\
    \ = 0;\n    let mut row_idx11 = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13\
    \ = 0;\n    let mut row_idx14 = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16\
    \ = 0;\n    let mut row_idx17 = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19\
    \ = 0;\n    let mut row_idx20 = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22\
    \ = 0;\n    let mut row_idx23 = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25\
    \ = 0;\n    let mut row_idx26 = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28\
    \ = 0;\n    let mut row_idx29 = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31\
    \ = 0;\n    let mut row_idx32 = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34\
    \ = 0;\n    let mut row_idx35 = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37\
    \ = 0;\n    let mut row_idx38 = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40\
    \ = 0;\n    let mut row_idx41 = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43\
    \ = 0;\n    let mut row_idx44 = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46\
    \ = 0;\n    let mut row_idx47 = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49\
    \ = 0;\n    let mut row_idx50 = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52\
    \ = 0;\n    let mut row_idx53 = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55\
    \ = 0;\n    let mut row_idx56 = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58\
    \ = 0;\n    let mut row_idx59 = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61\
    \ = 0;\n    let mut row_idx62 = 0;\n    let mut row_\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwcu_1gxu.rs:80:17\n   |\n\
    80 |     let mut row_\n   |                 ^ help: add `;` here\n81 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwcu_1gxu.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n    for row_idx in 0..lst.len()\
    \ {\n        let row_len = lst[row_idx].len();\n        for col_len in 0..row_len\
    \ {\n            if row_idx == col_len {\n                row.push((row_idx, col_len));\n\
    \            }\n        }\n    }\n    row.sort_by_key(|&(x, y)| x.0);\n    row.sort_by_key(|&(x,\
    \ y)| y.0);\n    row.sort_by_key(|&(x, y)| x.1);\n    row.sort_by_key(|&(x, y)|\
    \ y.1);\n    row\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpejrybpbg.rs:25:27\n   |\n\
    25 |                 row.push((row_idx, col_len));\n   |                     \
    \      ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n25\
    \ |                 row.push((row_idx.try_into().unwrap(), col_len));\n   |  \
    \                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpejrybpbg.rs:25:36\n   |\n25 |                 row.push((row_idx,\
    \ col_len));\n   |                                    ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |                 row.push((row_idx,\
    \ col_len.try_into().unwrap()));\n   |                                       \
    \    ++++++++++++++++++++\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmpejrybpbg.rs:29:33\n   |\n29 |     row.sort_by_key(|&(x,\
    \ y)| x.0);\n   |                                 ^\n\nerror[E0610]: `isize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpejrybpbg.rs:30:33\n\
    \   |\n30 |     row.sort_by_key(|&(x, y)| y.0);\n   |                        \
    \         ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpejrybpbg.rs:31:33\n   |\n31 |     row.sort_by_key(|&(x,\
    \ y)| x.1);\n   |                                 ^\n\nerror[E0610]: `isize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpejrybpbg.rs:32:33\n\
    \   |\n32 |     row.sort_by_key(|&(x, y)| y.1);\n   |                        \
    \         ^\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0610.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_idx2 = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4\
    \ = 0;\n    let mut row_idx5 = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7\
    \ = 0;\n    let mut row_idx8 = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10\
    \ = 0;\n    let mut row_idx11 = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13\
    \ = 0;\n    let mut row_idx14 = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16\
    \ = 0;\n    let mut row_idx17 = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19\
    \ = 0;\n    let mut row_idx20 = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22\
    \ = 0;\n    let mut row_idx23 = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25\
    \ = 0;\n    let mut row_idx26 = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28\
    \ = 0;\n    let mut row_idx29 = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31\
    \ = 0;\n    let mut row_idx32 = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34\
    \ = 0;\n    let mut row_idx35 = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37\
    \ = 0;\n    let mut row_idx38 = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40\
    \ = 0;\n    let mut row_idx41 = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43\
    \ = 0;\n    let mut row_idx44 = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46\
    \ = 0;\n    let mut row_idx47 = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49\
    \ = 0;\n    let mut row_idx50 = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52\
    \ = 0;\n    let mut row_idx53 = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55\
    \ = 0;\n    let mut row_idx56 = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58\
    \ = 0;\n    let mut row_idx59 = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61\
    \ = 0;\n    let mut row_idx62 = 0;\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpy0j02d22.rs:81:1\n\
    \   |\n81 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_idx2 = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4\
    \ = 0;\n    let mut row_idx5 = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7\
    \ = 0;\n    let mut row_idx8 = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10\
    \ = 0;\n    let mut row_idx11 = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13\
    \ = 0;\n    let mut row_idx14 = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16\
    \ = 0;\n    let mut row_idx17 = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19\
    \ = 0;\n    let mut row_idx20 = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22\
    \ = 0;\n    let mut row_idx23 = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25\
    \ = 0;\n    let mut row_idx26 = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28\
    \ = 0;\n    let mut row_idx29 = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31\
    \ = 0;\n    let mut row_idx32 = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34\
    \ = 0;\n    let mut row_idx35 = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37\
    \ = 0;\n    let mut row_idx38 = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40\
    \ = 0;\n    let mut row_idx41 = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43\
    \ = 0;\n    let mut row_idx44 = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46\
    \ = 0;\n    let mut row_idx47 = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49\
    \ = 0;\n    let mut row_idx50 = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52\
    \ = 0;\n    let mut row_idx53 = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55\
    \ = 0;\n    let mut row_idx56 = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58\
    \ = 0;\n    let mut row_idx59 = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61\
    \ = 0;\n    let mut row_idx62 = 0;\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpy0j02d22.rs:81:1\n\
    \   |\n81 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut result = vec![];\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n \
    \   while col_idx < cols {\n        if row_idx == rows {\n            break;\n\
    \        }\n        let mut row_idx = row_idx;\n        let mut col_idx = col_idx;\n\
    \        let mut row_max = row_idx;\n        let mut col_max = col_idx;\n    \
    \    while row_idx < rows {\n            let mut row_idx = row_idx;\n        \
    \    let mut col_idx = col_idx;\n            while col_idx < cols {\n        \
    \        if row_idx == rows {\n                    break;\n                }\n\
    \                if row_idx < rows && col_idx < cols {\n                    if\
    \ lst[row_idx][col_idx] == x {\n                        row_max = row_idx;\n \
    \                       col_max = col_idx;\n                    }\n          \
    \      }\n                col_idx += 1;\n            }\n            row_idx +=\
    \ 1;\n        }\n        result.push((row_max, col_max));\n    }\n    result.sort_by_key(|&(x,\
    \ y)| x.0);\n    result.sort_by_key(|&(x, y)| y.0);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpn4skgd_n.rs:49:36\n   |\n49 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpn4skgd_n.rs:50:36\n\
    \   |\n50 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn4skgd_n.rs:51:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n51 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = Vec::<(isize, isize)>::new();\n    let mut row_idx = 1;\n\
    \    let mut col_count = 1;\n    let mut col_pos = 0;\n    let mut row_pos = 0;\n\
    \    let mut col_max = lst[0].len();\n    for col in lst {\n        if col_pos\
    \ < col_max {\n            row.push((row_idx, col_pos));\n            row_idx\
    \ += 1;\n            col_pos += 1;\n        } else {\n            col_pos = 0;\n\
    \            col_count += 1;\n        }\n    }\n    row.sort_by_key(|&(x, y)|\
    \ x.0);\n    row.sort_by_key(|&(x, y)| y.0);\n    row.sort_by_key(|&(x, y)| x.1);\n\
    \    row.iter().map(|&(x, y)| x).collect()\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuh4majn5.rs:25:32\n   |\n\
    25 |             row.push((row_idx, col_pos));\n   |                         \
    \       ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n25\
    \ |             row.push((row_idx, col_pos.try_into().unwrap()));\n   |      \
    \                                 ++++++++++++++++++++\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpuh4majn5.rs:33:33\n\
    \   |\n33 |     row.sort_by_key(|&(x, y)| x.0);\n   |                        \
    \         ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpuh4majn5.rs:34:33\n   |\n34 |     row.sort_by_key(|&(x,\
    \ y)| y.0);\n   |                                 ^\n\nerror[E0610]: `isize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpuh4majn5.rs:35:33\n\
    \   |\n35 |     row.sort_by_key(|&(x, y)| x.1);\n   |                        \
    \         ^\n\nerror[E0277]: a value of type `Vec<(isize, isize)>` cannot be built\
    \ from an iterator over elements of type `isize`\n    --> /tmp/tmpuh4majn5.rs:36:33\n\
    \     |\n36   |     row.iter().map(|&(x, y)| x).collect()\n     |            \
    \                     ^^^^^^^ value of type `Vec<(isize, isize)>` cannot be built\
    \ from `std::iter::Iterator<Item=isize>`\n     |\n     = help: the trait `FromIterator<isize>`\
    \ is not implemented for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0610.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    let mut row_idx = 1;\n    let mut col_idx\
    \ = 1;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    while row_idx < row_len {\n        let mut row_start = row_idx;\n       \
    \ let mut row_end = row_idx;\n        let mut col_start = col_idx;\n        let\
    \ mut col_end = col_idx;\n        while col_start < col_end {\n            if\
    \ row_start == row_end {\n                row_end = row_start + 1;\n         \
    \       col_end = col_start + 1;\n            } else {\n                row_end\
    \ = row_end;\n                col_end = col_end;\n            }\n            if\
    \ row_start == row_end {\n                row_start = row_start + 1;\n       \
    \         col_start = col_start + 1;\n            } else {\n                row_start\
    \ = row_start;\n                col_start = col_start;\n            }\n      \
    \  }\n        let mut row_tuple = (row_start, row_idx);\n        let mut col_tuple\
    \ = (col_idx, col_start);\n        result.push((row_tuple, col_tuple));\n    \
    \    col_idx += 1;\n    }\n    result.sort_by_key(|&(_, y)| y.0);\n    result.sort_by_key(|&(_,\
    \ y)| y.1);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr4f942oi.rs:50:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n50 |     result\n   |     ^^^^^^ expected\
    \ `isize`, found tuple\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<((usize, usize), ({integer}, {integer}))>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = Vec::new();\n    let mut row_coords = Vec::new();\n    let mut\
    \ col_coords = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted_idx = Vec::new();\n    let\
    \ mut col_sorted_idx = Vec::new();\n    let mut row_sorted_idx_last = Vec::new();\n\
    \    let mut col_sorted_idx_last = Vec::new();\n    let mut row_sorted_idx_last_idx\
    \ = Vec::new();\n    let mut col_sorted_idx_last_idx = Vec::new();\n    let mut\
    \ row_sorted_idx_last_idx_last = Vec::new();\n    let mut col_sorted_idx_last_idx_last\
    \ = Vec::new();\n    let mut row_sorted_idx_last_idx_last_idx = Vec::new();\n\
    \    let mut col_sorted_idx_last_idx_last_idx = Vec::new();\n    let mut row_sorted_idx_last_idx_last_idx_last\
    \ = Vec::new();\n    let mut col_sorted_idx_last_idx_last_idx_last = Vec::new();\n\
    \    let mut row_sorted_idx_last_idx_last_idx_last_idx = Vec::new();\n    let\
    \ mut col_sorted_idx_last_idx_last_idx_last_idx = Vec::new();\n    let mut row_sorted_idx_last_idx_last_idx_last_idx_last\
    \ = Vec::new();\n    let mut col_sorted_idx_last_idx_last_idx_last_idx_last =\
    \ Vec::new();\n    let mut row_sorted_idx_last_idx_last_idx_last_idx_last_idx\
    \ = Vec::new();\n    let mut col_sorted_idx_last_idx_last_idx_last_idx_last_idx\
    \ = Vec::new();\n    let mut row_sorted_idx_last_idx_last_idx_last_idx_last_idx_last\
    \ = Vec::new();\n    let mut col_sorted_idx_last_idx_last_idx_last_idx_last_idx_last\
    \ = Vec::new();\n    let mut row_sorted_idx_last_idx_last_idx_last_idx_last_idx_last_idx\
    \ = Vec::new();\n    let mut col_sorted_idx_last_idx_last_idx_last_idx_last_idx_last_idx\
    \ = Vec::new();\n    let mut row_sorted_idx_last_idx_last_idx_last_idx_last_idx_last_idx_last\
    \ = Vec::new();\n    let mut col_sorted_idx_last_idx_last_idx_last_idx_last_idx_last_idx_last\
    \ = Vec::new();\n    let mut row_sorted_idx_last_idx_last_idx_last_idx_last_idx_last_idx_last_idx\
    \ = Vec::new();\n    let mut col_sorted_idx_last_idx_last_idx_last_idx_last_idx_last_idx_last_idx\
    \ = Vec::new\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdchzdx1f.rs:49:92\n   |\n\
    49 |     let mut col_sorted_idx_last_idx_last_idx_last_idx_last_idx_last_idx_last_idx\
    \ = Vec::new\n   |                                                           \
    \                                 ^ help: add `;` here\n50 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdchzdx1f.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    let mut rows = lst.len();\n    let\
    \ mut cols = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n\
    \    while col_idx < cols {\n        if row_idx == rows {\n            break;\n\
    \        }\n        let mut row_start = row_idx;\n        let mut row_end = row_idx;\n\
    \        let mut col_start = col_idx;\n        let mut col_end = col_idx;\n  \
    \      while row_end < rows && col_end < cols {\n            if row_end == rows\
    \ {\n                row_end += 1;\n            }\n            if col_end == cols\
    \ {\n                col_end += 1;\n            }\n            if row_start ==\
    \ row_end {\n                row_start += 1;\n            }\n            if col_start\
    \ == col_end {\n                col_start += 1;\n            }\n            if\
    \ row_start <= row_end && col_start <= col_end {\n                if lst[row_start][col_start]\
    \ == x {\n                    result.push((row_start, col_start));\n         \
    \       }\n                row_end += 1;\n                col_end += 1;\n    \
    \        }\n        }\n        row_idx += 1;\n        col_idx += 1;\n    }\n \
    \   result.sort_by_key(|&(x, y)| x.0);\n    result.sort_by_key(|&(x, y)| y.0);\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpj5hgnzpm.rs:54:36\n   |\n54 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpj5hgnzpm.rs:55:36\n\
    \   |\n55 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj5hgnzpm.rs:56:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n56 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut col_idx = 0;\n    let mut row_len = lst.len();\n    let mut col_len\
    \ = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let\
    \ mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n    let mut row_idx\
    \ = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n    let mut\
    \ col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n\
    \    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n    let\
    \ mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n\
    \    let mut col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n\
    \    let mut col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n\
    \    let mut col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n\
    \    let mut col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n\
    \    let mut col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = \n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpr0gsusye.rs:77:1\n\
    \   |\n77 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_idx_max = 0;\n    let mut row_idx_min = 0;\n    let mut\
    \ col_max = 0;\n    let mut col_min = 0;\n    let mut col_max_idx = 0;\n    let\
    \ mut col_min_idx = 0;\n    let mut col_max_idx2 = 0;\n    let mut col_min_idx2\
    \ = 0;\n    let mut col_max_idx3 = 0;\n    let mut col_min_idx3 = 0;\n    let\
    \ mut col_max_idx4 = 0;\n    let mut col_min_idx4 = 0;\n    let mut col_max_idx5\
    \ = 0;\n    let mut col_min_idx5 = 0;\n    let mut col_max_idx6 = 0;\n    let\
    \ mut col_min_idx6 = 0;\n    let mut col_max_idx7 = 0;\n    let mut col_min_idx7\
    \ = 0;\n    let mut col_max_idx8 = 0;\n    let mut col_min_idx8 = 0;\n    let\
    \ mut col_max_idx9 = 0;\n    let mut col_min_idx9 = 0;\n    let mut col_max_idx10\
    \ = 0;\n    let mut col_min_idx10 = 0;\n    let mut col_max_idx11 = 0;\n    let\
    \ mut col_min_idx11 = 0;\n    let mut col_max_idx12 = 0;\n    let mut col_min_idx12\
    \ = 0;\n    let mut col_max_idx13 = 0;\n    let mut col_min_idx13 = 0;\n    let\
    \ mut col_max_idx14 = 0;\n    let mut col_min_idx14 = 0;\n    let mut col_max_idx15\
    \ = 0;\n    let mut col_min_idx15 = 0;\n    let mut col_max_idx16 = 0;\n    let\
    \ mut col_min_idx16 = 0;\n    let mut col_max_idx17 = 0;\n    let mut col_min_idx17\
    \ = 0;\n    let mut col_max_idx18 = 0;\n    let mut col_min_idx18 = 0;\n    let\
    \ mut col_max_idx19 = 0;\n    let mut col_min_idx19 = 0;\n    let mut col_max_idx20\
    \ = 0;\n    let mut col_min_idx20 = 0;\n    let mut col_max_idx21 = 0;\n    let\
    \ mut col_min_idx21 = 0;\n    let mut col_max_idx22 = 0;\n    let mut col_min_idx22\
    \ = 0;\n    let mut col_max_idx23 = 0;\n    let mut col_min_idx23 = 0;\n    let\
    \ mut col_max_idx24 = 0;\n    let mut col_min_idx24 = 0;\n    let mut col_max_idx25\
    \ = 0;\n    let mut col_min_idx25 = 0;\n    let mut col_max_idx26 = 0;\n    let\
    \ mut col_min_idx26 = 0;\n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4ff52rwn.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    while rows > 0 || cols > 0 {\n        if rows > 0\
    \ {\n            rows -= 1;\n            cols = lst[rows][0].len();\n        }\n\
    \        if cols > 0 {\n            cols -= 1;\n            coords.push(vec![(rows\
    \ - 1, cols - 1)]);\n        }\n    }\n    coords.sort_by_key(|&(_, y)| y.0);\n\
    \    coords.sort_by_key(|&(_, y)| y.1);\n    coords.reverse();\n    coords.iter().map(|&(_,\
    \ y)| vec![(y.0, y.1)]).collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpmtnq5ku2.rs:23:33\n   |\n23 |             cols = lst[rows][0].len();\n\
    \   |                                 ^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmtnq5ku2.rs:30:26\n   |\n30 |     coords.sort_by_key(|&(_,\
    \ y)| y.0);\n   |                          ^^^^^-\n   |                      \
    \    |    |\n   |                          |    expected due to this\n   |   \
    \                       expected struct `Vec`, found tuple\n   |\n   = note: expected\
    \ struct `Vec<(usize, usize)>`\n               found tuple `(_, _)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmtnq5ku2.rs:31:26\n   |\n31 |     coords.sort_by_key(|&(_,\
    \ y)| y.1);\n   |                          ^^^^^-\n   |                      \
    \    |    |\n   |                          |    expected due to this\n   |   \
    \                       expected struct `Vec`, found tuple\n   |\n   = note: expected\
    \ struct `Vec<(usize, usize)>`\n               found tuple `(_, _)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmtnq5ku2.rs:33:25\n   |\n33 |     coords.iter().map(|&(_,\
    \ y)| vec![(y.0, y.1)]).collect()\n   |                         ^^^^^-\n   | \
    \                        |    |\n   |                         |    expected due\
    \ to this\n   |                         expected struct `Vec`, found tuple\n \
    \  |\n   = note: expected struct `Vec<(usize, usize)>`\n               found tuple\
    \ `(_, _)`\n\nerror[E0277]: a value of type `Vec<(isize, isize)>` cannot be built\
    \ from an iterator over elements of type `Vec<_, _>`\n    --> /tmp/tmpmtnq5ku2.rs:33:51\n\
    \     |\n33   |     coords.iter().map(|&(_, y)| vec![(y.0, y.1)]).collect()\n\
    \     |                                                   ^^^^^^^ value of type\
    \ `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=Vec<_,\
    \ _>>`\n     |\n     = help: the trait `FromIterator<Vec<_, _>>` is not implemented\
    \ for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: ab"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut row_idx_max = 0;\n    let mut row_idx_min = std::i32::MAX;\n    let\
    \ mut col_max = 0;\n    let mut col_min = std::i32::MIN;\n    for row in lst {\n\
    \        let mut col_max = 0;\n        let mut col_min = std::i32::MIN;\n    \
    \    for col in row {\n            if col > col_max {\n                col_max\
    \ = col;\n            }\n            if col < col_min {\n                col_min\
    \ = col;\n            }\n        }\n        if row_idx_max < row {\n         \
    \   row_idx_max = row;\n        }\n        if row_idx_min > row {\n          \
    \  row_idx_min = row;\n        }\n        if col_max < x {\n            col_max\
    \ = x;\n        }\n        if col_min > x {\n            col_min = x;\n      \
    \  }\n    }\n    let mut row_idx = row_idx_min;\n    let mut col_max = col_min;\n\
    \    let mut col_min = std::i32::MAX;\n    for row in lst {\n        let mut col_max\
    \ = 0;\n        let mut col_min = std::i32::MIN;\n        for col in row {\n \
    \           if col > col_max {\n                col_max = col;\n            }\n\
    \            if col < col_min {\n                col_min = col;\n            }\n\
    \        }\n        if row_idx < row {\n            row_idx = row;\n        }\n\
    \        if col_min > x {\n            col_min = x;\n        }\n        if col_max\
    \ < x {\n            col_max = x;\n        }\n    }\n    let mut row_idx = row_idx_min;\n\
    \    let mut col_max = col_min;\n    let mut col_min = std::i32::MAX;\n    for\
    \ row in lst {\n        let mut col_max = 0;\n        let mut col_min = std::i32::MIN;\n\
    \        for col in row {\n            if col > col_max {\n                col_max\
    \ = col;\n            }\n            if col < col_min {\n                col_min\
    \ = col;\n            }\n        }\n        if row_idx < row {\n            row_idx\
    \ = row;\n        }\n        if col_min > x {\n            col_min = x;\n    \
    \    }\n        if col_max < x {\n            col_max = x;\n        }\n    }\n\
    \    let mut row_idx = row_idx_min;\n    let mut col_max = col_min;\n    let mut\
    \ col_min = std::i32::MAX;\n    for row in lst {\n        let mut col_max = 0;\n\
    \        let mut col_min = std::i32\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmplpoexwv4.rs:111:3\n\
    \    |\n16  | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    |                                                                   -\
    \ unclosed delimiter\n...\n98  |     for row in lst {\n    |                 \
    \   - this delimiter might not be properly closed...\n...\n101 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n111 | }\n    |   ^\n\n\
    error: expected `;`, found `}`\n   --> /tmp/tmplpoexwv4.rs:100:35\n    |\n100\
    \ |         let mut col_min = std::i32\n    |                                \
    \   ^ help: add `;` here\n101 | }\n    | - unexpected token\n\nerror[E0423]: expected\
    \ value, found module `std::i32`\n   --> /tmp/tmplpoexwv4.rs:100:27\n    |\n100\
    \ |         let mut col_min = std::i32\n    |                           ^^^^^^^^\
    \ not a value\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplpoexwv4.rs:30:22\n\
    \   |\n30 |             if col < col_min {\n   |                      ^^^^^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n30 |             if col\
    \ < col_min.try_into().unwrap() {\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplpoexwv4.rs:31:27\n   |\n25 |\
    \         let mut col_min = std::i32::MIN;\n   |                           -------------\
    \ expected due to this value\n...\n31 |                 col_min = col;\n   | \
    \                          ^^^ expected `i32`, found `isize`\n\nerror[E0277]:\
    \ can't compare `{integer}` with `Vec<isize>`\n  --> /tmp/tmplpoexwv4.rs:34:24\n\
    \   |\n34 |         if row_idx_max < row {\n   |                        ^ no implementation\
    \ for `{integer} < Vec<isize>` and `{integer} > Vec<isize>`\n   |\n   = help:\
    \ the trait `PartialOrd<Vec<isize>>` is not implemented for `{integer}`\n   =\
    \ help: the following other types implement trait `PartialOrd<Rhs>`:\n       \
    \      f32\n             f64\n             i128\n             i16\n          \
    \   i32\n             i64\n             i8\n          "
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    for row in lst {\n\
    \        let mut row_result = Vec::<(isize, isize)>::new();\n        for (i, elem)\
    \ in row.iter().enumerate() {\n            if i == x {\n                row_result.push((i,\
    \ elem));\n            }\n        }\n        result.push(row_result);\n    }\n\
    \    result.sort_by_key(|x| x.0);\n    result.sort_by_key(|x| x.1, |a, b| b.1.cmp(&a.1));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr3kgt3vy.rs:21:21\n   |\n\
    21 |             if i == x {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |             if i == x.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr3kgt3vy.rs:22:34\n   |\n22 |                 row_result.push((i,\
    \ elem));\n   |                                  ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |                 row_result.push((i.try_into().unwrap(),\
    \ elem));\n   |                                   ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr3kgt3vy.rs:22:37\n   |\n22 |              \
    \   row_result.push((i, elem));\n   |                                     ^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n22 |                 row_result.push((i, *elem));\n   |               \
    \                      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr3kgt3vy.rs:25:21\n\
    \   |\n25 |         result.push(row_result);\n   |                     ^^^^^^^^^^\
    \ expected tuple, found struct `Vec`\n   |\n   = note: expected tuple `(isize,\
    \ isize)`\n             found struct `Vec<(isize, isize)>`\n\nerror[E0061]: this\
    \ function takes 1 argument but 2 arguments were supplied\n   --> /tmp/tmpr3kgt3vy.rs:28:12\n\
    \    |\n28  |     result.sort_by_key(|x| x.1, |a, b| b.1.cmp(&a.1));\n    |  \
    \          ^^^^^^^^^^^ -------  -------------------- supplied 2 arguments\n  \
    \  |            |\n    |            expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = Vec::new();\n    let mut row = 0;\n    let mut col = 0;\n    while\
    \ row < rows {\n        while col < cols {\n            if lst[row][col] == x\
    \ {\n                coords.push((row, col));\n                break;\n      \
    \      }\n            col += 1;\n        }\n        row += 1;\n        col = 0;\n\
    \    }\n    coords.sort_by_key(|&(x, y)| x.0);\n    coords.sort_by_key(|&(x, y)|\
    \ y.0);\n    coords\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpkdsweae7.rs:33:36\n   |\n33 |     coords.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpkdsweae7.rs:34:36\n\
    \   |\n34 |     coords.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkdsweae7.rs:35:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n35 |     coords\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst.clone();\n    lst.sort_by_key(|row| row.iter().cloned().collect::<Vec<_>>());\n\
    \    lst.sort_by_key(|row| row.iter().cloned().reverse().collect::<Vec<_>>());\n\
    \    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n  \
    \  for row in lst {\n        let mut row_idx = 0;\n        let mut col_idx = 0;\n\
    \        while col_idx < row.len() {\n            if row[col_idx] == x {\n   \
    \             let row_idx = row_idx;\n                let col_idx = col_idx +\
    \ 1;\n                break;\n            }\n            col_idx += 1;\n     \
    \   }\n        row.push(row_idx, col_idx);\n    }\n    row.sort_by_key(|row| row.iter().cloned().collect::<Vec<_>>());\n\
    \    row.sort_by_key(|row| row.iter().cloned().reverse().collect::<Vec<_>>());\n\
    \    row\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpsaqzl6u2.rs:19:47\n   |\n19 |     lst.sort_by_key(|row|\
    \ row.iter().cloned().reverse().collect::<Vec<_>>());\n   |                  \
    \                             ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0061]: this function takes 1 argument but 2 arguments were\
    \ supplied\n    --> /tmp/tmpsaqzl6u2.rs:33:13\n     |\n33   |         row.push(row_idx,\
    \ col_idx);\n     |             ^^^^ -------  ------- supplied 2 arguments\n \
    \    |             |\n     |             expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0599]: no method named `iter` found for reference\
    \ `&(isize, isize)` in the current scope\n  --> /tmp/tmpsaqzl6u2.rs:35:31\n  \
    \ |\n35 |     row.sort_by_key(|row| row.iter().cloned().collect::<Vec<_>>());\n\
    \   |                               ^^^^ method not found in `&(isize, isize)`\n\
    \nerror[E0599]: no method named `iter` found for reference `&(isize, isize)` in\
    \ the current scope\n  --> /tmp/tmpsaqzl6u2.rs:36:31\n   |\n36 |     row.sort_by_key(|row|\
    \ row.iter().cloned().reverse().collect::<Vec<_>>());\n   |                  \
    \             ^^^^ method not found in `&(isize, isize)`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut col_pos = 0;\n\
    \    for row in lst {\n        row_len += row.len();\n        col_len = row.len();\n\
    \        if row_len > x {\n            break;\n        }\n        for col in row\
    \ {\n            col_pos += col_len;\n            if col_pos > x {\n         \
    \       break;\n            }\n            row.push(col_pos);\n        }\n   \
    \     row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n       \
    \ row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x|\
    \ x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n\
    \        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n    \
    \    row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n\
    \        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n    \
    \    row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x|\
    \ x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n\
    \        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n    \
    \    row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n\
    \        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n    \
    \    row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x|\
    \ x.0);\n        row.sort_by_key(|&\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpz3ndlnub.rs:79:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n22 |     for row in lst {\n   |                   \
    \ - this delimiter might not be properly closed...\n...\n69 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n79 | }\n   |   ^\n\n\
    error: mismatched closing delimiter: `}`\n  --> /tmp/tmpz3ndlnub.rs:68:24\n  \
    \ |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |                                                                   - closing\
    \ delimiter possibly meant for this\n...\n68 |         row.sort_by_key(|&\n  \
    \ |                        ^ unclosed delimiter\n69 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: expected parameter name, found `)`\n  --> /tmp/tmpz3ndlnub.rs:69:1\n\
    \   |\n69 | }\n   | ^ expected parameter name\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpz3ndlnub.rs:25:22\n   |\n25 |         if row_len > x {\n   |  \
    \                    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    25 |         if row_len > x.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz3ndlnub.rs:30:26\n\
    \   |\n30 |             if col_pos > x {\n   |                          ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n30 |             if col_pos\
    \ > x.try_into().unwrap() {\n   |                           ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpz3ndlnub.rs:33:22\n   |\n33 |\
    \             row.push(col_pos);\n   |                      ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n33 |             row.push(col_pos.try_into().unwrap());\n\
    \   |                           "
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    for row in lst {\n        let mut row_result\
    \ = Vec::new();\n        for el in row {\n            if el == x {\n         \
    \       row_result.push((row, el));\n            }\n        }\n        result.push(row_result);\n\
    \    }\n    result.sort_by(|a, b| a.iter().cmp(b.iter()).reverse());\n    result.sort_by(|a,\
    \ b| b.iter().cmp(a.iter()).reverse());\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmq9_6v4j.rs:29:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n29 |     result\n   |     ^^^^^^ expected\
    \ tuple, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<(Vec<isize>, isize)>>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut col_max = 0;\n    for row in lst {\n        let mut col_max\
    \ = 0;\n        for col in row {\n            if col > col_max {\n           \
    \     col_max = col;\n            }\n        }\n        row.sort_by_key(|&x| x.0);\n\
    \        row.sort_by_key(|&x| x.1);\n        let mut row_idx = 0;\n        for\
    \ col in row.iter().rev() {\n            if col == x {\n                row_idx\
    \ += 1;\n            }\n        }\n        row.sort_by_key(|&x| x.1);\n      \
    \  row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x|\
    \ x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n\
    \        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n    \
    \    row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n\
    \        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n    \
    \    row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x|\
    \ x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n\
    \        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n    \
    \    row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n\
    \        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n    \
    \    row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x|\
    \ x.0);\n        row.sort_by_key(|\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpxkloag3i.rs:78:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n20 |     for row in lst {\n   |                   \
    \ - this delimiter might not be properly closed...\n...\n68 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n78 | }\n   |   ^\n\n\
    error: mismatched closing delimiter: `}`\n  --> /tmp/tmpxkloag3i.rs:67:24\n  \
    \ |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |                                                                   - closing\
    \ delimiter possibly meant for this\n...\n67 |         row.sort_by_key(|\n   |\
    \                        ^ unclosed delimiter\n68 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: expected `|`, found `)`\n  --> /tmp/tmpxkloag3i.rs:68:1\n\
    \   |\n67 |         row.sort_by_key(|\n   |                          - expected\
    \ `|`\n68 | }\n   | ^ unexpected token\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpxkloag3i.rs:27:32\n  \
    \ |\n27 |         row.sort_by_key(|&x| x.0);\n   |                           \
    \     ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpxkloag3i.rs:28:32\n   |\n28 |         row.sort_by_key(|&x|\
    \ x.1);\n   |                                ^\n\nerror[E0277]: can't compare\
    \ `&isize` with `isize`\n  --> /tmp/tmpxkloag3i.rs:31:20\n   |\n31 |         \
    \    if col == x {\n   |                    ^^ no implementation for `&isize ==\
    \ isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for\
    \ `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmpxkloag3i.rs:35:32\n   |\n35 |         row.sort_by_key(|&x|\
    \ x.1);\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_idx_max = 0;\n    let mut row_idx_min = 0;\n    let mut\
    \ col_max = 0;\n    let mut col_min = 0;\n    for row in lst {\n        let mut\
    \ col_max = 0;\n        let mut col_min = 0;\n        for col in row {\n     \
    \       if col > col_max {\n                col_max = col;\n            }\n  \
    \          if col < col_min {\n                col_min = col;\n            }\n\
    \        }\n        if row_idx > row_idx_max {\n            row_idx_max = row_idx;\n\
    \        }\n        if row_idx < row_idx_min {\n            row_idx_min = row_idx;\n\
    \        }\n        if col_min > col_max {\n            col_max = col_min;\n \
    \       }\n        if col_min < col_max {\n            row.push((row_idx, col_max));\n\
    \        }\n        row_idx += 1;\n    }\n    row.sort_by_key(|&(x, y)| x.0);\n\
    \    row.sort_by_key(|&(x, y)| y.0);\n    row\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp16kjexbq.rs:44:22\n   |\n\
    44 |             row.push((row_idx, col_max));\n   |                      ^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n    \
    \         found tuple `({integer}, isize)`\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmp16kjexbq.rs:48:33\n  \
    \ |\n48 |     row.sort_by_key(|&(x, y)| x.0);\n   |                          \
    \       ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmp16kjexbq.rs:49:33\n   |\n49 |     row.sort_by_key(|&(x,\
    \ y)| y.0);\n   |                                 ^\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut col_idx = 0;\n    let mut col_max = lst[0].len();\n    let mut row_max\
    \ = lst[0].len();\n    for row in lst {\n        let row_len = row.len();\n  \
    \      if row_len > col_max {\n            col_max = row_len;\n        }\n   \
    \     if row_len > row_max {\n            row_max = row_len;\n        }\n    }\n\
    \    for row in lst {\n        let mut row_idx = 0;\n        for col in row {\n\
    \            if col == x {\n                row_idx += 1;\n            }\n   \
    \     }\n        let mut col_idx = 0;\n        for col in row {\n            if\
    \ col == x {\n                col_idx -= 1;\n            }\n        }\n      \
    \  row.swap(row_idx, col_idx);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n\
    \        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n    \
    \    row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x|\
    \ x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n\
    \        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n    \
    \    row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n\
    \        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n    \
    \    row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x|\
    \ x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n\
    \        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n    \
    \    row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmptv1qp_td.rs:84:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n31 |     for row in lst {\n   |                   \
    \ - this delimiter might not be properly closed...\n...\n74 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n84 | }\n   |   ^\n\n\
    error: mismatched closing delimiter: `}`\n  --> /tmp/tmptv1qp_td.rs:73:24\n  \
    \ |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |                                                                   - closing\
    \ delimiter possibly meant for this\n...\n73 |         row.sort_by_key(|\n   |\
    \                        ^ unclosed delimiter\n74 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: expected `|`, found `)`\n  --> /tmp/tmptv1qp_td.rs:74:1\n\
    \   |\n73 |         row.sort_by_key(|\n   |                          - expected\
    \ `|`\n74 | }\n   | ^ unexpected token\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmptv1qp_td.rs:45:32\n  \
    \ |\n45 |         row.sort_by_key(|&x| x.0);\n   |                           \
    \     ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmptv1qp_td.rs:46:32\n   |\n46 |         row.sort_by_key(|&x|\
    \ x.1);\n   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmptv1qp_td.rs:47:32\n  \
    \ |\n47 |         row.sort_by_key(|&x| x.0);\n   |                           \
    \     ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmptv1qp_td.rs:48:32\n   |\n48 |         row.sort_by_key(|&x|\
    \ x.1);\n   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmptv1qp_td.rs:49:32\n  \
    \ |\n49 |         row.sort_by_key(|&x| x.0);\n   |                           \
    \     ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fiel"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst.clone();\n    let mut row: Vec<(isize, isize)> = vec![];\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_idxs: Vec<isize>\
    \ = vec![];\n    let mut col_idxs: Vec<isize> = vec![];\n    let mut row_idxs_idx\
    \ = 0;\n    let mut col_idxs_idx = 0;\n    while row_idx < lst.len() {\n     \
    \   let mut row_idxs_idx = row_idx;\n        let mut col_idxs_idx = col_idx;\n\
    \        while col_idx < lst[row_idx].len() {\n            if lst[row_idx][col_idx]\
    \ == x {\n                row.push((row_idx, col_idx));\n                row_idxs.push(row_idx);\n\
    \                col_idxs.push(col_idx);\n                row_idxs_idx += 1;\n\
    \                col_idxs_idx += 1;\n            }\n            col_idx += 1;\n\
    \        }\n        row_idx += 1;\n        col_idx = 0;\n        row_idxs_idx\
    \ = 0;\n        col_idxs_idx = 0;\n    }\n    row.sort_by_key(|&(x, y)| x.0);\n\
    \    row.sort_by_key(|&(x, y)| y.0);\n    row.sort_by_key(|&(x, y)| x.1);\n  \
    \  row.sort_by_key(|&(x, y)| y.1);\n    row.iter().map(|&(x, y)| vec![(x.0, x.1),\
    \ (y.0, y.1)]).collect()\n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6qh086j6.rs:30:27\n   |\n\
    30 |                 row.push((row_idx, col_idx));\n   |                     \
    \      ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n30\
    \ |                 row.push((row_idx.try_into().unwrap(), col_idx));\n   |  \
    \                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6qh086j6.rs:30:36\n   |\n30 |                 row.push((row_idx,\
    \ col_idx));\n   |                                    ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n30 |                 row.push((row_idx,\
    \ col_idx.try_into().unwrap()));\n   |                                       \
    \    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6qh086j6.rs:31:31\n\
    \   |\n31 |                 row_idxs.push(row_idx);\n   |                    \
    \           ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    31 |                 row_idxs.push(row_idx.try_into().unwrap());\n   |       \
    \                               ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6qh086j6.rs:32:31\n   |\n32 |                 col_idxs.push(col_idx);\n\
    \   |                               ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n32 |                 col_idxs.push(col_idx.try_into().unwrap());\n\
    \   |                                      ++++++++++++++++++++\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmp6qh086j6.rs:43:33\n\
    \   |\n43 |     row.sort_by_key(|&(x, y)| x.0);\n   |                        \
    \         ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmp6qh086j6.rs:44:33\n   |\n44 |     row.sort_by_key(|&(x,\
    \ y)| y.0);\n  "
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst.clone();\n    let mut rows = lst.len();\n    let mut\
    \ cols = lst[0].len();\n    let mut res = Vec::new();\n    while rows > 0 || cols\
    \ > 0 {\n        if rows == 0 {\n            cols = 0;\n            rows += 1;\n\
    \        }\n        if cols == 0 {\n            rows += 1;\n            cols +=\
    \ 1;\n        }\n        let row = lst.len() - rows - 1;\n        let col = lst[row].len()\
    \ - cols - 1;\n        if lst[row][col] == x {\n            res.push((row, col));\n\
    \        }\n        if row > 0 {\n            lst[row] = lst[row - 1].clone();\n\
    \            rows += 1;\n        }\n        if col > 0 {\n            lst[row][col]\
    \ = lst[row - 1][col - 1];\n            cols += 1;\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmxytgljt.rs:44:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n44 |     res\n   |     ^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n    \
    \          found struct `Vec<(usize, usize)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    let mut row_idx =\
    \ 1;\n    let mut col_idx = 1;\n    let mut row_len = lst.len();\n    let mut\
    \ col_len = lst[0].len();\n    let mut row_start = row_idx;\n    let mut col_start\
    \ = col_idx;\n    while row_idx < row_len {\n        let mut row_end = row_idx;\n\
    \        while row_end < row_len && row_end - row_start < col_len {\n        \
    \    row_end += 1;\n        }\n        let mut col_end = col_idx;\n        while\
    \ col_end < col_len && col_end - col_start < row_len {\n            col_end +=\
    \ 1;\n        }\n        if row_end == row_len {\n            result.push((row_start,\
    \ col_idx));\n            row_idx += 1;\n            col_start = col_idx;\n  \
    \          col_idx = 1;\n        } else if col_end == col_len {\n            result.push((row_idx,\
    \ col_start));\n            row_idx = row_end;\n            col_start += 1;\n\
    \        } else {\n            let mut row_end = row_idx;\n            while row_end\
    \ < row_len && row_end - row_start < col_len {\n                row_end += 1;\n\
    \            }\n            let mut col_end = col_idx;\n            while col_end\
    \ < col_len && col_end - col_start < row_len {\n                col_end += 1;\n\
    \            }\n            result.push((row_start, col_start));\n           \
    \ result.push((row_end, col_end));\n            row_idx += 1;\n            col_start\
    \ += 1;\n            col_idx += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzullonvq.rs:34:26\n   |\n\
    34 |             result.push((row_start, col_idx));\n   |                    \
    \      ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    34 |             result.push((row_start.try_into().unwrap(), col_idx));\n   |\
    \                                   ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzullonvq.rs:34:37\n   |\n34 |             result.push((row_start,\
    \ col_idx));\n   |                                     ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n34 |             result.push((row_start,\
    \ col_idx.try_into().unwrap()));\n   |                                       \
    \     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzullonvq.rs:39:26\n\
    \   |\n39 |             result.push((row_idx, col_start));\n   |             \
    \             ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    39 |             result.push((row_idx.try_into().unwrap(), col_start));\n   |\
    \                                 ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzullonvq.rs:39:35\n   |\n39 |             result.push((row_idx,\
    \ col_start));\n   |                                   ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n39 |             result.push((row_idx,\
    \ col_start.try_into().unwrap()));\n   |                                     \
    \       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzullonvq.rs:51:26\n\
    \   |\n51 |             result.push((row_start, col_start));\n   |           \
    \               ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n51 |             "
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    let mut row = 0;\n    let mut col =\
    \ 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    while row < row_len {\n        if col == col_len {\n            result.push((row,\
    \ col));\n            row++;\n            col = 0;\n            col_len = lst[0].len();\n\
    \        } else {\n            if lst[row][col] == x {\n                col++;\n\
    \            } else {\n                col = 0;\n            }\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmptrx8hz4w.rs:25:16\n\
    \   |\n25 |             row++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n25 |             { let tmp = row; row +=\
    \ 1; tmp };\n   |             +++++++++++    ~~~~~~~~~~~~~~~~~\n25 -         \
    \    row++;\n25 +             row += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmptrx8hz4w.rs:30:20\n   |\n30 |                 col++;\n\
    \   |                    ^^ not a valid postfix operator\n   |\nhelp: use `+=\
    \ 1` instead\n   |\n30 |                 { let tmp = col; col += 1; tmp };\n \
    \  |                 +++++++++++    ~~~~~~~~~~~~~~~~~\n30 -                 col++;\n\
    30 +                 col += 1;\n   | \n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmptrx8hz4w.rs:36:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |                                             \
    \  ------------------- expected `Vec<(isize, isize)>` because of return type\n\
    ...\n36 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<(usize, usize)>`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    let mut rows = lst.len();\n\
    \    let mut cols = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    while row_idx < rows {\n        let mut row_idx = row_idx;\n     \
    \   while col_idx < cols {\n            if row_idx == x {\n                result.push((row_idx,\
    \ col_idx));\n                break;\n            }\n            col_idx += 1;\n\
    \        }\n        row_idx += 1;\n    }\n    result.sort_by_key(|&(x, y)| x.0);\n\
    \    result.sort_by_key(|&(x, y)| y.0);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgqqu57x8.rs:25:27\n   |\n\
    25 |             if row_idx == x {\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n25 |             if row_idx\
    \ == x.try_into().unwrap() {\n   |                            ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgqqu57x8.rs:26:30\n   |\n26 |\
    \                 result.push((row_idx, col_idx));\n   |                     \
    \         ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    26 |                 result.push((row_idx.try_into().unwrap(), col_idx));\n  \
    \ |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgqqu57x8.rs:26:39\n   |\n26 |              \
    \   result.push((row_idx, col_idx));\n   |                                   \
    \    ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n26 |     \
    \            result.push((row_idx, col_idx.try_into().unwrap()));\n   |      \
    \                                        ++++++++++++++++++++\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpgqqu57x8.rs:33:36\n\
    \   |\n33 |     result.sort_by_key(|&(x, y)| x.0);\n   |                     \
    \               ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpgqqu57x8.rs:34:36\n   |\n34 |     result.sort_by_key(|&(x,\
    \ y)| y.0);\n   |                                    ^\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx: Vec<isize>\
    \ = vec![];\n    let mut row_idx2: Vec<isize> = vec![];\n    let mut row_idx3:\
    \ Vec<isize> = vec![];\n    let mut row_idx4: Vec<isize> = vec![];\n    let mut\
    \ row_idx5: Vec<isize> = vec![];\n    let mut row_idx6: Vec<isize> = vec![];\n\
    \    let mut row_idx7: Vec<isize> = vec![];\n    let mut row_idx8: Vec<isize>\
    \ = vec![];\n    let mut row_idx9: Vec<isize> = vec![];\n    let mut row_idx10:\
    \ Vec<isize> = vec![];\n    let mut row_idx11: Vec<isize> = vec![];\n    let mut\
    \ row_idx12: Vec<isize> = vec![];\n    let mut row_idx13: Vec<isize> = vec![];\n\
    \    let mut row_idx14: Vec<isize> = vec![];\n    let mut row_idx15: Vec<isize>\
    \ = vec![];\n    let mut row_idx16: Vec<isize> = vec![];\n    let mut row_idx17:\
    \ Vec<isize> = vec![];\n    let mut row_idx18: Vec<isize> = vec![];\n    let mut\
    \ row_idx19: Vec<isize> = vec![];\n    let mut row_idx20: Vec<isize> = vec![];\n\
    \    let mut row_idx21: Vec<isize> = vec![];\n    let mut row_idx22: Vec<isize>\
    \ = vec![];\n    let mut row_idx23: Vec<isize> = vec![];\n    let mut row_idx24:\
    \ Vec<isize> = vec![];\n    let mut row_idx25: Vec<isize> = vec![];\n    let mut\
    \ row_idx26: Vec<isize> = vec![];\n    let mut row_idx27: Vec<isize> = vec![];\n\
    \    let mut row_idx28: Vec<isize> = vec![];\n    let mut row_idx29: Vec<isize>\
    \ = vec![];\n    let mut row_idx30: \n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmp_l4z4lw7.rs:48:1\n   |\n\
    47 |     let mut row_idx30: \n   |         ------------- while parsing the type\
    \ for `mut row_idx30`\n48 | }\n   | ^ expected type\n\nerror: aborting due to\
    \ previous error\n\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst.clone();\n    let mut row: Vec<(isize, isize)> = vec![];\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_idx2 = 0;\n\
    \    let mut col_idx2 = 0;\n    while row_idx < lst.len() {\n        let mut row_idx2\
    \ = 0;\n        while col_idx < lst[row_idx].len() {\n            if lst[row_idx][col_idx]\
    \ == x {\n                row.push((row_idx, col_idx));\n                row_idx2\
    \ += 1;\n            }\n            col_idx += 1;\n        }\n        if row_idx2\
    \ == 0 {\n            break;\n        }\n        row_idx += 1;\n        col_idx\
    \ = 0;\n    }\n    row.sort_by_key(|&(x, y)| x.0);\n    row.sort_by_key(|&(x,\
    \ y)| y.0);\n    row.sort_by_key(|&(x, y)| x.1 > y.1);\n    row.iter().map(|&(x,\
    \ y)| x).collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7emm9a9t.rs:27:27\n   |\n\
    27 |                 row.push((row_idx, col_idx));\n   |                     \
    \      ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n27\
    \ |                 row.push((row_idx.try_into().unwrap(), col_idx));\n   |  \
    \                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7emm9a9t.rs:27:36\n   |\n27 |                 row.push((row_idx,\
    \ col_idx));\n   |                                    ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n27 |                 row.push((row_idx,\
    \ col_idx.try_into().unwrap()));\n   |                                       \
    \    ++++++++++++++++++++\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmp7emm9a9t.rs:38:33\n   |\n38 |     row.sort_by_key(|&(x,\
    \ y)| x.0);\n   |                                 ^\n\nerror[E0610]: `isize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmp7emm9a9t.rs:39:33\n\
    \   |\n39 |     row.sort_by_key(|&(x, y)| y.0);\n   |                        \
    \         ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmp7emm9a9t.rs:40:33\n   |\n40 |     row.sort_by_key(|&(x,\
    \ y)| x.1 > y.1);\n   |                                 ^\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmp7emm9a9t.rs:40:39\n\
    \   |\n40 |     row.sort_by_key(|&(x, y)| x.1 > y.1);\n   |                  \
    \                     ^\n\nerror[E0277]: a value of type `Vec<(isize, isize)>`\
    \ cannot be built from an iterator over elements of type `isize`\n    --> /tmp/tmp7emm9a9t.rs:41:33\n\
    \     |\n41   |     row.iter().map(|&(x, y)| x).collect()\n     |            \
    \                     ^^^^^^^ value of type `Vec<(isize, isize)>` cannot be built\
    \ from `std::iter::Iterator<Item=isize>`\n     |\n     = help: the trait `FromIterator<isize"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = Vec::new();\n    let mut row_coords = Vec::new();\n    let mut\
    \ col_coords = Vec::new();\n    let mut row_coord = Vec::new();\n    let mut col_coord\
    \ = Vec::new();\n    let mut row = 0;\n    let mut col = 0;\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < rows {\n        while j < cols {\n        \
    \    if lst[i][j] == x {\n                row_coord.push((i, j));\n          \
    \      col_coord.push((j, i));\n                i += 1;\n                j +=\
    \ 1;\n            } else {\n                j += 1;\n            }\n        }\n\
    \        i += 1;\n        j = 0;\n    }\n    row_coords.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    row_coords.reverse();\n    col_coords.sort_by(|a, b| b.0.cmp(&a.0));\n  \
    \  col_coords.reverse();\n    for coord in row_coords {\n        coords.push((coord.0,\
    \ coord.1));\n    }\n    for coord in col_coords {\n        coords.push((coord.1,\
    \ coord.0));\n    }\n    coords\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmp0nnqed3o.rs:42:25\n\
    \   |\n42 |     row_coords.sort_by(|a, b| a.0.cmp(&b.0));\n   |              \
    \           ^ consider giving this closure parameter the explicit type `&T`, where\
    \ the type parameter `T` is specified\n   |\n   = note: type must be known at\
    \ this point\n\nerror[E0609]: no field `0` on type `&_`\n  --> /tmp/tmp0nnqed3o.rs:42:33\n\
    \   |\n42 |     row_coords.sort_by(|a, b| a.0.cmp(&b.0));\n   |              \
    \                   ^\n\nerror[E0609]: no field `0` on type `&_`\n  --> /tmp/tmp0nnqed3o.rs:44:33\n\
    \   |\n44 |     col_coords.sort_by(|a, b| b.0.cmp(&a.0));\n   |              \
    \                   ^\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0282, E0609.\nFor more information about an error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut row_idx2 = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4 =\
    \ 0;\n    let mut row_idx5 = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7\
    \ = 0;\n    let mut row_idx8 = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10\
    \ = 0;\n    let mut row_idx11 = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13\
    \ = 0;\n    let mut row_idx14 = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16\
    \ = 0;\n    let mut row_idx17 = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19\
    \ = 0;\n    let mut row_idx20 = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22\
    \ = 0;\n    let mut row_idx23 = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25\
    \ = 0;\n    let mut row_idx26 = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28\
    \ = 0;\n    let mut row_idx29 = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31\
    \ = 0;\n    let mut row_idx32 = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34\
    \ = 0;\n    let mut row_idx35 = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37\
    \ = 0;\n    let mut row_idx38 = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40\
    \ = 0;\n    let mut row_idx41 = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43\
    \ = 0;\n    let mut row_idx44 = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46\
    \ = 0;\n    let mut row_idx47 = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49\
    \ = 0;\n    let mut row_idx50 = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52\
    \ = 0;\n    let mut row_idx53 = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55\
    \ = 0;\n    let mut row_idx56 = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58\
    \ = 0;\n    let mut row_idx59 = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61\
    \ = 0;\n    let mut row_idx62 = 0;\n    let mut row_\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwcu_1gxu.rs:80:17\n   |\n\
    80 |     let mut row_\n   |                 ^ help: add `;` here\n81 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwcu_1gxu.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords\
    \ = vec![];\n    let mut row_sort = vec![];\n    let mut col_sort = vec![];\n\
    \    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let\
    \ mut row_sort_idx_idx = vec![];\n    let mut col_sort_idx_idx = vec![];\n   \
    \ let mut row_sort_idx_idx_idx = vec![];\n    let mut col_sort_idx_idx_idx = vec![];\n\
    \    let mut row_sort_idx_idx_idx_idx = vec![];\n    let mut col_sort_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx = vec![];\n    let mut\
    \ col_sort_idx_idx_idx_idx_idx_idx = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let\
    \ mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let mut\
    \ row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sort_\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqncd2az8.rs:51:22\n   |\n\
    51 |     let mut col_sort_\n   |                      ^ help: add `;` here\n52\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqncd2az8.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut col_idx = 0;\n    for row in lst {\n        let mut row_idx = 0;\n\
    \        let mut col_idx = 0;\n        for col in row {\n            if col ==\
    \ x {\n                row.push(row_idx, col_idx);\n                row_idx +=\
    \ 1;\n            }\n            col_idx += 1;\n        }\n    }\n    row.sort_by_key(|&(_,\
    \ y)| y.cmp(&x));\n    row.sort_by_key(|&(_, y)| y.cmp(&x));\n    row\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpy10i1q0h.rs:25:21\n     |\n25   |                 row.push(row_idx,\
    \ col_idx);\n     |                     ^^^^ -------  ------- supplied 2 arguments\n\
    \     |                     |\n     |                     expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    let mut row = 0;\n\
    \    let mut col = 0;\n    while row < lst.len() {\n        let mut found = false;\n\
    \        for y in 0..lst[row].len() {\n            if lst[row][y] == x {\n   \
    \             found = true;\n                break;\n            }\n        }\n\
    \        if found {\n            result.push((row, col));\n            row +=\
    \ 1;\n            col = 0;\n        } else {\n            col += 1;\n        }\n\
    \    }\n    result.sort_by_key(|&(x, y)| x.0);\n    result.sort_by_key(|&(x, y)|\
    \ -x.1);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_sntjvy5.rs:29:26\n   |\n\
    29 |             result.push((row, col));\n   |                          ^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n29 |             result.push((row.try_into().unwrap(),\
    \ col));\n   |                             ++++++++++++++++++++\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmp_sntjvy5.rs:36:36\n\
    \   |\n36 |     result.sort_by_key(|&(x, y)| x.0);\n   |                     \
    \               ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmp_sntjvy5.rs:37:37\n   |\n37 |     result.sort_by_key(|&(x,\
    \ y)| -x.1);\n   |                                     ^\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    let mut row_idx =\
    \ 1;\n    let mut col_idx = 1;\n    let mut row_len = lst.len();\n    let mut\
    \ col_len = lst[0].len();\n    while row_idx < row_len {\n        let mut row_end\
    \ = row_idx;\n        while row_end < row_len && col_idx < col_len {\n       \
    \     if lst[row_end][col_idx] == x {\n                result.push((row_idx, col_idx));\n\
    \                break;\n            }\n            row_end += 1;\n          \
    \  col_idx += 1;\n        }\n        row_idx += 1;\n    }\n    result.sort_by_key(|&(x,\
    \ y)| x.0);\n    result.sort_by_key(|&(x, y)| y.0);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0rxowgjr.rs:26:30\n   |\n\
    26 |                 result.push((row_idx, col_idx));\n   |                  \
    \            ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    26 |                 result.push((row_idx.try_into().unwrap(), col_idx));\n  \
    \ |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0rxowgjr.rs:26:39\n   |\n26 |              \
    \   result.push((row_idx, col_idx));\n   |                                   \
    \    ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n26 |     \
    \            result.push((row_idx, col_idx.try_into().unwrap()));\n   |      \
    \                                        ++++++++++++++++++++\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmp0rxowgjr.rs:34:36\n\
    \   |\n34 |     result.sort_by_key(|&(x, y)| x.0);\n   |                     \
    \               ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmp0rxowgjr.rs:35:36\n   |\n35 |     result.sort_by_key(|&(x,\
    \ y)| y.0);\n   |                                    ^\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = vec![];\n    let mut row_idx = 1;\n    let mut col_idx\
    \ = 1;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    while row_idx < row_len {\n        let mut row_idx = 1;\n        while col_idx\
    \ < col_len {\n            if row_idx == row_len {\n                row_idx =\
    \ 0;\n                col_idx = 0;\n            }\n            if lst[row_idx][col_idx]\
    \ == x {\n                result.push((row_idx, col_idx));\n                row_idx\
    \ += 1;\n                col_idx += 1;\n            } else {\n               \
    \ col_idx += 1;\n            }\n        }\n    }\n    result.sort_by_key(|&(x,\
    \ y)| x.0);\n    result.sort_by_key(|&(x, y)| y.0);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpkre99gz_.rs:38:36\n   |\n38 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpkre99gz_.rs:39:36\n\
    \   |\n39 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkre99gz_.rs:40:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n40 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        Vec::new()\n    } else {\n        let mut\
    \ row = Vec::new();\n        let mut row_idx = 1;\n        let mut row_col = 0;\n\
    \        let mut row_col_max = 0;\n        for row_col in lst.iter().rev() {\n\
    \            if row_col[x] >= row_col_max {\n                row_col_max = row_col[x];\n\
    \            }\n        }\n        for row_col in lst.iter().rev() {\n       \
    \     if row_col[x] == row_col_max {\n                row.push((row_idx, row_col[x]));\n\
    \                row_idx += 1;\n            }\n        }\n        row.sort_by_key(|&(x,\
    \ y)| x.cmp(y));\n        row.sort_by_key(|&(x, y)| y.cmp(x));\n        row\n\
    \    }\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmplsplh2wz.rs:25:16\n\
    \   |\n25 |             if row_col[x] >= row_col_max {\n   |                ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmplsplh2wz.rs:26:31\n\
    \   |\n26 |                 row_col_max = row_col[x];\n   |                  \
    \             ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmplsplh2wz.rs:30:16\n\
    \   |\n30 |             if row_col[x] == row_col_max {\n   |                ^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmplsplh2wz.rs:31:36\n\
    \   |\n31 |                 row.push((row_idx, row_col[x]));\n   |           \
    \                         ^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplsplh2wz.rs:36:41\n\
    \   |\n36 |         row.sort_by_key(|&(x, y)| y.cmp"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    for row in lst {\n\
    \        let mut row_result = Vec::<(isize, isize)>::new();\n        for (i, v)\
    \ in row.iter().enumerate() {\n            if i == x {\n                row_result.push((i,\
    \ v));\n            }\n        }\n        result.push(row_result);\n    }\n  \
    \  result.sort_by_key(|&(_, v)| v.iter().rev().collect::<Vec<_>>());\n    result.sort_by_key(|&(_,\
    \ v)| v.iter().collect::<Vec<_>>().rev());\n    result\n}\n\nfn main() {\n   \
    \ let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphz85hfu2.rs:21:21\n   |\n\
    21 |             if i == x {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |             if i == x.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphz85hfu2.rs:22:34\n   |\n22 |                 row_result.push((i,\
    \ v));\n   |                                  ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |                 row_result.push((i.try_into().unwrap(),\
    \ v));\n   |                                   ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphz85hfu2.rs:22:37\n   |\n22 |              \
    \   row_result.push((i, v));\n   |                                     ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    22 |                 row_result.push((i, *v));\n   |                         \
    \            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphz85hfu2.rs:25:21\n\
    \   |\n25 |         result.push(row_result);\n   |                     ^^^^^^^^^^\
    \ expected tuple, found struct `Vec`\n   |\n   = note: expected tuple `(isize,\
    \ isize)`\n             found struct `Vec<(isize, isize)>`\n\nerror[E0599]: no\
    \ method named `iter` found for type `isize` in the current scope\n  --> /tmp/tmphz85hfu2.rs:27:36\n\
    \   |\n27 |     result.sort_by_key(|&(_, v)| v.iter().rev().collect::<Vec<_>>());\n\
    \   |                                    ^^^^ method not found in `isize`\n\n\
    error[E0599]: no method named `iter` found for type `isize` in the current scope\n\
    \  --> /tmp/tmphz85hfu2.rs:28:36\n   |\n28 |     result.sort_by_key(|&(_, v)|\
    \ v.iter().collect::<Vec<_>>().rev());\n   |                                 \
    \   ^^^^ method not found in `isize`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rus"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut col_idx = 0;\n    let mut row_len = lst.len();\n    let mut col_len\
    \ = lst[0].len();\n    while row_idx < row_len {\n        let mut row_idx = row_idx;\n\
    \        while col_idx < col_len {\n            if row_idx == row_len {\n    \
    \            row_idx = 0;\n                col_idx++;\n            }\n       \
    \     if col_idx == col_len {\n                row_idx++;\n                col_idx\
    \ = 0;\n            }\n            if lst[row_idx][col_idx] == x {\n         \
    \       rows.push((row_idx, col_idx));\n                row_idx++;\n         \
    \       col_idx++;\n                break;\n            }\n            col_idx++;\n\
    \        }\n    }\n    rows\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpqt45ajdw.rs:27:24\n\
    \   |\n27 |                 col_idx++;\n   |                        ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n27 |               \
    \  { let tmp = col_idx; col_idx += 1; tmp };\n   |                 +++++++++++\
    \        ~~~~~~~~~~~~~~~~~~~~~\n27 -                 col_idx++;\n27 +        \
    \         col_idx += 1;\n   | \n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmpqt45ajdw.rs:30:24\n   |\n30 |                 row_idx++;\n   |\
    \                        ^^ not a valid postfix operator\n   |\nhelp: use `+=\
    \ 1` instead\n   |\n30 |                 { let tmp = row_idx; row_idx += 1; tmp\
    \ };\n   |                 +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n30 -    \
    \             row_idx++;\n30 +                 row_idx += 1;\n   | \n\nerror:\
    \ Rust has no postfix increment operator\n  --> /tmp/tmpqt45ajdw.rs:35:24\n  \
    \ |\n35 |                 row_idx++;\n   |                        ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n35 |               \
    \  { let tmp = row_idx; row_idx += 1; tmp };\n   |                 +++++++++++\
    \        ~~~~~~~~~~~~~~~~~~~~~\n35 -                 row_idx++;\n35 +        \
    \         row_idx += 1;\n   | \n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmpqt45ajdw.rs:39:20\n   |\n39 |             col_idx++;\n   |    \
    \                ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n39 |             { let tmp = col_idx; col_idx += 1; tmp };\n   |      \
    \       +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n39 -             col_idx++;\n\
    39 +             col_idx += 1;\n   | \n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpqt45ajdw.rs:34:28\n   |\n34 |                 rows.push((row_idx, col_idx));\n\
    \   |                            ^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n34 |                 rows.push((row_idx.try_into().unwrap(),\
    \ col_idx));\n   |                                   ++++++++++++++++++++\n\n\
    error[E030"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    let mut rows = lst.len();\n    let\
    \ mut cols = lst[0].len();\n    let mut row_idx = 1;\n    let mut col_idx = 1;\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    while\
    \ row_idx < rows {\n        let mut row_sorted = vec![];\n        let mut col_sorted\
    \ = vec![];\n        while col_idx < cols {\n            if row_idx != row_sorted.len()\
    \ {\n                row_sorted.push(row_idx);\n            }\n            if\
    \ col_idx != col_sorted.len() {\n                col_sorted.push(col_idx);\n \
    \           }\n            if row_idx < rows && col_idx < cols && row_sorted[col_idx]\
    \ < col_sorted[row_sorted[col_idx]] {\n                row_sorted.push(row_idx);\n\
    \                col_sorted.push(col_idx);\n            }\n            col_idx++;\n\
    \        }\n        result.push((row_sorted[0], col_sorted[0]));\n        row_idx++;\n\
    \        col_idx = 0;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpjgl3p806.rs:38:20\n\
    \   |\n38 |             col_idx++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n38 |             { let tmp =\
    \ col_idx; col_idx += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    38 -             col_idx++;\n38 +             col_idx += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmpjgl3p806.rs:41:16\n   |\n41\
    \ |         row_idx++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n41 |         { let tmp = row_idx; row_idx\
    \ += 1; tmp };\n   |         +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n41 -  \
    \       row_idx++;\n41 +         row_idx += 1;\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjgl3p806.rs:44:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n44 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<(usize, usize)>`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst.clone();\n    let mut row: Vec<(isize, isize)> = vec![];\n\
    \    let mut row_idx = 0;\n    let mut row_idx_max = 0;\n    let mut row_idx_min\
    \ = 0;\n    let mut row_idx_min_idx = 0;\n    let mut row_idx_max_idx = 0;\n \
    \   let mut col_min = 0;\n    let mut col_max = 0;\n    let mut col_min_idx =\
    \ 0;\n    let mut col_max_idx = 0;\n    let mut col_min_idx2 = 0;\n    let mut\
    \ col_max_idx2 = 0;\n    let mut col_min_idx3 = 0;\n    let mut col_max_idx3 =\
    \ 0;\n    let mut col_min_idx4 = 0;\n    let mut col_max_idx4 = 0;\n    let mut\
    \ col_min_idx5 = 0;\n    let mut col_max_idx5 = 0;\n    let mut col_min_idx6 =\
    \ 0;\n    let mut col_max_idx6 = 0;\n    let mut col_min_idx7 = 0;\n    let mut\
    \ col_max_idx7 = 0;\n    let mut col_min_idx8 = 0;\n    let mut col_max_idx8 =\
    \ 0;\n    let mut col_min_idx9 = 0;\n    let mut col_max_idx9 = 0;\n    let mut\
    \ col_min_idx10 = 0;\n    let mut col_max_idx10 = 0;\n    let mut col_min_idx11\
    \ = 0;\n    let mut col_max_idx11 = 0;\n    let mut col_min_idx12 = 0;\n    let\
    \ mut col_max_idx12 = 0;\n    let mut col_min_idx13 = 0;\n    let mut col_max_idx13\
    \ = 0;\n    let mut col_min_idx14 = 0;\n    let mut col_max_idx14 = 0;\n    let\
    \ mut col_min_idx15 = 0;\n    let mut col_max_idx15 = 0;\n    let mut col_min_idx16\
    \ = 0;\n    let mut col_max_idx16 = 0;\n    let mut col_min_idx17 = 0;\n    let\
    \ mut col_max_idx17 = 0;\n    let mut col_min_idx18 = 0;\n    let mut col_max_idx18\
    \ = 0;\n    let mut col_min_idx19 = 0;\n    let mut col_max_idx19 = 0;\n    let\
    \ mut col_min_idx20 = 0;\n    let mut col_max_idx20 = 0;\n    let mut col_min_idx21\
    \ = 0;\n    let mut col_max_idx21 = 0;\n    let mut col_min_idx22 = 0;\n    let\
    \ mut col_max_idx22 = 0;\n    let mut col_min_idx23 = 0;\n    let mut col_max_idx23\
    \ = 0;\n    let mut col_min_idx24 = 0;\n    let mut col_max_idx24 = 0;\n    let\
    \ mut col_min_idx25 = 0;\n\n}\n\nfn main() {\n    let candidate = get_row;\n \
    \   assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcm7821as.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_idx_max = 0;\n    let mut row_idx_min = 0;\n    let mut\
    \ col_max = 0;\n    let mut col_min = 0;\n    let mut col_max_idx = 0;\n    let\
    \ mut col_min_idx = 0;\n    let mut col_max_idx2 = 0;\n    let mut col_min_idx2\
    \ = 0;\n    let mut row_max = lst.len();\n    let mut row_min = lst.len();\n \
    \   let mut col_max = lst.len();\n    let mut col_min = lst.len();\n    let mut\
    \ col_max_idx = lst.len();\n    let mut col_min_idx = lst.len();\n    let mut\
    \ col_max_idx2 = lst.len();\n    let mut col_min_idx2 = lst.len();\n    let mut\
    \ row_idx2 = 0;\n    let mut row_idx2max = 0;\n    let mut row_idx2min = 0;\n\
    \    let mut col_max2 = 0;\n    let mut col_min2 = 0;\n    let mut col_max_idx2\
    \ = 0;\n    let mut col_min_idx2 = 0;\n    let mut col_max2idx = lst.len();\n\
    \    let mut col_min2idx = lst.len();\n    let mut row_idx2max2 = lst.len();\n\
    \    let mut row_idx2min2 = lst.len();\n    let mut col_max2idx2 = lst.len();\n\
    \    let mut col_min2idx2 = lst.len();\n    let mut row_idx2max3 = lst.len();\n\
    \    let mut row_idx2min3 = lst.len();\n    let mut col_max2idx3 = lst.len();\n\
    \    let mut col_min2idx3 = lst.len();\n    let mut row_idx2max4 = lst.len();\n\
    \    let mut row_idx2min4 = lst.len();\n    let mut col_max2idx4 = lst.len();\n\
    \    let mut col_min2idx4 = lst.len();\n    let mut row_idx2max5 = lst.len();\n\
    \    let mut row_idx2min5 = lst.len();\n    let mut col_max2idx5 = lst.len();\n\
    \    let mut col_min2idx5 = lst.len();\n    let mut row_idx2max6 = lst.len();\n\
    \    let mut row_idx2min6 = lst.len();\n    let mut col_max2idx6 = lst.len();\n\
    \    let mut col_min2idx6 = lst.len();\n\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn5yctrgk.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    for row in lst {\n\
    \        let mut row_result = Vec::<(isize, isize)>::new();\n        for (i, elem)\
    \ in row.iter().enumerate() {\n            if i == x {\n                row_result.push((i,\
    \ elem));\n            }\n        }\n        result.push(row_result);\n    }\n\
    \    result.sort_by_key(|&(_, y)| y.0);\n    result.sort_by_key(|&(_, y)| -y.1);\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps8zf6vhz.rs:21:21\n   |\n\
    21 |             if i == x {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |             if i == x.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmps8zf6vhz.rs:22:34\n   |\n22 |                 row_result.push((i,\
    \ elem));\n   |                                  ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |                 row_result.push((i.try_into().unwrap(),\
    \ elem));\n   |                                   ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps8zf6vhz.rs:22:37\n   |\n22 |              \
    \   row_result.push((i, elem));\n   |                                     ^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n22 |                 row_result.push((i, *elem));\n   |               \
    \                      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps8zf6vhz.rs:25:21\n\
    \   |\n25 |         result.push(row_result);\n   |                     ^^^^^^^^^^\
    \ expected tuple, found struct `Vec`\n   |\n   = note: expected tuple `(isize,\
    \ isize)`\n             found struct `Vec<(isize, isize)>`\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmps8zf6vhz.rs:27:36\n\
    \   |\n27 |     result.sort_by_key(|&(_, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmps8zf6vhz.rs:28:37\n   |\n28 |     result.sort_by_key(|&(_,\
    \ y)| -y.1);\n   |                                     ^\n\nerror: aborting due\
    \ to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sort = vec![];\n    let mut col_sort = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let\
    \ mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut\
    \ col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx\
    \ = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n\
    \    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let\
    \ mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut\
    \ row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let\
    \ mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut\
    \ col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx\
    \ = vec![];\n    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n\
    \    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let\
    \ mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut\
    \ row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx\
    \ = vec![];\n    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n\
    \    let mut col_sort_idx = vec![];\n    let mut row_sort_idx = vec![];\n    let\
    \ mut col_sort_idx = vec![];\n    let mut row_sort_\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxyco2bh0.rs:68:22\n   |\n\
    68 |     let mut row_sort_\n   |                      ^ help: add `;` here\n69\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxyco2bh0.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        Vec::new()\n    } else {\n        let mut\
    \ rows = lst.iter().map(|row| row.iter().cloned()).collect::<Vec<_>>();\n    \
    \    sort_rows(&mut rows);\n        let mut cols = vec![0; rows.len()];\n    \
    \    let mut i = 0;\n        for r in rows.iter() {\n            for c in r.iter().rev()\
    \ {\n                cols[i] = c;\n                i += 1;\n            }\n  \
    \      }\n        sort_cols(&mut cols);\n        let mut res = vec![];\n     \
    \   for i in 0..rows.len() {\n            let row = rows[i];\n            let\
    \ col = cols[i];\n            let x = row.get_index(x);\n            let y = col.get_index(x);\n\
    \            res.push((x, y));\n        }\n        res\n    }\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_rows` in this scope\n  --> /tmp/tmp9v_awqwb.rs:21:9\n\
    \   |\n21 |         sort_rows(&mut rows);\n   |         ^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `sort_cols` in this scope\n\
    \  --> /tmp/tmp9v_awqwb.rs:30:9\n   |\n30 |         sort_cols(&mut cols);\n  \
    \ |         ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `iter` found for reference `&Cloned<std::slice::Iter<'_, isize>>` in the current\
    \ scope\n  --> /tmp/tmp9v_awqwb.rs:25:24\n   |\n25 |             for c in r.iter().rev()\
    \ {\n   |                        ^^^^ method not found in `&Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `get_index` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmp9v_awqwb.rs:35:25\n   |\n35 |          \
    \   let x = row.get_index(x);\n   |                         ^^^^^^^^^ method not\
    \ found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method named\
    \ `get_index` found for type `{integer}` in the current scope\n  --> /tmp/tmp9v_awqwb.rs:36:25\n\
    \   |\n36 |             let y = col.get_index(x);\n   |                      \
    \   ^^^^^^^^^ method not found in `{integer}`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut col_idx = 0;\n    let mut row_len = 0;\n    let mut col_len\
    \ = 0;\n    let mut row_start = 0;\n    let mut col_start = 0;\n    let mut row_end\
    \ = row_len;\n    let mut col_end = col_len;\n    let mut row_idx2 = 0;\n    let\
    \ mut col_idx2 = 0;\n    let mut row_len2 = 0;\n    let mut col_len2 = 0;\n  \
    \  let mut row_start2 = 0;\n    let mut col_start2 = 0;\n    let mut row_end2\
    \ = row_len2;\n    let mut col_end2 = col_len2;\n    let mut row_idx3 = 0;\n \
    \   let mut col_idx3 = 0;\n    let mut row_len3 = 0;\n    let mut col_len3 = 0;\n\
    \    let mut row_start3 = 0;\n    let mut col_start3 = 0;\n    let mut row_end3\
    \ = row_len3;\n    let mut col_end3 = col_len3;\n    let mut row_idx4 = 0;\n \
    \   let mut col_idx4 = 0;\n    let mut row_len4 = 0;\n    let mut col_len4 = 0;\n\
    \    let mut row_start4 = 0;\n    let mut col_start4 = 0;\n    let mut row_end4\
    \ = row_len4;\n    let mut col_end4 = col_len4;\n    let mut row_idx5 = 0;\n \
    \   let mut col_idx5 = 0;\n    let mut row_len5 = 0;\n    let mut col_len5 = 0;\n\
    \    let mut row_start5 = 0;\n    let mut col_start5 = 0;\n    let mut row_end5\
    \ = row_len5;\n    let mut col_end5 = col_len5;\n    let mut row_idx6 = 0;\n \
    \   let mut col_idx6 = 0;\n    let mut row_len6 = 0;\n    let mut col_len6 = 0;\n\
    \    let mut row_start6 = 0;\n    let mut col_start6 = 0;\n    let mut row_end6\
    \ = row_len6;\n    let mut col_end6 = col_len6;\n    let mut row_idx7 = 0;\n \
    \   let mut col_idx7 = 0;\n    let mut row_len7 = 0;\n    let mut col_len7 = 0;\n\
    \    let mut row_start7 = 0;\n    let mut col_start7 = 0;\n    let mut row_end7\
    \ = row_len7;\n    let mut col_end7 = col_len7;\n    let mut row_idx8 = 0;\n \
    \   let mut col_idx8 = 0;\n    let mut row_len8 = 0;\n    let mut col_len8 = 0;\n\
    \    let mut row_start8 = 0;\n    let mut col_start8 = 0;\n    let mut row_\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpllvph515.rs:80:17\n   |\n\
    80 |     let mut row_\n   |                 ^ help: add `;` here\n81 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpllvph515.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut row_idx_max = 0;\n    let mut row_idx_min = std::cmp::min::<isize>(lst.len(),\
    \ x);\n    let mut col_max = 0;\n    let mut col_min = 0;\n    let mut col_max_idx\
    \ = 0;\n    let mut col_min_idx = 0;\n    let mut col_max_idx2 = 0;\n    let mut\
    \ col_min_idx2 = 0;\n    let mut col_max_idx3 = 0;\n    let mut col_min_idx3 =\
    \ 0;\n    let mut col_max_idx4 = 0;\n    let mut col_min_idx4 = 0;\n    let mut\
    \ col_max_idx5 = 0;\n    let mut col_min_idx5 = 0;\n    let mut col_max_idx6 =\
    \ 0;\n    let mut col_min_idx6 = 0;\n    let mut col_max_idx7 = 0;\n    let mut\
    \ col_min_idx7 = 0;\n    let mut col_max_idx8 = 0;\n    let mut col_min_idx8 =\
    \ 0;\n    let mut col_max_idx9 = 0;\n    let mut col_min_idx9 = 0;\n    let mut\
    \ col_max_idx10 = 0;\n    let mut col_min_idx10 = 0;\n    let mut col_max_idx11\
    \ = 0;\n    let mut col_min_idx11 = 0;\n    let mut col_max_idx12 = 0;\n    let\
    \ mut col_min_idx12 = 0;\n    let mut col_max_idx13 = 0;\n    let mut col_min_idx13\
    \ = 0;\n    let mut col_max_idx14 = 0;\n    let mut col_min_idx14 = 0;\n    let\
    \ mut col_max_idx15 = 0;\n    let mut col_min_idx15 = 0;\n    let mut col_max_idx16\
    \ = 0;\n    let mut col_min_idx16 = 0;\n    let mut col_max_idx17 = 0;\n    let\
    \ mut col_min_idx17 = 0;\n    let mut col_max_idx18 = 0;\n    let mut col_min_idx18\
    \ = 0;\n    let mut col_max_idx19 = 0;\n    let mut col_min_idx19 = 0;\n    let\
    \ mut col_max_idx20 = 0;\n    let mut col_min_idx20 = 0;\n    let mut col_max_idx21\
    \ = 0;\n    let mut col_min_idx21 = 0;\n    let mut col_max_idx22 = 0;\n    let\
    \ mut col_min_idx22 = 0;\n    let mut col_max_idx23 = 0;\n    let mut col_min_idx23\
    \ = 0;\n    let mut col_max_idx24 = 0;\n    let mut col_min_idx24 = 0;\n    let\
    \ mut col_max_idx25 = 0;\n    let mut col_min_idx25 = 0;\n    let mut col_max_\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt_o132nk.rs:73:21\n   |\n\
    73 |     let mut col_max_\n   |                     ^ help: add `;` here\n74 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_o132nk.rs:20:50\n\
    \   |\n20 |     let mut row_idx_min = std::cmp::min::<isize>(lst.len(), x);\n\
    \   |                                                  ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n20 |     let mut row_idx_min = std::cmp::min::<isize>(lst.len().try_into().unwrap(),\
    \ x);\n   |                                                           ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpt_o132nk.rs:16:47\n   |\n16 |\
    \ fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |  \
    \  -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst.clone();\n    let mut rows = lst.len();\n    let mut\
    \ cols = lst[0].len();\n    let mut res = Vec::<(isize, isize)>::new();\n    while\
    \ rows > 0 {\n        let mut row = vec![];\n        for _ in 0..cols {\n    \
    \        row.push((0, 0));\n        }\n        res.push(row.clone());\n      \
    \  cols -= 1;\n        while cols > 0 {\n            let mut col = vec![];\n \
    \           for _ in 0..rows {\n                col.push((0, 0));\n          \
    \  }\n            rows.push(col.clone());\n            cols -= 1;\n        }\n\
    \        rows -= 1;\n    }\n    let mut rows = lst.len();\n    let mut cols =\
    \ lst[0].len();\n    while cols > 0 {\n        let mut col = vec![];\n       \
    \ for _ in 0..rows {\n            col.push((0, 0));\n        }\n        res.push(col.clone());\n\
    \        cols -= 1;\n    }\n    for row in lst {\n        for col in row {\n \
    \           if col == x {\n                res.push((row, col));\n           \
    \ }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp51dyloeg.rs:26:18\n   |\n\
    26 |         res.push(row.clone());\n   |                  ^^^^^^^^^^^ expected\
    \ tuple, found struct `Vec`\n   |\n   = note: expected tuple `(isize, isize)`\n\
    \             found struct `Vec<({integer}, {integer})>`\n\nerror[E0599]: no method\
    \ named `push` found for type `usize` in the current scope\n  --> /tmp/tmp51dyloeg.rs:33:18\n\
    \   |\n33 |             rows.push(col.clone());\n   |                  ^^^^ method\
    \ not found in `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp51dyloeg.rs:45:18\n\
    \   |\n45 |         res.push(col.clone());\n   |                  ^^^^^^^^^^^\
    \ expected tuple, found struct `Vec`\n   |\n   = note: expected tuple `(isize,\
    \ isize)`\n             found struct `Vec<({integer}, {integer})>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp51dyloeg.rs:51:27\n   |\n51 |              \
    \   res.push((row, col));\n   |                           ^^^ expected `isize`,\
    \ found struct `Vec`\n   |\n   = note: expected type `isize`\n            found\
    \ struct `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst.clone();\n    let mut rows = lst.len();\n    let mut\
    \ cols = lst[0].len();\n    let mut result = Vec::<(isize, isize)>::new();\n \
    \   while rows > 0 || cols > 0 {\n        if rows > 0 {\n            cols = lst[rows].len();\n\
    \        }\n        if cols > 0 {\n            result.push((rows - 1, cols - 1));\n\
    \        }\n        rows -= 1;\n        cols -= 1;\n    }\n    result.sort_by_key(|&(x,\
    \ y)| x.0);\n    result.sort_by_key(|&(x, y)| y.0);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppl9ln1kc.rs:26:26\n   |\n\
    26 |             result.push((rows - 1, cols - 1));\n   |                    \
    \      ^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n26\
    \ |             result.push(((rows - 1).try_into().unwrap(), cols - 1));\n   |\
    \                          +        +++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppl9ln1kc.rs:26:36\n   |\n26 |             result.push((rows\
    \ - 1, cols - 1));\n   |                                    ^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n26 |             result.push((rows\
    \ - 1, (cols - 1).try_into().unwrap()));\n   |                               \
    \     +        +++++++++++++++++++++\n\nerror[E0610]: `isize` is a primitive type\
    \ and therefore doesn't have fields\n  --> /tmp/tmppl9ln1kc.rs:31:36\n   |\n31\
    \ |     result.sort_by_key(|&(x, y)| x.0);\n   |                             \
    \       ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmppl9ln1kc.rs:32:36\n   |\n32 |     result.sort_by_key(|&(x,\
    \ y)| y.0);\n   |                                    ^\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = Vec::new();\n    let mut row_coords = Vec::new();\n    let mut\
    \ col_coords = Vec::new();\n    let mut row_sort = Vec::new();\n    let mut col_sort\
    \ = Vec::new();\n    let mut row_sort_idx = Vec::new();\n    let mut col_sort_idx\
    \ = Vec::new();\n    let mut row_sort_idx2 = Vec::new();\n    let mut col_sort_idx2\
    \ = Vec::new();\n    let mut row_sort_idx3 = Vec::new();\n    let mut col_sort_idx3\
    \ = Vec::new();\n    let mut row_sort_idx4 = Vec::new();\n    let mut col_sort_idx4\
    \ = Vec::new();\n    let mut row_sort_idx5 = Vec::new();\n    let mut col_sort_idx5\
    \ = Vec::new();\n    let mut row_sort_idx6 = Vec::new();\n    let mut col_sort_idx6\
    \ = Vec::new();\n    let mut row_sort_idx7 = Vec::new();\n    let mut col_sort_idx7\
    \ = Vec::new();\n    let mut row_sort_idx8 = Vec::new();\n    let mut col_sort_idx8\
    \ = Vec::new();\n    let mut row_sort_idx9 = Vec::new();\n    let mut col_sort_idx9\
    \ = Vec::new();\n    let mut row_sort_idx10 = Vec::new();\n    let mut col_sort_idx10\
    \ = Vec::new();\n    let mut row_sort_idx11 = Vec::new();\n    let mut col_sort_idx11\
    \ = Vec::new();\n    let mut row_sort_idx12 = Vec::new();\n    let mut col_sort_idx12\
    \ = Vec::new();\n    let mut row_sort_idx13 = Vec::new();\n    let mut col_sort_idx13\
    \ = Vec::new();\n    let mut row_sort_idx14 = Vec::new();\n    let mut col_sort_idx14\
    \ = Vec::new();\n    let mut row_sort_idx15 = Vec::new();\n    let mut col_sort_idx15\
    \ = Vec::new();\n    let mut row_sort_idx16 = Vec::new();\n    let mut col_sort_idx16\
    \ = Vec::new();\n    let mut row_sort_idx17 = Vec::new();\n    let mut col_sort_idx17\
    \ = Vec::new();\n    let mut row_sort_idx18 = Vec::new();\n    let mut col_sort_idx18\
    \ = Vec::new\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphsidd_8j.rs:59:38\n   |\n\
    59 |     let mut col_sort_idx18 = Vec::new\n   |                             \
    \         ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphsidd_8j.rs:16:47\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |    -------       \
    \                             ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = vec![];\n    let mut cols = vec![];\n    for row in lst\
    \ {\n        cols.clear();\n        for col in row {\n            if col == x\
    \ {\n                cols.push((row, col));\n            }\n        }\n      \
    \  rows.push((row, cols.reverse()));\n    }\n    rows.sort_by(|a, b| a.1.cmp(&b.1));\n\
    \    rows.reverse();\n    rows\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeu9p7_b7.rs:30:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n30 |     rows\n   |     ^^^^ expected\
    \ `isize`, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<(Vec<isize>, ())>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut row_idx_max = 0;\n    let mut row_idx_min = 0;\n    let mut row_idx_max_col\
    \ = 0;\n    let mut row_idx_min_col = 0;\n    let mut row_idx_max_col_len = 0;\n\
    \    let mut row_idx_min_col_len = 0;\n    let mut row_idx_max_col_len2 = 0;\n\
    \    let mut row_idx_min_col_len2 = 0;\n    let mut row_idx_max_col_len3 = 0;\n\
    \    let mut row_idx_min_col_len3 = 0;\n    let mut row_idx_max_col_len4 = 0;\n\
    \    let mut row_idx_min_col_len4 = 0;\n    let mut row_idx_max_col_len5 = 0;\n\
    \    let mut row_idx_min_col_len5 = 0;\n    let mut row_idx_max_col_len6 = 0;\n\
    \    let mut row_idx_min_col_len6 = 0;\n    let mut row_idx_max_col_len7 = 0;\n\
    \    let mut row_idx_min_col_len7 = 0;\n    let mut row_idx_max_col_len8 = 0;\n\
    \    let mut row_idx_min_col_len8 = 0;\n    let mut row_idx_max_col_len9 = 0;\n\
    \    let mut row_idx_min_col_len9 = 0;\n    let mut row_idx_max_col_len10 = 0;\n\
    \    let mut row_idx_min_col_len10 = 0;\n    let mut row_idx_max_col_len11 = 0;\n\
    \    let mut row_idx_min_col_len11 = 0;\n    let mut row_idx_max_col_len12 = 0;\n\
    \    let mut row_idx_min_col_len12 = 0;\n    let mut row_idx_max_col_len13 = 0;\n\
    \    let mut row_idx_min_col_len13 = 0;\n    let mut row_idx_max_col_len14 = 0;\n\
    \    let mut row_idx_min_col_len14 = 0;\n    let mut row_idx_max_col_len15 = 0;\n\
    \    let mut row_idx_min_col_len15 = 0;\n    let mut row_idx_max_col_len16 = 0;\n\
    \    let mut row_idx_min_col_len16 = 0;\n    let mut row_idx_max_col_len17 = 0;\n\
    \    let mut row_idx_min_col_len17 = 0;\n    let mut row_idx_max_col_len18 = 0;\n\
    \    let mut row_idx_min_col_len18 = 0;\n    let mut row_idx_max_col_len19 = 0;\n\
    \    let mut row_idx_min_col_len19 = 0;\n    let mut row_idx_max_col_len20 = 0;\n\
    \    let mut row_idx_min_col_len20 = 0;\n    let mut row_idx_max_col_len21 = 0;\n\
    \    let mut row_idx_min_col_len21 = 0;\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx7cgdhsv.rs:65:11\n   |\n\
    65 |     let mu\n   |           ^ help: add `;` here\n66 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx7cgdhsv.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut col_num = 0;\n    let mut col_max = 0;\n    for row in lst {\n  \
    \      col_num = row.len();\n        if col_num > col_max {\n            col_max\
    \ = col_num;\n        }\n    }\n    for row in lst {\n        let mut col_num\
    \ = 0;\n        for col in row {\n            if col == x {\n                let\
    \ mut coord = (row_idx, col_num);\n                row.swap(row_idx, col_num);\n\
    \                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ col_num);\n                row.swap(row_idx, col_num);\n                row.swap(row_idx,\
    \ \n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1ftn64uz.rs:83:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n27 |     for row in lst {\n   |                   \
    \ - unclosed delimiter\n28 |         let mut col_num = 0;\n29 |         for col\
    \ in row {\n   |                        - unclosed delimiter\n30 |           \
    \  if col == x {\n   |                         - this delimiter might not be properly\
    \ closed...\n...\n73 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n83 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp1ftn64uz.rs:72:25\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ closing delimiter possibly meant for this\n...\n72 |                 row.swap(row_idx,\
    \ \n   |                         ^ unclosed delimiter\n73 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0061]: this function takes 2 arguments but 1 argument\
    \ was supplied\n   --> /tmp/tmp1ftn64uz.rs:72:21\n    |\n72  |               \
    \  row.swap(row_idx, \n    |                     ^^^^ ------- supplied 1 argument\n\
    \    |                     |\n    |                     expected 2 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1ftn64uz.rs:27:5\n   |\n16 |   fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \              ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n27 | /     for row in lst {\n28 | |         let mut col_num = 0;\n\
    29 | |         for col in row {\n30 | |             if col == x {\n...  |\n82\
    \ | |     assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]], 3), vec![(2,\
    \ 2)]);\n83 | | }\n   | |__^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<(isize, isize)>`\n           found unit type `()`\n\nerror:\
    \ aborting due to 4 previou"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut col_max = 0;\n    for row in lst {\n        let mut col_max = 0;\n\
    \        for col in row {\n            if col > col_max {\n                col_max\
    \ = col;\n            }\n        }\n        if col_max > x {\n            break;\n\
    \        }\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n\
    \        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n    \
    \    row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x|\
    \ x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n\
    \        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n    \
    \    row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n\
    \        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n    \
    \    row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x|\
    \ x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n\
    \        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n    \
    \    row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n\
    \        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n    \
    \    row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x|\
    \ x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpjxsub0xv.rs:77:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n20 |     for row in lst {\n   |                   \
    \ - this delimiter might not be properly closed...\n...\n67 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n77 | }\n   |   ^\n\n\
    error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpjxsub0xv.rs:30:32\n   |\n30 |         row.sort_by_key(|&x| x.0);\n\
    \   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpjxsub0xv.rs:31:32\n  \
    \ |\n31 |         row.sort_by_key(|&x| x.1);\n   |                           \
    \     ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpjxsub0xv.rs:32:32\n   |\n32 |         row.sort_by_key(|&x|\
    \ x.0);\n   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpjxsub0xv.rs:33:32\n  \
    \ |\n33 |         row.sort_by_key(|&x| x.1);\n   |                           \
    \     ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpjxsub0xv.rs:34:32\n   |\n34 |         row.sort_by_key(|&x|\
    \ x.0);\n   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpjxsub0xv.rs:35:32\n  \
    \ |\n35 |         row.sort_by_key(|&x| x.1);\n   |                           \
    \     ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpjxsub0xv.rs:36:32\n   |\n36 |         row.sort_by_key(|&x|\
    \ x.0);\n   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpjxsub0xv.rs:37:32\n  \
    \ |\n37 |         row.sort_by_key(|&x| x.1);\n   |                           \
    \     ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't ha"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    let mut row_idx =\
    \ 1;\n    let mut col_idx = 1;\n    let mut row_max = lst.len();\n    let mut\
    \ col_max = lst[0].len();\n    while row_idx < row_max {\n        let mut row_idx\
    \ = 1;\n        while col_idx < col_max {\n            if lst[row_idx][col_idx]\
    \ == x {\n                result.push((row_idx, col_idx));\n                break;\n\
    \            }\n            col_idx += 1;\n        }\n        row_idx += 1;\n\
    \    }\n    result.sort_by_key(|&(x, y)| x.0);\n    result.sort_by_key(|&(x, y)|\
    \ y.0);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzjj_rcq9.rs:26:30\n   |\n\
    26 |                 result.push((row_idx, col_idx));\n   |                  \
    \            ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    26 |                 result.push((row_idx.try_into().unwrap(), col_idx));\n  \
    \ |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzjj_rcq9.rs:26:39\n   |\n26 |              \
    \   result.push((row_idx, col_idx));\n   |                                   \
    \    ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n26 |     \
    \            result.push((row_idx, col_idx.try_into().unwrap()));\n   |      \
    \                                        ++++++++++++++++++++\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpzjj_rcq9.rs:33:36\n\
    \   |\n33 |     result.sort_by_key(|&(x, y)| x.0);\n   |                     \
    \               ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpzjj_rcq9.rs:34:36\n   |\n34 |     result.sort_by_key(|&(x,\
    \ y)| y.0);\n   |                                    ^\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut col_idx = 0;\n    let mut row_len = lst.len();\n    let mut col_len\
    \ = lst[0].len();\n    let mut row_start = 0;\n    let mut col_start = 0;\n  \
    \  while row_idx < row_len {\n        let row_end = row_start + lst[row_idx].len();\n\
    \        let col_end = col_start + lst[row_idx][col_idx].len();\n        if row_end\
    \ > row_start {\n            row.push((row_start, row_idx));\n            row_start\
    \ = row_end;\n        }\n        if col_end > col_start {\n            row.push((col_start,\
    \ col_idx));\n            col_start = col_end;\n        }\n        row_idx +=\
    \ 1;\n        col_idx += 1;\n    }\n    row.push((row_start, row_idx));\n    row.push((col_start,\
    \ col_idx));\n    row.sort_by(|a, b| a.1.cmp(&b.1));\n    row.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    row\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmphk422a7w.rs:26:57\n   |\n26 |         let col_end = col_start\
    \ + lst[row_idx][col_idx].len();\n   |                                       \
    \                  ^^^ method not found in `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphk422a7w.rs:28:23\n   |\n28 |             row.push((row_start,\
    \ row_idx));\n   |                       ^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n28 |             row.push((row_start.try_into().unwrap(),\
    \ row_idx));\n   |                                ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphk422a7w.rs:28:34\n   |\n28 |             row.push((row_start,\
    \ row_idx));\n   |                                  ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n28 |             row.push((row_start,\
    \ row_idx.try_into().unwrap()));\n   |                                       \
    \  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphk422a7w.rs:32:34\n\
    \   |\n32 |             row.push((col_start, col_idx));\n   |                \
    \                  ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n32 |             row.push((col_start, col_idx.try_into().unwrap()));\n\
    \   |                                         ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphk422a7w.rs:38:15\n   |\n38 |     row.push((row_start,\
    \ row_idx));\n   |               ^^^^^^^^^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n38 |     row.push((row_start.try_into().unwrap(), row_idx));\n\
    \   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphk422a7w.rs:38:26\n   |\n38 |     row.push((row_start,\
    \ row_idx));\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut col_len_idx\
    \ = 0;\n    let mut col_len_idx_max = 0;\n    let mut row_len_idx = 0;\n    let\
    \ mut row_len_idx_max = 0;\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut col_idx = 0;\n    let mut col_idx_max = 0;\n    let mut row_idx\
    \ = 0;\n    let mut row_idx_max = 0;\n    let mut col_idx = 0;\n    let mut col_idx_max\
    \ = 0;\n    let mut row_idx = 0;\n    let mut row_idx_max = 0;\n    let mut col_idx\
    \ = 0;\n    let mut col_idx_max = 0;\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut col_idx = 0;\n    let mut col_idx_max = 0;\n    let mut row_idx\
    \ = 0;\n    let mut row_idx_max = 0;\n    let mut col_idx = 0;\n    let mut col_idx_max\
    \ = 0;\n    let mut row_idx = 0;\n    let mut row_idx_max = 0;\n    let mut col_idx\
    \ = 0;\n    let mut col_idx_max = 0;\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut col_idx = 0;\n    let mut col_idx_max = 0;\n    let mut row_idx\
    \ = 0;\n    let mut row_idx_max = 0;\n    let mut col_idx = 0;\n    let mut col_idx_max\
    \ = 0;\n    let mut row_idx = 0;\n    let mut row_idx_max = 0;\n    let mut col_idx\
    \ = 0;\n    let mut col_idx_max = 0;\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut col_idx = 0;\n    let mut col_idx_max = 0;\n    let mut row_idx\
    \ = 0;\n    let mut row_idx_max = 0;\n    let mut col_idx = 0;\n    let mut col_idx_max\
    \ = 0;\n    let mut row_idx = 0;\n    let mut row_idx_max = 0;\n    let mut col_idx\
    \ = 0;\n    let mut col_idx_max = 0;\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut col_idx = 0;\n    let mut col_idx_max = 0;\n    let mut row_idx\
    \ = 0;\n    let mut row_idx_max = 0;\n    let mut col_idx = 0;\n    let mut col_idx_max\
    \ = 0;\n    let mut row_idx = 0;\n    let mut row_idx_max = 0;\n    let mut col\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpogdmqowq.rs:83:16\n   |\n\
    83 |     let mut col\n   |                ^ help: add `;` here\n84 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpogdmqowq.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx2 = vec![];\n    let mut col_idx2 = vec![];\n    let mut row_sorted2\
    \ = vec![];\n    let mut col_sorted2 = vec![];\n    let mut row_idx3 = vec![];\n\
    \    let mut col_idx3 = vec![];\n    let mut row_sorted3 = vec![];\n    let mut\
    \ col_sorted3 = vec![];\n    let mut row_idx4 = vec![];\n    let mut col_idx4\
    \ = vec![];\n    let mut row_sorted4 = vec![];\n    let mut col_sorted4 = vec![];\n\
    \    let mut row_idx5 = vec![];\n    let mut col_idx5 = vec![];\n    let mut row_sorted5\
    \ = vec![];\n    let mut col_sorted5 = vec![];\n    let mut row_idx6 = vec![];\n\
    \    let mut col_idx6 = vec![];\n    let mut row_sorted6 = vec![];\n    let mut\
    \ col_sorted6 = vec![];\n    let mut row_idx7 = vec![];\n    let mut col_idx7\
    \ = vec![];\n    let mut row_sorted7 = vec![];\n    let mut col_sorted7 = vec![];\n\
    \    let mut row_idx8 = vec![];\n    let mut col_idx8 = vec![];\n    let mut row_sorted8\
    \ = vec![];\n    let mut col_sorted8 = vec![];\n    let mut row_idx9 = vec![];\n\
    \    let mut col_idx9 = vec![];\n    let mut row_sorted9 = vec![];\n    let mut\
    \ col_sorted9 = vec![];\n    let mut row_idx10 = vec![];\n    let mut col_idx10\
    \ = vec![];\n    let mut row_sorted10 = vec![];\n    let mut col_sorted10 = vec![];\n\
    \    let mut row_idx11 = vec![];\n    let mut col_idx11 = vec![];\n    let mut\
    \ row_sorted11 = vec![];\n    let mut col_sorted11 = vec![];\n    let mut row_idx12\
    \ = vec![];\n    let mut col_idx12 = vec![];\n    let mut row_sorted12 = vec![];\n\
    \    let mut col_sorted12 = vec![];\n    let mut row_idx13 = vec\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph3uz3uar.rs:68:28\n   |\n\
    68 |     let mut row_idx13 = vec\n   |                            ^ help: add\
    \ `;` here\n69 | }\n   | - unexpected token\n\nerror[E0423]: expected value, found\
    \ macro `vec`\n  --> /tmp/tmph3uz3uar.rs:68:25\n   |\n68 |     let mut row_idx13\
    \ = vec\n   |                         ^^^ not a value\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph3uz3uar.rs:16:47\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |    -------                        \
    \            ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n           found unit\
    \ type `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0423.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = Vec::new();\n    for row in 0..rows {\n        let mut cols = lst[row].len();\n\
    \        let mut coord = vec![];\n        for col in 0..cols {\n            if\
    \ row == 0 || col == 0 || row == rows - 1 || col == cols - 1 {\n             \
    \   coord.push((row, col));\n            }\n        }\n        coords.sort_by_key(|&(x,\
    \ y)| x.cmp(y));\n        coords.sort_by_key(|&(x, y)| y.cmp(x));\n    }\n   \
    \ coords.iter().map(|&(x, y)| vec![(x + 0, y + 0)]).collect()\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&(_, _)`\n  --> /tmp/tmpwpovfmmo.rs:28:29\n\
    \   |\n28 |         coords.sort_by_key(|&(x, y)| x.cmp(y));\n   |            \
    \                 ^^^^^^^ consider giving this closure parameter the explicit\
    \ type `&(_, _)`, with the type parameters specified\n   |\n   = note: type must\
    \ be known at this point\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        vec![]\n    } else {\n        let mut rows\
    \ = lst.iter().map(|row| row.iter().cloned()).collect::<Vec<_>>();\n        sort_rows(&mut\
    \ rows);\n        let mut cols = rows.iter().map(|row| row.iter().cloned()).collect::<Vec<_>>();\n\
    \        sort_cols(&mut cols);\n        let mut result = vec![];\n        for\
    \ row in rows {\n            for col in cols {\n                if col == x {\n\
    \                    result.push((row, col));\n                }\n           \
    \ }\n        }\n        result\n    }\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_rows` in this scope\n  --> /tmp/tmpjk7be68a.rs:21:9\n\
    \   |\n21 |         sort_rows(&mut rows);\n   |         ^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `sort_cols` in this scope\n\
    \  --> /tmp/tmpjk7be68a.rs:23:9\n   |\n23 |         sort_cols(&mut cols);\n  \
    \ |         ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `iter` found for reference `&Cloned<std::slice::Iter<'_, isize>>` in the current\
    \ scope\n  --> /tmp/tmpjk7be68a.rs:22:50\n   |\n22 |         let mut cols = rows.iter().map(|row|\
    \ row.iter().cloned()).collect::<Vec<_>>();\n   |                            \
    \                      ^^^^ method not found in `&Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjk7be68a.rs:32:9\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n32 |         result\n   |\
    \         ^^^^^^ expected `isize`, found struct `Cloned`\n   |\n   = note: expected\
    \ struct `Vec<(isize, isize)>`\n              found struct `Vec<(Cloned<std::slice::Iter<'_,\
    \ isize>>, _)>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx: usize\
    \ = 0;\n    let mut col_num: usize = 0;\n    let mut col_num2: usize = 0;\n  \
    \  let mut row_len: usize = 0;\n    let mut col_len: usize = 0;\n    let mut row_idx2:\
    \ usize = 0;\n    let mut col_num3: usize = 0;\n    let mut row_idx3: usize =\
    \ 0;\n    let mut col_num4: usize = 0;\n    let mut row_idx4: usize = 0;\n   \
    \ let mut col_num5: usize = 0;\n    let mut row_idx5: usize = 0;\n    let mut\
    \ col_num6: usize = 0;\n    let mut row_idx6: usize = 0;\n    let mut col_num7:\
    \ usize = 0;\n    let mut row_idx7: usize = 0;\n    let mut col_num8: usize =\
    \ 0;\n    let mut row_idx8: usize = 0;\n    let mut col_num9: usize = 0;\n   \
    \ let mut row_idx9: usize = 0;\n    let mut col_num10: usize = 0;\n    let mut\
    \ row_idx10: usize = 0;\n    let mut col_num11: usize = 0;\n    let mut row_idx11:\
    \ usize = 0;\n    let mut col_num12: usize = 0;\n    let mut row_idx12: usize\
    \ = 0;\n    let mut col_num13: usize = 0;\n    let mut row_idx13: usize = 0;\n\
    \    let mut col_num14: usize = 0;\n    let mut row_idx14: usize = 0;\n    let\
    \ mut col_num15: usize = 0;\n    let mut row_idx15: usize = 0;\n    let mut col_num16:\
    \ usize = 0;\n    let mut row_idx16: usize = 0;\n    let mut col_num17: usize\
    \ = 0;\n    let mut row_idx17: usize = 0;\n    let mut col_num18: usize = 0;\n\
    \    let mut row_idx18: usize = 0;\n    let mut col_num19: usize = 0;\n    let\
    \ mut row_idx19: usize = 0;\n    let mut col_num20: usize = 0;\n    let mut row_idx20:\
    \ usize = 0;\n    let mut col_num21: usize = 0;\n    let mut row_idx21: usize\
    \ = 0;\n    let mut col_num22: usize = 0;\n    let mut row_idx22: usize = 0;\n\
    \    let \n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp6ucixd55.rs:65:1\n  \
    \ |\n65 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        vec![]\n    } else {\n        let mut rows\
    \ = vec![];\n        let mut cols = vec![];\n        for row in lst {\n      \
    \      let mut row_cols = vec![];\n            for col in row.iter().cloned()\
    \ {\n                if col == x {\n                    row_cols.push((col, row.len()));\n\
    \                }\n            }\n            rows.push(row_cols);\n        \
    \    cols.push(row_cols.iter().cloned().collect::<Vec<_>>().reverse());\n    \
    \    }\n        vec![\n            rows.iter().cloned().collect::<Vec<_>>().reverse().cloned(),\n\
    \            cols.iter().cloned().collect::<Vec<_>>().reverse().cloned(),\n  \
    \      ]\n    }\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmpxxg2wyth.rs:33:64\n\
    \   |\n33 |             rows.iter().cloned().collect::<Vec<_>>().reverse().cloned(),\n\
    \   |                                                                ^^^^^^ `()`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpxxg2wyth.rs:34:64\n   |\n\
    34 |             cols.iter().cloned().collect::<Vec<_>>().reverse().cloned(),\n\
    \   |                                                                ^^^^^^ `()`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut col_pos\
    \ = 0;\n    let mut col_pos_idx = 0;\n    let mut col_pos_len = 0;\n    let mut\
    \ col_pos_len_idx = 0;\n    let mut col_pos_len_idx_idx = 0;\n    let mut row_len_idx\
    \ = 0;\n    let mut row_len_idx_idx = 0;\n    let mut row_len_idx_len = 0;\n \
    \   let mut row_len_idx_len_idx = 0;\n    let mut row_len_idx_len_idx_idx = 0;\n\
    \    let mut row_len_idx_len_idx_len = 0;\n    let mut row_len_idx_len_idx_len_idx\
    \ = 0;\n    let mut row_len_idx_len_idx_len_idx_idx = 0;\n    let mut row_len_idx_len_idx_len_idx_len\
    \ = 0;\n    let mut row_len_idx_len_idx_len_idx_len_idx = 0;\n    let mut row_len_idx_len_idx_len_idx_len_idx_idx\
    \ = 0;\n    let mut row_len_idx_len_idx_len_idx_len_idx_len = 0;\n    let mut\
    \ row_len_idx_len_idx_len_idx_len_idx_len_idx = 0;\n    let mut row_len_idx_len_idx_len_idx_len_idx_len_idx_idx\
    \ = 0;\n    let mut row_len_idx_len_idx_len_idx_len_idx_len_idx_len = 0;\n   \
    \ let mut row_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx = 0;\n    let mut\
    \ row_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len = 0;\n    let mut row_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx\
    \ = 0;\n    let mut row_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len\
    \ = 0;\n    let mut row_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx\
    \ = 0;\n    let mut row_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len\
    \ = 0;\n    let mut row_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx\
    \ = 0;\n    let mut row_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len\
    \ = 0;\n    let mut row_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx\
    \ = 0;\n    let mut row_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len\
    \ = 0;\n    let mut row_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9v5ul98w.rs:51:89\n   |\n\
    51 |     let mut row_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_len_idx_\n\
    \   |                                                                        \
    \                 ^ help: add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9v5ul98w.rs:16:47\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |    -------       \
    \                             ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    for row in 0..rows {\n        let mut cols = lst[row].len();\n\
    \        for col in 0..cols {\n            if lst[row][col] == x {\n         \
    \       coords.push((row, col));\n            }\n        }\n    }\n    coords.sort_by_key(|&(x,\
    \ y)| x.0);\n    coords.sort_by_key(|&(x, y)| y.0);\n    coords.iter().map(|&(x,\
    \ y)| vec![(x.0, y.0)]).collect()\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpsr2tl0cf.rs:28:36\n   |\n28 |     coords.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpsr2tl0cf.rs:29:36\n\
    \   |\n29 |     coords.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0610]: `usize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpsr2tl0cf.rs:30:41\n   |\n30 |     coords.iter().map(|&(x,\
    \ y)| vec![(x.0, y.0)]).collect()\n   |                                      \
    \   ^\n\nerror[E0610]: `usize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpsr2tl0cf.rs:30:46\n   |\n30 |     coords.iter().map(|&(x,\
    \ y)| vec![(x.0, y.0)]).collect()\n   |                                      \
    \        ^\n\nerror[E0277]: a value of type `Vec<(isize, isize)>` cannot be built\
    \ from an iterator over elements of type `Vec<_, _>`\n    --> /tmp/tmpsr2tl0cf.rs:30:51\n\
    \     |\n30   |     coords.iter().map(|&(x, y)| vec![(x.0, y.0)]).collect()\n\
    \     |                                                   ^^^^^^^ value of type\
    \ `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=Vec<_,\
    \ _>>`\n     |\n     = help: the trait `FromIterator<Vec<_, _>>` is not implemented\
    \ for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0610.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        Vec::new()\n    } else {\n        let mut\
    \ rows = lst.len();\n        let mut cols = lst[0].len();\n        let mut coords\
    \ = vec![];\n        let mut row_coords = vec![];\n        let mut col_coords\
    \ = vec![];\n        let mut row_sorted = vec![];\n        let mut col_sorted\
    \ = vec![];\n        let mut row_sort = vec![];\n        let mut col_sort = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n        let mut col_sort_idx = vec![];\n\
    \        let mut row_sort_idx = vec![];\n\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp62x523tr.rs:81:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n19 |     } else {\n   |            - this delimiter\
    \ might not be properly closed...\n...\n71 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n81 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp62x523tr.rs:18:9\n   |\n17 | /     if lst.is_empty() {\n\
    18 | |         Vec::new()\n   | |         ^^^^^^^^^^ expected `()`, found struct\
    \ `Vec`\n19 | |     } else {\n20 | |         let mut rows = lst.len();\n...  |\n\
    70 | |\n71 | | }\n   | |_- expected this to be `()`\n   |\n   = note: expected\
    \ unit type `()`\n                 found struct `Vec<_>`\nhelp: consider using\
    \ a semicolon here\n   |\n18 |         Vec::new();\n   |                   +\n\
    help: consider using a semicolon here\n   |\n71 | };\n   |  +\nhelp: you might\
    \ have meant to return this value\n   |\n18 |         return Vec::new();\n   |\
    \         ++++++           +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp62x523tr.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut col_pos\
    \ = 0;\n    let mut col_pos_idx = 0;\n    let mut row_pos = 0;\n    let mut row_pos_idx\
    \ = 0;\n    let mut col_pos_len = 0;\n    let mut col_pos_len_idx = 0;\n    let\
    \ mut row_pos_len = 0;\n    let mut row_pos_len_idx = 0;\n    let mut row_pos_len_idx\
    \ = 0;\n    let mut col_pos_len_idx = 0;\n    let mut col_pos_len_idx = 0;\n \
    \   let mut row_pos_len_idx = 0;\n    let mut row_pos_len_idx = 0;\n    let mut\
    \ row_pos_len_idx = 0;\n    let mut col_pos_len_idx = 0;\n    let mut col_pos_len_idx\
    \ = 0;\n    let mut row_pos_len_idx = 0;\n    let mut row_pos_len_idx = 0;\n \
    \   let mut row_pos_len_idx = 0;\n    let mut col_pos_len_idx = 0;\n    let mut\
    \ col_pos_len_idx = 0;\n    let mut row_pos_len_idx = 0;\n    let mut row_pos_len_idx\
    \ = 0;\n    let mut row_pos_len_idx = 0;\n    let mut col_pos_len_idx = 0;\n \
    \   let mut col_pos_len_idx = 0;\n    let mut row_pos_len_idx = 0;\n    let mut\
    \ row_pos_len_idx = 0;\n    let mut row_pos_len_idx = 0;\n    let mut col_pos_len_idx\
    \ = 0;\n    let mut col_pos_len_idx = 0;\n    let mut row_pos_len_idx = 0;\n \
    \   let mut row_pos_len_idx = 0;\n    let mut row_pos_len_idx = 0;\n    let mut\
    \ col_pos_len_idx = 0;\n    let mut col_pos_len_idx = 0;\n    let mut row_pos_len_idx\
    \ = 0;\n    let mut row_pos_len_idx = 0;\n    let mut row_pos_len_idx = 0;\n \
    \   let mut col_pos_len_idx = 0;\n    let mut col_pos_len_idx = 0;\n    let mut\
    \ row_pos_len_idx = 0;\n    let mut row_pos_len_idx = 0;\n    let mut row_pos_len_idx\
    \ = 0;\n    let mut col_pos_len_idx = 0;\n    let mut col_pos_len_idx = 0;\n \
    \   let mut row_pos_len_idx = 0;\n    let mut row_pos_len_idx = 0;\n    let mut\
    \ row_pos_len_idx = 0;\n    let mut col_pos_len_idx = 0;\n    let mut col_pos_len_idx\
    \ = 0;\n    let mut row_pos_len_idx = 0;\n    let mut row_pos_len_idx = 0;\n \
    \   let mut row_\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvc2beugy.rs:74:17\n   |\n\
    74 |     let mut row_\n   |                 ^ help: add `;` here\n75 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvc2beugy.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = vec![];\n    let mut row_idx = 1;\n    let mut col_idx\
    \ = 1;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    while row_idx < row_len {\n        let mut row_start = row_idx;\n       \
    \ let mut row_end = row_idx;\n        let mut col_start = col_idx;\n        let\
    \ mut col_end = col_idx;\n        while row_end < row_len && col_end < col_len\
    \ {\n            if lst[row_end][col_end] < x {\n                row_end += 1;\n\
    \            } else {\n                col_end += 1;\n            }\n        }\n\
    \        result.push((row_start, col_start));\n        result.push((row_end, col_end));\n\
    \        row_idx += 1;\n        col_idx += 1;\n    }\n    result.sort();\n   \
    \ result.sort_by_key(|&(x, y)| {\n        let mut x_idx = 1;\n        let mut\
    \ y_idx = 1;\n        while x_idx < x.len() && y_idx < y.len() {\n           \
    \ if x[x_idx] < y[y_idx] {\n                x_idx += 1;\n            } else {\n\
    \                y_idx += 1;\n            }\n        }\n        x_idx - y_idx\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpes1i6bqz.rs:43:25\n   |\n43 |         while x_idx < x.len()\
    \ && y_idx < y.len() {\n   |                         ^^^ method not found in `usize`\n\
    \nerror[E0599]: no method named `len` found for type `usize` in the current scope\n\
    \  --> /tmp/tmpes1i6bqz.rs:43:44\n   |\n43 |         while x_idx < x.len() &&\
    \ y_idx < y.len() {\n   |                                            ^^^ method\
    \ not found in `usize`\n\nerror[E0608]: cannot index into a value of type `usize`\n\
    \  --> /tmp/tmpes1i6bqz.rs:44:16\n   |\n44 |             if x[x_idx] < y[y_idx]\
    \ {\n   |                ^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `usize`\n  --> /tmp/tmpes1i6bqz.rs:44:27\n   |\n44 |             if x[x_idx]\
    \ < y[y_idx] {\n   |                           ^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpes1i6bqz.rs:52:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n52 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<(usize, usize)>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut col_idx = 0;\n    let mut row_len = 0;\n    let mut col_len\
    \ = 0;\n    for row in lst {\n        row_len += row.len();\n    }\n    for row\
    \ in lst {\n        col_idx = 0;\n        for col in row {\n            if col\
    \ == x {\n                row.insert(row_idx, (row_idx, col_idx));\n         \
    \       row_idx += 1;\n                break;\n            }\n            col_idx\
    \ += 1;\n        }\n    }\n    row.sort_by_key(|&(_, y)| y.0);\n    row.sort_by_key(|&(_,\
    \ y)| y.1);\n    row\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt18j6ucc.rs:29:37\n   |\n\
    29 |                 row.insert(row_idx, (row_idx, col_idx));\n   |          \
    \                           ^^^^^^^^^^^^^^^^^^ expected `isize`, found tuple\n\
    \   |\n   = note: expected type `isize`\n             found tuple `(usize, {integer})`\n\
    \nerror[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpt18j6ucc.rs:36:33\n   |\n36 |     row.sort_by_key(|&(_, y)| y.0);\n\
    \   |                                 ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpt18j6ucc.rs:37:33\n  \
    \ |\n37 |     row.sort_by_key(|&(_, y)| y.1);\n   |                          \
    \       ^\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0610.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sor\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuhnsu3xc.rs:68:20\n   |\n\
    68 |     let mut row_sor\n   |                    ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuhnsu3xc.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    for row in lst {\n\
    \        let mut row_result = Vec::<(isize, isize)>::new();\n        for (i, v)\
    \ in row.iter().enumerate() {\n            if i == x {\n                row_result.push((i,\
    \ v));\n            }\n        }\n        result.push(row_result);\n    }\n  \
    \  result.sort_by_key(|x| x.0);\n    result.sort_by_key(|x| x.1, |a, b| b.1.cmp(&a.1));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp16jpe075.rs:21:21\n   |\n\
    21 |             if i == x {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |             if i == x.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp16jpe075.rs:22:34\n   |\n22 |                 row_result.push((i,\
    \ v));\n   |                                  ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |                 row_result.push((i.try_into().unwrap(),\
    \ v));\n   |                                   ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp16jpe075.rs:22:37\n   |\n22 |              \
    \   row_result.push((i, v));\n   |                                     ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    22 |                 row_result.push((i, *v));\n   |                         \
    \            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp16jpe075.rs:25:21\n\
    \   |\n25 |         result.push(row_result);\n   |                     ^^^^^^^^^^\
    \ expected tuple, found struct `Vec`\n   |\n   = note: expected tuple `(isize,\
    \ isize)`\n             found struct `Vec<(isize, isize)>`\n\nerror[E0061]: this\
    \ function takes 1 argument but 2 arguments were supplied\n   --> /tmp/tmp16jpe075.rs:28:12\n\
    \    |\n28  |     result.sort_by_key(|x| x.1, |a, b| b.1.cmp(&a.1));\n    |  \
    \          ^^^^^^^^^^^ -------  -------------------- supplied 2 arguments\n  \
    \  |            |\n    |            expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sor\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuhnsu3xc.rs:68:20\n   |\n\
    68 |     let mut row_sor\n   |                    ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuhnsu3xc.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut col_max = 0;\n    for row in lst {\n        let mut col_max\
    \ = 0;\n        for col in row {\n            if col > col_max {\n           \
    \     col_max = col;\n            }\n        }\n        if col_max > x {\n   \
    \         break;\n        }\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n\
    \        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n    \
    \    row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x|\
    \ x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n\
    \        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n    \
    \    row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n\
    \        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n    \
    \    row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x|\
    \ x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n\
    \        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n    \
    \    row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n\
    \        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n    \
    \    row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpm4nmzmkn.rs:77:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n20 |     for row in lst {\n   |                   \
    \ - this delimiter might not be properly closed...\n...\n67 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n77 | }\n   |   ^\n\n\
    error: unexpected token: `}`\n  --> /tmp/tmpm4nmzmkn.rs:67:1\n   |\n67 | }\n \
    \  | ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpm4nmzmkn.rs:30:32\n   |\n30 |         row.sort_by_key(|&x|\
    \ x.0);\n   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpm4nmzmkn.rs:31:32\n  \
    \ |\n31 |         row.sort_by_key(|&x| x.1);\n   |                           \
    \     ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpm4nmzmkn.rs:32:32\n   |\n32 |         row.sort_by_key(|&x|\
    \ x.0);\n   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpm4nmzmkn.rs:33:32\n  \
    \ |\n33 |         row.sort_by_key(|&x| x.1);\n   |                           \
    \     ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpm4nmzmkn.rs:34:32\n   |\n34 |         row.sort_by_key(|&x|\
    \ x.0);\n   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpm4nmzmkn.rs:35:32\n  \
    \ |\n35 |         row.sort_by_key(|&x| x.1);\n   |                           \
    \     ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpm4nmzmkn.rs:36:32\n   |\n36 |         row.sort_by_key(|&x|\
    \ x.0);\n   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpm4nmzmkn.rs:37:32\n  \
    \ |\n37 |         row.sort_by_key(|&x| x.1);\n   |                     "
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n    let mut\
    \ col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n\
    \    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n    let\
    \ mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n\
    \    let mut col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n\
    \    let mut col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n\
    \    let mut col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n\
    \    let mut col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n\
    \    let mut col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n\
    \    let mut col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8udr_4ne.rs:76:17\n   |\n\
    76 |     let mut row_\n   |                 ^ help: add `;` here\n77 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8udr_4ne.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    for row in lst {\n\
    \        let mut row_result = Vec::<(isize, isize)>::new();\n        for (i, elem)\
    \ in row.iter().enumerate() {\n            if i == x {\n                row_result.push((i,\
    \ elem));\n            }\n        }\n        result.push(row_result);\n    }\n\
    \    result.sort_by_key(|&(_, y)| y.0);\n    result.sort_by_key(|&(_, y)| -y.1);\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps8zf6vhz.rs:21:21\n   |\n\
    21 |             if i == x {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |             if i == x.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmps8zf6vhz.rs:22:34\n   |\n22 |                 row_result.push((i,\
    \ elem));\n   |                                  ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |                 row_result.push((i.try_into().unwrap(),\
    \ elem));\n   |                                   ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps8zf6vhz.rs:22:37\n   |\n22 |              \
    \   row_result.push((i, elem));\n   |                                     ^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n22 |                 row_result.push((i, *elem));\n   |               \
    \                      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps8zf6vhz.rs:25:21\n\
    \   |\n25 |         result.push(row_result);\n   |                     ^^^^^^^^^^\
    \ expected tuple, found struct `Vec`\n   |\n   = note: expected tuple `(isize,\
    \ isize)`\n             found struct `Vec<(isize, isize)>`\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmps8zf6vhz.rs:27:36\n\
    \   |\n27 |     result.sort_by_key(|&(_, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmps8zf6vhz.rs:28:37\n   |\n28 |     result.sort_by_key(|&(_,\
    \ y)| -y.1);\n   |                                     ^\n\nerror: aborting due\
    \ to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    for row in lst {\n        let mut cols = row.len();\n\
    \        for col in row {\n            if col == x {\n                coords.push((row,\
    \ col));\n            }\n            cols -= 1;\n        }\n        rows -= 1;\n\
    \    }\n    coords.sort_by_key(|&(_, col)| col);\n    coords.sort_by_key(|&(_,\
    \ col)| -col);\n    coords\n}\n\nfn main() {\n    let candidate = get_row;\n \
    \   assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphql1uwo8.rs:32:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n32 |     coords\n   |     ^^^^^^ expected\
    \ `isize`, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, _)>`\n\
    \              found struct `Vec<(Vec<isize>, _)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut col_start\
    \ = 0;\n    for row in lst {\n        row_len += row.len();\n        if row_len\
    \ == x {\n            row_idx += 1;\n            row_len = 0;\n        }\n   \
    \ }\n    for row in lst {\n        col_len += row.len();\n        if col_len ==\
    \ x {\n            col_start = row.len() - 1;\n            col_len = 0;\n    \
    \    }\n    }\n    for row in lst {\n        for col in row.iter().rev() {\n \
    \           if col == x {\n                row.swap(row_idx, col_start);\n   \
    \             row_idx -= 1;\n                col_start -= 1;\n               \
    \ col_len -= 1;\n            }\n        }\n    }\n    row\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplg1m6ts7.rs:24:23\n   |\n\
    24 |         if row_len == x {\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n24 |         if row_len == x.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplg1m6ts7.rs:31:23\n   |\n31 |         if col_len == x {\n\
    \   |                       ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n31 |         if col_len == x.try_into().unwrap() {\n   |        \
    \                ++++++++++++++++++++\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmplg1m6ts7.rs:38:20\n   |\n38 |             if col\
    \ == x {\n   |                    ^^ no implementation for `&isize == isize`\n\
    \   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n\
    \    let mut row_sorted_idx_start = vec![];\n    let mut col_sorted_idx_start\
    \ = vec![];\n    let mut row_sorted_idx_end = vec![];\n    let mut col_sorted_idx_end\
    \ = vec![];\n    let mut row_sorted_idx_start = vec![];\n    let mut col_sorted_idx_start\
    \ = vec![];\n    let mut row_sorted_idx_end = vec![];\n    let mut col_sorted_idx_end\
    \ = vec![];\n    let mut row_sorted_idx_start = vec![];\n    let mut col_sorted_idx_start\
    \ = vec![];\n    let mut row_sorted_idx_end = vec![];\n    let mut col_sorted_idx_end\
    \ = vec![];\n    let mut row_sorted_idx_start = vec![];\n    let mut col_sorted_idx_start\
    \ = vec![];\n    let mut row_sorted_idx_end = vec![];\n    let mut col_sorted_idx_end\
    \ = vec![];\n    let mut row_sorted_idx_start = vec![];\n    let mut col_sorted_idx_start\
    \ = vec![];\n    let mut row_sorted_idx_end = vec![];\n    let mut col_sorted_idx_end\
    \ = vec![];\n    let mut row_sorted_idx_start = vec![];\n    let mut col_sorted_idx_start\
    \ = vec![];\n    let mut row_sorted_idx_end = vec![];\n    let mut col_sorted_idx_end\
    \ = vec![];\n    let mut row_sorted_idx_start = vec![];\n    let mut col_sorted_idx_start\
    \ = vec![];\n    let mut row_sorted_idx_end = vec![];\n    let mut col_sorted_idx_end\
    \ = vec![];\n    let mut row_sorted_idx_start = vec![];\n    let mut col_sorted_idx_start\
    \ = vec![];\n    let mut row_sorted_idx_end = vec![];\n    let mut col_sorted_idx_end\
    \ = vec![];\n    let mut row_sorted_idx_start = vec![];\n    let mut col_sorted_idx_start\
    \ = vec![];\n    let mut row_sorted_idx_end = vec![];\n    let mut col_sorted_idx_end\
    \ = vec![];\n    let mut row_sorted_idx_start = vec![];\n    let mut col_sorted_idx_start\
    \ = vec![];\n    let mut row_sorted_idx_end = \n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpw_r595x8.rs:65:1\n\
    \   |\n65 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    let mut rows = lst.len();\n\
    \    let mut cols = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    while row_idx < rows {\n        let mut row_coord = vec![];\n    \
    \    while col_idx < cols {\n            if row_idx == row_idx {\n           \
    \     row_coord.push((row_idx, col_idx));\n            }\n            if row_idx\
    \ < rows && col_idx < cols {\n                if lst[row_idx][col_idx] == x {\n\
    \                    row_coord.push((row_idx, col_idx));\n                   \
    \ break;\n                }\n            }\n            col_idx++;\n        }\n\
    \        result.push(row_coord);\n        row_idx++;\n        col_idx = 0;\n \
    \   }\n    result.sort_by_key(|&(_, y)| y.0);\n    result.sort_by_key(|&(_, y)|\
    \ -y.1);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpc2xhhzq0.rs:34:20\n\
    \   |\n34 |             col_idx++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n34 |             { let tmp =\
    \ col_idx; col_idx += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    34 -             col_idx++;\n34 +             col_idx += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmpc2xhhzq0.rs:37:16\n   |\n37\
    \ |         row_idx++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n37 |         { let tmp = row_idx; row_idx\
    \ += 1; tmp };\n   |         +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n37 -  \
    \       row_idx++;\n37 +         row_idx += 1;\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc2xhhzq0.rs:36:21\n   |\n36 |         result.push(row_coord);\n\
    \   |                     ^^^^^^^^^ expected tuple, found struct `Vec`\n   |\n\
    \   = note: expected tuple `(isize, isize)`\n             found struct `Vec<(usize,\
    \ usize)>`\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpc2xhhzq0.rs:40:36\n   |\n40 |     result.sort_by_key(|&(_,\
    \ y)| y.0);\n   |                                    ^\n\nerror[E0610]: `isize`\
    \ is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpc2xhhzq0.rs:41:37\n\
    \   |\n41 |     result.sort_by_key(|&(_, y)| -y.1);\n   |                    \
    \                 ^\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0610.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sor\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuhnsu3xc.rs:68:20\n   |\n\
    68 |     let mut row_sor\n   |                    ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuhnsu3xc.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    let mut row_idx =\
    \ 1;\n    let mut col_idx = 1;\n    let mut row_len = lst.len();\n    let mut\
    \ col_len = lst[0].len();\n    while row_idx < row_len {\n        let mut row_idx\
    \ = 1;\n        while col_idx < col_len {\n            if row_idx == row_len {\n\
    \                break;\n            }\n            if col_idx == col_len {\n\
    \                break;\n            }\n            if lst[row_idx][col_idx] ==\
    \ x {\n                result.push((row_idx, col_idx));\n                row_idx\
    \ += 1;\n                col_idx += 1;\n            } else {\n               \
    \ col_idx += 1;\n            }\n        }\n        row_len += 1;\n        col_len\
    \ += 1;\n    }\n    result.sort_by_key(|&(_, y)| y.0);\n    result.sort_by_key(|&(_,\
    \ y)| -y.0);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz0idrnyh.rs:32:30\n   |\n\
    32 |                 result.push((row_idx, col_idx));\n   |                  \
    \            ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    32 |                 result.push((row_idx.try_into().unwrap(), col_idx));\n  \
    \ |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz0idrnyh.rs:32:39\n   |\n32 |              \
    \   result.push((row_idx, col_idx));\n   |                                   \
    \    ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n32 |     \
    \            result.push((row_idx, col_idx.try_into().unwrap()));\n   |      \
    \                                        ++++++++++++++++++++\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpz0idrnyh.rs:42:36\n\
    \   |\n42 |     result.sort_by_key(|&(_, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpz0idrnyh.rs:43:37\n   |\n43 |     result.sort_by_key(|&(_,\
    \ y)| -y.0);\n   |                                     ^\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = Vec::new();\n    let mut row_coords = Vec::new();\n    let mut\
    \ col_coords = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp87t1dkxc.rs:16:47\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \    -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n    for row in lst {\n\
    \        row_len += row.len();\n        if row_len > x {\n            break;\n\
    \        }\n        col_len = row.len();\n        if col_len > x {\n         \
    \   break;\n        }\n    }\n    for row in lst {\n        let mut row_idx =\
    \ 0;\n        let mut row_len = 0;\n        let mut col_len = 0;\n        for\
    \ col in row {\n            row_len += 1;\n            if row_len > x {\n    \
    \            break;\n            }\n            col_len += 1;\n            if\
    \ col_len > x {\n                break;\n            }\n            row_idx +=\
    \ 1;\n        }\n        row.push(row_idx, col_len);\n    }\n    row.sort_by_key(|&(_,\
    \ y)| y.reverse());\n    row.sort_by_key(|&(_, y)| y.reverse());\n    row\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbpxk63mo.rs:23:22\n   |\n\
    23 |         if row_len > x {\n   |                      ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n23 |         if row_len > x.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbpxk63mo.rs:27:22\n   |\n27 |         if col_len > x {\n\
    \   |                      ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n27 |         if col_len > x.try_into().unwrap() {\n   |         \
    \              ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n    --> /tmp/tmpbpxk63mo.rs:46:13\n     |\n46\
    \   |         row.push(row_idx, col_len);\n     |             ^^^^ -------  -------\
    \ supplied 2 arguments\n     |             |\n     |             expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0599]: no method named\
    \ `reverse` found for type `isize` in the current scope\n  --> /tmp/tmpbpxk63mo.rs:48:33\n\
    \   |\n48 |     row.sort_by_key(|&(_, y)| y.reverse());\n   |                \
    \                 ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reverse_bits`\n\nerror[E0599]: no method named `reverse` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpbpxk63mo.rs:49:33\n   |\n49 |  \
    \   row.sort_by_key(|&(_, y)| y.reverse());\n   |                            \
    \     ^^^^^^^ help: there is an associated function with a similar name: `reverse_bits`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_idx2 = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4\
    \ = 0;\n    let mut row_idx5 = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7\
    \ = 0;\n    let mut row_idx8 = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10\
    \ = 0;\n    let mut row_idx11 = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13\
    \ = 0;\n    let mut row_idx14 = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16\
    \ = 0;\n    let mut row_idx17 = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19\
    \ = 0;\n    let mut row_idx20 = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22\
    \ = 0;\n    let mut row_idx23 = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25\
    \ = 0;\n    let mut row_idx26 = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28\
    \ = 0;\n    let mut row_idx29 = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31\
    \ = 0;\n    let mut row_idx32 = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34\
    \ = 0;\n    let mut row_idx35 = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37\
    \ = 0;\n    let mut row_idx38 = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40\
    \ = 0;\n    let mut row_idx41 = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43\
    \ = 0;\n    let mut row_idx44 = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46\
    \ = 0;\n    let mut row_idx47 = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49\
    \ = 0;\n    let mut row_idx50 = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52\
    \ = 0;\n    let mut row_idx53 = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55\
    \ = 0;\n    let mut row_idx56 = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58\
    \ = 0;\n    let mut row_idx59 = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61\
    \ = 0;\n    let mut row_idx62 = 0;\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpy0j02d22.rs:81:1\n\
    \   |\n81 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst.clone();\n    let mut row = 0;\n    let mut col = 0;\n\
    \    while row < lst.len() {\n        let mut found = false;\n        for y in\
    \ 0..row.len() {\n            if lst[row][y] == x {\n                found = true;\n\
    \                break;\n            }\n        }\n        if found {\n      \
    \      return vec![(0, row), (1, col), (row, col)].into_iter().collect();\n  \
    \      }\n        row += 1;\n        col += 1;\n    }\n    vec![]\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp_f7qi6ds.rs:22:25\n   |\n22 |         for y in 0..row.len()\
    \ {\n   |                         ^^^ method not found in `usize`\n\nerror[E0277]:\
    \ a value of type `Vec<(isize, isize)>` cannot be built from an iterator over\
    \ elements of type `(usize, usize)`\n    --> /tmp/tmp_f7qi6ds.rs:29:69\n     |\n\
    29   |             return vec![(0, row), (1, col), (row, col)].into_iter().collect();\n\
    \     |                                                                     ^^^^^^^\
    \ value of type `Vec<(isize, isize)>` cannot be built from `std::iter::Iterator<Item=(usize,\
    \ usize)>`\n     |\n     = help: the trait `FromIterator<(usize, usize)>` is not\
    \ implemented for `Vec<(isize, isize)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = vec![];\n    for row in lst {\n        let mut row_result\
    \ = vec![];\n        for col in row.iter().rev() {\n            if col == x {\n\
    \                row_result.push((row.len(), col.len()));\n            }\n   \
    \     }\n        result.push(row_result);\n    }\n    result.sort_by_key(|row|\
    \ row[0].cmp(&row[1]));\n    result.sort_by_key(|row| row[1].cmp(&row[0]));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp91n919na.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0599]: no method named `len`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmp91n919na.rs:22:49\n\
    \   |\n22 |                 row_result.push((row.len(), col.len()));\n   |   \
    \                                              ^^^ method not found in `&isize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut col_max = lst[0].len();\n    let mut col_min = col_max - 1;\n\
    \    let mut row_max = lst[0].len();\n    let mut row_min = row_max - 1;\n   \
    \ let mut row_idx = 0;\n    for row in lst {\n        row_idx = row.iter().enumerate().filter(|&(i,\
    \ _)| i == x).count();\n        if row_idx > 0 {\n            row_idx -= 1;\n\
    \        }\n        let mut col_max = row.len();\n        let mut col_min = col_max\
    \ - 1;\n        for col in row {\n            col_max = col.max();\n         \
    \   col_min = col.min();\n            if col == x {\n                row.push((row_idx,\
    \ col_max));\n            }\n        }\n        if row_idx > 0 {\n           \
    \ row_idx -= 1;\n        }\n    }\n    row.sort_by_key(|&(_, y)| y.cmp(&row_min));\n\
    \    row.sort_by_key(|&(_, y)| y.cmp(&row_max));\n    row\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp16b9bvvz.rs:25:64\n   |\n\
    25 |         row_idx = row.iter().enumerate().filter(|&(i, _)| i == x).count();\n\
    \   |                                                                ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n25 |         row_idx = row.iter().enumerate().filter(|&(i,\
    \ _)| i == x.try_into().unwrap()).count();\n   |                             \
    \                                    ++++++++++++++++++++\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp16b9bvvz.rs:32:27\n\
    \    |\n32  |             col_max = col.max();\n    |                        \
    \   ^^^- supplied 0 arguments\n    |                           |\n    |      \
    \                     expected 1 argument\n    |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp16b9bvvz.rs:32:23\n  \
    \ |\n29 |         let mut col_max = row.len();\n   |                         \
    \  --------- expected due to this value\n...\n32 |             col_max = col.max();\n\
    \   |                       ^^^^^^^^^ expected `usize`, found `isize`\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp16b9bvvz.rs:33:27\n\
    \    |\n33  |             col_min = col.min();\n    |                        \
    \   ^^^- supplied 0 arguments\n    |                           |\n    |      \
    \                     expected 1 argument\n    |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp16b9bvvz.rs:33:23\n  \
    \ |\n30 |         let mut col_min = col_max - 1;\n   |                       \
    \    ----------- expected due to this value\n...\n33 |             col_min = col.min();\n\
    \   |                       ^^^^^^^^^ expected `usize`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp16b9bvvz.rs:35:26\n   |\n35 |              \
    \   row.push((row_idx, col_max));\n   |                          ^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut col_max = 0;\n    for row in lst {\n        let mut col_max\
    \ = 0;\n        for col in row {\n            if col > col_max {\n           \
    \     col_max = col;\n            }\n        }\n        row_idx += 1;\n      \
    \  for col in row.iter().rev() {\n            if col > col_max {\n           \
    \     col_max = col;\n            }\n        }\n        row.sort_by_key(|&x| x.0);\n\
    \        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n    \
    \    row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n\
    \        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n    \
    \    row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x|\
    \ x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n\
    \        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n    \
    \    row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n\
    \        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n    \
    \    row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x|\
    \ x.0);\n        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n\
    \        row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n    \
    \    row.sort_by_key(|&x| x.1);\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ x.1);\n        row.sort_by_key(|\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpc8a02p68.rs:78:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n20 |     for row in lst {\n   |                   \
    \ - this delimiter might not be properly closed...\n...\n68 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n78 | }\n   |   ^\n\n\
    error: mismatched closing delimiter: `}`\n  --> /tmp/tmpc8a02p68.rs:67:24\n  \
    \ |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |                                                                   - closing\
    \ delimiter possibly meant for this\n...\n67 |         row.sort_by_key(|\n   |\
    \                        ^ unclosed delimiter\n68 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: expected `|`, found `)`\n  --> /tmp/tmpc8a02p68.rs:68:1\n\
    \   |\n67 |         row.sort_by_key(|\n   |                          - expected\
    \ `|`\n68 | }\n   | ^ unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpc8a02p68.rs:29:22\n   |\n29 |             if col > col_max {\n   | \
    \                     ^^^^^^^\n   |                      |\n   |             \
    \         expected `&isize`, found `isize`\n   |                      help: consider\
    \ borrowing here: `&col_max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc8a02p68.rs:30:27\n\
    \   |\n21 |         let mut col_max = 0;\n   |                           - expected\
    \ due to this value\n...\n30 |                 col_max = col;\n   |          \
    \                 ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n30 |                 col_max = *col;\n   |               \
    \            +\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpc8a02p68.rs:33:32\n   |\n33 |         row.sort_by_key(|&x|\
    \ x.0);\n   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpc8a02p68.rs:34:32\n  \
    \ |\n34 |         row.sort_by_key(|&x| x.1);\n   "
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords\
    \ = vec![];\n    let mut row_coord = vec![];\n    let mut col_coord = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_coord = vec![];\n    let mut col_coord = vec![];\n    let mut row_coords\
    \ = vec![];\n    let mut col_coords = vec![];\n    let mut row_coord = vec![];\n\
    \    let mut col_coord = vec![];\n    let mut row_coords = vec![];\n    let mut\
    \ col_coords = vec![];\n    let mut row_coord = vec![];\n    let mut col_coord\
    \ = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n\
    \    let mut row_coord = vec![];\n    let mut col_coord = vec![];\n    let mut\
    \ row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut row_coord\
    \ = vec![];\n    let mut col_coord = vec![];\n    let mut row_coords = vec![];\n\
    \    let mut col_coords = vec![];\n    let mut row_coord = vec![];\n    let mut\
    \ col_coord = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords\
    \ = vec![];\n    let mut row_coord = vec![];\n    let mut col_coord = vec![];\n\
    \    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n    let mut\
    \ row_coord = vec![];\n    let mut col_coord = vec![];\n    let mut row_coords\
    \ = vec![];\n    let mut col_coords = vec![];\n    let mut row_coord = vec![];\n\
    \    let mut col_coord = vec![];\n    let mut row_coords = vec![];\n    let mut\
    \ col_coords = vec![];\n    let mut row_coord = vec![];\n    let mut col_coord\
    \ = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords = vec![];\n\
    \    let mut row_coord = vec![];\n    let mut col_coord = vec![];\n    let mut\
    \ row_coord\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpno2dvim9.rs:68:22\n   |\n\
    68 |     let mut row_coord\n   |                      ^ help: add `;` here\n69\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpno2dvim9.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut col_idx = 0;\n    let mut col_max = lst[0].len();\n    for row in\
    \ lst {\n        if row.len() > col_idx {\n            row_idx += 1;\n       \
    \     col_idx = 0;\n        }\n        if col_idx > col_max {\n            col_max\
    \ = row.len();\n        }\n        if row[col_idx] == x {\n            row.push((row_idx,\
    \ col_idx));\n        }\n        col_idx += 1;\n    }\n    row.sort_by_key(|&(_,\
    \ y)| y.cmp(&x));\n    row.sort_by_key(|&(_, y)| y.cmp(&-x));\n    row\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphsvd4r90.rs:30:22\n   |\n\
    30 |             row.push((row_idx, col_idx));\n   |                      ^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found tuple\n   |\n   = note: expected type `isize`\n    \
    \         found tuple `({integer}, usize)`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_idx_max = 0;\n    let mut row_idx_min = 0;\n    let mut\
    \ col_max = 0;\n    let mut col_min = 0;\n    let mut col_max_idx = 0;\n    let\
    \ mut col_min_idx = 0;\n    for row in lst {\n        let row_len = row.len();\n\
    \        if row_len > row_idx_max {\n            row_idx_max = row_len;\n    \
    \    }\n        if row_len < row_idx_min {\n            row_idx_min = row_len;\n\
    \        }\n        for col in row {\n            if col > col_max {\n       \
    \         col_max = col;\n                col_max_idx = col;\n            }\n\
    \            if col < col_min {\n                col_min = col;\n            \
    \    col_min_idx = col;\n            }\n        }\n    }\n    let mut row_max\
    \ = row_idx_max;\n    let mut row_min = row_idx_min;\n    let mut col_max = col_max;\n\
    \    let mut col_min = col_min;\n    let mut col_max_idx = col_max_idx;\n    let\
    \ mut col_min_idx = col_min_idx;\n    for row in lst {\n        let row_len =\
    \ row.len();\n        if row_len > row_max {\n            row_max = row_len;\n\
    \        }\n        if row_len < row_min {\n            row_min = row_len;\n \
    \       }\n        for col in row {\n            if col > col_max {\n        \
    \        col_max = col;\n                col_max_idx = col;\n            }\n \
    \           if col < col_min {\n                col_min = col;\n             \
    \   col_min_idx = col;\n            }\n        }\n    }\n    let mut row_range\
    \ = row_max - row_min + 1;\n    let mut col_range = col_max - col_min + 1;\n \
    \   let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_idx_max =\
    \ 0;\n    let mut row_idx_min = 0;\n    let mut col_max = 0;\n    let mut col_min\
    \ = 0;\n    let mut col_max_idx = 0;\n    let mut col_min_idx = 0;\n    let mut\
    \ row_idx_min = 0;\n    let mut row_idx_max = 0;\n    let mut col_min = 0;\n \
    \   let mut col_max = 0;\n    let mut col_min_idx = 0;\n    let mut col_max_idx\
    \ = 0;\n    let mut row_idx_min = 0;\n    let mut row_idx_max = 0;\n    let mut\
    \ col_min = 0;\n    let mut col_max = 0;\n    let mut col_min_idx = 0;\n    let\
    \ mut col_max_idx = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpovif63_q.rs:91:11\n   |\n\
    91 |     let mu\n   |           ^ help: add `;` here\n92 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpovif63_q.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut col_pos\
    \ = 0;\n    let mut col_pos_idx = 0;\n    let mut col_pos_len = 0;\n    let mut\
    \ col_pos_len_idx = 0;\n    let mut row_len_idx = 0;\n    let mut row_len_idx_idx\
    \ = 0;\n    let mut col_pos_len_idx = 0;\n    let mut col_pos_len_idx_idx = 0;\n\
    \    let mut row_idx = 0;\n    let mut row_idx_idx = 0;\n    let mut col_pos_idx\
    \ = 0;\n    let mut col_pos_idx_idx = 0;\n    let mut col_pos_len_idx = 0;\n \
    \   let mut col_pos_len_idx_idx = 0;\n    let mut row_idx = 0;\n    let mut row_idx_idx\
    \ = 0;\n    let mut col_pos_idx = 0;\n    let mut col_pos_idx_idx = 0;\n    let\
    \ mut col_pos_len_idx = 0;\n    let mut col_pos_len_idx_idx = 0;\n    let mut\
    \ row_idx = 0;\n    let mut row_idx_idx = 0;\n    let mut col_pos_idx = 0;\n \
    \   let mut col_pos_idx_idx = 0;\n    let mut col_pos_len_idx = 0;\n    let mut\
    \ col_pos_len_idx_idx = 0;\n    let mut row_idx = 0;\n    let mut row_idx_idx\
    \ = 0;\n    let mut col_pos_idx = 0;\n    let mut col_pos_idx_idx = 0;\n    let\
    \ mut col_pos_len_idx = 0;\n    let mut col_pos_len_idx_idx = 0;\n    let mut\
    \ row_idx = 0;\n    let mut row_idx_idx = 0;\n    let mut col_pos_idx = 0;\n \
    \   let mut col_pos_idx_idx = 0;\n    let mut col_pos_len_idx = 0;\n    let mut\
    \ col_pos_len_idx_idx = 0;\n    let mut row_idx = 0;\n    let mut row_idx_idx\
    \ = 0;\n    let mut col_pos_idx = 0;\n    let mut col_pos_idx_idx = 0;\n    let\
    \ mut col_pos_len_idx = 0;\n    let mut col_pos_len_idx_idx = 0;\n    let mut\
    \ row_idx = 0;\n    let mut row_idx_idx = 0;\n    let mut col_pos_idx = 0;\n \
    \   let mut col_pos_idx_idx = 0;\n    let mut col_pos_len_idx = 0;\n    let mut\
    \ col_pos_len_idx_idx = 0;\n    let mut row_idx = 0;\n    let mut row_idx_idx\
    \ = 0;\n    let mut col_pos_idx = 0;\n    let mut col_pos_idx_idx = 0;\n    let\
    \ mut col_pos_len_idx = 0;\n    let mut col_pos_len_idx_\n}\n\nfn main() {\n \
    \   let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvbbrzi42.rs:76:29\n   |\n\
    76 |     let mut col_pos_len_idx_\n   |                             ^ help: add\
    \ `;` here\n77 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvbbrzi42.rs:16:47\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |    -------                        \
    \            ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n           found unit\
    \ type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    for row in lst {\n        let mut row_result\
    \ = Vec::new();\n        for el in row {\n            if el == x {\n         \
    \       row_result.push((row, el));\n            }\n        }\n        result.push(row_result);\n\
    \    }\n    result.sort_by_key(|x| x.0);\n    result.sort_by_key(|x| x.1, |a,\
    \ b| b.1.cmp(&a.1));\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&Vec<(Vec<isize>, isize)>`\n  --> /tmp/tmptqe6d6hn.rs:27:30\n\
    \   |\n27 |     result.sort_by_key(|x| x.0);\n   |                           \
    \   ^ unknown field\n\nerror[E0061]: this function takes 1 argument but 2 arguments\
    \ were supplied\n   --> /tmp/tmptqe6d6hn.rs:28:12\n    |\n28  |     result.sort_by_key(|x|\
    \ x.1, |a, b| b.1.cmp(&a.1));\n    |            ^^^^^^^^^^^ -------  --------------------\
    \ supplied 2 arguments\n    |            |\n    |            expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptqe6d6hn.rs:29:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x:\
    \ isize) -> Vec<(isize, isize)> {\n   |                                      \
    \         ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n29 |     result\n   |     ^^^^^^ expected tuple, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<(Vec<isize>, isize)>>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_idx2 = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4\
    \ = 0;\n    let mut row_idx5 = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7\
    \ = 0;\n    let mut row_idx8 = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10\
    \ = 0;\n    let mut row_idx11 = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13\
    \ = 0;\n    let mut row_idx14 = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16\
    \ = 0;\n    let mut row_idx17 = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19\
    \ = 0;\n    let mut row_idx20 = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22\
    \ = 0;\n    let mut row_idx23 = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25\
    \ = 0;\n    let mut row_idx26 = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28\
    \ = 0;\n    let mut row_idx29 = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31\
    \ = 0;\n    let mut row_idx32 = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34\
    \ = 0;\n    let mut row_idx35 = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37\
    \ = 0;\n    let mut row_idx38 = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40\
    \ = 0;\n    let mut row_idx41 = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43\
    \ = 0;\n    let mut row_idx44 = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46\
    \ = 0;\n    let mut row_idx47 = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49\
    \ = 0;\n    let mut row_idx50 = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52\
    \ = 0;\n    let mut row_idx53 = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55\
    \ = 0;\n    let mut row_idx56 = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58\
    \ = 0;\n    let mut row_idx59 = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61\
    \ = 0;\n    let mut row_idx62 = 0;\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpy0j02d22.rs:81:1\n\
    \   |\n81 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut col_max = 0;\n    for row in lst {\n        let mut col_max\
    \ = 0;\n        for col in row {\n            if col > col_max {\n           \
    \     col_max = col;\n            }\n        }\n        row_idx += 1;\n      \
    \  if row_idx == x {\n            break;\n        }\n    }\n    let mut col_min\
    \ = 0;\n    for row in lst {\n        let mut col_min = 0;\n        for col in\
    \ row {\n            if col < col_min {\n                col_min = col;\n    \
    \        }\n        }\n        row_idx += 1;\n        if row_idx == x {\n    \
    \        break;\n        }\n    }\n    let mut row_max = row_idx;\n    let mut\
    \ col_min = col_max;\n    for row in lst {\n        let mut col_min = col_max;\n\
    \        for col in row {\n            if col < col_min {\n                col_min\
    \ = col;\n            }\n        }\n        row_max += 1;\n        if row_max\
    \ == x {\n            break;\n        }\n    }\n    let mut row_min = row_idx;\n\
    \    let mut col_max = col_min;\n    for row in lst {\n        let mut col_max\
    \ = col_min;\n        for col in row {\n            if col > col_max {\n     \
    \           col_max = col;\n            }\n        }\n        row_min += 1;\n\
    \        if row_min == x {\n            break;\n        }\n    }\n    let mut\
    \ row_max = row_idx;\n    let mut col_min = col_max;\n    for row in lst {\n \
    \       let mut col_min = col_max;\n        for col in row {\n            if col\
    \ > col_min {\n                col_min = col;\n            }\n        }\n    \
    \    row_max += 1;\n        if row_max == x {\n            break;\n        }\n\
    \    }\n    let mut row_min = row_idx;\n    let mut col_max = col_min;\n    for\
    \ row in lst {\n        let mut col_max = col_min;\n        for col in row {\n\
    \            if col < col_max {\n                col_max = col;\n            }\n\
    \        }\n        row_min += 1;\n        if row_min == x {\n            break;\n\
    \        }\n    }\n    let mut row_max = row_idx;\n    let mut col_min = col_max;\n\
    \    for row in lst {\n        let mut col_min = col_max;\n        for col in\
    \ row {\n            if col < col_min {\n                col_min = col;\n    \
    \        }\n        }\n        row_max += 1;\n        if row_max == x {\n    \
    \        break;\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpo70v1b_f.rs:123:3\n\
    \    |\n16  | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    |                                                                   -\
    \ unclosed delimiter\n...\n103 |     for row in lst {\n    |                 \
    \   - unclosed delimiter\n...\n111 |         if row_max == x {\n    |        \
    \                 - this delimiter might not be properly closed...\n112 |    \
    \         break;\n113 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n123 | }\n    |   ^\n\nerror[E0308]: mismatched types\n   -->\
    \ /tmp/tmpo70v1b_f.rs:103:5\n    |\n16  |   fn get_row(lst: Vec<Vec<isize>>, x:\
    \ isize) -> Vec<(isize, isize)> {\n    |                                     \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n103 | /     for row in lst {\n104 | |         let mut col_min = col_max;\n\
    105 | |         for col in row {\n106 | |             if col < col_min {\n...\
    \   |\n122 | |     assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2, 3]],\
    \ 3), vec![(2, 2)]);\n123 | | }\n    | |__^ expected struct `Vec`, found `()`\n\
    \    |\n    = note: expected struct `Vec<(isize, isize)>`\n            found unit\
    \ type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = vec![];\n    for row in lst {\n        let mut row =\
    \ row.clone();\n        row.sort_by_key(|&x| x.0);\n        row.sort_by_key(|&x|\
    \ -x.1);\n        for row in row.iter().rev() {\n            if row.1 == x {\n\
    \                result.push((row.0, row.1));\n            }\n        }\n    }\n\
    \    result.sort_by_key(|&(x, y)| x.0);\n    result.sort_by_key(|&(x, y)| -x.1);\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpzmhbhgnn.rs:20:32\n   |\n20 |         row.sort_by_key(|&x| x.0);\n\
    \   |                                ^\n\nerror[E0610]: `isize` is a primitive\
    \ type and therefore doesn't have fields\n  --> /tmp/tmpzmhbhgnn.rs:21:33\n  \
    \ |\n21 |         row.sort_by_key(|&x| -x.1);\n   |                          \
    \       ^\n\nerror[E0609]: no field `1` on type `&isize`\n  --> /tmp/tmpzmhbhgnn.rs:23:20\n\
    \   |\n23 |             if row.1 == x {\n   |                    ^\n\nerror[E0609]:\
    \ no field `0` on type `&isize`\n  --> /tmp/tmpzmhbhgnn.rs:24:34\n   |\n24 | \
    \                result.push((row.0, row.1));\n   |                          \
    \        ^\n\nerror[E0609]: no field `1` on type `&isize`\n  --> /tmp/tmpzmhbhgnn.rs:24:41\n\
    \   |\n24 |                 result.push((row.0, row.1));\n   |               \
    \                          ^\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0609, E0610.\nFor more information about\
    \ an error, try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    for row in lst {\n        let mut row_result\
    \ = Vec::new();\n        for col in row.iter().rev() {\n            if col ==\
    \ x {\n                row_result.push((row, col));\n            }\n        }\n\
    \        result.push(row_result);\n    }\n    result.sort_by_key(|row| row.iter().rev());\n\
    \    result.sort_by_key(|row| row.iter().rev());\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpvj72pepe.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0277]: the trait bound `Rev<std::slice::Iter<'_,\
    \ (Vec<isize>, &isize)>>: Ord` is not satisfied\n   --> /tmp/tmpvj72pepe.rs:27:24\n\
    \    |\n27  |     result.sort_by_key(|row| row.iter().rev());\n    |         \
    \   ----------- ^^^^^^^^^^^^^^^^^^^^^^ the trait `Ord` is not implemented for\
    \ `Rev<std::slice::Iter<'_, (Vec<isize>, &isize)>>`\n    |            |\n    |\
    \            required by a bound introduced by this call\n    |\nnote: required\
    \ by a bound in `slice::<impl [T]>::sort_by_key`\n\nerror[E0277]: the trait bound\
    \ `Rev<std::slice::Iter<'_, (Vec<isize>, &isize)>>: Ord` is not satisfied\n  \
    \ --> /tmp/tmpvj72pepe.rs:28:24\n    |\n28  |     result.sort_by_key(|row| row.iter().rev());\n\
    \    |            ----------- ^^^^^^^^^^^^^^^^^^^^^^ the trait `Ord` is not implemented\
    \ for `Rev<std::slice::Iter<'_, (Vec<isize>, &isize)>>`\n    |            |\n\
    \    |            required by a bound introduced by this call\n    |\nnote: required\
    \ by a bound in `slice::<impl [T]>::sort_by_key`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvj72pepe.rs:29:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x:\
    \ isize) -> Vec<(isize, isize)> {\n   |                                      \
    \         ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n29 |     result\n   |     ^^^^^^ expected tuple, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<(Vec<isize>, &isize)>>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut result = Vec::new();\n    let mut row_idx = 1;\n    let mut col_idx = 1;\n\
    \    let mut row_start = 0;\n    let mut col_start = 0;\n    let mut row_end =\
    \ 0;\n    let mut col_end = 0;\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_start = 0;\n    let mut col_start = 0;\n    let mut row_end\
    \ = 0;\n    let mut col_end = 0;\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_start = 0;\n    let mut col_start = 0;\n    let mut row_end\
    \ = 0;\n    let mut col_end = 0;\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_start = 0;\n    let mut col_start = 0;\n    let mut row_end\
    \ = 0;\n    let mut col_end = 0;\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_start = 0;\n    let mut col_start = 0;\n    let mut row_end\
    \ = 0;\n    let mut col_end = 0;\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_start = 0;\n    let mut col_start = 0;\n    let mut row_end\
    \ = 0;\n    let mut col_end = 0;\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_start = 0;\n    let mut col_start = 0;\n    let mut row_end\
    \ = 0;\n    let mut col_end = 0;\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_start = 0;\n    let mut col_start = 0;\n    let mut row_end\
    \ = 0;\n    let mut col_end = 0;\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_start = 0;\n    let mut col_start = 0;\n    let mut row_end\
    \ = 0;\n    let mut col_end = 0;\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_start = 0;\n    let mut col_start = 0;\n    let mut row_end\
    \ = 0;\n    let mut col_end = 0;\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_start = 0;\n    let mut col_start = 0;\n    let mut row_end\
    \ = 0;\n    let mut col_end = 0;\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_start = 0;\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp67z1sout.rs:89:11\n   |\n\
    89 |     let mu\n   |           ^ help: add `;` here\n90 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp67z1sout.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut result = Vec::new();\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n\
    \    while col_idx < cols {\n        while row_idx < rows {\n            if lst[row_idx][col_idx]\
    \ == x {\n                result.push((row_idx, col_idx));\n                break;\n\
    \            }\n            row_idx += 1;\n        }\n        col_idx += 1;\n\
    \    }\n    result.sort_by_key(|&(x, y)| x.0);\n    result.sort_by_key(|&(x, y)|\
    \ y.0);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp1zk11gfr.rs:32:36\n   |\n32 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmp1zk11gfr.rs:33:36\n\
    \   |\n33 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1zk11gfr.rs:34:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n34 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n\
    \    let mut row_sorted_idx2 = vec![];\n    let mut col_sorted_idx2 = vec![];\n\
    \    let mut row_sorted_idx3 = vec![];\n    let mut col_sorted_idx3 = vec![];\n\
    \    let mut row_sorted_idx4 = vec![];\n    let mut col_sorted_idx4 = vec![];\n\
    \    let mut row_sorted_idx5 = vec![];\n    let mut col_sorted_idx5 = vec![];\n\
    \    let mut row_sorted_idx6 = vec![];\n    let mut col_sorted_idx6 = vec![];\n\
    \    let mut row_sorted_idx7 = vec![];\n    let mut col_sorted_idx7 = vec![];\n\
    \    let mut row_sorted_idx8 = vec![];\n    let mut col_sorted_idx8 = vec![];\n\
    \    let mut row_sorted_idx9 = vec![];\n    let mut col_sorted_idx9 = vec![];\n\
    \    let mut row_sorted_idx10 = vec![];\n    let mut col_sorted_idx10 = vec![];\n\
    \    let mut row_sorted_idx11 = vec![];\n    let mut col_sorted_idx11 = vec![];\n\
    \    let mut row_sorted_idx12 = vec![];\n    let mut col_sorted_idx12 = vec![];\n\
    \    let mut row_sorted_idx13 = vec![];\n    let mut col_sorted_idx13 = vec![];\n\
    \    let mut row_sorted_idx14 = vec![];\n    let mut col_sorted_idx14 = vec![];\n\
    \    let mut row_sorted_idx15 = vec![];\n    let mut col_sorted_idx15 = vec![];\n\
    \    let mut row_sorted_idx16 = vec![];\n    let mut col_sorted_idx16 = vec![];\n\
    \    let mut row_sorted_idx17 = vec![];\n    let mut col_sorted_idx17 = vec![];\n\
    \    let mut row_sorted_idx18 = vec![];\n    let mut col_sorted_idx18 = vec![];\n\
    \    let mut row_sorted_idx19 = vec![];\n    let mut col_sorted_idx19 = vec![];\n\
    \    let mut row_sorted_idx20 = vec![];\n    let mut \n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpb1ptgsjd.rs:64:1\n\
    \   |\n64 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut result = vec![];\n    let mut row_idx = 1;\n    let mut col_idx = 1;\n \
    \   let mut row_start = 0;\n    let mut col_start = 0;\n    while row_idx < rows\
    \ {\n        let mut row_end = row_start;\n        while col_idx < cols {\n  \
    \          if row_end == row_idx {\n                row_end = row_idx;\n     \
    \           col_idx = 0;\n            }\n            if row_end == row_idx &&\
    \ col_idx < cols {\n                row_end = row_idx;\n                col_idx++;\n\
    \            }\n            if row_end == row_idx && col_idx > cols {\n      \
    \          row_end = row_idx;\n                col_idx--;\n            }\n   \
    \         if row_end == row_idx && col_idx == cols {\n                row_end\
    \ = row_idx;\n                col_idx = 0;\n            }\n            if row_end\
    \ == row_idx && col_idx < cols {\n                row_end = row_idx;\n       \
    \         col_idx++;\n            }\n            if row_end == row_idx && col_idx\
    \ > cols {\n                row_end = row_idx;\n                col_idx--;\n \
    \           }\n            if row_end == row_idx && col_idx == cols {\n      \
    \          row_end = row_idx;\n                col_idx = 0;\n            }\n \
    \           if row_end == row_idx && col_idx < cols {\n                row_end\
    \ = row_idx;\n                col_idx++;\n            }\n            if row_end\
    \ == row_idx && col_idx > cols {\n                row_end = row_idx;\n       \
    \         col_idx--;\n            }\n            if row_end == row_idx && col_idx\
    \ == cols {\n                row_end = row_idx;\n                col_idx = 0;\n\
    \            }\n            if row_end == row_idx && col_idx < cols {\n      \
    \          row_end = row_idx;\n                col_idx++;\n            }\n   \
    \         if row_end == row_idx && col_idx > cols {\n                row_end =\
    \ row_idx;\n                col_idx--;\n            }\n            if row_end\
    \ == row_idx && col_idx == cols {\n                row_end = row_idx;\n      \
    \          col_idx = 0;\n            }\n            if row_end == row_idx && col_idx\
    \ < cols {\n                row_end = row_idx;\n                col_idx++;\n \
    \           }\n            if row_end == row_idx && col_idx > cols {\n       \
    \         row_end = row_idx;\n                col_idx--;\n            }\n    \
    \        if row_end == row_idx && col_idx == cols {\n                row_end =\
    \ row_idx;\n                col_idx = 0;\n            }\n            if row_end\
    \ == row_idx && col_id\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp_c_15dvw.rs:102:3\n\
    \    |\n16  | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    |                                                                   -\
    \ unclosed delimiter\n...\n24  |     while row_idx < rows {\n    |           \
    \               - unclosed delimiter\n25  |         let mut row_end = row_start;\n\
    26  |         while col_idx < cols {\n    |                              - this\
    \ delimiter might not be properly closed...\n...\n92  | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n102 | }\n    |   ^\n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmp_c_15dvw.rs:33:24\n   |\n33\
    \ |                 col_idx++;\n   |                        ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n33 |                 { let tmp\
    \ = col_idx; col_idx += 1; tmp };\n   |                 +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    33 -                 col_idx++;\n33 +                 col_idx += 1;\n   | \n\n\
    error: Rust has no postfix increment operator\n  --> /tmp/tmp_c_15dvw.rs:45:24\n\
    \   |\n45 |                 col_idx++;\n   |                        ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n45 |               \
    \  { let tmp = col_idx; col_idx += 1; tmp };\n   |                 +++++++++++\
    \        ~~~~~~~~~~~~~~~~~~~~~\n45 -                 col_idx++;\n45 +        \
    \         col_idx += 1;\n   | \n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmp_c_15dvw.rs:57:24\n   |\n57 |                 col_idx++;\n   |\
    \                        ^^ not a valid postfix operator\n   |\nhelp: use `+=\
    \ 1` instead\n   |\n57 |                 { let tmp = col_idx; col_idx += 1; tmp\
    \ };\n   |                 +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n57 -    \
    \             col_idx++;\n57 +                 col_idx += 1;\n   | \n\nerror:\
    \ Rust has no postfix increment operator\n  --> /tmp/tmp_c_15dvw.rs:69:24\n  \
    \ |\n69 |                 col_idx++;\n   |                        ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n69 |  "
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    let mut rows = lst.len();\n    let\
    \ mut cols = lst[0].len();\n    let mut row_idx = 1;\n    let mut col_idx = 1;\n\
    \    let mut row_max = rows;\n    let mut col_max = cols;\n    while row_idx <\
    \ rows {\n        let mut row_min = row_idx;\n        while row_min < rows &&\
    \ lst[row_min][col_idx] < x {\n            row_min += 1;\n        }\n        let\
    \ mut col_min = col_idx;\n        while col_min < cols && lst[row_idx][col_min]\
    \ > x {\n            col_min += 1;\n        }\n        result.push((row_min, col_min));\n\
    \        if col_min == col_max {\n            row_max -= 1;\n            col_idx\
    \ = 1;\n            col_max = cols;\n        } else {\n            col_idx -=\
    \ 1;\n            col_max = cols;\n        }\n        row_idx += 1;\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpht94__ek.rs:44:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n44 |     result\n   |     ^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<(usize, usize)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut result = Vec::new();\n    let mut row_idx = 1;\n    let mut col_idx = 1;\n\
    \    while col_idx < cols {\n        if row_idx == rows {\n            result.push((row_idx,\
    \ col_idx));\n            break;\n        }\n        let mut found = false;\n\
    \        for row in lst {\n            if row[row_idx] == x {\n              \
    \  found = true;\n                break;\n            }\n        }\n        if\
    \ found {\n            result.push((row_idx, col_idx));\n            row_idx++;\n\
    \            col_idx++;\n        } else {\n            col_idx++;\n        }\n\
    \    }\n    result.sort_by_key(|&(x, y)| x.0);\n    result.sort_by_key(|&(x, y)|\
    \ y.0);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp46hnyf71.rs:36:20\n\
    \   |\n36 |             row_idx++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n36 |             { let tmp =\
    \ row_idx; row_idx += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    36 -             row_idx++;\n36 +             row_idx += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmp46hnyf71.rs:39:20\n   |\n39\
    \ |             col_idx++;\n   |                    ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n39 |             { let tmp = col_idx; col_idx\
    \ += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n39\
    \ -             col_idx++;\n39 +             col_idx += 1;\n   | \n\nerror[E0610]:\
    \ `usize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmp46hnyf71.rs:42:36\n\
    \   |\n42 |     result.sort_by_key(|&(x, y)| x.0);\n   |                     \
    \               ^\n\nerror[E0610]: `usize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmp46hnyf71.rs:43:36\n   |\n43 |     result.sort_by_key(|&(x,\
    \ y)| y.0);\n   |                                    ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp46hnyf71.rs:44:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n44 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<(usize, usize)>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0610.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    let mut rows = lst.len();\n    let\
    \ mut cols = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n\
    \    while col_idx < cols {\n        if row_idx == rows {\n            result.push((row_idx,\
    \ col_idx));\n            break;\n        }\n        let mut row_value = vec![0;\
    \ cols];\n        for row_idx in 0..rows {\n            row_value[col_idx] = lst[row_idx][col_idx];\n\
    \            col_idx++;\n            if col_idx >= cols {\n                col_idx\
    \ = 0;\n                row_idx++;\n            }\n        }\n        if row_value[x]\
    \ < row_value[x + 1] {\n            result.push((row_idx, col_idx));\n       \
    \ }\n        col_idx++;\n    }\n    result.sort_by_key(|&(x, y)| x.0);\n    result.sort_by_key(|&(x,\
    \ y)| y.0);\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp76a46kv_.rs:30:20\n\
    \   |\n30 |             col_idx++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n30 |             { let tmp =\
    \ col_idx; col_idx += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    30 -             col_idx++;\n30 +             col_idx += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmp76a46kv_.rs:39:16\n   |\n39\
    \ |         col_idx++;\n   |                ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n39 |         { let tmp = col_idx; col_idx\
    \ += 1; tmp };\n   |         +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n39 -  \
    \       col_idx++;\n39 +         col_idx += 1;\n   | \n\nerror[E0277]: the type\
    \ `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp76a46kv_.rs:36:12\n  \
    \ |\n36 |         if row_value[x] < row_value[x + 1] {\n   |            ^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp76a46kv_.rs:36:27\n\
    \   |\n36 |         if row_value[x] < row_value[x + 1] {\n   |               \
    \            ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp76a46kv_.rs:41:36\n   |\n41 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmp76a46kv_.rs:42:36\n\
    \   |\n42 |     result.sort_b"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut col_idx = 0;\n    let mut row_len = 0;\n    let mut col_len\
    \ = 0;\n    for row in lst {\n        row_len += row.len();\n        if row_idx\
    \ >= row_len {\n            break;\n        }\n        for col in row {\n    \
    \        col_len += 1;\n            if col_idx >= col_len {\n                break;\n\
    \            }\n            if col == x {\n                row.swap(row_idx, col_idx);\n\
    \                row_idx += 1;\n                col_idx -= 1;\n            }\n\
    \        }\n    }\n    row\n}\n\nfn main() {\n    let candidate = get_row;\n \
    \   assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpx8zzxy10.rs:17:9\n\
    \   |\n17 |     let mut row: Vec<(isize, isize)> = Vec::new();\n   |         ----^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `row` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpx8zzxy10.rs:33:17\n   |\n22 |     for row\
    \ in lst {\n   |         --- help: consider changing this to be mutable: `mut\
    \ row`\n...\n33 |                 row.swap(row_idx, col_idx);\n   |          \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `row`\n   --> /tmp/tmpx8zzxy10.rs:33:17\n    |\n22  |     for\
    \ row in lst {\n    |         --- move occurs because `row` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n...\n27  |         for col in row\
    \ {\n    |                    --- `row` moved due to this implicit call to `.into_iter()`\n\
    ...\n33  |                 row.swap(row_idx, col_idx);\n    |                \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `row`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n27  |         for col in &row {\n    |                  \
    \  +\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors\
    \ have detailed explanations: E0382, E0596.\nFor more information about an error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx\
    \ = 0;\n    let mut col_idx = 0;\n    let mut row_idx2 = 0;\n    let mut col_idx2\
    \ = 0;\n    for row in lst {\n        if row_idx == x {\n            rows.push(vec![(row_idx,\
    \ col_idx)]);\n            row_idx++;\n            col_idx = 0;\n        }\n \
    \       for col in row {\n            if col_idx == x {\n                rows.push(vec![(row_idx,\
    \ col_idx)]);\n                row_idx++;\n                col_idx++;\n      \
    \      }\n            if col_idx2 == x {\n                rows.push(vec![(row_idx,\
    \ col_idx)]);\n                row_idx++;\n                col_idx++;\n      \
    \          col_idx2 = 0;\n            }\n            if col_idx2 == col {\n  \
    \              rows.push(vec![(row_idx, col_idx)]);\n                row_idx++;\n\
    \                col_idx++;\n                col_idx2++;\n            }\n    \
    \    }\n    }\n    rows\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpeofldahe.rs:25:20\n\
    \   |\n25 |             row_idx++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n25 |             { let tmp =\
    \ row_idx; row_idx += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    25 -             row_idx++;\n25 +             row_idx += 1;\n   | \n\nerror: Rust\
    \ has no postfix increment operator\n  --> /tmp/tmpeofldahe.rs:31:24\n   |\n31\
    \ |                 row_idx++;\n   |                        ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n31 |                 { let tmp\
    \ = row_idx; row_idx += 1; tmp };\n   |                 +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    31 -                 row_idx++;\n31 +                 row_idx += 1;\n   | \n\n\
    error: Rust has no postfix increment operator\n  --> /tmp/tmpeofldahe.rs:36:24\n\
    \   |\n36 |                 row_idx++;\n   |                        ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n36 |               \
    \  { let tmp = row_idx; row_idx += 1; tmp };\n   |                 +++++++++++\
    \        ~~~~~~~~~~~~~~~~~~~~~\n36 -                 row_idx++;\n36 +        \
    \         row_idx += 1;\n   | \n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmpeofldahe.rs:42:24\n   |\n42 |                 row_idx++;\n   |\
    \                        ^^ not a valid postfix operator\n   |\nhelp: use `+=\
    \ 1` instead\n   |\n42 |                 { let tmp = row_idx; row_idx += 1; tmp\
    \ };\n   |                 +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n42 -    \
    \             row_idx++;\n42 +                 row_idx += 1;\n   | \n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpeofldahe.rs:24:23\n   |\n24 |             rows.push(vec![(row_idx,\
    \ col_idx)]);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple,\
    \ found struct `Vec`\n   |\n   = note: expected tuple `(isize, isize)`\n     \
    \        found struct `Vec<(isize, {integer})>`\n   = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0308"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        vec![]\n    } else {\n        let mut rows\
    \ = lst.len();\n        let mut cols = lst[0].len();\n        let mut coords =\
    \ vec![];\n        let mut row = 0;\n        let mut col = 0;\n        while row\
    \ < rows {\n            while col < cols {\n                if lst[row][col] ==\
    \ x {\n                    coords.push((row, col));\n                    break;\n\
    \                }\n                col += 1;\n            }\n            row\
    \ += 1;\n            col = 0;\n        }\n        coords.sort_by_key(|&(_, y)|\
    \ y.cmp(&x));\n        coords.sort_by_key(|&(_, y)| y.cmp(x.reverse()));\n   \
    \     coords\n    }\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp68kwzbqy.rs:36:44\n   |\n\
    36 |         coords.sort_by_key(|&(_, y)| y.cmp(&x));\n   |                  \
    \                          ^^ expected `usize`, found `isize`\n   |\n   = note:\
    \ expected reference `&usize`\n              found reference `&isize`\n\nerror[E0599]:\
    \ no method named `reverse` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmp68kwzbqy.rs:37:46\n   |\n37 |         coords.sort_by_key(|&(_, y)| y.cmp(x.reverse()));\n\
    \   |                                              ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reverse_bits`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp68kwzbqy.rs:38:9\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x:\
    \ isize) -> Vec<(isize, isize)> {\n   |                                      \
    \         ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n38 |         coords\n   |         ^^^^^^ expected `isize`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n          \
    \    found struct `Vec<(usize, usize)>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_idx_max = 0;\n    let mut row_idx_min = 0;\n    let mut\
    \ row_idx_max_idx = 0;\n    let mut row_idx_min_idx = 0;\n    let mut col_max\
    \ = 0;\n    let mut col_min = 0;\n    let mut col_max_idx = 0;\n    let mut col_min_idx\
    \ = 0;\n    let mut row_max = 0;\n    let mut row_min = 0;\n    let mut row_max_idx\
    \ = 0;\n    let mut row_min_idx = 0;\n    let mut col_max = 0;\n    let mut col_min\
    \ = 0;\n    let mut col_max_idx = 0;\n    let mut col_min_idx = 0;\n    let mut\
    \ row_max = 0;\n    let mut row_min = 0;\n    let mut row_max_idx = 0;\n    let\
    \ mut row_min_idx = 0;\n    let mut col_max = 0;\n    let mut col_min = 0;\n \
    \   let mut col_max_idx = 0;\n    let mut col_min_idx = 0;\n    let mut row_max\
    \ = 0;\n    let mut row_min = 0;\n    let mut row_max_idx = 0;\n    let mut row_min_idx\
    \ = 0;\n    let mut col_max = 0;\n    let mut col_min = 0;\n    let mut col_max_idx\
    \ = 0;\n    let mut col_min_idx = 0;\n    let mut row_max = 0;\n    let mut row_min\
    \ = 0;\n    let mut row_max_idx = 0;\n    let mut row_min_idx = 0;\n    let mut\
    \ col_max = 0;\n    let mut col_min = 0;\n    let mut col_max_idx = 0;\n    let\
    \ mut col_min_idx = 0;\n    let mut row_max = 0;\n    let mut row_min = 0;\n \
    \   let mut row_max_idx = 0;\n    let mut row_min_idx = 0;\n    let mut col_max\
    \ = 0;\n    let mut col_min = 0;\n    let mut col_max_idx = 0;\n    let mut col_min_idx\
    \ = 0;\n    let mut row_max = 0;\n    let mut row_min = 0;\n    let mut row_max_idx\
    \ = 0;\n    let mut row_min_idx = 0;\n    let mut col_max = 0;\n    let mut col_min\
    \ = 0;\n    let mut col_max_idx = 0;\n    let mut col_min_idx = 0;\n    let mut\
    \ row_max = 0;\n    let mut row_min = 0;\n    let mut row_max_idx = 0;\n    let\
    \ mut row_min_idx = 0;\n    let mut col_max = 0;\n    let mut col_min = 0;\n \
    \   let mut col_max_idx = 0;\n    let mut col_min_idx = 0;\n    let mut \n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpvrmae0nm.rs:84:1\n\
    \   |\n84 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut result = vec![];\n    let mut row_idx = vec![];\n    let mut col_idx = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_idx2 = vec![];\n    let mut col_idx2 = vec![];\n    let mut row_sorted2\
    \ = vec![];\n    let mut col_sorted2 = vec![];\n    let mut row_idx3 = vec![];\n\
    \    let mut col_idx3 = vec![];\n    let mut row_sorted3 = vec![];\n    let mut\
    \ col_sorted3 = vec![];\n    let mut row_idx4 = vec![];\n    let mut col_idx4\
    \ = vec![];\n    let mut row_sorted4 = vec![];\n    let mut col_sorted4 = vec![];\n\
    \    let mut row_idx5 = vec![];\n    let mut col_idx5 = vec![];\n    let mut row_sorted5\
    \ = vec![];\n    let mut col_sorted5 = vec![];\n    let mut row_idx6 = vec![];\n\
    \    let mut col_idx6 = vec![];\n    let mut row_sorted6 = vec![];\n    let mut\
    \ col_sorted6 = vec![];\n    let mut row_idx7 = vec![];\n    let mut col_idx7\
    \ = vec![];\n    let mut row_sorted7 = vec![];\n    let mut col_sorted7 = vec![];\n\
    \    let mut row_idx8 = vec![];\n    let mut col_idx8 = vec![];\n    let mut row_sorted8\
    \ = vec![];\n    let mut col_sorted8 = vec![];\n    let mut row_idx9 = vec![];\n\
    \    let mut col_idx9 = vec![];\n    let mut row_sorted9 = vec![];\n    let mut\
    \ col_sorted9 = vec![];\n    let mut row_idx10 = vec![];\n    let mut col_idx10\
    \ = vec![];\n    let mut row_sorted10 = vec![];\n    let mut col_sorted10 = vec![];\n\
    \    let mut row_idx11 = vec![];\n    let mut col_idx11 = vec![];\n    let mut\
    \ row_sorted11 = vec![];\n    let mut col_sorted11 = vec![];\n    let mut row_idx12\
    \ = vec![];\n    let mut col_idx12 = vec![];\n    let mut row_sorted12 = vec![];\n\
    \    let mut col_sorted12 = vec![];\n    let mut row_idx13 = vec\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph3uz3uar.rs:68:28\n   |\n\
    68 |     let mut row_idx13 = vec\n   |                            ^ help: add\
    \ `;` here\n69 | }\n   | - unexpected token\n\nerror[E0423]: expected value, found\
    \ macro `vec`\n  --> /tmp/tmph3uz3uar.rs:68:25\n   |\n68 |     let mut row_idx13\
    \ = vec\n   |                         ^^^ not a value\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph3uz3uar.rs:16:47\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |    -------                        \
    \            ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n           found unit\
    \ type `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0423.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    for row in lst {\n\
    \        let mut row_result = Vec::<(isize, isize)>::new();\n        for (i, v)\
    \ in row.iter().enumerate() {\n            if i == x {\n                row_result.push((i,\
    \ v));\n            }\n        }\n        result.push(row_result);\n    }\n  \
    \  result.sort_by_key(|&(_, v)| v.iter().rev().collect::<Vec<_>>());\n    result.sort_by_key(|&(_,\
    \ v)| v.iter().collect::<Vec<_>>().rev());\n    result\n}\n\nfn main() {\n   \
    \ let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphz85hfu2.rs:21:21\n   |\n\
    21 |             if i == x {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |             if i == x.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphz85hfu2.rs:22:34\n   |\n22 |                 row_result.push((i,\
    \ v));\n   |                                  ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |                 row_result.push((i.try_into().unwrap(),\
    \ v));\n   |                                   ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphz85hfu2.rs:22:37\n   |\n22 |              \
    \   row_result.push((i, v));\n   |                                     ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    22 |                 row_result.push((i, *v));\n   |                         \
    \            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphz85hfu2.rs:25:21\n\
    \   |\n25 |         result.push(row_result);\n   |                     ^^^^^^^^^^\
    \ expected tuple, found struct `Vec`\n   |\n   = note: expected tuple `(isize,\
    \ isize)`\n             found struct `Vec<(isize, isize)>`\n\nerror[E0599]: no\
    \ method named `iter` found for type `isize` in the current scope\n  --> /tmp/tmphz85hfu2.rs:27:36\n\
    \   |\n27 |     result.sort_by_key(|&(_, v)| v.iter().rev().collect::<Vec<_>>());\n\
    \   |                                    ^^^^ method not found in `isize`\n\n\
    error[E0599]: no method named `iter` found for type `isize` in the current scope\n\
    \  --> /tmp/tmphz85hfu2.rs:28:36\n   |\n28 |     result.sort_by_key(|&(_, v)|\
    \ v.iter().collect::<Vec<_>>().rev());\n   |                                 \
    \   ^^^^ method not found in `isize`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rus"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = Vec::new();\n    let mut row_coords = Vec::new();\n    let mut\
    \ col_coords = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while\
    \ i < rows {\n        let mut row_coord = Vec::new();\n        let mut col_coord\
    \ = Vec::new();\n        while j < cols {\n            if lst[i][j] == x {\n \
    \               row_coord.push((i, j));\n                col_coord.push((j, j));\n\
    \                i += 1;\n                j += 1;\n            } else {\n    \
    \            row_coord.push((i, j));\n                col_coord.push((j, j));\n\
    \                i += 1;\n            }\n        }\n        coords.push(row_coord);\n\
    \        coords.push(col_coord);\n    }\n    coords.sort_by_key(|&(_, y)| y.0);\n\
    \    coords.sort_by_key(|&(_, y)| y.1);\n    coords\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6zpwvrk5.rs:42:26\n   |\n\
    42 |     coords.sort_by_key(|&(_, y)| y.0);\n   |                          ^^^^^-\n\
    \   |                          |    |\n   |                          |    expected\
    \ due to this\n   |                          expected struct `Vec`, found tuple\n\
    \   |\n   = note: expected struct `Vec<(usize, usize)>`\n               found\
    \ tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6zpwvrk5.rs:43:26\n\
    \   |\n43 |     coords.sort_by_key(|&(_, y)| y.1);\n   |                     \
    \     ^^^^^-\n   |                          |    |\n   |                     \
    \     |    expected due to this\n   |                          expected struct\
    \ `Vec`, found tuple\n   |\n   = note: expected struct `Vec<(usize, usize)>`\n\
    \               found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp6zpwvrk5.rs:44:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |                                             \
    \  ------------------- expected `Vec<(isize, isize)>` because of return type\n\
    ...\n44 |     coords\n   |     ^^^^^^ expected tuple, found struct `Vec`\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<(usize, usize)>>`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = vec![];\n    for row in lst {\n        let mut row_result\
    \ = vec![];\n        for col in row.iter().rev() {\n            if col == x {\n\
    \                row_result.push((row.len(), col.len()));\n            }\n   \
    \     }\n        result.push(row_result);\n    }\n    result.sort_by_key(|row|\
    \ row[0]);\n    result.sort_by_key(|row| row[1], |&(a, b)| {\n        if a.1 <\
    \ b.1 {\n            1\n        } else {\n            -1\n        }\n    });\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpgbrqy0ko.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0599]: no method named `len`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmpgbrqy0ko.rs:22:49\n\
    \   |\n22 |                 row_result.push((row.len(), col.len()));\n   |   \
    \                                              ^^^ method not found in `&isize`\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmpgbrqy0ko.rs:28:12\n    |\n28  |       result.sort_by_key(|row|\
    \ row[1], |&(a, b)| {\n    |  ____________^^^^^^^^^^^_------------__-\n    | |\
    \            |\n    | |            expected 1 argument\n29  | |         if a.1\
    \ < b.1 {\n30  | |             1\n31  | |         } else {\n32  | |          \
    \   -1\n33  | |         }\n34  | |     });\n    | |_____- supplied 2 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgbrqy0ko.rs:35:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x:\
    \ isize) -> Vec<(isize, isize)> {\n   |                                      \
    \         ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n35 |     result\n   |     ^^^^^^ expected tuple, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<_>>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut col_max = lst.len();\n    let mut col_min = 0;\n    let mut\
    \ col_sum = 0;\n    let mut row_sum = 0;\n    let mut row_idx = 0;\n    let mut\
    \ col_max = lst.len();\n    let mut col_min = 0;\n    let mut col_sum = 0;\n \
    \   let mut row_sum = 0;\n    let mut row_idx = 0;\n    for row in lst {\n   \
    \     row_sum += row.len();\n        if row_sum == x {\n            break;\n \
    \       }\n        row_idx += 1;\n    }\n    for col in lst {\n        col_sum\
    \ += col.len();\n        if col_sum == x {\n            break;\n        }\n  \
    \      col_max += 1;\n    }\n    for row in lst {\n        for col in lst {\n\
    \            if col[col_min..col_max].iter().any(|&x| x == x) {\n            \
    \    row.push((row_idx, col_min));\n            }\n        }\n    }\n    row.sort_by_key(|&x|\
    \ x.1);\n    row.sort_by_key(|&x| x.1.reverse());\n    row\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxpnf3qmy.rs:31:23\n   |\n\
    31 |         if row_sum == x {\n   |                       ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n31 |         if row_sum == x.try_into().unwrap()\
    \ {\n   |                        ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxpnf3qmy.rs:38:23\n   |\n38 |         if col_sum == x {\n\
    \   |                       ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n38 |         if col_sum == x.try_into().unwrap() {\n   |        \
    \                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxpnf3qmy.rs:46:26\n   |\n46 |                 row.push((row_idx, col_min));\n\
    \   |                          ^^^^^^^^^^^^^^^^^^ expected `isize`, found tuple\n\
    \   |\n   = note: expected type `isize`\n             found tuple `({integer},\
    \ usize)`\n\nerror[E0599]: no method named `reverse` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmpxpnf3qmy.rs:51:30\n   |\n51 |     row.sort_by_key(|&x|\
    \ x.1.reverse());\n   |                              ^^^^^^^ help: there is an\
    \ associated function with a similar name: `reverse_bits`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_idx_max = 0;\n    let mut col_max = 0;\n    for row in lst\
    \ {\n        let mut col = 0;\n        let mut col_max = 0;\n        for el in\
    \ row {\n            if el == x {\n                row.push(col_max);\n      \
    \          row.push(row_idx);\n                row_idx += 1;\n               \
    \ col += 1;\n                col_max = col;\n            }\n        }\n      \
    \  row.push(col_max);\n        row.push(row_idx);\n        row_idx_max += 1;\n\
    \    }\n    row.sort_by_key(|&el| el[0]);\n    row.sort_by_key(|&el| el[1]).reverse();\n\
    \    row\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `(isize, isize)`\n  -->\
    \ /tmp/tmpl71fl0c_.rs:37:27\n   |\n37 |     row.sort_by_key(|&el| el[0]);\n  \
    \ |                           ^^^^^ help: to access tuple elements, use: `el.0`\n\
    \nerror[E0608]: cannot index into a value of type `(isize, isize)`\n  --> /tmp/tmpl71fl0c_.rs:38:27\n\
    \   |\n38 |     row.sort_by_key(|&el| el[1]).reverse();\n   |                \
    \           ^^^^^ help: to access tuple elements, use: `el.1`\n\nerror[E0599]:\
    \ no method named `reverse` found for unit type `()` in the current scope\n  -->\
    \ /tmp/tmpl71fl0c_.rs:38:34\n   |\n38 |     row.sort_by_key(|&el| el[1]).reverse();\n\
    \   |                                  ^^^^^^^ method not found in `()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = Vec::new();\n    for row in lst {\n        let mut coord\
    \ = vec![];\n        for col in row.iter().rev() {\n            if col == x {\n\
    \                coord.push((row.len(), col.len()));\n            }\n        }\n\
    \        coords.insert(0, coord);\n    }\n    coords.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    coords.sort_by(|a, b| b.1.cmp(&a.1));\n    coords\n}\n\nfn main() {\n   \
    \ let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpymbfalxl.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0599]: no method named `len`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmpymbfalxl.rs:22:44\n\
    \   |\n22 |                 coord.push((row.len(), col.len()));\n   |        \
    \                                    ^^^ method not found in `&isize`\n\nerror[E0609]:\
    \ no field `0` on type `&Vec<_>`\n  --> /tmp/tmpymbfalxl.rs:27:29\n   |\n27 |\
    \     coords.sort_by(|a, b| a.0.cmp(&b.0));\n   |                            \
    \ ^ unknown field\n\nerror[E0609]: no field `0` on type `&Vec<_>`\n  --> /tmp/tmpymbfalxl.rs:27:38\n\
    \   |\n27 |     coords.sort_by(|a, b| a.0.cmp(&b.0));\n   |                  \
    \                    ^ unknown field\n\nerror[E0609]: no field `1` on type `&Vec<_>`\n\
    \  --> /tmp/tmpymbfalxl.rs:28:29\n   |\n28 |     coords.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \   |                             ^ unknown field\n\nerror[E0609]: no field `1`\
    \ on type `&Vec<_>`\n  --> /tmp/tmpymbfalxl.rs:28:38\n   |\n28 |     coords.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n   |                                      ^ unknown field\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpymbfalxl.rs:29:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n29 |     coords\n   |     ^^^^^^ expected\
    \ tuple, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<_>>`\n\nerror: aborting due to 7 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599, E0609.\n\
    For more infor"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n    let mut\
    \ col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n\
    \    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n    let\
    \ mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n\
    \    let mut col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n\
    \    let mut col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n\
    \    let mut col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n\
    \    let mut col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n\
    \    let mut col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n\
    \    let mut col_len = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut row_\n}\n\nfn\
    \ main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8udr_4ne.rs:76:17\n   |\n\
    76 |     let mut row_\n   |                 ^ help: add `;` here\n77 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8udr_4ne.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    for row in lst {\n\
    \        let mut row_result = Vec::<(isize, isize)>::new();\n        for cell\
    \ in row {\n            if cell == x {\n                row_result.push((cell,\
    \ cell));\n            }\n        }\n        result.push(row_result);\n    }\n\
    \    result.sort_by(|a, b| a.iter().rev().zip(b).map(|(a, b)| a.1).cmp(&b.1));\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5dwwcbjn.rs:25:21\n   |\n\
    25 |         result.push(row_result);\n   |                     ^^^^^^^^^^ expected\
    \ tuple, found struct `Vec`\n   |\n   = note: expected tuple `(isize, isize)`\n\
    \             found struct `Vec<(isize, isize)>`\n\nerror[E0599]: no method named\
    \ `iter` found for reference `&(isize, isize)` in the current scope\n  --> /tmp/tmp5dwwcbjn.rs:27:29\n\
    \   |\n27 |     result.sort_by(|a, b| a.iter().rev().zip(b).map(|(a, b)| a.1).cmp(&b.1));\n\
    \   |                             ^^^^ method not found in `&(isize, isize)`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n    for row in lst {\n\
    \        row_len += row.len();\n        col_len += row.iter().map(|x| x.len()).sum();\n\
    \    }\n    let mut col_pos = 0;\n    let mut col_pos = col_len.cmp(&row_len);\n\
    \    while col_pos != 0 {\n        let mut row_pos = 0;\n        let mut row_pos\
    \ = row_len.cmp(&col_pos);\n        while row_pos != 0 {\n            let mut\
    \ i = 0;\n            let mut i = row_len.cmp(&col_pos);\n            while i\
    \ != 0 {\n                let mut j = 0;\n                let mut j = col_len.cmp(&row_pos);\n\
    \                while j != 0 {\n                    let mut k = 0;\n        \
    \            let mut k = col_len.cmp(&row_pos);\n                    while k !=\
    \ 0 {\n                        let mut l = 0;\n                        let mut\
    \ l = row_len.cmp(&col_pos);\n                        while l != 0 {\n       \
    \                     let mut m = 0;\n                            let mut m =\
    \ col_len.cmp(&row_pos);\n                            while m != 0 {\n       \
    \                         let mut n = 0;\n                                let\
    \ mut n = row_len.cmp(&col_pos);\n                                while n != 0\
    \ {\n                                    let mut o = 0;\n                    \
    \                let mut o = row_len.cmp(&col_pos);\n                        \
    \            while o != 0 {\n                                        let mut p\
    \ = 0;\n                                        let mut p = col_len.cmp(&row_pos);\n\
    \                                        while p != 0 {\n                    \
    \                        let mut q = 0;\n                                    \
    \        let mut q = row_len.cmp(&col_pos);\n                                \
    \            while q != 0 {\n                                                let\
    \ mut r = 0;\n                                                let mut r = col_len.cmp(&row_pos);\n\
    \                                                while r != 0 {\n            \
    \                                        let mut s = 0;\n                    \
    \                                let mut s = col_len.cmp(&row_pos);\n        \
    \                                            while s != 0 {\n                \
    \                                        let mut t = 0;\n                    \
    \                                    let mut t = row_len.cmp(&col_pos);\n    \
    \                                                    while t != 0 {\n        \
    \                                                    let mut u = 0;\n        \
    \                                                    let mut u = col_len.cmp(&row_pos);\n\
    \                                                            while u != 0 {\n\
    \                                                                let mut v = 0;\n\
    \                                                                let mut v = row_len.cmp(&col_pos);\n\
    \                                                                while v != 0\
    \ {\n                                                                    let mut\
    \ w = 0;\n                                                                   \
    \ let mut w = col_len.cmp\n}\n\nfn main() {\n    let candidate = get_row;\n  \
    \  assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp9nrzu107.rs:85:3\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ unclosed delimiter\n...\n27 |     while col_pos != 0 {\n   |               \
    \         - unclosed delimiter\n...\n30 |         while row_pos != 0 {\n   | \
    \                           - unclosed delimiter\n...\n33 |             while\
    \ i != 0 {\n   |                          - unclosed delimiter\n...\n36 |    \
    \             while j != 0 {\n   |                              - unclosed delimiter\n\
    ...\n39 |                     while k != 0 {\n   |                           \
    \       - unclosed delimiter\n...\n42 |                         while l != 0 {\n\
    \   |                                      - unclosed delimiter\n...\n45 |   \
    \                          while m != 0 {\n   |                              \
    \            - unclosed delimiter\n...\n48 |                                 while\
    \ n != 0 {\n   |                                              - unclosed delimiter\n\
    ...\n51 |                                     while o != 0 {\n   |           \
    \                                       - unclosed delimiter\n...\n54 |      \
    \                                   while p != 0 {\n   |                     \
    \                                 - unclosed delimiter\n...\n57 |            \
    \                                 while q != 0 {\n   |                       \
    \                                   - unclosed delimiter\n...\n60 |          \
    \                                       while r != 0 {\n   |                 \
    \                                             - unclosed delimiter\n...\n63 |\
    \                                                     while s != 0 {\n   |   \
    \                                                               - unclosed delimiter\n\
    ...\n66 |                                                         while t != 0\
    \ {\n   |                                                                    \
    \  - unclosed delimiter\n...\n69 |                                           \
    \  "
  stdout: ''
  timestamp: 1660010754
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n    let mut\
    \ col_len = lst[0].len();\n    let mut row_start = 0;\n    let mut col_start =\
    \ 0;\n    while row_idx < row_len {\n        if row_idx == row_start {\n     \
    \       row_idx += 1;\n            row_start = row_idx;\n        }\n        if\
    \ row_idx == row_len - 1 {\n            row_idx += 1;\n            row_len = row_idx;\n\
    \        }\n        if col_idx < col_len {\n            if col_idx < col_start\
    \ {\n                col_idx += 1;\n                col_start = col_idx;\n   \
    \         }\n            if col_idx == col_len {\n                col_idx += 1;\n\
    \                col_len = col_idx;\n            }\n            if lst[row_idx][col_idx]\
    \ == x {\n                row.push((row_idx, col_idx));\n            }\n     \
    \   }\n    }\n    row.sort_by_key(|&(x, y)| x.0);\n    row.sort_by_key(|&(x, y)|\
    \ -y.0);\n    row\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4bl5itdb.rs:43:27\n   |\n\
    43 |                 row.push((row_idx, col_idx));\n   |                     \
    \      ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n43\
    \ |                 row.push((row_idx.try_into().unwrap(), col_idx));\n   |  \
    \                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4bl5itdb.rs:43:36\n   |\n43 |                 row.push((row_idx,\
    \ col_idx));\n   |                                    ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n43 |                 row.push((row_idx,\
    \ col_idx.try_into().unwrap()));\n   |                                       \
    \    ++++++++++++++++++++\n\nerror[E0610]: `isize` is a primitive type and therefore\
    \ doesn't have fields\n  --> /tmp/tmp4bl5itdb.rs:47:33\n   |\n47 |     row.sort_by_key(|&(x,\
    \ y)| x.0);\n   |                                 ^\n\nerror[E0610]: `isize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmp4bl5itdb.rs:48:34\n\
    \   |\n48 |     row.sort_by_key(|&(x, y)| -y.0);\n   |                       \
    \           ^\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0610.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx\
    \ = 0;\n    let mut col_idx = 0;\n    let mut row_len = 0;\n    let mut col_len\
    \ = 0;\n    for row in lst {\n        row_len += row.len();\n        row_idx +=\
    \ 1;\n        if row_idx > x {\n            break;\n        }\n        for col\
    \ in row {\n            col_len += 1;\n            col_idx += 1;\n           \
    \ if col_idx > x {\n                break;\n            }\n            rows.push((row_idx,\
    \ col_idx));\n        }\n    }\n    rows\n        .iter()\n        .sort_by(|a,\
    \ b| a.1.cmp(&b.1))\n        .sort_by(|a, b| b.0.cmp(&a.0));\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpkiv42eij.rs:39:10\n   |\n39 |         .sort_by(|a,\
    \ b| a.1.cmp(&b.1))\n   |          ^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ (isize, isize)>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkiv42eij.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = Vec::<(isize, isize)>::new();\n    let mut row_sorted =\
    \ Vec::<(isize, isize)>::new();\n    let mut col_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sorted_reverse = Vec::<(isize, isize)>::new();\n    let mut row_sorted_reverse\
    \ = Vec::<(isize, isize)>::new();\n    let mut row_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sorted_reverse = Vec::<(isize, isize)>::new();\n    let mut row_sorted_reverse\
    \ = Vec::<(isize, isize)>::new();\n    let mut row_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sorted_reverse = Vec::<(isize, isize)>::new();\n    let mut row_sorted_reverse\
    \ = Vec::<(isize, isize)>::new();\n    let mut row_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sorted_reverse = Vec::<(isize, isize)>::new();\n    let mut row_sorted_reverse\
    \ = Vec::<(isize, isize)>::new();\n    let mut row_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sorted_reverse = Vec::<(isize, isize)>::new();\n    let mut row_sorted_reverse\
    \ = Vec::<(isize, isize)>::new();\n    let mut row_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sorted_reverse = Vec::<(isize, isize)>::new();\n    let mut row_sorted_reverse\
    \ = Vec::<(isize, isize)>::new();\n    let mut row_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sorted_reverse = Vec::<(isize, isize)>::new();\n    let mut row_sorted_reverse\
    \ = Vec::<(isize, isize)>::new();\n    let mut row_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sorted_reverse = Vec::<(isize, isize)>::new();\n    let mut row_sorted_reverse\
    \ = Vec::<(isize, isize)>::new();\n    let mut row_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sorted_reverse = Vec::<(isize, isize)>::new();\n    let mut row_sorted_reverse\
    \ = Vec::<(isize, isize)>::new();\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpgkwq4m6h.rs:47:1\n\
    \   |\n47 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut col_len_idx\
    \ = 0;\n    let mut col_len_idx_max = 0;\n    let mut row_len_idx = 0;\n    let\
    \ mut row_len_idx_max = 0;\n    let mut row_idx = 0;\n    let mut row_idx_max\
    \ = 0;\n    let mut col_idx = 0;\n    let mut col_idx_max = 0;\n    let mut col_len\
    \ = 0;\n    let mut col_len_idx = 0;\n    let mut col_len_idx_max = 0;\n    let\
    \ mut row_len = 0;\n    let mut row_len_idx = 0;\n    let mut row_len_idx_max\
    \ = 0;\n    let mut row_idx = 0;\n    let mut row_idx_max = 0;\n    let mut col_idx\
    \ = 0;\n    let mut col_idx_max = 0;\n    let mut col_len = 0;\n    let mut col_len_idx\
    \ = 0;\n    let mut col_len_idx_max = 0;\n    let mut row_len = 0;\n    let mut\
    \ row_len_idx = 0;\n    let mut row_len_idx_max = 0;\n    let mut row_idx = 0;\n\
    \    let mut row_idx_max = 0;\n    let mut col_idx = 0;\n    let mut col_idx_max\
    \ = 0;\n    let mut col_len = 0;\n    let mut col_len_idx = 0;\n    let mut col_len_idx_max\
    \ = 0;\n    let mut row_len = 0;\n    let mut row_len_idx = 0;\n    let mut row_len_idx_max\
    \ = 0;\n    let mut row_idx = 0;\n    let mut row_idx_max = 0;\n    let mut col_idx\
    \ = 0;\n    let mut col_idx_max = 0;\n    let mut col_len = 0;\n    let mut col_len_idx\
    \ = 0;\n    let mut col_len_idx_max = 0;\n    let mut row_len = 0;\n    let mut\
    \ row_len_idx = 0;\n    let mut row_len_idx_max = 0;\n    let mut row_idx = 0;\n\
    \    let mut row_idx_max = 0;\n    let mut col_idx = 0;\n    let mut col_idx_max\
    \ = 0;\n    let mut col_len = 0;\n    let mut col_len_idx = 0;\n    let mut col_len_idx_max\
    \ = 0;\n    let mut row_len = 0;\n    let mut row_len_idx = 0;\n    let mut row_len_idx_max\
    \ = 0;\n    let mut row_idx = 0;\n    let mut row_idx_max = 0;\n    let mut col_idx\
    \ = 0;\n    let mut col_idx_max = 0;\n    let mut col_len = 0;\n    let mut col_len_idx\
    \ = 0;\n    let mut col_\n}\n\nfn main() {\n    let candidate = get_row;\n   \
    \ assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1,\
    \ 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp64jes_1r.rs:81:17\n   |\n\
    81 |     let mut col_\n   |                 ^ help: add `;` here\n82 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp64jes_1r.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords\
    \ = vec![];\n    let mut row_sort = vec![];\n    let mut col_sort = vec![];\n\
    \    let mut row_sort_idx = vec![];\n    let mut col_sort_idx = vec![];\n    let\
    \ mut row_sort_idx_idx = vec![];\n    let mut col_sort_idx_idx = vec![];\n   \
    \ let mut row_sort_idx_idx_idx = vec![];\n    let mut col_sort_idx_idx_idx = vec![];\n\
    \    let mut row_sort_idx_idx_idx_idx = vec![];\n    let mut col_sort_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx = vec![];\n    let mut\
    \ col_sort_idx_idx_idx_idx_idx_idx = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let\
    \ mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let mut\
    \ row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpp1kfmxob.rs:50:86\n   |\n\
    50 |     let mut row_sort_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_\n\
    \   |                                                                        \
    \              ^ help: add `;` here\n51 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp1kfmxob.rs:16:47\n   |\n16 | fn get_row(lst:\
    \ Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |    -------       \
    \                             ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    for row in lst {\n        let mut row_result\
    \ = Vec::new();\n        for col in row.iter().rev() {\n            if col ==\
    \ x {\n                row_result.push((row, col));\n            }\n        }\n\
    \        result.push(row_result);\n    }\n    result.sort_by_key(|row| row.iter().rev());\n\
    \    result.sort_by_key(|row| row.iter().rev());\n    result\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpvj72pepe.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0277]: the trait bound `Rev<std::slice::Iter<'_,\
    \ (Vec<isize>, &isize)>>: Ord` is not satisfied\n   --> /tmp/tmpvj72pepe.rs:27:24\n\
    \    |\n27  |     result.sort_by_key(|row| row.iter().rev());\n    |         \
    \   ----------- ^^^^^^^^^^^^^^^^^^^^^^ the trait `Ord` is not implemented for\
    \ `Rev<std::slice::Iter<'_, (Vec<isize>, &isize)>>`\n    |            |\n    |\
    \            required by a bound introduced by this call\n    |\nnote: required\
    \ by a bound in `slice::<impl [T]>::sort_by_key`\n\nerror[E0277]: the trait bound\
    \ `Rev<std::slice::Iter<'_, (Vec<isize>, &isize)>>: Ord` is not satisfied\n  \
    \ --> /tmp/tmpvj72pepe.rs:28:24\n    |\n28  |     result.sort_by_key(|row| row.iter().rev());\n\
    \    |            ----------- ^^^^^^^^^^^^^^^^^^^^^^ the trait `Ord` is not implemented\
    \ for `Rev<std::slice::Iter<'_, (Vec<isize>, &isize)>>`\n    |            |\n\
    \    |            required by a bound introduced by this call\n    |\nnote: required\
    \ by a bound in `slice::<impl [T]>::sort_by_key`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvj72pepe.rs:29:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x:\
    \ isize) -> Vec<(isize, isize)> {\n   |                                      \
    \         ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n29 |     result\n   |     ^^^^^^ expected tuple, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<(Vec<isize>, &isize)>>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = vec![];\n    for row in lst {\n        let mut coord\
    \ = vec![];\n        for elem in row {\n            if elem == x {\n         \
    \       coord.push((row, elem));\n            }\n        }\n        coords.push_back(coord);\n\
    \    }\n    coords.sort_by(|a, b| a.0.cmp(&b.0));\n    coords.sort_by(|a, b| b.1.cmp(&a.1));\n\
    \    coords\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push_back` found for struct `Vec<_>` in\
    \ the current scope\n  --> /tmp/tmpl14dpkn6.rs:25:16\n   |\n25 |         coords.push_back(coord);\n\
    \   |                ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0609]: no\
    \ field `0` on type `&_`\n  --> /tmp/tmpl14dpkn6.rs:27:29\n   |\n27 |     coords.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n   |                             ^\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0599, E0609.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_idx2 = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4\
    \ = 0;\n    let mut row_idx5 = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7\
    \ = 0;\n    let mut row_idx8 = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10\
    \ = 0;\n    let mut row_idx11 = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13\
    \ = 0;\n    let mut row_idx14 = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16\
    \ = 0;\n    let mut row_idx17 = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19\
    \ = 0;\n    let mut row_idx20 = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22\
    \ = 0;\n    let mut row_idx23 = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25\
    \ = 0;\n    let mut row_idx26 = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28\
    \ = 0;\n    let mut row_idx29 = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31\
    \ = 0;\n    let mut row_idx32 = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34\
    \ = 0;\n    let mut row_idx35 = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37\
    \ = 0;\n    let mut row_idx38 = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40\
    \ = 0;\n    let mut row_idx41 = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43\
    \ = 0;\n    let mut row_idx44 = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46\
    \ = 0;\n    let mut row_idx47 = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49\
    \ = 0;\n    let mut row_idx50 = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52\
    \ = 0;\n    let mut row_idx53 = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55\
    \ = 0;\n    let mut row_idx56 = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58\
    \ = 0;\n    let mut row_idx59 = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61\
    \ = 0;\n    let mut row_idx62 = 0;\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpy0j02d22.rs:81:1\n\
    \   |\n81 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = Vec::new();\n    let mut row_coords = Vec::new();\n    let mut\
    \ col_coords = Vec::new();\n    let mut row_sorted = Vec::new();\n    let mut\
    \ col_sorted = Vec::new();\n    let mut row_coord = Vec::new();\n    let mut col_coord\
    \ = Vec::new();\n    let mut row = 0;\n    let mut col = 0;\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < rows {\n        row_sorted.push(0);\n     \
    \   col_sorted.push(0);\n        row_coord.push(0);\n        col_coord.push(0);\n\
    \        i += 1;\n    }\n    while j < cols {\n        row_sorted.push(0);\n \
    \       col_sorted.push(0);\n        row_coord.push(0);\n        col_coord.push(0);\n\
    \        j += 1;\n    }\n    while i < rows {\n        while j < cols {\n    \
    \        if lst[i][j] == x {\n                row_sorted.push(j);\n          \
    \      col_sorted.push(i);\n                row_coord.push(j);\n             \
    \   col_coord.push(i);\n                i += 1;\n                j += 1;\n   \
    \         } else {\n                i += 1;\n            }\n        }\n    }\n\
    \    while j < cols {\n        while i < rows {\n            if lst[i][j] == x\
    \ {\n                row_sorted.push(j);\n                col_sorted.push(i);\n\
    \                row_coord.push(j);\n                col_coord.push(i);\n    \
    \            i += 1;\n            } else {\n                j += 1;\n        \
    \    }\n        }\n    }\n    for i in 0..row_sorted.len() {\n        row_coord.push(row_sorted[i]);\n\
    \        col_coord.push(col_sorted[i]);\n    }\n    for i in 0..row_coord.len()\
    \ {\n        coords.push((row_coord[i], col_coord[i]));\n    }\n    coords\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk1n2nca7.rs:78:5\n   |\n\
    16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |\
    \                                               ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n78 |     coords\n   |     ^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<(usize, usize)>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_len = 0;\n    let mut col_len = 0;\n    let mut col_pos\
    \ = 0;\n    let mut col_pos_idx = 0;\n    let mut col_pos_len = 0;\n    let mut\
    \ row_len_idx = 0;\n    let mut row_len_idx_idx = 0;\n    let mut col_len_idx\
    \ = 0;\n    let mut col_len_idx_idx = 0;\n    let mut row_idx = 0;\n    let mut\
    \ row_idx_idx = 0;\n    let mut col_pos_idx = 0;\n    let mut col_pos_idx_idx\
    \ = 0;\n    let mut col_pos_len_idx = 0;\n    let mut row_len_idx_idx = 0;\n \
    \   let mut row_len_idx_idx_idx = 0;\n    let mut col_len_idx_idx = 0;\n    let\
    \ mut col_len_idx_idx_idx = 0;\n    let mut row_idx = 0;\n    let mut row_idx_idx\
    \ = 0;\n    let mut col_pos_idx = 0;\n    let mut col_pos_idx_idx = 0;\n    let\
    \ mut col_pos_len_idx = 0;\n    let mut row_len_idx_idx = 0;\n    let mut row_len_idx_idx_idx\
    \ = 0;\n    let mut col_len_idx_idx = 0;\n    let mut col_len_idx_idx_idx = 0;\n\
    \    let mut row_idx = 0;\n    let mut row_idx_idx = 0;\n    let mut col_pos_idx\
    \ = 0;\n    let mut col_pos_idx_idx = 0;\n    let mut col_pos_len_idx = 0;\n \
    \   let mut row_len_idx_idx = 0;\n    let mut row_len_idx_idx_idx = 0;\n    let\
    \ mut col_len_idx_idx = 0;\n    let mut col_len_idx_idx_idx = 0;\n    let mut\
    \ row_idx = 0;\n    let mut row_idx_idx = 0;\n    let mut col_pos_idx = 0;\n \
    \   let mut col_pos_idx_idx = 0;\n    let mut col_pos_len_idx = 0;\n    let mut\
    \ row_len_idx_idx = 0;\n    let mut row_len_idx_idx_idx = 0;\n    let mut col_len_idx_idx\
    \ = 0;\n    let mut col_len_idx_idx_idx = 0;\n    let mut row_idx = 0;\n    let\
    \ mut row_idx_idx = 0;\n    let mut col_pos_idx = 0;\n    let mut col_pos_idx_idx\
    \ = 0;\n    let mut col_pos_len_idx = 0;\n    let mut row_len_idx_idx = 0;\n \
    \   let mut row_len_idx_idx_idx = 0;\n    let mut col_len_idx_idx = 0;\n    let\
    \ mut col_len_idx_idx_idx = 0;\n    let mut row_idx = 0;\n    let mut row_idx_idx\
    \ = 0;\n    let mut col_pos_idx\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1iiq_7ac.rs:75:24\n   |\n\
    75 |     let mut col_pos_idx\n   |                        ^ help: add `;` here\n\
    76 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1iiq_7ac.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_idx_max = 0;\n    let mut col_max = 0;\n    let mut col_min\
    \ = 0;\n    let mut col_max_idx = 0;\n    let mut col_min_idx = 0;\n    let mut\
    \ row_max_idx = 0;\n    let mut row_min_idx = 0;\n    for row_idx in 0..lst.len()\
    \ {\n        let mut col_max = 0;\n        let mut col_min = 0;\n        let mut\
    \ col_max_idx = 0;\n        let mut col_min_idx = 0;\n        for col_idx in 0..lst[row_idx].len()\
    \ {\n            if col_idx > col_max {\n                col_max = col_idx;\n\
    \                col_max_idx = col_idx;\n            }\n            if col_idx\
    \ < col_min {\n                col_min = col_idx;\n                col_min_idx\
    \ = col_idx;\n            }\n        }\n        if col_max > col_max_idx {\n \
    \           row_max_idx = row_idx;\n        }\n        if col_min < col_min_idx\
    \ {\n            row_min_idx = row_idx;\n        }\n        if row_max_idx > row_idx\
    \ {\n            row.push((row_idx, col_max_idx));\n        }\n        if row_min_idx\
    \ < row_idx {\n            row.push((row_idx, col_min_idx));\n        }\n    }\n\
    \    row.sort_by_key(|&(x, y)| x.0);\n    row.sort_by_key(|&(x, y)| y.0);\n  \
    \  row\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptzgan95x.rs:48:23\n   |\n\
    48 |             row.push((row_idx, col_max_idx));\n   |                     \
    \  ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n48 |     \
    \        row.push((row_idx.try_into().unwrap(), col_max_idx));\n   |         \
    \                     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptzgan95x.rs:48:32\n   |\n48 |             row.push((row_idx, col_max_idx));\n\
    \   |                                ^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n48 |             row.push((row_idx, col_max_idx.try_into().unwrap()));\n\
    \   |                                           ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptzgan95x.rs:51:23\n   |\n51 |             row.push((row_idx,\
    \ col_min_idx));\n   |                       ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n51 |             row.push((row_idx.try_into().unwrap(),\
    \ col_min_idx));\n   |                              ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptzgan95x.rs:51:32\n   |\n51 |             row.push((row_idx,\
    \ col_min_idx));\n   |                                ^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n51 |             row.push((row_idx,\
    \ col_min_idx.try_into().unwrap()));\n   |                                   \
    \        ++++++++++++++++++++\n\nerror[E0610]: `isize` is a primitive type and\
    \ therefore doesn't have fields\n  --> /tmp/tmptzgan95x.rs:54:33\n   |\n54 | \
    \    row.sort_by_key(|&(x, y)| x.0);\n   |                                 ^\n\
    \nerror[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmptzgan95x.rs:55:33\n   |\n55 |     row.sort_by_key(|&(x, y)"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx\
    \ = 0;\n    let mut col_idx = 0;\n    for row in lst {\n        let mut row_idx\
    \ = 0;\n        let mut col_idx = 0;\n        for el in row {\n            if\
    \ el == x {\n                rows.push((row_idx, col_idx));\n            }\n \
    \           row_idx += 1;\n        }\n        col_idx += 1;\n    }\n    rows\n\
    \        .iter()\n        .sort_by(|a, b| a.1.cmp(&b.1))\n        .sort_by(|a,\
    \ b| b.0.cmp(&a.0));\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmp1l2sou66.rs:33:10\n   |\n33 |         .sort_by(|a,\
    \ b| a.1.cmp(&b.1))\n   |          ^^^^^^^ method not found in `std::slice::Iter<'_,\
    \ (isize, isize)>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1l2sou66.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sor\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuhnsu3xc.rs:68:20\n   |\n\
    68 |     let mut row_sor\n   |                    ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuhnsu3xc.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    let mut row_idx = 1;\n    let mut col_idx\
    \ = 1;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    while row_idx < row_len {\n        let mut row_idx = 1;\n        while col_idx\
    \ < col_len {\n            if lst[row_idx][col_idx] == x {\n                result.push((row_idx,\
    \ col_idx));\n                break;\n            }\n            col_idx += 1;\n\
    \        }\n        row_idx += 1;\n    }\n    result.sort_by_key(|&(x, y)| x.0);\n\
    \    result.sort_by_key(|&(x, y)| y.0);\n    result\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpk8huubow.rs:33:36\n   |\n33 |     result.sort_by_key(|&(x, y)|\
    \ x.0);\n   |                                    ^\n\nerror[E0610]: `usize` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmpk8huubow.rs:34:36\n\
    \   |\n34 |     result.sort_by_key(|&(x, y)| y.0);\n   |                     \
    \               ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk8huubow.rs:35:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n35 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = Vec::new();\n    let mut rows = Vec::new();\n    let\
    \ mut cols = Vec::new();\n    for row in lst {\n        let mut cols = row.clone();\n\
    \        cols.sort_by_key(|&x| x.partial_cmp(&x).reverse());\n        rows.push(cols);\n\
    \    }\n    rows.sort_by_key(|&x| x.partial_cmp(&x).reverse());\n    for row in\
    \ rows {\n        let mut cols = row.clone();\n        cols.sort_by_key(|&x| x.partial_cmp(&x).reverse());\n\
    \        coords.push(cols);\n    }\n    coords.sort_by_key(|&x| x.partial_cmp(&x).reverse());\n\
    \    let mut coord = coords.iter().cloned().collect::<Vec<_>>();\n    coord.sort_by_key(|&x|\
    \ x.partial_cmp(&x).reverse());\n    let mut coord = coord.iter().cloned().collect::<Vec<_>>();\n\
    \    coord.sort_by_key(|&x| x.partial_cmp(&x).reverse());\n    let mut coord =\
    \ coord.iter().cloned().collect::<Vec<_>>();\n    coord.sort_by_key(|&x| x.partial_cmp(&x).reverse());\n\
    \    let mut coord = coord.iter().cloned().collect::<Vec<_>>();\n    coord.sort_by_key(|&x|\
    \ x.partial_cmp(&x).reverse());\n    let mut coord = coord.iter().cloned().collect::<Vec<_>>();\n\
    \    coord.sort_by_key(|&x| x.partial_cmp(&x).reverse());\n    let mut coord =\
    \ coord.iter().cloned().collect::<Vec<_>>();\n    coord.sort_by_key(|&x| x.partial_cmp(&x).reverse());\n\
    \    let mut coord = coord.iter().cloned().collect::<Vec<_>>();\n    coord.sort_by_key(|&x|\
    \ x.partial_cmp(&x).reverse());\n    let mut coord = coord.iter().cloned().collect::<Vec<_>>();\n\
    \    coord.sort_by_key(|&x| x.partial_cmp(&x).reverse());\n    let mut coord =\
    \ coord.iter().cloned().collect::<Vec<_>>();\n    coord.sort_by_key(|&x| x.partial_cmp(&x).reverse());\n\
    \    let mut coord = coord.iter().cloned().collect::<Vec<_>>();\n    coord.sort_by_key(|&x|\
    \ x.partial_cmp(&x).\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpxfg2w9am.rs:51:22\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                                                   -\
    \ closing delimiter possibly meant for this\n...\n51 |     coord.sort_by_key(|&x|\
    \ x.partial_cmp(&x).\n   |                      ^ unclosed delimiter\n52 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror: unexpected token: `)`\n  --> /tmp/tmpxfg2w9am.rs:52:1\n\
    \   |\n52 | }\n   | ^\n\nerror[E0599]: no method named `reverse` found for enum\
    \ `Option` in the current scope\n  --> /tmp/tmpxfg2w9am.rs:22:49\n   |\n22 | \
    \        cols.sort_by_key(|&x| x.partial_cmp(&x).reverse());\n   |           \
    \                                      ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\
    \nerror[E0599]: no method named `reverse` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpxfg2w9am.rs:25:45\n   |\n25 |     rows.sort_by_key(|&x|\
    \ x.partial_cmp(&x).reverse());\n   |                                        \
    \     ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\nerror[E0599]:\
    \ no method named `reverse` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmpxfg2w9am.rs:28:49\n   |\n28 |         cols.sort_by_key(|&x| x.partial_cmp(&x).reverse());\n\
    \   |                                                 ^^^^^^^ method not found\
    \ in `Option<std::cmp::Ordering>`\n\nerror[E0599]: no method named `reverse` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpxfg2w9am.rs:31:47\n  \
    \ |\n31 |     coords.sort_by_key(|&x| x.partial_cmp(&x).reverse());\n   |    \
    \                                           ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\
    \nerror[E0599]: no method named `reverse` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpxfg2w9am.rs:33:46\n   |\n33 |     coord.sort_by_key(|&x|\
    \ x.partial_cmp(&x).reverse());\n   |                                        \
    \      ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\nerror[E0599]:\
    \ no method named `reverse` found for enum `Option` in the current scope"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = vec![];\n    let mut cols = vec![];\n    for row in lst\
    \ {\n        cols.push(row.iter().cloned().collect::<Vec<_>>());\n    }\n    for\
    \ col in cols.iter_mut() {\n        col.sort_by(|a, b| a.partial_cmp(b).reverse());\n\
    \    }\n    let mut row_iter = rows.iter();\n    row_iter.sort_by(|a, b| a.partial_cmp(b).reverse());\n\
    \    let mut col_iter = cols.iter();\n    col_iter.sort_by(|a, b| b.partial_cmp(a).reverse());\n\
    \    let mut result = vec![];\n    for row in row_iter {\n        let mut row_result\
    \ = vec![];\n        for col in col_iter {\n            let mut col_result = vec![];\n\
    \            for (row_i, col_i) in row.iter().zip(col.iter()) {\n            \
    \    row_result.push((row_i, col_i));\n            }\n            col_result.sort_by(|a,\
    \ b| b.partial_cmp(a).reverse());\n            row_result.extend(col_result);\n\
    \        }\n        result.push(row_result);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmpjlwj0gir.rs:23:45\n   |\n23 |         col.sort_by(|a,\
    \ b| a.partial_cmp(b).reverse());\n   |                                      \
    \       ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\nerror[E0599]:\
    \ no method named `sort_by` found for struct `std::slice::Iter` in the current\
    \ scope\n  --> /tmp/tmpjlwj0gir.rs:26:14\n   |\n26 |     row_iter.sort_by(|a,\
    \ b| a.partial_cmp(b).reverse());\n   |              ^^^^^^^ method not found\
    \ in `std::slice::Iter<'_, _>`\n\nerror[E0599]: no method named `sort_by` found\
    \ for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmpjlwj0gir.rs:28:14\n\
    \   |\n28 |     col_iter.sort_by(|a, b| b.partial_cmp(a).reverse());\n   |   \
    \           ^^^^^^^ method not found in `std::slice::Iter<'_, Vec<isize>>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpjlwj0gir.rs:42:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n42 |     result\n   |     ^^^^^^ expected\
    \ tuple, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<(_, _)>>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_idx2 = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4\
    \ = 0;\n    let mut row_idx5 = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7\
    \ = 0;\n    let mut row_idx8 = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10\
    \ = 0;\n    let mut row_idx11 = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13\
    \ = 0;\n    let mut row_idx14 = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16\
    \ = 0;\n    let mut row_idx17 = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19\
    \ = 0;\n    let mut row_idx20 = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22\
    \ = 0;\n    let mut row_idx23 = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25\
    \ = 0;\n    let mut row_idx26 = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28\
    \ = 0;\n    let mut row_idx29 = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31\
    \ = 0;\n    let mut row_idx32 = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34\
    \ = 0;\n    let mut row_idx35 = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37\
    \ = 0;\n    let mut row_idx38 = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40\
    \ = 0;\n    let mut row_idx41 = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43\
    \ = 0;\n    let mut row_idx44 = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46\
    \ = 0;\n    let mut row_idx47 = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49\
    \ = 0;\n    let mut row_idx50 = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52\
    \ = 0;\n    let mut row_idx53 = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55\
    \ = 0;\n    let mut row_idx56 = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58\
    \ = 0;\n    let mut row_idx59 = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61\
    \ = 0;\n    let mut row_idx62 = 0;\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpy0j02d22.rs:81:1\n\
    \   |\n81 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = vec![];\n    let mut rows = vec![];\n    for row in\
    \ lst {\n        let mut cols = vec![];\n        for col in row {\n          \
    \  if col == x {\n                coords.push((row, col));\n            }\n  \
    \          cols.push(col);\n        }\n        rows.push(cols);\n    }\n    coords.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n    coords.sort_by(|a, b| b.1.cmp(&a.1));\n    coords.iter().map(|c|\
    \ c.0).collect()\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<(isize, isize)>` cannot be built from\
    \ an iterator over elements of type `Vec<isize>`\n    --> /tmp/tmply3in7ul.rs:31:32\n\
    \     |\n31   |     coords.iter().map(|c| c.0).collect()\n     |             \
    \                   ^^^^^^^ value of type `Vec<(isize, isize)>` cannot be built\
    \ from `std::iter::Iterator<Item=Vec<isize>>`\n     |\n     = help: the trait\
    \ `FromIterator<Vec<isize>>` is not implemented for `Vec<(isize, isize)>`\n  \
    \   = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_idx2 = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4\
    \ = 0;\n    let mut row_idx5 = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7\
    \ = 0;\n    let mut row_idx8 = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10\
    \ = 0;\n    let mut row_idx11 = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13\
    \ = 0;\n    let mut row_idx14 = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16\
    \ = 0;\n    let mut row_idx17 = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19\
    \ = 0;\n    let mut row_idx20 = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22\
    \ = 0;\n    let mut row_idx23 = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25\
    \ = 0;\n    let mut row_idx26 = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28\
    \ = 0;\n    let mut row_idx29 = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31\
    \ = 0;\n    let mut row_idx32 = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34\
    \ = 0;\n    let mut row_idx35 = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37\
    \ = 0;\n    let mut row_idx38 = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40\
    \ = 0;\n    let mut row_idx41 = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43\
    \ = 0;\n    let mut row_idx44 = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46\
    \ = 0;\n    let mut row_idx47 = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49\
    \ = 0;\n    let mut row_idx50 = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52\
    \ = 0;\n    let mut row_idx53 = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55\
    \ = 0;\n    let mut row_idx56 = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58\
    \ = 0;\n    let mut row_idx59 = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61\
    \ = 0;\n    let mut row_idx62 = 0;\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpy0j02d22.rs:81:1\n\
    \   |\n81 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst.first().len();\n\
    \    let mut col_len2 = lst.last().len();\n    let mut col_len3 = lst.last().last().len();\n\
    \    let mut col_len4 = lst.last().last().last().len();\n    let mut col_len5\
    \ = lst.last().last().last().last().len();\n    let mut col_len6 = lst.last().last().last().last().last().len();\n\
    \    let mut col_len7 = lst.last().last().last().last().last().last().len();\n\
    \    let mut col_len8 = lst.last().last().last().last().last().last().last().last().len();\n\
    \    let mut col_len9 = lst.last().last().last().last().last().last().last().last().last().len();\n\
    \    let mut col_len10 = lst.last().last().last().last().last().last().last().last().last().len();\n\
    \    let mut col_len11 = lst.last().last().last().last().last().last().last().last().last().last().len();\n\
    \    let mut col_len12 = lst.last().last().last().last().last().last().last().last().last().last().last().len();\n\
    \    let mut col_len13 = lst.last().last().last().last().last().last().last().last().last().last().last().last().len();\n\
    \    let mut col_len14 = lst.last().last().last().last().last().last().last().last().last().last().last().last().last().len();\n\
    \    let mut col_len15 = lst.last().last().last().last().last().last().last().last().last().last().last().last().last().len();\n\
    \    let mut col_len16 = lst.last().last().last().last().last().last().last().last().last().last().last().last().last().len();\n\
    \    let mut col_len17 = lst.last().last().last().last().last().last().last().last().last().last().last().last().last().last().len();\n\
    \    let mut col_len18 = lst.last().last().last().last().last().last().last().last().last().last().last().last().last().last().last().len();\n\
    \    let mut col_len19 = lst.last().last().last().last().last().last().last().last().last().last().last().last().last().last().last().len();\n\
    \    let mut col_len20 = lst.last().last().last().last().last().last().last().last().last().last().last().last().last().last().last().len();\n\
    \    let mut col_len21 = lst.last().last().last().last().last().last().last().last().last().last().last().last().last().last().last().len();\n\
    \    let mut col_len22 = lst.last().last().last().last().last().last().last().last().last().last().last().last().last().last().last().last().len();\n\
    \    let mut col_len23 = lst.last().last().last().last().last().last().\n}\n\n\
    fn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmphf5kj_91.rs:43:1\n   |\n43\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmphf5kj_91.rs:42:71\n\
    \   |\n42 |     let mut col_len23 = lst.last().last().last().last().last().last().\n\
    \   |                                                                       ^\
    \ help: add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0599]: no method\
    \ named `len` found for enum `Option` in the current scope\n  --> /tmp/tmphf5kj_91.rs:20:35\n\
    \   |\n20 |     let mut col_len = lst.first().len();\n   |                   \
    \                ^^^ method not found in `Option<&Vec<isize>>`\n\nerror[E0599]:\
    \ no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmphf5kj_91.rs:21:35\n\
    \   |\n21 |     let mut col_len2 = lst.last().len();\n   |                   \
    \                ^^^ method not found in `Option<&Vec<isize>>`\n\nerror[E0599]:\
    \ `Option<&Vec<isize>>` is not an iterator\n   --> /tmp/tmphf5kj_91.rs:22:35\n\
    \    |\n22  |       let mut col_len3 = lst.last().last().len();\n    |       \
    \                              ^^^^ `Option<&Vec<isize>>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<&Vec<isize>>: Iterator`\n            which is required by `&mut Option<&Vec<isize>>:\
    \ Iterator`\n\nerror[E0599]: `Option<&Vec<isize>>` is not an iterator\n   -->\
    \ /tmp/tmphf5kj_91.rs:23:35\n    |\n23  |       let mut col_len4 = lst.last().last().last().len();\n\
    \    |                                     ^^^^ `Option<&Vec<isize>>` is not an\
    \ iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<&Vec<isize>>: Iterator`\n            which is required by\
    \ `&mut Option<&Vec<isize>>: Iterator`\n\nerror[E0599]: `Option<&Vec<isize>>`\
    \ is not an iterator\n   --> /tmp/tmphf5kj_91.rs:24:35\n    |\n24  |       let\
    \ mut col_len5 = lst.last().last().last().last().len();\n    |               \
    \                      ^^^^ `Option<&Vec<isize>>` is not an iterator\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `Option<&Vec<isize>>:\
    \ It"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = vec![];\n    let mut rows = vec![];\n    let mut cols\
    \ = vec![];\n    for row in lst {\n        let mut row_coords = vec![];\n    \
    \    let mut row_cols = vec![];\n        for col in row {\n            if col\
    \ == x {\n                row_coords.push((row, col));\n            }\n      \
    \      row_cols.push((col, row));\n        }\n        row_coords.sort_by(|a, b|\
    \ a.1.cmp(&b.1));\n        row_coords.reverse();\n        row_cols.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n        row_cols.reverse();\n        row_coords.reverse();\n\
    \        row_cols.reverse();\n        coords.push(row_coords);\n        rows.push(row_cols);\n\
    \        cols.push(row_coords);\n    }\n    coords.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    coords.reverse();\n    rows.sort_by(|a, b| b.0.cmp(&a.0));\n    rows.reverse();\n\
    \    cols.sort_by(|a, b| b.0.cmp(&a.0));\n    cols.reverse();\n    coords.reverse();\n\
    \    rows.reverse();\n    cols.reverse();\n    coords\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&Vec<(Vec<isize>, isize)>`\n  --> /tmp/tmpafrfxyay.rs:39:29\n\
    \   |\n39 |     coords.sort_by(|a, b| a.0.cmp(&b.0));\n   |                  \
    \           ^ unknown field\n\nerror[E0609]: no field `0` on type `&Vec<(Vec<isize>,\
    \ isize)>`\n  --> /tmp/tmpafrfxyay.rs:39:38\n   |\n39 |     coords.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n   |                                      ^ unknown field\n\
    \nerror[E0609]: no field `0` on type `&Vec<(isize, Vec<isize>)>`\n  --> /tmp/tmpafrfxyay.rs:41:27\n\
    \   |\n41 |     rows.sort_by(|a, b| b.0.cmp(&a.0));\n   |                    \
    \       ^ unknown field\n\nerror[E0609]: no field `0` on type `&Vec<(isize, Vec<isize>)>`\n\
    \  --> /tmp/tmpafrfxyay.rs:41:36\n   |\n41 |     rows.sort_by(|a, b| b.0.cmp(&a.0));\n\
    \   |                                    ^ unknown field\n\nerror[E0609]: no field\
    \ `0` on type `&Vec<(Vec<isize>, isize)>`\n  --> /tmp/tmpafrfxyay.rs:43:27\n \
    \  |\n43 |     cols.sort_by(|a, b| b.0.cmp(&a.0));\n   |                     \
    \      ^ unknown field\n\nerror[E0609]: no field `0` on type `&Vec<(Vec<isize>,\
    \ isize)>`\n  --> /tmp/tmpafrfxyay.rs:43:36\n   |\n43 |     cols.sort_by(|a, b|\
    \ b.0.cmp(&a.0));\n   |                                    ^ unknown field\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpafrfxyay.rs:48:5\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n48 |     coords\n   |     ^^^^^^ expected\
    \ tuple, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize, isize)>`\n\
    \              found struct `Vec<Vec<(Vec<isize>, isize)>>`\n\nerror: aborting\
    \ due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0609.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        Vec::new()\n    } else {\n        let mut\
    \ rows = lst.iter().map(|row| row.iter().cloned()).collect::<Vec<_>>();\n    \
    \    sort_rows(&mut rows);\n        let mut cols = rows.iter().map(|row| row.iter().cloned()).collect::<Vec<_>>();\n\
    \        sort_cols(&mut cols);\n        let mut result = vec![];\n        for\
    \ row in 0..rows.len() {\n            for col in 0..cols.len() {\n           \
    \     if col == x {\n                    result.push((row, col));\n          \
    \      }\n            }\n        }\n        result\n    }\n}\n\nfn main() {\n\
    \    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_rows` in this scope\n  --> /tmp/tmpylmnvvvb.rs:21:9\n\
    \   |\n21 |         sort_rows(&mut rows);\n   |         ^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `sort_cols` in this scope\n\
    \  --> /tmp/tmpylmnvvvb.rs:23:9\n   |\n23 |         sort_cols(&mut cols);\n  \
    \ |         ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `iter` found for reference `&Cloned<std::slice::Iter<'_, isize>>` in the current\
    \ scope\n  --> /tmp/tmpylmnvvvb.rs:22:50\n   |\n22 |         let mut cols = rows.iter().map(|row|\
    \ row.iter().cloned()).collect::<Vec<_>>();\n   |                            \
    \                      ^^^^ method not found in `&Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpylmnvvvb.rs:27:27\n\
    \   |\n27 |                 if col == x {\n   |                           ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n27 |                 if\
    \ col == x.try_into().unwrap() {\n   |                            ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpylmnvvvb.rs:32:9\n   |\n16 | fn\
    \ get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |     \
    \                                          ------------------- expected `Vec<(isize,\
    \ isize)>` because of return type\n...\n32 |         result\n   |         ^^^^^^\
    \ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<(usize, usize)>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = Vec::<(isize, isize)>::new();\n    let mut row_idx = 1;\n\
    \    let mut row_idx2 = 1;\n    let mut row_idx3 = 1;\n    let mut row_idx4 =\
    \ 1;\n    let mut row_idx5 = 1;\n    let mut row_idx6 = 1;\n    let mut row_idx7\
    \ = 1;\n    let mut row_idx8 = 1;\n    let mut row_idx9 = 1;\n    let mut row_idx10\
    \ = 1;\n    let mut row_idx11 = 1;\n    let mut row_idx12 = 1;\n    let mut row_idx13\
    \ = 1;\n    let mut row_idx14 = 1;\n    let mut row_idx15 = 1;\n    let mut row_idx16\
    \ = 1;\n    let mut row_idx17 = 1;\n    let mut row_idx18 = 1;\n    let mut row_idx19\
    \ = 1;\n    let mut row_idx20 = 1;\n    let mut row_idx21 = 1;\n    let mut row_idx22\
    \ = 1;\n    let mut row_idx23 = 1;\n    let mut row_idx24 = 1;\n    let mut row_idx25\
    \ = 1;\n    let mut row_idx26 = 1;\n    let mut row_idx27 = 1;\n    let mut row_idx28\
    \ = 1;\n    let mut row_idx29 = 1;\n    let mut row_idx30 = 1;\n    let mut row_idx31\
    \ = 1;\n    let mut row_idx32 = 1;\n    let mut row_idx33 = 1;\n    let mut row_idx34\
    \ = 1;\n    let mut row_idx35 = 1;\n    let mut row_idx36 = 1;\n    let mut row_idx37\
    \ = 1;\n    let mut row_idx38 = 1;\n    let mut row_idx39 = 1;\n    let mut row_idx40\
    \ = 1;\n    let mut row_idx41 = 1;\n    let mut row_idx42 = 1;\n    let mut row_idx43\
    \ = 1;\n    let mut row_idx44 = 1;\n    let mut row_idx45 = 1;\n    let mut row_idx46\
    \ = 1;\n    let mut row_idx47 = 1;\n    let mut row_idx48 = 1;\n    let mut row_idx49\
    \ = 1;\n    let mut row_idx50 = 1;\n    let mut row_idx51 = 1;\n    let mut row_idx52\
    \ = 1;\n    let mut row_idx53 = 1;\n    let mut row_idx54 = 1;\n    let mut row_idx55\
    \ = 1;\n    let mut row_idx56 = 1;\n    let mut row_idx57 = 1;\n    let mut row_idx58\
    \ = 1;\n    let mut row_idx59 = 1;\n    let mut row_idx60 = 1;\n    let mut row_idx61\
    \ = 1;\n    let mut row_idx62 = \n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp5fb733uj.rs:80:1\n\
    \   |\n80 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = Vec::<(isize, isize)>::new();\n    let mut row_sorted =\
    \ Vec::<(isize, isize)>::new();\n    let mut row_reversed = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sorted = Vec::<(isize, isize)>::new();\n    let mut col_sorted\
    \ = Vec::<(isize, isize)>::new();\n    let mut col_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sorted = Vec::<(isize, isize)>::new();\n    let mut col_sorted\
    \ = Vec::<(isize, isize)>::new();\n    let mut col_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sorted = Vec::<(isize, isize)>::new();\n    let mut col_sorted\
    \ = Vec::<(isize, isize)>::new();\n    let mut col_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sorted = Vec::<(isize, isize)>::new();\n    let mut col_sorted\
    \ = Vec::<(isize, isize)>::new();\n    let mut col_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sorted = Vec::<(isize, isize)>::new();\n    let mut col_sorted\
    \ = Vec::<(isize, isize)>::new();\n    let mut col_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sorted = Vec::<(isize, isize)>::new();\n    let mut col_sorted\
    \ = Vec::<(isize, isize)>::new();\n    let mut col_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sorted = Vec::<(isize, isize)>::new();\n    let mut col_sorted\
    \ = Vec::<(isize, isize)>::new();\n    let mut col_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sorted = Vec::<(isize, isize)>::new();\n    let mut col_sorted\
    \ = Vec::<(isize, isize)>::new();\n    let mut col_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_sorted = Vec::<(isize, isize)>::new();\n    let mut col_sorted\
    \ = Vec::<(isize, isize)>::new();\n    let mut col_sorted = Vec::<(isize, isize)>::new();\n\
    \    let mut col_\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmps6v7gk6f.rs:47:17\n   |\n\
    47 |     let mut col_\n   |                 ^ help: add `;` here\n48 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps6v7gk6f.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sor\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuhnsu3xc.rs:68:20\n   |\n\
    68 |     let mut row_sor\n   |                    ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuhnsu3xc.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut row_idx2 = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4 =\
    \ 0;\n    let mut row_idx5 = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7\
    \ = 0;\n    let mut row_idx8 = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10\
    \ = 0;\n    let mut row_idx11 = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13\
    \ = 0;\n    let mut row_idx14 = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16\
    \ = 0;\n    let mut row_idx17 = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19\
    \ = 0;\n    let mut row_idx20 = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22\
    \ = 0;\n    let mut row_idx23 = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25\
    \ = 0;\n    let mut row_idx26 = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28\
    \ = 0;\n    let mut row_idx29 = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31\
    \ = 0;\n    let mut row_idx32 = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34\
    \ = 0;\n    let mut row_idx35 = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37\
    \ = 0;\n    let mut row_idx38 = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40\
    \ = 0;\n    let mut row_idx41 = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43\
    \ = 0;\n    let mut row_idx44 = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46\
    \ = 0;\n    let mut row_idx47 = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49\
    \ = 0;\n    let mut row_idx50 = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52\
    \ = 0;\n    let mut row_idx53 = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55\
    \ = 0;\n    let mut row_idx56 = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58\
    \ = 0;\n    let mut row_idx59 = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61\
    \ = 0;\n    let mut row_idx62 = 0;\n    let mut row_\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphuncwqqz.rs:80:17\n   |\n\
    80 |     let mut row_\n   |                 ^ help: add `;` here\n81 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphuncwqqz.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut coords = Vec::new();\n    let mut rows = Vec::new();\n    let\
    \ mut cols = Vec::new();\n    for row in lst {\n        if row.len() == x {\n\
    \            coords.push(row.iter().cloned().collect::<Vec<_>>());\n         \
    \   rows.push(row.iter().cloned().collect::<Vec<_>>());\n            cols.push(row.iter().cloned().collect::<Vec<_>>());\n\
    \        }\n    }\n    coords.sort_by(|a, b| a.iter().cmp(b.iter()).reverse());\n\
    \    rows.sort_by(|a, b| b.iter().cmp(a.iter()).reverse());\n    cols.sort_by(|a,\
    \ b| b.iter().cmp(a.iter()).reverse());\n    coords.iter().cloned().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxtx69sz5.rs:21:25\n   |\n\
    21 |         if row.len() == x {\n   |                         ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |         if row.len() == x.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxtx69sz5.rs:30:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |                                   \
    \            ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n30 |     coords.iter().cloned().collect::<Vec<_>>()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected tuple, found struct `Vec`\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n              found struct `Vec<Vec<isize>>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorting = vec![];\n    let mut col_sorting = vec![];\n    let\
    \ mut row_sorting_index = vec![];\n    let mut col_sorting_index = vec![];\n \
    \   let mut row_sorting_index2 = vec![];\n    let mut col_sorting_index2 = vec![];\n\
    \    let mut row_sorting_index3 = vec![];\n    let mut col_sorting_index3 = vec![];\n\
    \    let mut row_sorting_index4 = vec![];\n    let mut col_sorting_index4 = vec![];\n\
    \    let mut row_sorting_index5 = vec![];\n    let mut col_sorting_index5 = vec![];\n\
    \    let mut row_sorting_index6 = vec![];\n    let mut col_sorting_index6 = vec![];\n\
    \    let mut row_sorting_index7 = vec![];\n    let mut col_sorting_index7 = vec![];\n\
    \    let mut row_sorting_index8 = vec![];\n    let mut col_sorting_index8 = vec![];\n\
    \    let mut row_sorting_index9 = vec![];\n    let mut col_sorting_index9 = vec![];\n\
    \    let mut row_sorting_index10 = vec![];\n    let mut col_sorting_index10 =\
    \ vec![];\n    let mut row_sorting_index11 = vec![];\n    let mut col_sorting_index11\
    \ = vec![];\n    let mut row_sorting_index12 = vec![];\n    let mut col_sorting_index12\
    \ = vec![];\n    let mut row_sorting_index13 = vec![];\n    let mut col_sorting_index13\
    \ = vec![];\n    let mut row_sorting_index14 = vec![];\n    let mut col_sorting_index14\
    \ = vec![];\n    let mut row_sorting_index15 = vec![];\n    let mut col_sorting_index15\
    \ = vec![];\n    let mut row_sorting_index16 = vec![];\n    let mut col_sorting_index16\
    \ = vec![];\n    let mut row_sorting_index17 = vec![];\n    let mut col_sorting_index17\
    \ = vec![];\n    let mut row_sorting_index\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxu9l6g2z.rs:60:30\n   |\n\
    60 |     let mut row_sorting_index\n   |                              ^ help:\
    \ add `;` here\n61 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxu9l6g2z.rs:16:47\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |    -------                        \
    \            ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n           found unit\
    \ type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut row_idx2 = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4 =\
    \ 0;\n    let mut row_idx5 = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7\
    \ = 0;\n    let mut row_idx8 = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10\
    \ = 0;\n    let mut row_idx11 = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13\
    \ = 0;\n    let mut row_idx14 = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16\
    \ = 0;\n    let mut row_idx17 = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19\
    \ = 0;\n    let mut row_idx20 = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22\
    \ = 0;\n    let mut row_idx23 = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25\
    \ = 0;\n    let mut row_idx26 = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28\
    \ = 0;\n    let mut row_idx29 = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31\
    \ = 0;\n    let mut row_idx32 = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34\
    \ = 0;\n    let mut row_idx35 = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37\
    \ = 0;\n    let mut row_idx38 = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40\
    \ = 0;\n    let mut row_idx41 = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43\
    \ = 0;\n    let mut row_idx44 = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46\
    \ = 0;\n    let mut row_idx47 = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49\
    \ = 0;\n    let mut row_idx50 = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52\
    \ = 0;\n    let mut row_idx53 = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55\
    \ = 0;\n    let mut row_idx56 = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58\
    \ = 0;\n    let mut row_idx59 = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61\
    \ = 0;\n    let mut row_idx62 = 0;\n    let mut row_\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwcu_1gxu.rs:80:17\n   |\n\
    80 |     let mut row_\n   |                 ^ help: add `;` here\n81 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwcu_1gxu.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx\
    \ = 0;\n    let mut col_idx = 0;\n    let mut row_len = lst.len();\n    let mut\
    \ col_len = lst[0].len();\n    let mut row_idxs = Vec::new();\n    let mut col_idxs\
    \ = Vec::new();\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut\
    \ row_len = lst.len();\n    let mut col_len = lst[0].len();\n    let mut row_idxs\
    \ = Vec::new();\n    let mut col_idxs = Vec::new();\n    let mut row_idx = 0;\n\
    \    let mut col_idx = 0;\n    let mut row_len = lst.len();\n    let mut col_len\
    \ = lst[0].len();\n    let mut row_idxs = Vec::new();\n    let mut col_idxs =\
    \ Vec::new();\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut\
    \ row_len = lst.len();\n    let mut col_len = lst[0].len();\n    let mut row_idxs\
    \ = Vec::new();\n    let mut col_idxs = Vec::new();\n    let mut row_idx = 0;\n\
    \    let mut col_idx = 0;\n    let mut row_len = lst.len();\n    let mut col_len\
    \ = lst[0].len();\n    let mut row_idxs = Vec::new();\n    let mut col_idxs =\
    \ Vec::new();\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut\
    \ row_len = lst.len();\n    let mut col_len = lst[0].len();\n    let mut row_idxs\
    \ = Vec::new();\n    let mut col_idxs = Vec::new();\n    let mut row_idx = 0;\n\
    \    let mut col_idx = 0;\n    let mut row_len = lst.len();\n    let mut col_len\
    \ = lst[0].len();\n    let mut row_idxs = Vec::new();\n    let mut col_idxs =\
    \ Vec::new();\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n    let mut\
    \ row_len = lst.len();\n    let mut col_len = lst[0].len();\n    let mut row_idxs\
    \ = Vec::new();\n    let mut col_idxs = Vec::new();\n    let mut row_idx = 0;\n\
    \    let mut col_idx = 0;\n    let mut row_len = lst.len();\n    let mut col_len\
    \ = lst[0].len();\n    let mut row_idxs = Vec::new();\n    let \n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp8fxvyzxs.rs:72:1\n  \
    \ |\n72 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    if lst.is_empty() {\n        vec![]\n    } else {\n        let mut row:\
    \ Vec<(isize, isize)> = vec![];\n        let mut row_idx = 0;\n        let mut\
    \ row_len = 0;\n        for row_idx in 0..lst.len() {\n            let row_len\
    \ = lst[row_idx].len();\n            if row_len > x {\n                break;\n\
    \            }\n            let mut row_col: Vec<(isize, isize)> = vec![];\n \
    \           for col_idx in 0..row_len {\n                if row_col.is_empty()\
    \ {\n                    row_col.push((row_idx, col_idx));\n                }\
    \ else {\n                    let mut col_len = 0;\n                    for col\
    \ in row_col {\n                        col_len += col;\n                    }\n\
    \                    if col_len > x {\n                        break;\n      \
    \              }\n                    row_col.push((row_idx, col_idx));\n    \
    \            }\n            }\n            row.push(row_col);\n        }\n   \
    \     row.sort_by_key(|&(_, y)| y.cmp(&x));\n        row.sort_by_key(|&(_, y)|\
    \ y.cmp(&x));\n        row\n    }\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp09qgqxk0.rs:25:26\n   |\n\
    25 |             if row_len > x {\n   |                          ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |             if row_len > x.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp09qgqxk0.rs:31:35\n   |\n31 |                     row_col.push((row_idx,\
    \ col_idx));\n   |                                   ^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n31 |                     row_col.push((row_idx.try_into().unwrap(),\
    \ col_idx));\n   |                                          ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp09qgqxk0.rs:31:44\n   |\n31 |\
    \                     row_col.push((row_idx, col_idx));\n   |                \
    \                            ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n31 |                     row_col.push((row_idx, col_idx.try_into().unwrap()));\n\
    \   |                                                   ++++++++++++++++++++\n\
    \nerror[E0277]: cannot add-assign `(isize, isize)` to `{integer}`\n  --> /tmp/tmp09qgqxk0.rs:35:33\n\
    \   |\n35 |                         col_len += col;\n   |                    \
    \             ^^ no implementation for `{integer} += (isize, isize)`\n   |\n \
    \  = help: the trait `AddAssign<(isize, isize)>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst.clone();\n    let mut row: Vec<(isize, isize)> = Vec::new();\n\
    \    let mut row_idx = 0;\n    let mut row_idx2 = 0;\n    let mut row_idx3 = 0;\n\
    \    let mut row_idx4 = 0;\n    let mut row_idx5 = 0;\n    let mut row_idx6 =\
    \ 0;\n    let mut row_idx7 = 0;\n    let mut row_idx8 = 0;\n    let mut row_idx9\
    \ = 0;\n    let mut row_idx10 = 0;\n    let mut row_idx11 = 0;\n    let mut row_idx12\
    \ = 0;\n    let mut row_idx13 = 0;\n    let mut row_idx14 = 0;\n    let mut row_idx15\
    \ = 0;\n    let mut row_idx16 = 0;\n    let mut row_idx17 = 0;\n    let mut row_idx18\
    \ = 0;\n    let mut row_idx19 = 0;\n    let mut row_idx20 = 0;\n    let mut row_idx21\
    \ = 0;\n    let mut row_idx22 = 0;\n    let mut row_idx23 = 0;\n    let mut row_idx24\
    \ = 0;\n    let mut row_idx25 = 0;\n    let mut row_idx26 = 0;\n    let mut row_idx27\
    \ = 0;\n    let mut row_idx28 = 0;\n    let mut row_idx29 = 0;\n    let mut row_idx30\
    \ = 0;\n    let mut row_idx31 = 0;\n    let mut row_idx32 = 0;\n    let mut row_idx33\
    \ = 0;\n    let mut row_idx34 = 0;\n    let mut row_idx35 = 0;\n    let mut row_idx36\
    \ = 0;\n    let mut row_idx37 = 0;\n    let mut row_idx38 = 0;\n    let mut row_idx39\
    \ = 0;\n    let mut row_idx40 = 0;\n    let mut row_idx41 = 0;\n    let mut row_idx42\
    \ = 0;\n    let mut row_idx43 = 0;\n    let mut row_idx44 = 0;\n    let mut row_idx45\
    \ = 0;\n    let mut row_idx46 = 0;\n    let mut row_idx47 = 0;\n    let mut row_idx48\
    \ = 0;\n    let mut row_idx49 = 0;\n    let mut row_idx50 = 0;\n    let mut row_idx51\
    \ = 0;\n    let mut row_idx52 = 0;\n    let mut row_idx53 = 0;\n    let mut row_idx54\
    \ = 0;\n    let mut row_idx55 = 0;\n    let mut row_idx56 = 0;\n    let mut row_idx57\
    \ = 0;\n    let mut row_idx58 = 0;\n    let mut row_idx59 = 0;\n    let mut row_idx60\
    \ = 0;\n    let mut row_idx61 = 0;\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt4oqgfky.rs:80:11\n   |\n\
    80 |     let mu\n   |           ^ help: add `;` here\n81 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt4oqgfky.rs:16:47\n \
    \  |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n\
    \   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ row_sor\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuhnsu3xc.rs:68:20\n   |\n\
    68 |     let mut row_sor\n   |                    ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuhnsu3xc.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row = vec![];\n    let mut row_sorted = vec![];\n    let mut\
    \ row_reversed = vec![];\n    let mut col_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ col_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut col_sorted\
    \ = vec![];\n    let mut col_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut col_sorted = vec![];\n    let mut col_sorted = vec![];\n    let mut\
    \ col_\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpma7n4a2w.rs:68:17\n   |\n\
    68 |     let mut col_\n   |                 ^ help: add `;` here\n69 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpma7n4a2w.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = vec![];\n    let mut row_coords = vec![];\n    let mut col_coords\
    \ = vec![];\n    let mut row_sorted = vec![];\n    let mut col_sorted = vec![];\n\
    \    let mut row_sorted_idx = vec![];\n    let mut col_sorted_idx = vec![];\n\
    \    let mut row_sorted_idx_idx = vec![];\n    let mut col_sorted_idx_idx = vec![];\n\
    \    let mut row_sorted_idx_idx_idx = vec![];\n    let mut col_sorted_idx_idx_idx\
    \ = vec![];\n    let mut row_sorted_idx_idx_idx_idx = vec![];\n    let mut col_sorted_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sorted_idx_idx_idx_idx_idx = vec![];\n    let mut\
    \ col_sorted_idx_idx_idx_idx_idx = vec![];\n    let mut row_sorted_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sorted_idx_idx_idx_idx_idx_idx = vec![];\n    let\
    \ mut row_sorted_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let mut\
    \ row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx =\
    \ vec![];\n    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = vec![];\n\
    \    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx =\
    \ vec![];\n    let mut col_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut row_sorted_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx\
    \ = vec![];\n    let mut col_sorted_idx_\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx8ohvc3t.rs:51:28\n   |\n\
    51 |     let mut col_sorted_idx_\n   |                            ^ help: add\
    \ `;` here\n52 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpx8ohvc3t.rs:16:47\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>,\
    \ x: isize) -> Vec<(isize, isize)> {\n   |    -------                        \
    \            ^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n           found unit\
    \ type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut lst = lst.clone();\n    let mut rows = lst.len();\n    let mut\
    \ cols = lst[0].len();\n    let mut coords = Vec::new();\n    let mut row_coords\
    \ = Vec::new();\n    let mut col_coords = Vec::new();\n    let mut i = 0;\n  \
    \  let mut j = 0;\n    while i < rows {\n        let mut row_coord = Vec::new();\n\
    \        let mut col_coord = Vec::new();\n        while j < cols {\n         \
    \   if lst[i][j] == x {\n                row_coord.push((i, j));\n           \
    \     col_coord.push((j, i));\n                i += 1;\n                j += 1;\n\
    \            } else {\n                j += 1;\n            }\n        }\n   \
    \     coords.push(row_coord);\n        row_coords.push(row_coord);\n        col_coords.push(col_coord);\n\
    \    }\n    coords.sort_by_key(|x| x.0);\n    row_coords.sort_by_key(|x| x.0);\n\
    \    col_coords.sort_by_key(|x| x.1);\n    coords\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&Vec<(usize, usize)>`\n  --> /tmp/tmpke8jq2my.rs:42:30\n\
    \   |\n42 |     coords.sort_by_key(|x| x.0);\n   |                           \
    \   ^ unknown field\n\nerror[E0609]: no field `0` on type `&Vec<(usize, usize)>`\n\
    \  --> /tmp/tmpke8jq2my.rs:43:34\n   |\n43 |     row_coords.sort_by_key(|x| x.0);\n\
    \   |                                  ^ unknown field\n\nerror[E0609]: no field\
    \ `1` on type `&Vec<(usize, usize)>`\n  --> /tmp/tmpke8jq2my.rs:44:34\n   |\n\
    44 |     col_coords.sort_by_key(|x| x.1);\n   |                              \
    \    ^ unknown field\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpke8jq2my.rs:45:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n45 |     coords\n   |   \
    \  ^^^^^^ expected tuple, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<(isize, isize)>`\n              found struct `Vec<Vec<(usize, usize)>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0609.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = vec![];\n    for row in lst {\n        let mut row_result\
    \ = vec![];\n        for col in row.iter().rev() {\n            if col == x {\n\
    \                row_result.push((row, col));\n            }\n        }\n    \
    \    result.push(row_result);\n    }\n    result.sort_by(|a, b| a.0.cmp(&b.0));\n\
    \    result.sort_by(|a, b| b.1.cmp(&a.1));\n    result\n}\n\nfn main() {\n   \
    \ let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5,\
    \ 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2,\
    \ 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6],\
    \ vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1),\
    \ vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4),\
    \ (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpb00kekl9.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0609]: no field `0` on type `&Vec<(Vec<isize>,\
    \ &isize)>`\n  --> /tmp/tmpb00kekl9.rs:27:29\n   |\n27 |     result.sort_by(|a,\
    \ b| a.0.cmp(&b.0));\n   |                             ^ unknown field\n\nerror[E0609]:\
    \ no field `0` on type `&Vec<(Vec<isize>, &isize)>`\n  --> /tmp/tmpb00kekl9.rs:27:38\n\
    \   |\n27 |     result.sort_by(|a, b| a.0.cmp(&b.0));\n   |                  \
    \                    ^ unknown field\n\nerror[E0609]: no field `1` on type `&Vec<(Vec<isize>,\
    \ &isize)>`\n  --> /tmp/tmpb00kekl9.rs:28:29\n   |\n28 |     result.sort_by(|a,\
    \ b| b.1.cmp(&a.1));\n   |                             ^ unknown field\n\nerror[E0609]:\
    \ no field `1` on type `&Vec<(Vec<isize>, &isize)>`\n  --> /tmp/tmpb00kekl9.rs:28:38\n\
    \   |\n28 |     result.sort_by(|a, b| b.1.cmp(&a.1));\n   |                  \
    \                    ^ unknown field\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpb00kekl9.rs:29:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize)\
    \ -> Vec<(isize, isize)> {\n   |                                             \
    \  ------------------- expected `Vec<(isize, isize)>` because of return type\n\
    ...\n29 |     result\n   |     ^^^^^^ expected tuple, found struct `Vec`\n   |\n\
    \   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<Vec<(Vec<isize>, &isize)>>`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    let mut rows = lst.len();\n    let\
    \ mut cols = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx = 0;\n\
    \    while col_idx < cols {\n        while row_idx < rows {\n            if lst[row_idx][col_idx]\
    \ == x {\n                result.push((row_idx, col_idx));\n                break;\n\
    \            }\n            row_idx += 1;\n        }\n        col_idx += 1;\n\
    \    }\n    result.sort_by_key(|&(_, y)| y.reverse());\n    result.sort_by_key(|&(_,\
    \ y)| y.reverse());\n    result\n}\n\nfn main() {\n    let candidate = get_row;\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6],\
    \ vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n\
    \    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1,\
    \ 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2,\
    \ 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmph3smv3a_.rs:32:36\n   |\n32 |     result.sort_by_key(|&(_,\
    \ y)| y.reverse());\n   |                                    ^^^^^^^ help: there\
    \ is an associated function with a similar name: `reverse_bits`\n\nerror[E0599]:\
    \ no method named `reverse` found for type `usize` in the current scope\n  -->\
    \ /tmp/tmph3smv3a_.rs:33:36\n   |\n33 |     result.sort_by_key(|&(_, y)| y.reverse());\n\
    \   |                                    ^^^^^^^ help: there is an associated\
    \ function with a similar name: `reverse_bits`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmph3smv3a_.rs:34:5\n   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x:\
    \ isize) -> Vec<(isize, isize)> {\n   |                                      \
    \         ------------------- expected `Vec<(isize, isize)>` because of return\
    \ type\n...\n34 |     result\n   |     ^^^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<(isize, isize)>`\n              found struct\
    \ `Vec<(usize, usize)>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::new();\n    for row in lst {\n        let mut row_result\
    \ = Vec::new();\n        for col in row.iter().rev() {\n            if col ==\
    \ x {\n                row_result.push((row.len(), col.len()));\n            }\n\
    \        }\n        result.push(row_result);\n    }\n    result.sort_by_key(|&(_,\
    \ y)| y.len());\n    result.sort_by_key(|&(_, y)| y.iter().rev().cloned());\n\
    \    result\n}\n\nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpfeqy_kji.rs:21:20\n\
    \   |\n21 |             if col == x {\n   |                    ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0599]: no method named `len`\
    \ found for reference `&isize` in the current scope\n  --> /tmp/tmpfeqy_kji.rs:22:49\n\
    \   |\n22 |                 row_result.push((row.len(), col.len()));\n   |   \
    \                                              ^^^ method not found in `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfeqy_kji.rs:27:26\n   |\n27 |\
    \     result.sort_by_key(|&(_, y)| y.len());\n   |                          ^^^^^-\n\
    \   |                          |    |\n   |                          |    expected\
    \ due to this\n   |                          expected struct `Vec`, found tuple\n\
    \   |\n   = note: expected struct `Vec<_>`\n               found tuple `(_, _)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfeqy_kji.rs:28:26\n   |\n28 |\
    \     result.sort_by_key(|&(_, y)| y.iter().rev().cloned());\n   |           \
    \               ^^^^^-\n   |                          |    |\n   |           \
    \               |    expected due to this\n   |                          expected\
    \ struct `Vec`, found tuple\n   |\n   = note: expected struct `Vec<_>`\n     \
    \          found tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfeqy_kji.rs:29:5\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |                                               ------------------- expected\
    \ `Vec<(isize, isize)>` because of return type\n...\n29 |     result\n   |   \
    \  ^^^^^^ expected tuple, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<(isize, isize)>`\n              found struct `Vec<Vec<_>>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors "
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut rows = lst.len();\n    let mut cols = lst[0].len();\n    let\
    \ mut coords = Vec::new();\n    let mut row_coords = Vec::new();\n    let mut\
    \ col_coords = Vec::new();\n    let mut row_coord = Vec::new();\n    let mut col_coord\
    \ = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while i < rows {\n\
    \        row_coord.clear();\n        col_coord.clear();\n        row_coords.clear();\n\
    \        col_coords.clear();\n        while j < cols {\n            row_coord.push((i,\
    \ j));\n            col_coord.push((i, j));\n            row_coords.push((i, j));\n\
    \            col_coords.push((i, j));\n            i += 1;\n            j += 1;\n\
    \        }\n        if row_coord.iter().any(|&(_, y)| y == x) {\n            coords.push_back(row_coord);\n\
    \            coords.push_back(col_coord);\n        }\n    }\n    coords.sort_by_key(|&(_,\
    \ y)| y);\n    coords.sort_by_key(|&(_, y)| y, |&(_, y)| -y);\n    coords\n}\n\
    \nfn main() {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz9d4a2mc.rs:39:48\n   |\n\
    39 |         if row_coord.iter().any(|&(_, y)| y == x) {\n   |               \
    \                                 ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n39 |         if row_coord.iter().any(|&(_, y)| y == x.try_into().unwrap())\
    \ {\n   |                                                 ++++++++++++++++++++\n\
    \nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current\
    \ scope\n  --> /tmp/tmpz9d4a2mc.rs:40:20\n   |\n40 |             coords.push_back(row_coord);\n\
    \   |                    ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]:\
    \ no method named `push_back` found for struct `Vec<_>` in the current scope\n\
    \  --> /tmp/tmpz9d4a2mc.rs:41:20\n   |\n41 |             coords.push_back(col_coord);\n\
    \   |                    ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n   --> /tmp/tmpz9d4a2mc.rs:45:12\n\
    \    |\n45  |     coords.sort_by_key(|&(_, y)| y, |&(_, y)| -y);\n    |      \
    \      ^^^^^^^^^^^ -----------  ------------ supplied 2 arguments\n    |     \
    \       |\n    |            expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut result = Vec::<(isize, isize)>::new();\n    let mut rows = lst.len();\n\
    \    let mut cols = lst[0].len();\n    let mut row_idx = 0;\n    let mut col_idx\
    \ = 0;\n    while row_idx < rows {\n        while col_idx < cols {\n         \
    \   if lst[row_idx][col_idx] == x {\n                result.push((row_idx, col_idx));\n\
    \                break;\n            }\n            col_idx += 1;\n        }\n\
    \        col_idx = 0;\n        row_idx += 1;\n    }\n    result.sort_by_key(|&(x,\
    \ y)| x.0);\n    result.sort_by_key(|&(x, y)| y.0);\n    result\n}\n\nfn main()\
    \ {\n    let candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3,\
    \ 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 4), (1, 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1,\
    \ 1), (2, 1), (3, 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1,\
    \ 4, 5, 6], vec![1, 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5,\
    \ 1]], 1), vec![(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(),\
    \ 1), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![1]],\
    \ 2), Vec::<(isize, isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1],\
    \ vec![1, 2, 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1_fuz74e.rs:25:30\n   |\n\
    25 |                 result.push((row_idx, col_idx));\n   |                  \
    \            ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    25 |                 result.push((row_idx.try_into().unwrap(), col_idx));\n  \
    \ |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1_fuz74e.rs:25:39\n   |\n25 |              \
    \   result.push((row_idx, col_idx));\n   |                                   \
    \    ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n25 |     \
    \            result.push((row_idx, col_idx.try_into().unwrap()));\n   |      \
    \                                        ++++++++++++++++++++\n\nerror[E0610]:\
    \ `isize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmp1_fuz74e.rs:33:36\n\
    \   |\n33 |     result.sort_by_key(|&(x, y)| x.0);\n   |                     \
    \               ^\n\nerror[E0610]: `isize` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmp1_fuz74e.rs:34:36\n   |\n34 |     result.sort_by_key(|&(x,\
    \ y)| y.0);\n   |                                    ^\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0610.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = vec![];\n    let mut row_idx = 0;\n\
    \    let mut row_idx2 = 0;\n    let mut row_idx3 = 0;\n    let mut row_idx4 =\
    \ 0;\n    let mut row_idx5 = 0;\n    let mut row_idx6 = 0;\n    let mut row_idx7\
    \ = 0;\n    let mut row_idx8 = 0;\n    let mut row_idx9 = 0;\n    let mut row_idx10\
    \ = 0;\n    let mut row_idx11 = 0;\n    let mut row_idx12 = 0;\n    let mut row_idx13\
    \ = 0;\n    let mut row_idx14 = 0;\n    let mut row_idx15 = 0;\n    let mut row_idx16\
    \ = 0;\n    let mut row_idx17 = 0;\n    let mut row_idx18 = 0;\n    let mut row_idx19\
    \ = 0;\n    let mut row_idx20 = 0;\n    let mut row_idx21 = 0;\n    let mut row_idx22\
    \ = 0;\n    let mut row_idx23 = 0;\n    let mut row_idx24 = 0;\n    let mut row_idx25\
    \ = 0;\n    let mut row_idx26 = 0;\n    let mut row_idx27 = 0;\n    let mut row_idx28\
    \ = 0;\n    let mut row_idx29 = 0;\n    let mut row_idx30 = 0;\n    let mut row_idx31\
    \ = 0;\n    let mut row_idx32 = 0;\n    let mut row_idx33 = 0;\n    let mut row_idx34\
    \ = 0;\n    let mut row_idx35 = 0;\n    let mut row_idx36 = 0;\n    let mut row_idx37\
    \ = 0;\n    let mut row_idx38 = 0;\n    let mut row_idx39 = 0;\n    let mut row_idx40\
    \ = 0;\n    let mut row_idx41 = 0;\n    let mut row_idx42 = 0;\n    let mut row_idx43\
    \ = 0;\n    let mut row_idx44 = 0;\n    let mut row_idx45 = 0;\n    let mut row_idx46\
    \ = 0;\n    let mut row_idx47 = 0;\n    let mut row_idx48 = 0;\n    let mut row_idx49\
    \ = 0;\n    let mut row_idx50 = 0;\n    let mut row_idx51 = 0;\n    let mut row_idx52\
    \ = 0;\n    let mut row_idx53 = 0;\n    let mut row_idx54 = 0;\n    let mut row_idx55\
    \ = 0;\n    let mut row_idx56 = 0;\n    let mut row_idx57 = 0;\n    let mut row_idx58\
    \ = 0;\n    let mut row_idx59 = 0;\n    let mut row_idx60 = 0;\n    let mut row_idx61\
    \ = 0;\n    let mut row_idx62 = 0;\n    let mut row_\n}\n\nfn main() {\n    let\
    \ candidate = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1,\
    \ 0), (2, 5), (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6],\
    \ vec![1, 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1,\
    \ 2, 3, 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwcu_1gxu.rs:80:17\n   |\n\
    80 |     let mut row_\n   |                 ^ help: add `;` here\n81 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwcu_1gxu.rs:16:47\n\
    \   |\n16 | fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n   |    -------                                    ^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
- exit_code: 1
  program: "/// You are given a 2 dimensional data, as a nested lists,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the list,\n/// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    /// each tuple is a coordinate - (row, columns), starting with 0.\n/// Sort coordinates\
    \ initially by rows in ascending order.\n/// Also, sort coordinates of the row\
    \ by columns in descending order.\n/// Examples:\n/// >>> get_row(vec![vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1)\n/// vec![(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(vec![], 1)\n/// Vec::<(isize,\
    \ isize)>::new()\n/// >>> get_row(vec![vec![], vec![1], vec![1, 2, 3]], 3)\n///\
    \ vec![(2, 2)]\nfn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)>\
    \ {\n    let mut row: Vec<(isize, isize)> = Vec::new();\n    let mut row_idx =\
    \ 0;\n    let mut row_len = lst.len();\n    let mut col_len = lst[0].len();\n\
    \    let mut col_len2 = col_len;\n    let mut col_len3 = col_len;\n    let mut\
    \ col_len4 = col_len;\n    let mut col_len5 = col_len;\n    let mut col_len6 =\
    \ col_len;\n    let mut col_len7 = col_len;\n    let mut col_len8 = col_len;\n\
    \    let mut col_len9 = col_len;\n    let mut col_len10 = col_len;\n    let mut\
    \ col_len11 = col_len;\n    let mut col_len12 = col_len;\n    let mut col_len13\
    \ = col_len;\n    let mut col_len14 = col_len;\n    let mut col_len15 = col_len;\n\
    \    let mut col_len16 = col_len;\n    let mut col_len17 = col_len;\n    let mut\
    \ col_len18 = col_len;\n    let mut col_len19 = col_len;\n    let mut col_len20\
    \ = col_len;\n    let mut col_len21 = col_len;\n    let mut col_len22 = col_len;\n\
    \    let mut col_len23 = col_len;\n    let mut col_len24 = col_len;\n    let mut\
    \ col_len25 = col_len;\n    let mut col_len26 = col_len;\n    let mut col_len27\
    \ = col_len;\n    let mut col_len28 = col_len;\n    let mut col_len29 = col_len;\n\
    \    let mut col_len30 = col_len;\n    let mut col_len31 = col_len;\n    let mut\
    \ col_len32 = col_len;\n    let mut col_len33 = col_len;\n    let mut col_len34\
    \ = col_len;\n    let mut col_len35 = col_len;\n    let mut col_len36 = col_len;\n\
    \    let mut col_len37 = col_len;\n    let mut col_len38 = col_len;\n    let mut\
    \ col_len39 = col_len;\n    let mut col_len40 = col_len;\n    let mut col_len41\
    \ = col_len;\n    let mut col_len42 = col_len;\n    let mut col_len43 = col_len;\n\
    \    let mut col_len44 = col_len;\n    let mut col_len45 = col_len;\n    let mut\
    \ col_len46 = col_len;\n    let mut col_len47 = col_len;\n    let mut col_len48\
    \ = col_len;\n    let mut col_len49 = col_\n}\n\nfn main() {\n    let candidate\
    \ = get_row;\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0), (1, 4), (1, 0), (2, 5),\
    \ (2, 0)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1, 2,\
    \ 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4, 5, 6], vec![1, 2, 3, 4,\
    \ 5, 6], vec![1, 2, 3, 4, 5, 6]], 2), vec![(0, 1), (1, 1), (2, 1), (3, 1), (4,\
    \ 1), (5, 1)]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4, 5, 6], vec![1,\
    \ 2, 3, 4, 5, 6], vec![1, 1, 3, 4, 5, 6], vec![1, 2, 1, 4, 5, 6], vec![1, 2, 3,\
    \ 1, 5, 6], vec![1, 2, 3, 4, 1, 6], vec![1, 2, 3, 4, 5, 1]], 1), vec![(0, 0),\
    \ (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6,\
    \ 5), (6, 0)]);\n    assert_eq!(candidate(Vec::<Vec<isize>>::new(), 1), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![1]], 2), Vec::<(isize,\
    \ isize)>::new());\n    assert_eq!(candidate(vec![vec![], vec![1], vec![1, 2,\
    \ 3]], 3), vec![(2, 2)]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcmuj_mc0.rs:68:29\n   |\n\
    68 |     let mut col_len49 = col_\n   |                             ^ help: add\
    \ `;` here\n69 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `col_` in this scope\n  --> /tmp/tmpcmuj_mc0.rs:68:25\n   |\n68 |     let mut\
    \ col_len49 = col_\n   |                         ^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcmuj_mc0.rs:16:47\n   |\n16 |\
    \ fn get_row(lst: Vec<Vec<isize>>, x: isize) -> Vec<(isize, isize)> {\n   |  \
    \  -------                                    ^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<(isize,\
    \ isize)>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010753
