language: rs
name: HumanEval_10_make_palindrome
results:
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    for pos in string.char_indices() {\n        let mut suffix = &mut reversed_string[..pos];\n\
    \        let mut prefix = &mut reversed_string[..pos];\n        let mut suffix_length\
    \ = suffix.len();\n        while suffix_length > longest_postfix_length {\n  \
    \          let mut suffix_char = suffix[suffix_length - 1];\n            suffix_char.swap(suffix[suffix_length\
    \ - 1]);\n            suffix_length -= 1;\n            suffix.pop();\n       \
    \     prefix.push(suffix_char);\n        }\n        longest_postfix_length = suffix.len();\n\
    \        reversed_string = &mut suffix;\n    }\n    reversed_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeTo<(usize, char)>`\n\
    \  --> /tmp/tmpijqhmub5.rs:15:31\n   |\n15 |         let mut suffix = &mut reversed_string[..pos];\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `RangeTo<(usize, char)>`\n   |\n   = help: the trait `Index<RangeTo<(usize,\
    \ char)>>` is not implemented for `String`\n   = help: the following other types\
    \ implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `RangeTo<(usize,\
    \ char)>`\n  --> /tmp/tmpijqhmub5.rs:16:31\n   |\n16 |         let mut prefix\
    \ = &mut reversed_string[..pos];\n   |                               ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `RangeTo<(usize, char)>`\n   |\n   = help: the\
    \ trait `Index<RangeTo<(usize, char)>>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_length_index = 0;\n\
    \    while let Some(index) = string.rfind('a', longest_postfix_length_index) {\n\
    \        reversed_string += &string[index..];\n        longest_postfix_length\
    \ = index;\n        longest_postfix_length_index = index + 1;\n    }\n    longest_postfix_length_index\n\
    \        .checked_add(1)\n        .ok_or(Error::IndexOutOfBounds)\n        .checked_add(longest_postfix_length)\n\
    \        .ok_or(Error::IndexOutOfBounds)\n        .checked_add(1)\n        .ok_or(Error::IndexOutOfBounds)\n\
    \        .checked_add(longest_postfix_length)\n        .ok_or(Error::IndexOutOfBounds)\n\
    \        .checked_add(1)\n        .ok_or(Error::IndexOutOfBounds)\n        .checked_add(longest_postfix_length)\n\
    \        .ok_or(Error::IndexOutOfBounds)\n        .checked_add(1)\n        .ok_or(Error::IndexOutOfBounds)\n\
    \        .checked_add(longest_postfix_length)\n        .ok_or(Error::IndexOutOfBounds)\n\
    \        .checked_add(1)\n        .ok_or(Error::IndexOutOfBounds)\n        .checked_add(longest_postfix_length)\n\
    \        .ok_or(Error::IndexOutOfBounds)\n        .checked_add(1)\n        .ok_or(Error::IndexOutOfBounds)\n\
    \        .checked_add(longest_postfix_length)\n        .ok_or(Error::IndexOutOfBounds)\n\
    \        .checked_add(1)\n        .ok_or(Error::IndexOutOfBounds)\n        .checked_add(longest_postfix_length)\n\
    \        .ok_or(Error::IndexOutOfBounds)\n        .checked_add(1)\n        .ok_or(Error::IndexOutOfBounds)\n\
    \        .checked_add(longest_postfix_length)\n        .ok_or(Error::IndexOutOfBounds)\n\
    \        .checked_add(1)\n        .ok_or(Error::IndexOutOfBounds)\n        .checked_add(longest_postfix_length)\n\
    \        .ok_or(Error::IndexOutOfBounds)\n        .checked_add(1)\n        .ok_or(Error::IndexOutOfBounds)\n\
    \        .checked_add(longest_postfix_length)\n        .ok_or(Error::IndexOutOfBounds)\n\
    \        .checked_add(1)\n        .ok_or(Error::IndexOutOfBounds)\n        .check\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Error`\n  -->\
    \ /tmp/tmpe_2puvy_.rs:23:16\n   |\n23 |         .ok_or(Error::IndexOutOfBounds)\n\
    \   |                ^^^^^ use of undeclared type `Error`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Error`\n  --> /tmp/tmpe_2puvy_.rs:25:16\n\
    \   |\n25 |         .ok_or(Error::IndexOutOfBounds)\n   |                ^^^^^\
    \ use of undeclared type `Error`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Error`\n  --> /tmp/tmpe_2puvy_.rs:27:16\n   |\n27 |         .ok_or(Error::IndexOutOfBounds)\n\
    \   |                ^^^^^ use of undeclared type `Error`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Error`\n  --> /tmp/tmpe_2puvy_.rs:29:16\n\
    \   |\n29 |         .ok_or(Error::IndexOutOfBounds)\n   |                ^^^^^\
    \ use of undeclared type `Error`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Error`\n  --> /tmp/tmpe_2puvy_.rs:31:16\n   |\n31 |         .ok_or(Error::IndexOutOfBounds)\n\
    \   |                ^^^^^ use of undeclared type `Error`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Error`\n  --> /tmp/tmpe_2puvy_.rs:33:16\n\
    \   |\n33 |         .ok_or(Error::IndexOutOfBounds)\n   |                ^^^^^\
    \ use of undeclared type `Error`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Error`\n  --> /tmp/tmpe_2puvy_.rs:35:16\n   |\n35 |         .ok_or(Error::IndexOutOfBounds)\n\
    \   |                ^^^^^ use of undeclared type `Error`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Error`\n  --> /tmp/tmpe_2puvy_.rs:37:16\n\
    \   |\n37 |         .ok_or(Error::IndexOutOfBounds)\n   |                ^^^^^\
    \ use of undeclared type `Error`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Error`\n  --> /tmp/tmpe_2puvy_.rs:39:16\n   |\n39 |         .ok_or(Error::IndexOutOfBounds)\n\
    \   |                ^^^^^ use of undeclared type `Error`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `Error`\n  --> /tmp/tmpe_2puvy_.rs:41:16\n\
    \   |\n41 |         .ok_or(Error::IndexOutOfBounds)\n   |                ^^^^^\
    \ use of undeclared type `Error`\n\nerror[E0"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    while !string.is_empty() {\n        let mut\
    \ postfix_length = string.len();\n        while postfix_length >= longest_postfix_length\
    \ {\n            let mut postfix = &string[..postfix_length];\n            let\
    \ mut reversed_postfix = &reversed_string[..postfix_length];\n            reversed_postfix.reverse();\n\
    \            if postfix.eq(&reversed_postfix) {\n                longest_postfix_length\
    \ = postfix_length;\n            } else {\n                break;\n          \
    \  }\n            postfix_length -= 1;\n        }\n        string = &string[longest_postfix_length..];\n\
    \        reversed_string += &string[..longest_postfix_length];\n    }\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmp1eagi4_g.rs:20:30\n   |\n20 |             reversed_postfix.reverse();\n\
    \   |                              ^^^^^^^ method not found in `&str`\n\nerror[E0277]:\
    \ can't compare `str` with `&str`\n  --> /tmp/tmp1eagi4_g.rs:21:27\n   |\n21 |\
    \             if postfix.eq(&reversed_postfix) {\n   |                       \
    \ -- ^^^^^^^^^^^^^^^^^ no implementation for `str == &str`\n   |             \
    \           |\n   |                        required by a bound introduced by this\
    \ call\n   |\n   = note: the trait bound `str: PartialEq<&str>` is not satisfied\n\
    \   = help: the trait `PartialEq<&str>` is not implemented for `str`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <&'a\
    \ str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n \
    \            <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1eagi4_g.rs:28:18\n   |\n12 |     let mut string = string;\n\
    \   |                      ------ expected due to this value\n...\n28 |      \
    \   string = &string[longest_postfix_length..];\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n28 |         string = (&string[longest_postfix_length..]).to_string();\n\
    \   |                  +                                 +++++++++++++\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp1eagi4_g.rs:29:9\n\
    \   |\n29 |         reversed_string += &string[..longest_postfix_length];\n  \
    \ |         ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |       \
    \  |\n   |         cannot use `+=` on type `&str`\n\nerror: aborting due to 4\
    \ previous errors\n\nSome errors have detailed explanations:"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut lon\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsd4wrpdn.rs:63:16\n   |\n\
    63 |     let mut lon\n   |                ^ help: add `;` here\n64 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsd4wrpdn.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = string;\n    let mut prefix = string;\n    let mut suffix_len\
    \ = string.len();\n    let mut suffix_idx = 0;\n    let mut suffix_start = suffix_idx;\n\
    \    let mut suffix_end = suffix_idx;\n    let mut suffix_palindrome = string;\n\
    \    let mut suffix_palindrome_start = suffix_idx;\n    let mut suffix_palindrome_end\
    \ = suffix_idx;\n    let mut suffix_palindrome_len = suffix_len;\n    let mut\
    \ suffix_palindrome_palindrome = string;\n    let mut suffix_palindrome_palindrome_start\
    \ = suffix_idx;\n    let mut suffix_palindrome_palindrome_end = suffix_idx;\n\
    \    let mut suffix_palindrome_palindrome_len = suffix_len;\n    let mut suffix_palindrome_palindrome_palindrome\
    \ = string;\n    let mut suffix_palindrome_palindrome_palindrome_start = suffix_idx;\n\
    \    let mut suffix_palindrome_palindrome_palindrome_end = suffix_idx;\n    let\
    \ mut suffix_palindrome_palindrome_palindrome_len = suffix_len;\n    let mut suffix_palindrome_palindrome_palindrome_palindrome\
    \ = string;\n    let mut suffix_palindrome_palindrome_palindrome_palindrome_start\
    \ = suffix_idx;\n    let mut suffix_palindrome_palindrome_palindrome_palindrome_end\
    \ = suffix_idx;\n    let mut suffix_palindrome_palindrome_palindrome_palindrome_len\
    \ = suffix_len;\n    let mut suffix_palindrome_palindrome_palindrome_palindrome_palindrome\
    \ = string;\n    let mut suffix_palindrome_palindrome_palindrome_palindrome_palindrome_start\
    \ = suffix_idx;\n    let mut suffix_palindrome_palindrome_palindrome_palindrome_end\
    \ = suffix_idx;\n    let mut suffix_palindrome_palindrome_palindrome_palindrome_len\
    \ = suffix_len;\n    let mut suffix_palindrome_palindrome_palindrome_palindrome_palindrome_palin\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpukrxelek.rs:38:80\n   |\n\
    38 |     let mut suffix_palindrome_palindrome_palindrome_palindrome_palindrome_palin\n\
    \   |                                                                        \
    \        ^ help: add `;` here\n39 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpukrxelek.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed = string;\n    let mut longest = 0;\n    for pos in string.rchars().rev()\
    \ {\n        let mut char = &mut reversed[pos];\n        if char == char.to_ascii_lowercase()\
    \ {\n            longest = pos;\n        }\n    }\n    reversed.push_str(&string[longest..]);\n\
    \    reversed\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rchars` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpl6l8n9d9.rs:14:23\n   |\n14 |     for pos in string.rchars().rev()\
    \ {\n   |                       ^^^^^^ help: there is an associated function with\
    \ a similar name: `chars`\n\nerror[E0277]: the type `String` cannot be mutably\
    \ indexed by `{integer}`\n  --> /tmp/tmpl6l8n9d9.rs:15:29\n   |\n15 |        \
    \ let mut char = &mut reversed[pos];\n   |                             ^^^^^^^^^^^^^\
    \ `String` cannot be mutably indexed by `{integer}`\n   |\n   = help: the trait\
    \ `IndexMut<{integer}>` is not implemented for `String`\n   = note: you can use\
    \ `.chars().nth()` or `.bytes().nth()`\n           see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the following other types implement trait `IndexMut<Idx>`:\n     \
    \        <String as IndexMut<RangeFrom<usize>>>\n             <String as IndexMut<RangeFull>>\n\
    \             <String as IndexMut<RangeInclusive<usize>>>\n             <String\
    \ as IndexMut<RangeTo<usize>>>\n             <String as IndexMut<RangeToInclusive<usize>>>\n\
    \             <String as IndexMut<std::ops::Range<usize>>>\n             <str\
    \ as IndexMut<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfh1sihsn.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_length = 0;\n    while\
    \ !string.is_empty() {\n        let mut postfix = string;\n        let mut postfix_length\
    \ = 0;\n        while !postfix.is_empty() {\n            if postfix.chars().next().unwrap()\
    \ != postfix.chars().last().unwrap() {\n                break;\n            }\n\
    \            postfix_length += 1;\n            postfix = postfix.chars().nth(postfix_length).unwrap();\n\
    \        }\n        if postfix_length > longest_postfix_length {\n           \
    \ longest_postfix_length = postfix_length;\n            longest_postfix = postfix.to_string();\n\
    \        }\n        string = postfix.chars().nth(longest_postfix_length).unwrap();\n\
    \    }\n    longest_postfix.chars().nth(longest_postfix_length).unwrap()\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfvmfpv1h.rs:24:23\n   |\n\
    17 |         let mut postfix = string;\n   |                           ------\
    \ expected due to this value\n...\n24 |             postfix = postfix.chars().nth(postfix_length).unwrap();\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                       |\n\
    \   |                       expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfvmfpv1h.rs:28:31\n   |\n14 |     let mut longest_postfix\
    \ = \"\";\n   |                               -- expected due to this value\n\
    ...\n28 |             longest_postfix = postfix.to_string();\n   |           \
    \                    ^^^^^^^^^^^^^^^^^^^\n   |                               |\n\
    \   |                               expected `&str`, found struct `String`\n \
    \  |                               help: consider borrowing here: `&postfix.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfvmfpv1h.rs:30:18\n   |\n12 |\
    \     let mut string = string;\n   |                      ------ expected due\
    \ to this value\n...\n30 |         string = postfix.chars().nth(longest_postfix_length).unwrap();\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                  |\n   |\
    \                  expected struct `String`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfvmfpv1h.rs:32:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n32 |     longest_postfix.chars().nth(longest_postfix_length).unwrap()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `char`\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut longest_postfix = string;\n    let mut longest_postfix_length = longest_postfix.len();\n\
    \    let mut longest_postfix_index = 0;\n    let mut longest_postfix_index2 =\
    \ 0;\n    let mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut lon\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppqkgqqx_.rs:59:16\n   |\n\
    59 |     let mut lon\n   |                ^ help: add `;` here\n60 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppqkgqqx_.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut longest_postfix_length = 0;\n    let mut longest_postfix_length_index =\
    \ 0;\n    let mut longest_postfix_length_palindrome = string;\n    let mut longest_postfix_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_palindrome = string;\n \
    \   let mut longest_postfix_length_palindrome_palindrome_index = 0;\n    while\
    \ !string.is_empty() {\n        let mut postfix_length = 0;\n        let mut postfix_length_index\
    \ = 0;\n        let mut postfix_length_palindrome = string;\n        let mut postfix_length_palindrome_index\
    \ = 0;\n        let mut postfix_length_palindrome_palindrome = string;\n     \
    \   let mut postfix_length_palindrome_palindrome_index = 0;\n        while !string.is_empty()\
    \ {\n            let mut postfix_length = 0;\n            let mut postfix_length_index\
    \ = 0;\n            let mut postfix_length_palindrome = string;\n            let\
    \ mut postfix_length_palindrome_index = 0;\n            let mut postfix_length_palindrome_palindrome\
    \ = string;\n            let mut postfix_length_palindrome_palindrome_index =\
    \ 0;\n            while !string.is_empty() {\n                let mut postfix_length\
    \ = 0;\n                let mut postfix_length_index = 0;\n                let\
    \ mut postfix_length_palindrome = string;\n                let mut postfix_length_palindrome_index\
    \ = 0;\n                let mut postfix_length_palindrome_palindrome = string;\n\
    \                let mut postfix_length_palindrome_palindrome_index = 0;\n   \
    \             while !string.is_empty() {\n                    let mut postfix_length\
    \ = 0;\n                    let mut postfix_length_index = 0;\n              \
    \      let mut postfix_length_palindrome = string;\n                    let mut\
    \ postfix_length_palindrome_index = 0;\n                    let mut postfix_length_palindrome_palindrome\
    \ = string;\n                    let mut postfix_length_palindrome_palindrome_index\
    \ = 0;\n                    while !string.is_empty() {\n                     \
    \   let mut postfix_length = 0;\n                        let mut postfix_length_index\
    \ = 0;\n                        let mut postfix_length_palindrome = string;\n\
    \                        let mut postfix_length_palindrome_index = 0;\n      \
    \                  let mut postfix_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpjr2hi7s8.rs:63:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n20 |     while !string.is_empty()\
    \ {\n   |                              - unclosed delimiter\n...\n27 |       \
    \  while !string.is_empty() {\n   |                                  - unclosed\
    \ delimiter\n...\n34 |             while !string.is_empty() {\n   |          \
    \                            - unclosed delimiter\n...\n41 |                 while\
    \ !string.is_empty() {\n   |                                          - unclosed\
    \ delimiter\n...\n48 |                     while !string.is_empty() {\n   |  \
    \                                            - this delimiter might not be properly\
    \ closed...\n...\n54 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n63 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpjr2hi7s8.rs:53:41\n\
    \   |\n53 |                         let mut postfix_\n   |                   \
    \                      ^ help: add `;` here\n54 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjr2hi7s8.rs:20:5\n   |\n11 | \
    \  fn make_palindrome(string: String) -> String {\n   |                      \
    \                   ------ expected `String` because of return type\n...\n20 |\
    \ /     while !string.is_empty() {\n21 | |         let mut postfix_length = 0;\n\
    22 | |         let mut postfix_length_index = 0;\n23 | |         let mut postfix_length_palindrome\
    \ = string;\n...  |\n62 | |     assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n63 | | }\n   | |__^ expected struct `String`,\
    \ found `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_char = 0;\n    let mut longest_prefix_length = 0;\n    let\
    \ mut longest_prefix_index = 0;\n    let mut longest_prefix_char = 0;\n    let\
    \ mut longest_prefix_char_index = 0;\n    let mut longest_prefix_char_index2 =\
    \ 0;\n    let mut longest_prefix_char_index3 = 0;\n    let mut longest_prefix_char_index4\
    \ = 0;\n    let mut longest_prefix_char_index5 = 0;\n    let mut longest_prefix_char_index6\
    \ = 0;\n    let mut longest_prefix_char_index7 = 0;\n    let mut longest_prefix_char_index8\
    \ = 0;\n    let mut longest_prefix_char_index9 = 0;\n    let mut longest_prefix_char_index10\
    \ = 0;\n    let mut longest_prefix_char_index11 = 0;\n    let mut longest_prefix_char_index12\
    \ = 0;\n    let mut longest_prefix_char_index13 = 0;\n    let mut longest_prefix_char_index14\
    \ = 0;\n    let mut longest_prefix_char_index15 = 0;\n    let mut longest_prefix_char_index16\
    \ = 0;\n    let mut longest_prefix_char_index17 = 0;\n    let mut longest_prefix_char_index18\
    \ = 0;\n    let mut longest_prefix_char_index19 = 0;\n    let mut longest_prefix_char_index20\
    \ = 0;\n    let mut longest_prefix_char_index21 = 0;\n    let mut longest_prefix_char_index22\
    \ = 0;\n    let mut longest_prefix_char_index23 = 0;\n    let mut longest_prefix_char_index24\
    \ = 0;\n    let mut longest_prefix_char_index25 = 0;\n    let mut longest_prefix_char_index26\
    \ = 0;\n    let mut longest_prefix_char_index27 = 0;\n    let mut longest_prefix_char_index28\
    \ = 0;\n    let mut longest_prefix_char_index29 = 0;\n    let mut longest_prefix_char_index30\
    \ = 0;\n    let mut longest_prefix_char_index31 = 0;\n    let mut longest_prefix_char_index32\
    \ = 0;\n    let mut longest_prefix_char_index33 = 0;\n    let mut longest_prefix_char_index34\
    \ = 0;\n    let mut longest_prefix_char_index35 = 0;\n    let mut longest_prefix_char_index36\
    \ = 0;\n    let mut longest_prefix_char_index37 = 0;\n    let mut longest_prefix_char_index38\
    \ = 0;\n    let mut longest_prefix_char_index39 = 0;\n    let mut longest_prefix_char_index40\
    \ = 0;\n    let mut longest_prefix_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4r71xl4v.rs:60:28\n   |\n\
    60 |     let mut longest_prefix_\n   |                            ^ help: add\
    \ `;` here\n61 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4r71xl4v.rs:11:39\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo69wv1oh.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo69wv1oh.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo69wv1oh.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo69wv1oh.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut postfix = string;\n    let\
    \ mut suffix_length = 0;\n    while suffix_length < postfix.len() {\n        let\
    \ mut suffix_length = postfix.len();\n        for (i, c) in suffix.rposition(postfix)\
    \ {\n            suffix_length = i;\n            postfix = postfix.chars().nth(i).unwrap();\n\
    \        }\n        reversed_string += &postfix[..suffix_length];\n    }\n   \
    \ reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `suffix` in this scope\n  --> /tmp/tmpl4j7ptah.rs:17:23\n\
    \   |\n17 |         for (i, c) in suffix.rposition(postfix) {\n   |          \
    \             ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpl4j7ptah.rs:19:23\n   |\n13 |     let mut postfix = string;\n \
    \  |                       ------ expected due to this value\n...\n19 |      \
    \       postfix = postfix.chars().nth(i).unwrap();\n   |                     \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                       |\n   |                       expected struct `String`,\
    \ found `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    while\
    \ !reversed_string.is_empty() {\n        let mut suffix_length = 0;\n        for\
    \ ch in reversed_string.chars() {\n            if ch != string[prefix_length]\
    \ {\n                break;\n            }\n            suffix_length += 1\n \
    \       }\n        if suffix_length < 2 {\n            break;\n        }\n   \
    \     reversed_string = &string[prefix_length..prefix_length + suffix_length];\n\
    \        prefix_length += suffix_length\n    }\n    string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpy1wvzpoo.rs:17:22\n   |\n17 |             if ch != string[prefix_length]\
    \ {\n   |                      ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy1wvzpoo.rs:25:27\n\
    \   |\n12 |     let mut reversed_string = string;\n   |                      \
    \         ------ expected due to this value\n...\n25 |         reversed_string\
    \ = &string[prefix_length..prefix_length + suffix_length];\n   |             \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n \
    \  |\n25 |         reversed_string = (&string[prefix_length..prefix_length + suffix_length]).to_string();\n\
    \   |                           +                                            \
    \         +++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_reversed =\
    \ false;\n    let mut longest_postfix_length = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    for pos in string.char_indices() {\n        let mut current_char =\
    \ &string[pos];\n        let mut current_char_reversed = false;\n        let mut\
    \ current_char_length = 0;\n        let mut current_char_length_index = 0;\n \
    \       while current_char_length_index < current_char_length {\n            let\
    \ mut current_char_length_reversed = false;\n            let mut current_char_length_reversed_index\
    \ = 0;\n            while current_char_length_reversed_index < current_char_length\
    \ {\n                let mut current_char_length_reversed_reversed = false;\n\
    \                let mut current_char_length_reversed_reversed_index = 0;\n  \
    \              while current_char_length_reversed_reversed_index < current_char_length\
    \ {\n                    let mut current_char_length_reversed_reversed_reversed\
    \ = false;\n                    let mut current_char_length_reversed_reversed_reversed_index\
    \ = 0;\n                    while current_char_length_reversed_reversed_reversed_index\
    \ < current_char_length {\n                        let mut current_char_length_reversed_reversed_reversed_reversed\
    \ = false;\n                        let mut current_char_length_reversed_reversed_reversed_reversed_index\
    \ = 0;\n                        while current_char_length_reversed_reversed_reversed_reversed_index\
    \ < current_char_length {\n                            let mut current_char_length_reversed_reversed_reversed_reversed_reversed\
    \ = false;\n                            let mut current_char_length_reversed_reversed_reversed_reversed_reversed_index\
    \ = 0;\n                            while current_char_length_reversed_reversed_reversed_reversed_reversed_index\
    \ < current_char_length {\n                                let mut current_char_length_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = false;\n                                let mut current_char_length_reversed_reversed_reversed_reversed_reversed_reversed_index\
    \ = 0;\n                                while current_char_length_reversed_reversed_reversed_reversed_reversed_reversed_index\
    \ < current_char_length {\n                                    let mut current_char_length_reversed_reversed_reversed_reversed_reversed_reversed_reversed_index\
    \ = 0;\n                                    while current_char_length_reversed_reversed_reversed_reversed_reversed_reversed_reversed_index\
    \ < current_char_length {\n                                        let mut current_char_length_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_index\
    \ = 0;\n                                        while current_char_length_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_index\
    \ < current_char_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpa0m5o7xc.rs:53:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n16 |     for pos\
    \ in string.char_indices() {\n   |                                      - unclosed\
    \ delimiter\n...\n21 |         while current_char_length_index < current_char_length\
    \ {\n   |                                                               - unclosed\
    \ delimiter\n...\n24 |             while current_char_length_reversed_index <\
    \ current_char_length {\n   |                                                \
    \                            - unclosed delimiter\n...\n27 |                 while\
    \ current_char_length_reversed_reversed_index < current_char_length {\n   |  \
    \                                                                            \
    \           - unclosed delimiter\n...\n30 |                     while current_char_length_reversed_reversed_reversed_index\
    \ < current_char_length {\n   |                                              \
    \                                                        - unclosed delimiter\n\
    ...\n33 |                         while current_char_length_reversed_reversed_reversed_reversed_index\
    \ < current_char_length {\n   |                                              \
    \                                                                     - unclosed\
    \ delimiter\n...\n36 |                             while current_char_length_reversed_reversed_reversed_reversed_reversed_index\
    \ < current_char_length {\n   |                                              \
    \                                                                            \
    \      - unclosed delimiter\n...\n39 |                                 while current_char_length_reversed_reversed_reversed_reversed_reversed_reversed_index\
    \ < current_char_length {\n   |                                              \
    \                                                                            \
    \                   - unclosed delimiter\n40 |                               \
    \      let mut current_"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut i = 0;\n    while i < string.len() {\n        let mut j = i;\n        while\
    \ j + 1 < string.len() && string[j + 1] == string[j] {\n            j += 1\n \
    \       }\n        reversed_string = reversed_string.push_str(&string[i..j]);\n\
    \        i = j;\n    }\n    string.push_str(&reversed_string);\n    string\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1zgl3vj9.rs:17:39\n\
    \   |\n17 |         while j + 1 < string.len() && string[j + 1] == string[j] {\n\
    \   |                                       ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1zgl3vj9.rs:17:56\n   |\n17 |         while j + 1 < string.len()\
    \ && string[j + 1] == string[j] {\n   |                                      \
    \                  ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1zgl3vj9.rs:20:27\n   |\n13 |     let mut reversed_string\
    \ = string;\n   |                               ------ expected due to this value\n\
    ...\n20 |         reversed_string = reversed_string.push_str(&string[i..j]);\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `()`\n   |\nnote: method `push_str` modifies its receiver\
    \ in-place\n  --> /tmp/tmp1zgl3vj9.rs:20:43\n   |\n20 |         reversed_string\
    \ = reversed_string.push_str(&string[i..j]);\n   |                  "
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = string;\n    let mut postfix = string;\n    let mut i =\
    \ 0;\n    while i < reverse.len() {\n        if reverse[i] != postfix[i] {\n \
    \           break;\n        }\n        i += 1;\n    }\n    postfix.push_str(&reverse[i..]);\n\
    \    postfix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3u3_ra_1.rs:16:12\n\
    \   |\n16 |         if reverse[i] != postfix[i] {\n   |            ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3u3_ra_1.rs:16:26\n   |\n16 |         if reverse[i] != postfix[i]\
    \ {\n   |                          ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut prefix:\
    \ String;\n    let mut suffix: String;\n    let mut suffix_length = 0;\n    let\
    \ mut suffix_index = 0;\n    let mut suffix_length_index = 0;\n    let mut suffix_length_reverse\
    \ = 0;\n    let mut suffix_length_reverse_index = 0;\n    let mut suffix_length_reverse_length\
    \ = 0;\n    let mut suffix_length_reverse_length_index = 0;\n    let mut suffix_length_reverse_length_reverse\
    \ = 0;\n    let mut suffix_length_reverse_length_reverse_index = 0;\n    let mut\
    \ suffix_length_reverse_length_reverse_length = 0;\n    let mut suffix_length_reverse_length_reverse_length_index\
    \ = 0;\n    let mut suffix_length_reverse_length_reverse_length_reverse = 0;\n\
    \    let mut suffix_length_reverse_length_reverse_length_reverse_index = 0;\n\
    \    let mut suffix_length_reverse_length_reverse_length_reverse_length = 0;\n\
    \    let mut suffix_length_reverse_length_reverse_length_reverse_length_index\
    \ = 0;\n    let mut suffix_length_reverse_length_reverse_length_reverse_length_reverse\
    \ = 0;\n    let mut suffix_length_reverse_length_reverse_length_reverse_length_reverse_index\
    \ = 0;\n    let mut suffix_length_reverse_length_reverse_length_reverse_length_reverse_length\
    \ = 0;\n    let mut suffix_length_reverse_length_reverse_length_reverse_length_reverse_length_index\
    \ = 0;\n    let mut suffix_length_reverse_length_reverse_length_reverse_length_reverse_length_reverse\
    \ = 0;\n    let mut suffix_length_reverse_length_reverse_length_reverse_length_reverse_length_index\
    \ = 0;\n    let mut suffix_length_reverse_length_reverse_length_reverse_length_reverse_length_reverse\
    \ = 0;\n    let mut suffix_length_reverse_length_reverse_length_reverse_length_reverse_length_reverse_index\
    \ = 0;\n    let mut suffix_length_reverse_length_reverse_length_reverse_length_reverse_length_reverse_length\
    \ = 0;\n    let mut suffix_length_reverse_length_reverse_length_reverse_length_reverse_length_reverse_length_index\
    \ = 0;\n    let mut suffix_length_reverse_length_reverse_length_reverse_length_reverse_length_reverse_length_reverse\
    \ = 0;\n    let mut suffix_length_reverse_length_reverse_length_reverse_length_reverse_length_reverse_length_index\
    \ = 0;\n    let mut suffix_length_reverse_length_reverse_length_reverse_length_reverse_length_reverse_length_reverse\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpbwnjknlk.rs:45:1\n\
    \   |\n45 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_length = 0;\n    let\
    \ mut longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n  \
    \  let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value =\
    \ \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_value\
    \ = \"\";\n    let mut longest_postfix_value = \"\";\n    let mut longest_postfix_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaxz7kog6.rs:63:29\n   |\n\
    63 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpaxz7kog6.rs:11:39\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = string;\n    let mut prefix = string;\n    while !reverse.starts_with(&prefix)\
    \ {\n        reverse = reverse.chars().collect::<String>().rev().collect();\n\
    \        prefix = prefix.chars().collect::<String>().rev().collect();\n    }\n\
    \    reverse.chars().collect::<String>().rev().collect::<String>()\n        +\
    \ &prefix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpec57depu.rs:15:55\n\
    \    |\n15  |           reverse = reverse.chars().collect::<String>().rev().collect();\n\
    \    |                                                         ^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0599]: `String`\
    \ is not an iterator\n   --> /tmp/tmpec57depu.rs:16:53\n    |\n16  |         \
    \  prefix = prefix.chars().collect::<String>().rev().collect();\n    |       \
    \                                                ^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: Iterator`\n            which\
    \ is required by `&mut String: Iterator`\n            `str: Iterator`\n      \
    \      which is required by `&mut str: Iterator`\n\nerror[E0599]: `String` is\
    \ not an iterator\n   --> /tmp/tmpec57depu.rs:18:41\n    |\n18  |       reverse.chars().collect::<String>().rev().collect::<String>()\n\
    \    |                                           ^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: Iterator`\n            which\
    \ is required by `&mut String: Iterator`\n            `str: Iterator`\n      \
    \      which is required by `&mut str: Iterator`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    while\
    \ !reversed_string.is_empty() {\n        let mut suffix_length = 0;\n        while\
    \ !reversed_string.is_empty() && reversed_string[suffix_length] == reversed_string[suffix_length\
    \ + prefix_length] {\n            suffix_length += 1;\n        }\n        if suffix_length\
    \ < prefix_length {\n            break;\n        }\n        reversed_string =\
    \ reversed_string[..suffix_length];\n        prefix_length = suffix_length;\n\
    \    }\n    string + &reversed_string[..prefix_length]\n}\n\nfn main() {\n   \
    \ let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpp3wzx3uf.rs:16:46\n   |\n16 |         while !reversed_string.is_empty()\
    \ && reversed_string[suffix_length] == reversed_string[suffix_length + prefix_length]\
    \ {\n   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpp3wzx3uf.rs:16:80\n   |\n16 |         while !reversed_string.is_empty()\
    \ && reversed_string[suffix_length] == reversed_string[suffix_length + prefix_length]\
    \ {\n   |                                                                    \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp3wzx3uf.rs:22:27\n\
    \   |\n12 |     let mut reversed_string = string;\n   |                      \
    \         ------ expected due to this value\n...\n22 |         reversed_string\
    \ = reversed_string[..suffix_length];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try "
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = String::from(\"\");\n    let mut prefix = String::from(\"\
    \");\n    let mut suffix = String::from(\"\");\n    let mut longest = String::from(\"\
    \");\n    let mut longestlen = 0;\n    for c in string.chars() {\n        if longestlen\
    \ > longest.len() {\n            longest = String::from(\"\");\n            longestlen\
    \ = 0;\n        }\n        if longestlen == longest.len() {\n            longest\
    \ = longest + &c.to_string();\n            longestlen += 1;\n        }\n     \
    \   if longestlen == reverse.len() {\n            reverse = reverse + &c.to_string();\n\
    \        }\n        if longestlen == prefix.len() {\n            prefix = prefix\
    \ + &c.to_string();\n        }\n        if longestlen == suffix.len() {\n    \
    \        suffix = &c.to_string();\n        }\n    }\n    longest.push_str(&reverse);\n\
    \    prefix.push_str(&reverse);\n    suffix.push_str(&reverse);\n    longest +\
    \ prefix + suffix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n  \
    \  assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5ynnn_x4.rs:33:22\n   |\n\
    14 |     let mut suffix = String::from(\"\");\n   |                      ----------------\
    \ expected due to this value\n...\n33 |             suffix = &c.to_string();\n\
    \   |                      ^^^^^^^^^^^^^^ expected struct `String`, found `&String`\n\
    \   |\nhelp: consider removing the borrow\n   |\n33 -             suffix = &c.to_string();\n\
    33 +             suffix = c.to_string();\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5ynnn_x4.rs:39:15\n   |\n39 |     longest + prefix + suffix\n \
    \  |               ^^^^^^\n   |               |\n   |               expected `&str`,\
    \ found struct `String`\n   |               help: consider borrowing here: `&prefix`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5ynnn_x4.rs:39:24\n   |\n39 |\
    \     longest + prefix + suffix\n   |                        ^^^^^^\n   |    \
    \                    |\n   |                        expected `&str`, found struct\
    \ `String`\n   |                        help: consider borrowing here: `&suffix`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_length = 0;\n    while\
    \ !reversed_string.is_empty() {\n        let mut reverse_length = reversed_string.len();\n\
    \        reversed_string = reversed_string.chars().collect::<String>().rev().collect();\n\
    \        if reverse_length == 0 {\n            break;\n        }\n    }\n    let\
    \ mut reversed_string = reversed_string.chars().collect::<String>().rev().collect();\n\
    \    reversed_string.push_str(&string);\n    reversed_string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpuasbeo06.rs:16:71\n\
    \    |\n16  |           reversed_string = reversed_string.chars().collect::<String>().rev().collect();\n\
    \    |                                                                       \
    \  ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   \
    \ |\n    = note: the following trait bounds were not satisfied:\n            `String:\
    \ Iterator`\n            which is required by `&mut String: Iterator`\n      \
    \      `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpuasbeo06.rs:21:75\n\
    \    |\n21  |       let mut reversed_string = reversed_string.chars().collect::<String>().rev().collect();\n\
    \    |                                                                       \
    \      ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `&mut String: Iterator`\n\
    \            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_len = string.len();\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_start = -1;\n    let mut longest_postfix_postfix_end\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = \"\";\n    let mut lon\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpu_ycj8wj.rs:53:16\n   |\n\
    53 |     let mut lon\n   |                ^ help: add `;` here\n54 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu_ycj8wj.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_len = 0;\n\
    \    let mut longest_palindrome = string;\n    let mut longest_palindrome_len\
    \ = 0;\n    while !reversed_string.is_empty() {\n        let mut reversed_string_len\
    \ = 0;\n        let mut longest_palindrome_len = 0;\n        for c in reversed_string.chars()\
    \ {\n            if !c.is_alphanumeric() {\n                break;\n         \
    \   }\n            reversed_string_len += 1;\n            if reversed_string_len\
    \ > longest_palindrome_len {\n                longest_palindrome_len = reversed_string_len;\n\
    \                longest_palindrome = &reversed_string[..reversed_string_len];\n\
    \            }\n        }\n        reversed_string = &reversed_string[reversed_string_len..];\n\
    \    }\n    longest_palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_cacpwrf.rs:26:38\n   |\n\
    14 |     let mut longest_palindrome = string;\n   |                          \
    \        ------ expected due to this value\n...\n26 |                 longest_palindrome\
    \ = &reversed_string[..reversed_string_len];\n   |                           \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n26 |        \
    \         longest_palindrome = (&reversed_string[..reversed_string_len]).to_string();\n\
    \   |                                      +                                 \
    \      +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_cacpwrf.rs:29:27\n\
    \   |\n12 |     let mut reversed_string = string;\n   |                      \
    \         ------ expected due to this value\n...\n29 |         reversed_string\
    \ = &reversed_string[reversed_string_len..];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n29 |         reversed_string = (&reversed_string[reversed_string_len..]).to_string();\n\
    \   |                           +                                       +++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    while\
    \ longest_postfix_length < string.len() {\n        let mut postfix_length = longest_postfix_length;\n\
    \        let mut postfix_index = 0;\n        while postfix_length < string.len()\
    \ {\n            let mut postfix = &string[postfix_index..];\n            let\
    \ mut postfix_reversed = &reversed_string[..];\n            while postfix.len()\
    \ > 0 {\n                let mut postfix_char = postfix.remove(0);\n         \
    \       let mut postfix_reversed_char = postfix_reversed.remove(0);\n        \
    \        while postfix_char != postfix_reversed_char {\n                    postfix_reversed_char\
    \ = postfix_reversed.remove(0);\n                }\n                postfix_reversed.insert(0,\
    \ postfix_char);\n                postfix_length += 1;\n                postfix_index\
    \ += 1;\n            }\n            postfix_length = longest_postfix_length;\n\
    \            postfix_index = 0;\n        }\n        longest_postfix_length = postfix_length;\n\
    \        longest_postfix_index += 1;\n    }\n    string + &reversed_string[..longest_postfix_index]\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `remove` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpx64_fhyq.rs:23:48\n   |\n23 |                 let\
    \ mut postfix_char = postfix.remove(0);\n   |                                \
    \                ^^^^^^ method not found in `&str`\n\nerror[E0599]: no method\
    \ named `remove` found for reference `&str` in the current scope\n  --> /tmp/tmpx64_fhyq.rs:24:66\n\
    \   |\n24 |                 let mut postfix_reversed_char = postfix_reversed.remove(0);\n\
    \   |                                                                  ^^^^^^\
    \ method not found in `&str`\n\nerror[E0599]: no method named `remove` found for\
    \ reference `&str` in the current scope\n  --> /tmp/tmpx64_fhyq.rs:26:62\n   |\n\
    26 |                     postfix_reversed_char = postfix_reversed.remove(0);\n\
    \   |                                                              ^^^^^^ method\
    \ not found in `&str`\n\nerror[E0599]: no method named `insert` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpx64_fhyq.rs:28:34\n   |\n28 |   \
    \              postfix_reversed.insert(0, postfix_char);\n   |               \
    \                   ^^^^^^ method not found in `&str`\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo69wv1oh.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo69wv1oh.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut i =\
    \ 0;\n    while i < string.len() {\n        let mut j = i;\n        while j +\
    \ 1 < string.len() {\n            if string[j] != string[j + 1] {\n          \
    \      break;\n            }\n            i += 1;\n            j += 1;\n     \
    \   }\n        if j == i {\n            break;\n        }\n        reverse.push_str(&string[i..j]);\n\
    \        i += 1;\n    }\n    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpshx0hagn.rs:18:16\n\
    \   |\n18 |             if string[j] != string[j + 1] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpshx0hagn.rs:18:29\n   |\n18 |             if string[j] != string[j\
    \ + 1] {\n   |                             ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length =\
    \ 0;\n    while longest_postfix_index != longest_postfix_length {\n        let\
    \ mut longest_postfix_length = longest_postfix.len();\n        for (i, c) in longest_postfix.chars().enumerate()\
    \ {\n            if longest_postfix_length == i {\n                longest_postfix_length\
    \ = longest_postfix.len() + 1;\n            }\n            if longest_postfix.chars().nth(i).unwrap()\
    \ != c {\n                break;\n            }\n        }\n        longest_postfix_index\
    \ += longest_postfix_length;\n        let mut longest_postfix_postfix = longest_postfix.clone();\n\
    \        for (i, c) in reversed_string.chars().enumerate() {\n            if longest_postfix_postfix.chars().nth(i).unwrap()\
    \ != c {\n                break;\n            }\n        }\n        reversed_string\
    \ = reversed_string\n            .chars()\n            .skip(longest_postfix_index)\n\
    \            .take(longest_postfix_postfix.len())\n            .join(\"\");\n\
    \        longest_postfix = longest_postfix_postfix\n            .chars()\n   \
    \         .skip(longest_postfix_index)\n            .take(longest_postfix_length)\n\
    \            .join(\"\");\n    }\n    reversed_string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `join` found for struct `std::iter::Take`\
    \ in the current scope\n  --> /tmp/tmpktmzdw5x.rs:37:14\n   |\n37 |          \
    \   .join(\"\");\n   |              ^^^^ method not found in `std::iter::Take<Skip<Chars<'_>>>`\n\
    \nerror[E0599]: no method named `join` found for struct `std::iter::Take` in the\
    \ current scope\n  --> /tmp/tmpktmzdw5x.rs:42:14\n   |\n42 |             .join(\"\
    \");\n   |              ^^^^ method not found in `std::iter::Take<Skip<Chars<'_>>>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut max_len = string.len();\n    let mut i = 0;\n    while i < max_len {\n \
    \       let mut j = i;\n        while j + 1 < max_len && string[j] == string[j\
    \ + 1] {\n            j += 1\n        }\n        if j + 1 == max_len {\n     \
    \       break;\n        }\n        reversed_string.push((string[j]).to_string());\n\
    \        max_len = j - i;\n        i += 1;\n    }\n    string.push((reversed_string).to_string());\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp06d89nbb.rs:18:34\n\
    \   |\n18 |         while j + 1 < max_len && string[j] == string[j + 1] {\n  \
    \ |                                  ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp06d89nbb.rs:18:47\n   |\n18 |         while j + 1 < max_len &&\
    \ string[j] == string[j + 1] {\n   |                                         \
    \      ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp06d89nbb.rs:24:30\n   |\n24 |         reversed_string.push((string[j]).to_string());\n\
    \   |                              ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n     "
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    while !reversed_string.is_empty() {\n        let\
    \ mut current_char = reversed_string[0];\n        reversed_string = reversed_string.chars().skip(1).collect();\n\
    \        if current_char == current_char.to_string().chars().last().unwrap() {\n\
    \            suffix_length += 1;\n        } else {\n            prefix_length\
    \ += 1;\n        }\n    }\n    let mut palindrome = string;\n    palindrome.push_str(&string[prefix_length..suffix_length]);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp5sd5sl9r.rs:16:32\n   |\n16 |         let mut current_char = reversed_string[0];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut postfix = string;\n    let\
    \ mut prefix_length = string.len();\n    while prefix_length > 0 {\n        let\
    \ mut index = prefix_length;\n        while index > 0 {\n            let mut char\
    \ = &string[index - 1];\n            reversed_string.push(char);\n           \
    \ index -= 1;\n        }\n        postfix.reverse();\n        if string.cmp(&reversed_string)\
    \ == cmp::Ordering::Less {\n            break;\n        }\n        prefix_length\
    \ -= 1;\n    }\n    string + &reversed_string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpe00dzg9z.rs:23:44\n   |\n23 |         if string.cmp(&reversed_string)\
    \ == cmp::Ordering::Less {\n   |                                            ^^^\
    \ use of undeclared crate or module `cmp`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpe00dzg9z.rs:18:29\n   |\n18 |         \
    \    let mut char = &string[index - 1];\n   |                             ^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe00dzg9z.rs:19:34\n\
    \   |\n19 |             reversed_string.push(char);\n   |                    \
    \              ^^^^ expected `char`, found reference\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\nhelp: consider dereferencing the\
    \ borrow\n   |\n19 |             reversed_string.push(*char);\n   |          \
    \                        +\n\nerror[E0599]: no method named `reverse` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpe00dzg9z.rs:22:17\n   |\n\
    22 |         postfix.reverse();\n   |                 ^^^^^^^ help: there is an\
    \ associated function with a similar name: `reserve`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0433,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_length = 0;\n    while\
    \ !reversed_string.is_empty() {\n        let mut reverse_length = reversed_string.len();\n\
    \        reversed_string = reversed_string[..reverse_length].iter().rev().collect();\n\
    \    }\n    string + &reversed_string[..reverse_length]\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n  --> /tmp/tmpdmehx5_5.rs:16:61\n   |\n16 |         reversed_string =\
    \ reversed_string[..reverse_length].iter().rev().collect();\n   |            \
    \                                                 ^^^^ method not found in `str`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2c_ckosp.rs:63:32\n   |\n\
    63 |     let mut longest_postfix_end\n   |                                ^ help:\
    \ add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2c_ckosp.rs:11:39\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut i =\
    \ 0;\n    while i < string.len() {\n        let mut j = i;\n        while j <\
    \ string.len() {\n            if string[j] != string[i] {\n                break;\n\
    \            }\n            i += 1;\n            j += 1;\n        }\n        if\
    \ j == i {\n            break;\n        }\n        reverse = reverse.push_str(&string[j..i]);\n\
    \        i += 1;\n    }\n    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9gpf9zvg.rs:18:16\n\
    \   |\n18 |             if string[j] != string[i] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9gpf9zvg.rs:18:29\n   |\n18 |             if string[j] != string[i]\
    \ {\n   |                             ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gpf9zvg.rs:27:19\n\
    \   |\n13 |     let mut reverse = string;\n   |                       ------ expected\
    \ due to this value\n...\n27 |         reverse = reverse.push_str(&string[j..i]);\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n \
    \ --> /tmp/tmp9gpf9zvg.rs:27:27\n   |\n27 |         reverse = reverse.push_str(&string[j..i]);\n\
    \   |                   ------- ^^^^^^^^ this call modifies `reverse` in-place\n\
    \   |                   |\n   |                   you probably want to use this\
    \ value after calling the method...\n   ="
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_string = \"\";\n    while !string.is_empty() {\n       \
    \ let mut current_postfix_length = string.len();\n        while current_postfix_length\
    \ >= longest_postfix_length {\n            let mut current_postfix_index = 0;\n\
    \            while current_postfix_index < longest_postfix_index {\n         \
    \       let mut current_postfix_char = string[current_postfix_index];\n      \
    \          while current_postfix_char == string[current_postfix_index] {\n   \
    \                 current_postfix_index += 1;\n                }\n           \
    \     if current_postfix_index == longest_postfix_index {\n                  \
    \  longest_postfix_index += 1;\n                    longest_postfix_string +=\
    \ current_postfix_char;\n                }\n                current_postfix_char\
    \ = string[current_postfix_index];\n            }\n            longest_postfix_length\
    \ += 1;\n        }\n        let mut current_postfix_length = string.len();\n \
    \       while current_postfix_length >= longest_postfix_length {\n           \
    \ let mut current_postfix_index = 0;\n            while current_postfix_index\
    \ < longest_postfix_index {\n                let mut current_postfix_char = string[current_postfix_index];\n\
    \                while current_postfix_char == string[current_postfix_index] {\n\
    \                    current_postfix_index += 1;\n                }\n        \
    \        if current_postfix_index == longest_postfix_index {\n               \
    \     longest_postfix_index += 1;\n                    longest_postfix_string\
    \ += current_postfix_char;\n                }\n                current_postfix_char\
    \ = string[current_postfix_index];\n            }\n            longest_postfix_length\
    \ += 1;\n        }\n        string += string[longest_postfix_index..];\n     \
    \   reversed_string += string[longest_postfix_index..];\n    }\n    longest_postfix_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpbt2jhfxr.rs:22:48\n   |\n22 |                 let mut current_postfix_char\
    \ = string[current_postfix_index];\n   |                                     \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpbt2jhfxr.rs:23:47\n   |\n23 |                 while current_postfix_char\
    \ == string[current_postfix_index] {\n   |                                   \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmpbt2jhfxr.rs:28:21\n   |\n28 |                \
    \     longest_postfix_string += current_postfix_char;\n   |                  \
    \   ----------------------^^^^^^^^^^^^^^^^^^^^^^^^\n   |                     |\n\
    \   |                     cannot use `+=` on type `&str`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpbt2jhfxr.rs:30:40\n\
    \   |\n30 |                 curr"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_length = 0;\n    let mut\
    \ longest_postfix_index = 0;\n    let mut longest_postfix_index2 = 0;\n    let\
    \ mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4 = 0;\n \
    \   let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6 =\
    \ 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplyr_2x58.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = string;\n    let mut reversed_palindrome = string;\n\n    while !string.is_empty()\
    \ {\n        let mut i = string.len();\n        while i >= 0 {\n            if\
    \ string[i] == string[string.len() - i - 1] {\n                i -= 1;\n     \
    \       } else {\n                break;\n            }\n        }\n        string\
    \ = &string[..i];\n        palindrome = &palindrome[..i];\n        reversed_string\
    \ = &reversed_string[..i];\n        reversed_palindrome = &reversed_palindrome[..i];\n\
    \    }\n\n    string + &reversed_palindrome\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm4wnvbdt.rs:20:16\n\
    \   |\n20 |             if string[i] == string[string.len() - i - 1] {\n   | \
    \               ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpm4wnvbdt.rs:20:29\n   |\n20 |             if string[i] == string[string.len()\
    \ - i - 1] {\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm4wnvbdt.rs:26:18\n\
    \   |\n12 |     let mut string = string;\n   |                      ------ expected\
    \ due to this value\n...\n26 |         string = &string[..i];\n   |          \
    \        ^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try\
    \ using a conversion method\n   |\n26 |         string = (&string[..i]).to_string();\n\
    \   |                  +            +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm4wnvbdt.rs:27:22\n   |\n13 |     let mut palindrome =\
    \ string;\n   |                          ------ expected due to this value\n...\n\
    27 |      "
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_string = \"\";\n    while !string.is_empty() {\n       \
    \ let mut index = string.len();\n        while index > 0 {\n            let mut\
    \ char = string[longest_postfix_index];\n            longest_postfix_index -=\
    \ 1;\n            longest_postfix_string += char;\n            string.truncate(longest_postfix_index);\n\
    \            index -= 1;\n        }\n        let mut index = string.len();\n \
    \       while index > 0 {\n            let mut char = string[longest_postfix_index];\n\
    \            longest_postfix_index -= 1;\n            longest_postfix_string +=\
    \ char;\n            string.truncate(longest_postfix_index);\n            index\
    \ -= 1;\n        }\n        let mut index = string.len();\n        while index\
    \ > 0 {\n            let mut char = string[longest_postfix_index];\n         \
    \   longest_postfix_index -= 1;\n            longest_postfix_string += char;\n\
    \            string.truncate(longest_postfix_index);\n            index -= 1;\n\
    \        }\n        let mut index = string.len();\n        while index > 0 {\n\
    \            let mut char = string[longest_postfix_index];\n            longest_postfix_index\
    \ -= 1;\n            longest_postfix_string += char;\n            string.truncate(longest_postfix_index);\n\
    \            index -= 1;\n        }\n        let mut index = string.len();\n \
    \       while index > 0 {\n            let mut char = string[longest_postfix_index];\n\
    \            longest_postfix_index -= 1;\n            longest_postfix_string +=\
    \ char;\n            string.truncate(longest_postfix_index);\n            index\
    \ -= 1;\n        }\n        let mut index = string.len();\n        while index\
    \ > 0 {\n            let mut char = string[longest_postfix_index];\n         \
    \   longest_postfix_index -= 1;\n            longest_postfix_string += char;\n\
    \            string.truncate(longest_postfix_index);\n            index -= 1;\n\
    \        }\n        let mut index = string.len();\n        while index > 0 {\n\
    \            let mut char = string[longest_postfix_index];\n            longest_postfix_index\
    \ -= 1;\n            longest_postfix_string += char;\n            string.truncate(longest_postfix_index);\n\
    \            index -= 1;\n        }\n        let mut index = string.len();\n \
    \       while index > 0 {\n            let mut char = string[longest_postfix_index];\n\
    \            longest_postfix_index -= 1;\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpn61ucsfs.rs:87:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n17 |     while !string.is_empty()\
    \ {\n   |                              - unclosed delimiter\n...\n75 |       \
    \  while index > 0 {\n   |                         - this delimiter might not\
    \ be properly closed...\n...\n78 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n87 | }\n   |   ^\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmpn61ucsfs.rs:20:28\n   |\n20\
    \ |             let mut char = string[longest_postfix_index];\n   |          \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmpn61ucsfs.rs:22:13\n   |\n22 |             longest_postfix_string\
    \ += char;\n   |             ----------------------^^^^^^^^\n   |            \
    \ |\n   |             cannot use `+=` on type `&str`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpn61ucsfs.rs:28:28\n   |\n\
    28 |             let mut char = string[longest_postfix_index];\n   |         \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <Str"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n\n    while\
    \ !string.is_empty() {\n        let mut index = string.len() - 1;\n        let\
    \ mut char = string[index];\n\n        while index >= 0 {\n            if char\
    \ != string[index] {\n                break;\n            }\n            index\
    \ -= 1;\n        }\n\n        reversed_string.insert(0, char);\n        string\
    \ = &string[index..];\n    }\n\n    string + reversed_string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5hh9qety.rs:17:24\n\
    \   |\n17 |         let mut char = string[index];\n   |                      \
    \  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5hh9qety.rs:20:24\n   |\n20 |             if char != string[index]\
    \ {\n   |                        ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `insert` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmp5hh9qety.rs:26:25\n   |\n26 |         reversed_string.insert(0,\
    \ char);\n   |                         ^^^^^^ method not found in `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5hh9qety.rs:27:18\n   |\n12 |     let mut string\
    \ = string;\n   |                      ------ expected due to this value\n...\n\
    27 |         string = &string[index..];\n   |                  ^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n27 |         string = (&string[index..]).to_string();\n   |           \
    \       +              "
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    while\
    \ longest_postfix_length < string.len() {\n        let mut longest_postfix_length\
    \ = longest_postfix_length;\n        let mut longest_postfix_index = 0;\n    \
    \    for index in 0..string.len() - 1 {\n            if string[index] != string[string.len()\
    \ - index - 1] {\n                longest_postfix_length = index;\n          \
    \      longest_postfix_index = index;\n            }\n        }\n        reversed_string\
    \ += &string[longest_postfix_index..];\n        string = &string[longest_postfix_length..];\n\
    \    }\n    reversed_string += &string[longest_postfix_index..];\n    string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_cpwr_hs.rs:20:16\n\
    \   |\n20 |             if string[index] != string[string.len() - index - 1] {\n\
    \   |                ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_cpwr_hs.rs:20:33\n\
    \   |\n20 |             if string[index] != string[string.len() - index - 1] {\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmp_cpwr_hs.rs:25:9\n   |\n25 |         reversed_string\
    \ += &string[longest_postfix_index..];\n   |         ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_cpwr_hs.rs:26:18\n   |\n12 |     let mut string\
    \ = string;\n   |                      ------ expected due to this value\n...\n\
    26 |         string = &string[longest_postfix_length..];\n   |               \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut palindrome\
    \ = string;\n    let mut prefix_len = 0;\n    let mut suffix_len = 0;\n\n    while\
    \ !string.is_empty() {\n        let mut i = string.len() - 1;\n        let mut\
    \ j = string.len() - 1;\n\n        while i >= 0 && j >= 0 {\n            if string[i]\
    \ == string[j] {\n                i -= 1;\n                j -= 1;\n         \
    \   } else {\n                break;\n            }\n        }\n\n        if i\
    \ >= 0 {\n            prefix_len += 1;\n            palindrome = &string[prefix_len..i];\n\
    \        }\n\n        if j >= 0 {\n            suffix_len += 1;\n            palindrome\
    \ = &palindrome[..suffix_len] + &string[j..];\n        }\n\n        string = &string[..];\n\
    \    }\n\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps1aonyle.rs:23:16\n\
    \   |\n23 |             if string[i] == string[j] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmps1aonyle.rs:23:29\n   |\n23 |             if string[i] == string[j]\
    \ {\n   |                             ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps1aonyle.rs:33:26\n\
    \   |\n14 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n33 |             palindrome = &string[prefix_len..i];\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n33 |        \
    \     palindrome = (&string[prefix_len..i]).to_string();\n   |               \
    \           +                      +++++++++++++\n\nerror[E0369]: cannot add `&str`\
    \ to `&str`\n  --> /tmp/tmps1aonyle.rs:38:52\n   |\n38 |             palindrome\
    \ = &palindrome[..suffix_len] + &string[j..];\n   |      "
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_len = 0;\n   \
    \ let mut longest_postfix_start = String::new();\n    let mut longest_postfix_start_len\
    \ = 0;\n    let mut longest_postfix_end = String::new();\n    let mut longest_postfix_end_len\
    \ = 0;\n    let mut longest_postfix_start_end = String::new();\n    let mut longest_postfix_start_end_len\
    \ = 0;\n    let mut longest_postfix_start_end_start = String::new();\n    let\
    \ mut longest_postfix_start_end_start_len = 0;\n    let mut longest_postfix_start_end_start_start\
    \ = String::new();\n    let mut longest_postfix_start_end_start_start_len = 0;\n\
    \    let mut longest_postfix_start_end_start_start_start = String::new();\n  \
    \  let mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut longest_postfix_start_end_start_start_start\
    \ = String::new();\n    let mut longest_postfix_start_end_start_start_start_len\
    \ = 0;\n    let mut longest_postfix_start_end_start_start_start_start = String::new();\n\
    \    let mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut\
    \ longest_postfix_start_end_start_start_start_start = String::new();\n    let\
    \ mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut longest_postfix_start_end_start_start_start_start\
    \ = String::new();\n    let mut longest_postfix_start_end_start_start_start_len\
    \ = 0;\n    let mut longest_postfix_start_end_start_start_start_start = String::new();\n\
    \    let mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut\
    \ longest_postfix_start_end_start_start_start_start = String::new();\n    let\
    \ mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut longest_postfix_start_end_start_start_start_start\
    \ = String::new();\n    let mut longest_postfix_start_end_start_start_start_len\
    \ = 0;\n    let mut longest_postfix_start_end_start_start_start_start = String::new();\n\
    \    let mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut\
    \ longest_postfix_start_end_start_start_start_start = String::new();\n    let\
    \ mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut longest_postfix_start_end_start_start_start_start\
    \ = String::\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp2a2r7_st.rs:47:1\n\
    \   |\n47 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_length_index = 0;\n\
    \    let mut longest_postfix_length_palindrome = 0;\n    let mut longest_postfix_length_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_index = 0;\n    let mut longest_postfix_length_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix = 0;\n    let mut longest_postfix_length_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_palindrome = 0;\n   \
    \ let mut longest_postfix_length_suffix_suffix_suffix = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_palindrome = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix_suffix_suffix = 0;\n    let\
    \ mut longest_postfix_length_suffix_suffix_suffix_suffix_index = 0;\n    let mut\
    \ longest_postfix_length_suffix_suffix_suffix_suffix_palindrome = 0;\n    let\
    \ mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix = 0;\n    let\
    \ mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_index = 0;\n \
    \   let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph2tepb5a.rs:40:29\n   |\n\
    40 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n41 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmph2tepb5a.rs:11:39\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfh1sihsn.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut reversed_string = \"\";\n    let\
    \ mut longest_postfix = palindrome.chars().take_while(|c| !c.is_alphanumeric()).count();\n\
    \    while longest_postfix > 0 {\n        let mut prefix_length = longest_postfix\
    \ % 2;\n        let mut prefix = palindrome.chars().take(prefix_length).collect::<String>();\n\
    \        reversed_string += prefix.reverse();\n        palindrome = palindrome.chars().skip(prefix_length).collect();\n\
    \        longest_postfix /= 2;\n    }\n    palindrome += reversed_string;\n  \
    \  palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp4kr4ypxe.rs:18:35\n   |\n18 |         reversed_string\
    \ += prefix.reverse();\n   |                                   ^^^^^^^ help: there\
    \ is an associated function with a similar name: `reserve`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut i =\
    \ 0;\n    while i < string.len() {\n        let mut j = i;\n        while j +\
    \ 1 < string.len() && string[j] == string[j + 1] {\n            j += 1\n     \
    \   }\n        reverse.push_str(&string[i..j]);\n        i = j;\n    }\n    reverse\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9_t7vix0.rs:17:39\n\
    \   |\n17 |         while j + 1 < string.len() && string[j] == string[j + 1] {\n\
    \   |                                       ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9_t7vix0.rs:17:52\n   |\n17 |         while j + 1 < string.len()\
    \ && string[j] == string[j + 1] {\n   |                                      \
    \              ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_len = 0;\n\n    while !string.is_empty()\
    \ {\n        let mut postfix = string;\n        let mut postfix_len = 0;\n\n \
    \       while !postfix.is_empty() {\n            if postfix.chars().next().unwrap()\
    \ == postfix.chars().next().unwrap() {\n                postfix_len += 1;\n  \
    \          } else {\n                break;\n            }\n            postfix\
    \ = postfix.chars().next().unwrap();\n        }\n\n        if postfix_len > longest_postfix_len\
    \ {\n            longest_postfix = postfix.to_string();\n            longest_postfix_len\
    \ = postfix_len;\n        }\n\n        string = string.chars().next().unwrap();\n\
    \    }\n\n    longest_postfix.push_str(&reversed_string);\n    longest_postfix\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9fp9i73x.rs:27:23\n   |\n\
    18 |         let mut postfix = string;\n   |                           ------\
    \ expected due to this value\n...\n27 |             postfix = postfix.chars().next().unwrap();\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                       |\n   |      \
    \                 expected struct `String`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9fp9i73x.rs:31:31\n   |\n14 |     let mut longest_postfix\
    \ = \"\";\n   |                               -- expected due to this value\n\
    ...\n31 |             longest_postfix = postfix.to_string();\n   |           \
    \                    ^^^^^^^^^^^^^^^^^^^\n   |                               |\n\
    \   |                               expected `&str`, found struct `String`\n \
    \  |                               help: consider borrowing here: `&postfix.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9fp9i73x.rs:35:18\n   |\n12 |\
    \     let mut string = string;\n   |                      ------ expected due\
    \ to this value\n...\n35 |         string = string.chars().next().unwrap();\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                  |\n   |                  expected\
    \ struct `String`, found `char`\n\nerror[E0599]: no method named `push_str` found\
    \ for reference `&str` in the current scope\n  --> /tmp/tmp9fp9i73x.rs:38:21\n\
    \   |\n38 |     longest_postfix.push_str(&reversed_string);\n   |            \
    \         ^^^^^^^^ method not found in `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9fp9i73x.rs:39:5\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |                                       ------ expected `String`\
    \ because of return type\n...\n39 |     longest_postfix\n   |     ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E030"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_len = String::new();\n\
    \    let mut longest_postfix_len_index = 0;\n    let mut longest_postfix_len_index2\
    \ = 0;\n    let mut longest_postfix_len_index3 = 0;\n    let mut longest_postfix_len_index4\
    \ = 0;\n    let mut longest_postfix_len_index5 = 0;\n    let mut longest_postfix_len_index6\
    \ = 0;\n    let mut longest_postfix_len_index7 = 0;\n    let mut longest_postfix_len_index8\
    \ = 0;\n    let mut longest_postfix_len_index9 = 0;\n    let mut longest_postfix_len_index10\
    \ = 0;\n    let mut longest_postfix_len_index11 = 0;\n    let mut longest_postfix_len_index12\
    \ = 0;\n    let mut longest_postfix_len_index13 = 0;\n    let mut longest_postfix_len_index14\
    \ = 0;\n    let mut longest_postfix_len_index15 = 0;\n    let mut longest_postfix_len_index16\
    \ = 0;\n    let mut longest_postfix_len_index17 = 0;\n    let mut longest_postfix_len_index18\
    \ = 0;\n    let mut longest_postfix_len_index19 = 0;\n    let mut longest_postfix_len_index20\
    \ = 0;\n    let mut longest_postfix_len_index21 = 0;\n    let mut longest_postfix_len_index22\
    \ = 0;\n    let mut longest_postfix_len_index23 = 0;\n    let mut longest_postfix_len_index24\
    \ = 0;\n    let mut longest_postfix_len_index25 = 0;\n    let mut longest_postfix_len_index26\
    \ = 0;\n    let mut longest_postfix_len_index27 = 0;\n    let mut longest_postfix_len_index28\
    \ = 0;\n    let mut longest_postfix_len_index29 = 0;\n    let mut longest_postfix_len_index30\
    \ = 0;\n    let mut longest_postfix_len_index31 = 0;\n    let mut longest_postfix_len_index32\
    \ = 0;\n    let mut longest_postfix_len_index33 = 0;\n    let mut longest_postfix_len_index34\
    \ = 0;\n    let mut longest_postfix_len_index35 = 0;\n    let mut longest_postfix_len_index36\
    \ = 0;\n    let mut longest_postfix_len_index37 = 0;\n    let mut longest_postfix_len_index38\
    \ = 0;\n    let mut longest_postfix_len_index39 = 0;\n    let mut longest_postfix_len_index\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp22w85a90.rs:55:38\n   |\n\
    55 |     let mut longest_postfix_len_index\n   |                             \
    \         ^ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp22w85a90.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut is_palindrome\
    \ = true;\n    while is_palindrome {\n        let mut i = 0;\n        let mut\
    \ j = string.len() - 1;\n        while i <= j {\n            if string[i] != string[j]\
    \ {\n                is_palindrome = false;\n                break;\n        \
    \    }\n            i += 1;\n            j -= 1;\n        }\n        if is_palindrome\
    \ {\n            reverse.push_str(&string[i..j]);\n            i += 1;\n     \
    \       j -= 1;\n        }\n    }\n    reverse\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpeq5zmb0t.rs:19:16\n\
    \   |\n19 |             if string[i] != string[j] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpeq5zmb0t.rs:19:29\n   |\n19 |             if string[i] != string[j]\
    \ {\n   |                             ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_length = 0;\n\
    \    let mut longest_postfix_index = 0;\n    while !string.is_empty() {\n    \
    \    let mut postfix = String::new();\n        let mut postfix_length = 0;\n \
    \       let mut postfix_index = 0;\n        while !string.is_empty() {\n     \
    \       let c = string.chars().next().unwrap();\n            postfix.push(c);\n\
    \            postfix_length += 1;\n            longest_postfix = if postfix_length\
    \ > longest_postfix_length {\n                postfix.clone()\n            } else\
    \ {\n                longest_postfix.clone()\n            };\n            longest_postfix_length\
    \ = postfix_length;\n            longest_postfix_index += 1;\n            string\
    \ = string.chars().skip_while(|c| !c.is_ascii_lowercase()).collect();\n      \
    \  }\n        reversed_string += longest_postfix;\n        longest_postfix = String::new();\n\
    \        longest_postfix_length = 0;\n        longest_postfix_index = 0;\n   \
    \ }\n    reversed_string += longest_postfix;\n    reversed_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n  --> /tmp/tmpiohfq1ht.rs:34:9\n   |\n34 |         reversed_string +=\
    \ longest_postfix;\n   |         ---------------^--^^^^^^^^^^^^^^^^\n   |    \
    \     |               |\n   |         |               `+` cannot be used to concatenate\
    \ a `&str` with a `String`\n   |         cannot use `+=` on type `&str`\n   |\n\
    \   = note: string concatenation requires an owned `String` on the left\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpiohfq1ht.rs:39:5\n\
    \   |\n39 |     reversed_string += longest_postfix;\n   |     ---------------^--^^^^^^^^^^^^^^^^\n\
    \   |     |               |\n   |     |               `+` cannot be used to concatenate\
    \ a `&str` with a `String`\n   |     cannot use `+=` on type `&str`\n   |\n  \
    \ = note: string concatenation requires an owned `String` on the left\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiohfq1ht.rs:40:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n40 |     reversed_string\n   |     ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_len = 0;\n   \
    \ let mut longest_postfix_start = String::new();\n    let mut longest_postfix_start_len\
    \ = 0;\n    let mut longest_postfix_end = String::new();\n    let mut longest_postfix_end_len\
    \ = 0;\n    let mut longest_postfix_start_end = String::new();\n    let mut longest_postfix_start_end_len\
    \ = 0;\n    let mut longest_postfix_start_end_start = String::new();\n    let\
    \ mut longest_postfix_start_end_start_len = 0;\n    let mut longest_postfix_start_end_start_start\
    \ = String::new();\n    let mut longest_postfix_start_end_start_start_len = 0;\n\
    \    let mut longest_postfix_start_end_start_start_start = String::new();\n  \
    \  let mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut longest_postfix_start_end_start_start_start\
    \ = String::new();\n    let mut longest_postfix_start_end_start_start_start_len\
    \ = 0;\n    let mut longest_postfix_start_end_start_start_start_start = String::new();\n\
    \    let mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut\
    \ longest_postfix_start_end_start_start_start_start = String::new();\n    let\
    \ mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut longest_postfix_start_end_start_start_start_start\
    \ = String::new();\n    let mut longest_postfix_start_end_start_start_start_len\
    \ = 0;\n    let mut longest_postfix_start_end_start_start_start_start = String::new();\n\
    \    let mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut\
    \ longest_postfix_start_end_start_start_start_start = String::new();\n    let\
    \ mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut longest_postfix_start_end_start_start_start_start\
    \ = String::new();\n    let mut longest_postfix_start_end_start_start_start_len\
    \ = 0;\n    let mut longest_postfix_start_end_start_start_start_start = String::new();\n\
    \    let mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut\
    \ longest_postfix_start_end_start_start_start_start = String::new();\n    let\
    \ mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut longest_postfix_start_end_start_start_start_start\
    \ = String::\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp2a2r7_st.rs:47:1\n\
    \   |\n47 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    while longest_postfix_length < string.len() {\n        let mut postfix_length\
    \ = longest_postfix_length;\n        let mut postfix_index = longest_postfix_index;\n\
    \        let mut postfix_length_index = longest_postfix_length_index;\n      \
    \  while postfix_length < string.len() {\n            let mut postfix_char = string[postfix_index];\n\
    \            let mut postfix_char_length = postfix_char.len();\n            while\
    \ postfix_char_length >= longest_postfix_length {\n                postfix_char_length\
    \ -= longest_postfix_length;\n                postfix_index += longest_postfix_length;\n\
    \                postfix_length += longest_postfix_length;\n            }\n  \
    \          if postfix_char_length == 0 {\n                postfix_length_index\
    \ += longest_postfix_length;\n                postfix_length += longest_postfix_length;\n\
    \                postfix_index += longest_postfix_length;\n            }\n   \
    \         postfix_char = string[postfix_index];\n            postfix_char_length\
    \ = postfix_char.len();\n        }\n        if postfix_length == 0 {\n       \
    \     longest_postfix_length_index += longest_postfix_length;\n            longest_postfix_length\
    \ += longest_postfix_length;\n            longest_postfix_index += longest_postfix_length;\n\
    \        }\n        reversed_string.push_str(&string[longest_postfix_index..]);\n\
    \    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpr48uqwrz.rs:21:36\n   |\n21 |             let mut postfix_char = string[postfix_index];\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpr48uqwrz.rs:33:28\n   |\n33 |             postfix_char = string[postfix_index];\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string_to_reverse = string;\n    let mut reverse_string = \"\";\n\
    \    let mut longest_postfix = \"\";\n    while string_to_reverse.len() > 0 {\n\
    \        let mut postfix = string_to_reverse.chars().collect::<Vec<_>>();\n  \
    \      longest_postfix.extend(postfix);\n        reverse_string.extend(longest_postfix.chars().collect::<Vec<_>>());\n\
    \        string_to_reverse = string_to_reverse.chars().collect::<String>();\n\
    \    }\n    longest_postfix.reverse();\n    reverse_string.extend(longest_postfix.chars().collect::<Vec<_>>());\n\
    \    reverse_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `extend` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmp0x0vxahs.rs:17:25\n   |\n17 |         longest_postfix.extend(postfix);\n\
    \   |                         ^^^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `extend` found for reference `&str` in the current scope\n \
    \ --> /tmp/tmp0x0vxahs.rs:18:24\n   |\n18 |         reverse_string.extend(longest_postfix.chars().collect::<Vec<_>>());\n\
    \   |                        ^^^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `reverse` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmp0x0vxahs.rs:21:21\n   |\n21 |     longest_postfix.reverse();\n\
    \   |                     ^^^^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `extend` found for reference `&str` in the current scope\n \
    \ --> /tmp/tmp0x0vxahs.rs:22:20\n   |\n22 |     reverse_string.extend(longest_postfix.chars().collect::<Vec<_>>());\n\
    \   |                    ^^^^^^ method not found in `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0x0vxahs.rs:23:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n23 |     reverse_string\n   |     ^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = String::from(\"\");\n    let mut longest_postfix = String::from(\"\
    \");\n    let mut longest_postfix_len = String::from(0);\n    let mut longest_postfix_start\
    \ = String::from(\"\");\n    let mut longest_postfix_end = String::from(\"\");\n\
    \    let mut longest_postfix_start_len = String::from(0);\n    let mut longest_postfix_end_len\
    \ = String::from(0);\n    let mut longest_postfix_start_pos = String::from(0);\n\
    \    let mut longest_postfix_end_pos = String::from(0);\n    let mut longest_postfix_start_pos\
    \ = String::from(0);\n    let mut longest_postfix_end_pos = String::from(0);\n\
    \    let mut longest_postfix_start_pos = String::from(0);\n    let mut longest_postfix_end_pos\
    \ = String::from(0);\n    let mut longest_postfix_start_pos = String::from(0);\n\
    \    let mut longest_postfix_end_pos = String::from(0);\n    let mut longest_postfix_start_pos\
    \ = String::from(0);\n    let mut longest_postfix_end_pos = String::from(0);\n\
    \    let mut longest_postfix_start_pos = String::from(0);\n    let mut longest_postfix_end_pos\
    \ = String::from(0);\n    let mut longest_postfix_start_pos = String::from(0);\n\
    \    let mut longest_postfix_end_pos = String::from(0);\n    let mut longest_postfix_start_pos\
    \ = String::from(0);\n    let mut longest_postfix_end_pos = String::from(0);\n\
    \    let mut longest_postfix_start_pos = String::from(0);\n    let mut longest_postfix_end_pos\
    \ = String::from(0);\n    let mut longest_postfix_start_pos = String::from(0);\n\
    \    let mut longest_postfix_end_pos = String::from(0);\n    let mut longest_postfix_start_pos\
    \ = String::from(0);\n    let mut longest_postfix_end_pos = String::from(0);\n\
    \    let mut longest_postfix_start_pos = String::from(0);\n    let mut longest_postfix_end_pos\
    \ = String::from(0);\n    let mut longest_postfix_start_pos = String::from(0);\n\
    \    let mut longest_postfix_end_pos = String::from(0);\n    let mut longest_postfix_start_pos\
    \ = String::from(0);\n    let mut longest_postfix_end_pos = String::from(0);\n\
    \    let mut longest_postfix_start_pos = String::from(0);\n    let mut longest_postfix_end_pos\
    \ = String::from(0);\n    let mu\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuabkyt4p.rs:49:11\n   |\n\
    49 |     let mu\n   |           ^ help: add `;` here\n50 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: the trait bound `String: From<{integer}>` is not satisfied\n\
    \  --> /tmp/tmpuabkyt4p.rs:14:35\n   |\n14 |     let mut longest_postfix_len =\
    \ String::from(0);\n   |                                   ^^^^^^^^^^^^ the trait\
    \ `From<{integer}>` is not implemented for `String`\n   |\n   = help: the following\
    \ other types implement trait `From<T>`:\n             <String as From<&String>>\n\
    \             <String as From<&mut str>>\n             <String as From<&str>>\n\
    \             <String as From<Box<str>>>\n             <String as From<Cow<'a,\
    \ str>>>\n             <String as From<char>>\n\nerror[E0277]: the trait bound\
    \ `String: From<{integer}>` is not satisfied\n  --> /tmp/tmpuabkyt4p.rs:17:41\n\
    \   |\n17 |     let mut longest_postfix_start_len = String::from(0);\n   |   \
    \                                      ^^^^^^^^^^^^ the trait `From<{integer}>`\
    \ is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <String as From<&String>>\n       \
    \      <String as From<&mut str>>\n             <String as From<&str>>\n     \
    \        <String as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n\
    \             <String as From<char>>\n\nerror[E0277]: the trait bound `String:\
    \ From<{integer}>` is not satisfied\n  --> /tmp/tmpuabkyt4p.rs:18:39\n   |\n18\
    \ |     let mut longest_postfix_end_len = String::from(0);\n   |             \
    \                          ^^^^^^^^^^^^ the trait `From<{integer}>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0277]: the trait bound `String: From<{integer}>` is not satisfied\n \
    \ --> /tmp/tmpuabkyt4p.rs:19:41\n   |\n19 |     let mut "
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_pos = 0;\n    let\
    \ mut longest_postfix_len = 0;\n    while reverse_pos < reversed_string.len()\
    \ {\n        let mut postfix_len = reversed_string.len() - reverse_pos;\n    \
    \    if postfix_len > longest_postfix_len {\n            longest_postfix_len =\
    \ postfix_len;\n        }\n        if postfix_len == longest_postfix_len {\n \
    \           let mut postfix = reversed_string.clone();\n            postfix.insert(reverse_pos,\
    \ &reversed_string[reverse_pos]);\n            if postfix.is_palindrome() {\n\
    \                reversed_string = postfix;\n                reverse_pos = 0;\n\
    \            }\n        }\n        reverse_pos += 1;\n    }\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpudksl7tm.rs:22:42\n\
    \   |\n22 |             postfix.insert(reverse_pos, &reversed_string[reverse_pos]);\n\
    \   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpudksl7tm.rs:22:41\n\
    \   |\n22 |             postfix.insert(reverse_pos, &reversed_string[reverse_pos]);\n\
    \   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found reference\n   |\n   = note:   expected type `char`\n         \
    \  found reference `&_`\nhelp: consider removing the borrow\n   |\n22 -      \
    \       postfix.insert(reverse_pos, &reversed_string[reverse_pos]);\n22 +    \
    \         postfix.insert(reverse_pos, reversed_string[reverse_pos]);\n   | \n\n\
    error[E0599]: no method named `is_palindrome` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpudksl7tm.rs:23:24\n   |\n23 |             if postfix.is_palindrome()\
    \ {\n   |                        ^^^^^^^^^^^^^ method not found in `String`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    while !reversed_string.is_empty() {\n        let\
    \ mut current_char = reversed_string[0];\n        reversed_string = reversed_string.chars().skip_while(|c|\
    \ !c.is_ascii_lowercase()).collect();\n        if current_char == current_char.to_ascii_lowercase()\
    \ {\n            suffix_length += 1;\n        } else {\n            prefix_length\
    \ += 1;\n        }\n    }\n    let mut palindrome = String::new();\n    palindrome.push_str(&string[prefix_length..suffix_length]);\n\
    \    palindrome.push_str(&string[..prefix_length]);\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmptrikqbqd.rs:16:32\n   |\n16 |         let mut current_char = reversed_string[0];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_len = string.len();\n    let mut longest_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_len = string.len();\n    let\
    \ mut longest_postfix_postfix_postfix = string;\n    let mut longest_postfix_postfix_postfix_len\
    \ = string.len();\n    let mut longest_postfix_postfix_postfix_postfix = string;\n\
    \    let mut longest_postfix_postfix_postfix_len = string.len();\n    let mut\
    \ longest_postfix_postfix_postfix_postfix = string;\n    let mut longest_postfix_postfix_postfix_postfix_len\
    \ = string.len();\n    let mut longest_postfix_postfix_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_len =\
    \ string.len();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_len =\
    \ string.len();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_len =\
    \ string.len();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_len\
    \ = string.len();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_len\
    \ = string.len();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_len\
    \ = string.len();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_len\
    \ = string.len();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_len\
    \ = string.len();\n    let mut lon\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6m1yxfpo.rs:39:16\n   |\n\
    39 |     let mut lon\n   |                ^ help: add `;` here\n40 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6m1yxfpo.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_len = 0;\n\
    \    let mut longest_postfix_len = 0;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_postfix =\
    \ \"\";\n    let mut longest_postfix_postfix_len = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_len = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_len = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_len = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_len = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_len = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_len = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_len = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_len = 0;\n    let mut longest_postfix_postfix_start\
    \ = -1;\n    let mut longest_postfix_postfix_end = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut \n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpfijrbc3h.rs:55:1\n\
    \   |\n55 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    while\
    \ let Some(index) = string.rfind('a') {\n        longest_postfix_length = index;\n\
    \        longest_postfix_index = index;\n    }\n    let mut longest_postfix_index\
    \ = longest_postfix_index - longest_postfix_length as usize;\n    while let Some(index)\
    \ = string.rfind('a', longest_postfix_index) {\n        reversed_string += &string[longest_postfix_index..index];\n\
    \        longest_postfix_index = index;\n    }\n    reversed_string += &string[longest_postfix_index..];\n\
    \    String::from(reversed_string)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp9am9a89b.rs:21:36\n     |\n21   |     while let Some(index) =\
    \ string.rfind('a', longest_postfix_index) {\n     |                         \
    \           ^^^^^ ---  --------------------- supplied 2 arguments\n     |    \
    \                                |\n     |                                   \
    \ expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp9am9a89b.rs:22:9\n\
    \   |\n22 |         reversed_string += &string[longest_postfix_index..index];\n\
    \   |         ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&str`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp9am9a89b.rs:25:5\n\
    \   |\n25 |     reversed_string += &string[longest_postfix_index..];\n   |   \
    \  ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |     |\n   |     cannot\
    \ use `+=` on type `&str`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = string;\n    let mut longest = 0;\n    let mut longestlen\
    \ = 0;\n    let mut longestpalindrome = string;\n    for pos in string.char_indices()\
    \ {\n        let mut palindrome = string;\n        let mut palindromelen = 0;\n\
    \        for c in palindrome.chars() {\n            if pos == 0 {\n          \
    \      palindromelen += 1;\n                if palindromelen > longest {\n   \
    \                 longest = palindromelen;\n                    longestlen = pos;\n\
    \                    longestpalindrome = palindrome;\n                }\n    \
    \        } else {\n                palindromelen += 1;\n                if palindromelen\
    \ > longest {\n                    longest = palindromelen;\n                \
    \    longestlen = pos;\n                    longestpalindrome = palindrome;\n\
    \                }\n            }\n            palindrome += c;\n        }\n \
    \   }\n    longestpalindrome += &reverse[longestlen..longestlen + longest];\n\
    \    longestpalindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp436xvyt7.rs:20:23\n   |\n\
    20 |             if pos == 0 {\n   |                       ^ expected tuple, found\
    \ integer\n   |\n   = note: expected tuple `(usize, char)`\n               found\
    \ type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp436xvyt7.rs:24:34\n\
    \   |\n14 |     let mut longestlen = 0;\n   |                          - expected\
    \ due to this value\n...\n24 |                     longestlen = pos;\n   |   \
    \                               ^^^ expected integer, found tuple\n   |\n   =\
    \ note: expected type `{integer}`\n             found tuple `(usize, char)`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp436xvyt7.rs:31:34\n   |\n14 |  \
    \   let mut longestlen = 0;\n   |                          - expected due to this\
    \ value\n...\n31 |                     longestlen = pos;\n   |               \
    \                   ^^^ expected integer, found tuple\n   |\n   = note: expected\
    \ type `{integer}`\n             found tuple `(usize, char)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp436xvyt7.rs:35:27\n   |\n35 |             palindrome\
    \ += c;\n   |                           ^ expected `&str`, found `char`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut longest\
    \ = string;\n    let mut longest_index = 0;\n    let mut longest_index2 = 0;\n\
    \    let mut longest_index3 = 0;\n    let mut longest_index4 = 0;\n    while !string.is_empty()\
    \ {\n        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n\
    \        let mut l = 0;\n        while i < string.len() {\n            let mut\
    \ j = i;\n            let mut k = i;\n            let mut l = i;\n           \
    \ while j < string.len() {\n                let mut k = j;\n                while\
    \ k < string.len() {\n                    let mut l = k;\n                   \
    \ while l < string.len() {\n                        if string[j] != string[k]\
    \ {\n                            break;\n                        }\n         \
    \               l += 1;\n                        k += 1;\n                   \
    \ }\n                    if l == k {\n                        break;\n       \
    \             }\n                    k += 1;\n                }\n            \
    \    if k == j {\n                    break;\n                }\n            \
    \    j += 1;\n            }\n            if j == i {\n                break;\n\
    \            }\n            i += 1;\n        }\n        if i == j {\n        \
    \    break;\n        }\n        let mut k = i;\n        while k < string.len()\
    \ {\n            let mut l = k;\n            while l < string.len() {\n      \
    \          if string[k] != string[l] {\n                    break;\n         \
    \       }\n                l += 1;\n                k += 1;\n            }\n \
    \           if l == k {\n                break;\n            }\n            k\
    \ += 1;\n        }\n        if k == i {\n            break;\n        }\n     \
    \   let mut l = i;\n        while l < string.len() {\n            let mut k =\
    \ l;\n            while k < string.len() {\n                if string[k] != string[l]\
    \ {\n                    break;\n                }\n                k += 1;\n\
    \                l += 1;\n            }\n            if k == l {\n           \
    \     break;\n            }\n            l += 1;\n        }\n        if l == i\
    \ {\n            break;\n        }\n        let mut k = i;\n        while k <\
    \ string.len() {\n            let mut l = k;\n            while l < string.len()\
    \ {\n                if string[k] != string[l] {\n                    break;\n\
    \                }\n                k += 1;\n                l += 1;\n       \
    \     }\n            if k == l {\n                break;\n            }\n    \
    \        k += 1;\n        }\n        if k == i {\n            break;\n       \
    \ }\n        let mut l = i;\n        while l < string.len() {\n            let\
    \ mut k = l;\n            while k < string.len() {\n                if string[k]\
    \ != string[l] {\n                    break;\n                }\n            \
    \    k += 1;\n                l += 1;\n            }\n            if k == l {\n\
    \                break;\n            }\n            l += \n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpg92paf2c.rs:134:3\n\
    \    |\n11  | fn make_palindrome(string: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n19  |     while\
    \ !string.is_empty() {\n    |                              - unclosed delimiter\n\
    ...\n112 |         while l < string.len() {\n    |                           \
    \     - this delimiter might not be properly closed...\n...\n125 | }\n    | -\
    \ ...as it matches this but it has different indentation\n...\n134 | }\n    |\
    \   ^\n\nerror: expected expression, found `}`\n   --> /tmp/tmpg92paf2c.rs:125:1\n\
    \    |\n125 | }\n    | ^ expected expression\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpg92paf2c.rs:33:28\n   |\n33 |  \
    \                       if string[j] != string[k] {\n   |                    \
    \        ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpg92paf2c.rs:33:41\n   |\n33 |                         if string[j]\
    \ != string[k] {\n   |                                         ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    while\
    \ !reversed_string.is_empty() {\n        let mut suffix_length = 0;\n        while\
    \ !reversed_string.is_empty() && reversed_string[suffix_length] == reversed_string[suffix_length\
    \ + 1] {\n            suffix_length += 1;\n        }\n        if suffix_length\
    \ == 0 {\n            break;\n        }\n        let mut prefix_length = suffix_length;\n\
    \        while !reversed_string.is_empty() && reversed_string[prefix_length] ==\
    \ reversed_string[prefix_length - 1] {\n            prefix_length -= 1;\n    \
    \    }\n        if prefix_length == 0 {\n            break;\n        }\n     \
    \   reversed_string = reversed_string[prefix_length..].to_string();\n    }\n \
    \   string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpfy_a_f_y.rs:16:46\n   |\n16 |         while !reversed_string.is_empty()\
    \ && reversed_string[suffix_length] == reversed_string[suffix_length + 1] {\n\
    \   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpfy_a_f_y.rs:16:80\n   |\n16 |         while !reversed_string.is_empty()\
    \ && reversed_string[suffix_length] == reversed_string[suffix_length + 1] {\n\
    \   |                                                                        \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpfy_a_f_y.rs:23:46\n   |\n23 |         while !reversed_string.is_empty()\
    \ && reversed_string[prefix_length] == reversed_string[prefix_length - 1] {\n\
    \   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = string;\n    let mut reversed_palindrome = string;\n    let mut i = 0;\n \
    \   while i < string.len() {\n        let mut j = i;\n        while j < string.len()\
    \ {\n            if string[j] != string[i] {\n                break;\n       \
    \     }\n            j = j + 1;\n        }\n        if j == i {\n            palindrome\
    \ = &string[i..j];\n            reversed_palindrome = &string[j..i];\n       \
    \     i = j;\n        } else {\n            palindrome = &string[i..j];\n    \
    \        reversed_palindrome = &string[j..i];\n            i = j;\n        }\n\
    \    }\n    string = &palindrome;\n    reversed_string = &reversed_palindrome;\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpebql51my.rs:20:16\n\
    \   |\n20 |             if string[j] != string[i] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpebql51my.rs:20:29\n   |\n20 |             if string[j] != string[i]\
    \ {\n   |                             ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpebql51my.rs:26:26\n\
    \   |\n13 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n26 |             palindrome = &string[i..j];\n\
    \   |                          ^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n26 |             palindrome\
    \ = (&string[i..j]).to_string();\n   |                          +            \
    \ +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpebql51my.rs:27:35\n\
    \   |\n15 |     let mut reversed_palindrome = string;\n   |                  \
    \                 ------ expected due to this value\n...\n27 | "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome = string;\n    let mut reversed_string\
    \ = \"\";\n\n    while !string.is_empty() {\n        let mut index = string.len()\
    \ - 1;\n        let mut char = string.chars().nth(index).unwrap();\n\n       \
    \ while index >= 0 {\n            let mut next_char = string.chars().nth(index).unwrap();\n\
    \            if char == next_char {\n                index -= 1;\n           \
    \     char = next_char;\n            } else {\n                break;\n      \
    \      }\n        }\n\n        reversed_string.push(*char);\n        palindrome.push(*char);\n\
    \        string = &string[..index];\n    }\n\n    palindrome.push_str(reversed_string);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmp4hdk32_v.rs:30:25\n   |\n30 |         reversed_string.push(*char);\n\
    \   |                         ^^^^ method not found in `&str`\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp4hdk32_v.rs:30:30\n   |\n\
    30 |         reversed_string.push(*char);\n   |                              ^^^^^\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp4hdk32_v.rs:31:25\n\
    \   |\n31 |         palindrome.push(*char);\n   |                         ^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4hdk32_v.rs:32:18\n   |\n12 |\
    \     let mut string = string;\n   |                      ------ expected due\
    \ to this value\n...\n32 |         string = &string[..index];\n   |          \
    \        ^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp:\
    \ try using a conversion method\n   |\n32 |         string = (&string[..index]).to_string();\n\
    \   |                  +                +++++++++++++\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo69wv1oh.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo69wv1oh.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut suffix_length = 0;\n    let\
    \ mut prefix_length = 0;\n    while suffix_length != 0 || prefix_length != 0 {\n\
    \        if suffix_length == 0 {\n            suffix_length = string.len();\n\
    \        }\n        if prefix_length == 0 {\n            prefix_length = string.len()\
    \ - suffix_length;\n        }\n        let suffix_start = suffix_length - 1;\n\
    \        let suffix_end = suffix_start + 1;\n        let prefix_start = prefix_length\
    \ - 1;\n        let prefix_end = prefix_start + 1;\n        let suffix_char =\
    \ string[suffix_end];\n        let prefix_char = string[prefix_end];\n       \
    \ if suffix_char == prefix_char {\n            suffix_length -= 1;\n         \
    \   prefix_length -= 1;\n        } else {\n            suffix_length -= 1;\n \
    \           prefix_length -= 1;\n            reversed_string.push((suffix_char,\
    \ prefix_char));\n        }\n    }\n    reversed_string\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptd8k0_g6.rs:26:27\n\
    \   |\n26 |         let suffix_char = string[suffix_end];\n   |              \
    \             ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptd8k0_g6.rs:27:27\n\
    \   |\n27 |         let prefix_char = string[prefix_end];\n   |              \
    \             ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptd8k0_g6.rs:34:34\n   |\n34 |             reversed_string.push((suffix_char,\
    \ prefix_char));\n   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found tuple\n   |\n   = note: expected type `char`\n      \
    \       found tuple `(_, _)`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    while\
    \ !reversed_string.is_empty() {\n        let mut suffix_length = 0;\n        while\
    \ !reversed_string.starts_with(string[prefix_length..]) {\n            suffix_length\
    \ += 1;\n        }\n        reversed_string = reversed_string[..suffix_length];\n\
    \        prefix_length += suffix_length;\n    }\n    reversed_string\n}\n\nfn\
    \ main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n    --> /tmp/tmpw4ks5n0w.rs:16:44\n     |\n16   |         while !reversed_string.starts_with(string[prefix_length..])\
    \ {\n     |                                ----------- ^^^^^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n     |                          \
    \      |\n     |                                required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Sized` is not implemented for\
    \ `str`\nnote: required by a bound in `core::str::<impl str>::starts_with`\n\n\
    error[E0277]: expected a `FnMut<(char,)>` closure, found `str`\n    --> /tmp/tmpw4ks5n0w.rs:16:44\n\
    \     |\n16   |         while !reversed_string.starts_with(string[prefix_length..])\
    \ {\n     |                                ----------- ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an implementor of trait `Pattern<'_>`\n     |                     \
    \           |\n     |                                required by a bound introduced\
    \ by this call\n     |\n     = note: the trait bound `str: Pattern<'_>` is not\
    \ satisfied\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `str`\nnote: required by a bound in `core::str::<impl str>::starts_with`\n\
    help: consider borrowing here\n     |\n16   |         while !reversed_string.starts_with(&string[prefix_length..])\
    \ {\n     |                                            +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpw4ks5n0w.rs:19:27\n   |\n12 |     let mut reversed_string\
    \ = string;\n   |                               ------ expected due to this value\n\
    ...\n19 |         reversed_string = reversed_string[..suffix_length];\n   |  \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                           |\n   |  \
    \                         expected struct `String`, found `str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    while\
    \ !reversed_string.is_empty() {\n        let mut suffix_length = 0;\n        while\
    \ !reversed_string.is_empty() && reversed_string[suffix_length] == reversed_string[suffix_length\
    \ + 1] {\n            suffix_length += 1;\n        }\n        reversed_string\
    \ = &reversed_string[..suffix_length];\n        prefix_length += suffix_length;\n\
    \    }\n    string + &reversed_string[..prefix_length]\n}\n\nfn main() {\n   \
    \ let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpzk4yc69x.rs:16:46\n   |\n16 |         while !reversed_string.is_empty()\
    \ && reversed_string[suffix_length] == reversed_string[suffix_length + 1] {\n\
    \   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpzk4yc69x.rs:16:80\n   |\n16 |         while !reversed_string.is_empty()\
    \ && reversed_string[suffix_length] == reversed_string[suffix_length + 1] {\n\
    \   |                                                                        \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzk4yc69x.rs:19:27\n\
    \   |\n12 |     let mut reversed_string = string;\n   |                      \
    \         ------ expected due to this value\n...\n19 |         reversed_string\
    \ = &reversed_string[..suffix_length];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nh"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut longest_postfix = string;\n    let mut longest_postfix_index = -1;\n   \
    \ let mut longest_postfix_length = -1;\n    let mut longest_postfix_postfix =\
    \ string;\n    let mut longest_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_length\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = string;\n    let mut longest_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_length = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_length\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = string;\n    let mut longest_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_length = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_length\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = string;\n    let mut longest_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_length = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_length\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = string;\n    let mut longest_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_length = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_length\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = string;\n    let mut longest_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_length = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_index = -1;\n    let mut longest_postfix_postfix_length\
    \ = -1;\n    let mut longest_postfix_postfix_postfix = string;\n    let mut longest_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_length = -1;\n    let mut longest_postfix_postfix_postfix\
    \ = string;\n\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg5p9c6rp.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut longest_postfix = string;\n    let mut longest_postfix_length = 0;\n   \
    \ let mut longest_postfix_index = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl3hqb9jf.rs:63:34\n   |\n\
    63 |     let mut longest_postfix_start\n   |                                 \
    \ ^ help: add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl3hqb9jf.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_palindrome = string;\n\
    \    let mut longest_palindrome_len = string.len();\n    let mut longest_palindrome_start\
    \ = -1;\n    let mut longest_palindrome_end = -1;\n    let mut longest_palindrome_start_pos\
    \ = 0;\n    let mut longest_palindrome_end_pos = 0;\n    let mut longest_palindrome_start_pos\
    \ = 0;\n    let mut longest_palindrome_end_pos = 0;\n    let mut longest_palindrome_start_pos\
    \ = 0;\n    let mut longest_palindrome_end_pos = 0;\n    let mut longest_palindrome_start_pos\
    \ = 0;\n    let mut longest_palindrome_end_pos = 0;\n    let mut longest_palindrome_start_pos\
    \ = 0;\n    let mut longest_palindrome_end_pos = 0;\n    let mut longest_palindrome_start_pos\
    \ = 0;\n    let mut longest_palindrome_end_pos = 0;\n    let mut longest_palindrome_start_pos\
    \ = 0;\n    let mut longest_palindrome_end_pos = 0;\n    let mut longest_palindrome_start_pos\
    \ = 0;\n    let mut longest_palindrome_end_pos = 0;\n    let mut longest_palindrome_start_pos\
    \ = 0;\n    let mut longest_palindrome_end_pos = 0;\n    let mut longest_palindrome_start_pos\
    \ = 0;\n    let mut longest_palindrome_end_pos = 0;\n    let mut longest_palindrome_start_pos\
    \ = 0;\n    let mut longest_palindrome_end_pos = 0;\n    let mut longest_palindrome_start_pos\
    \ = 0;\n    let mut longest_palindrome_end_pos = 0;\n    let mut longest_palindrome_start_pos\
    \ = 0;\n    let mut longest_palindrome_end_pos = 0;\n    let mut longest_palindrome_start_pos\
    \ = 0;\n    let mut longest_palindrome_end_pos = 0;\n    let mut longest_palindrome_start_pos\
    \ = 0;\n    let mut longest_palindrome_end_pos = 0;\n    let mut longest_palindrome_start_pos\
    \ = 0;\n    let mut longest_palindrome_end_pos = 0;\n    let mut longest_palindrome_start_pos\
    \ = 0;\n    let mut longest_palindrome_end_pos = 0;\n    let mut longest_palindrome_start_pos\
    \ = 0;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpox_fmiv0.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_length = 0;\n    let mut\
    \ longest_postfix_index = 0;\n    let mut longest_postfix_index2 = 0;\n    let\
    \ mut longest_postfix_index3 = 0;\n    let mut longest_postfix_index4 = 0;\n \
    \   let mut longest_postfix_index5 = 0;\n    let mut longest_postfix_index6 =\
    \ 0;\n    let mut longest_postfix_index7 = 0;\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_index9 = 0;\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_index11 = 0;\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_index13 = 0;\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_index15 = 0;\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_index17 = 0;\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_index19 = 0;\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_index21 = 0;\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_index23 = 0;\n    let mut longest_postfix_index24\
    \ = 0;\n    let mut longest_postfix_index25 = 0;\n    let mut longest_postfix_index26\
    \ = 0;\n    let mut longest_postfix_index27 = 0;\n    let mut longest_postfix_index28\
    \ = 0;\n    let mut longest_postfix_index29 = 0;\n    let mut longest_postfix_index30\
    \ = 0;\n    let mut longest_postfix_index31 = 0;\n    let mut longest_postfix_index32\
    \ = 0;\n    let mut longest_postfix_index33 = 0;\n    let mut longest_postfix_index34\
    \ = 0;\n    let mut longest_postfix_index35 = 0;\n    let mut longest_postfix_index36\
    \ = 0;\n    let mut longest_postfix_index37 = 0;\n    let mut longest_postfix_index38\
    \ = 0;\n    let mut longest_postfix_index39 = 0;\n    let mut longest_postfix_index40\
    \ = 0;\n    let mut longest_postfix_index41 = 0;\n    let mut longest_postfix_index42\
    \ = 0;\n    let mut longest_postfix_index43 = 0;\n    let mut longest_postfix_index44\
    \ = 0;\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplyr_2x58.rs:11:39\n   |\n\
    11 | fn make_palindrome(string: String) -> String {\n   |    --------------- \
    \                   ^^^^^^ expected struct `String`, found `()`\n   |    |\n \
    \  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_string = \"\";\n    let mut longest_postfix_index = 0;\n\
    \    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\
    \ = 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_index\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3p78dhue.rs:63:34\n   |\n\
    63 |     let mut longest_postfix_index\n   |                                 \
    \ ^ help: add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3p78dhue.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_index = -1;\n    let mut longest_postfix_length =\
    \ -1;\n    for pos in string.char_indices() {\n        let mut postfix = &mut\
    \ reversed_string[..pos];\n        let mut postfix_length = pos.len();\n     \
    \   let mut postfix_index = -1;\n        while postfix_index != longest_postfix_index\
    \ {\n            postfix_index += 1;\n            postfix_length -= 1;\n     \
    \       if postfix_length == 0 {\n                break;\n            }\n    \
    \        if postfix_index == longest_postfix_index {\n                longest_postfix_length\
    \ = postfix_length;\n                longest_postfix_index = postfix_index;\n\
    \            }\n            postfix.push(string[postfix_index..postfix_index].chars().next().unwrap());\n\
    \        }\n        reversed_string.push_str(&postfix);\n    }\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeTo<(usize, char)>`\n\
    \  --> /tmp/tmpk2ryfvsj.rs:17:32\n   |\n17 |         let mut postfix = &mut reversed_string[..pos];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `RangeTo<(usize, char)>`\n   |\n   = help: the trait `Index<RangeTo<(usize,\
    \ char)>>` is not implemented for `String`\n   = help: the following other types\
    \ implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `len` found for tuple `(usize, char)`\
    \ in the current scope\n  --> /tmp/tmpk2ryfvsj.rs:18:38\n   |\n18 |         let\
    \ mut postfix_length = pos.len();\n   |                                      ^^^\
    \ method not found in `(usize, char)`\n\nerror[E0277]: the trait bound `usize:\
    \ Neg` is not satisfied\n  --> /tmp/tmpk2ryfvsj.rs:14:37\n   |\n14 |     let mut\
    \ longest_postfix_index = -1;\n   |                                     ^^ the\
    \ trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other\
    \ types implement trait `Neg`:\n             &f32\n             &f64\n       \
    \      &i128\n             &i16\n             &i32\n             &i64\n      \
    \       &i8\n             &isize\n           and 8 others\n\nerror[E0277]: the\
    \ trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpk2ryfvsj.rs:19:33\n\
    \   |\n19 |         let mut postfix_index = -1;\n   |                        \
    \         ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help:\
    \ the following other types implement trait `Neg`:\n             &f32\n      \
    \       &f64\n             &i128\n             &i16\n             &i32\n     \
    \        &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanation"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut longest_postfix = string;\n    let mut longest_postfix_index = -1;\n   \
    \ let mut longest_postfix_length = -1;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start =\
    \ -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = -1;\n    let mut longest_postfix_length = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_length\
    \ = -1;\n    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end\
    \ = \n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpz0i3zcrs.rs:64:1\n\
    \   |\n64 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    while\
    \ !reversed_string.is_empty() {\n        let mut current_char = reversed_string.chars().next();\n\
    \        if current_char.is_none() {\n            break;\n        }\n        let\
    \ mut current_char = current_char.unwrap();\n        if current_char == current_char.chars().next().unwrap()\
    \ {\n            prefix_length += 1;\n        }\n        reversed_string = reversed_string[..prefix_length].to_owned();\n\
    \    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpgzijewty.rs:20:41\n   |\n20 |         if current_char ==\
    \ current_char.chars().next().unwrap() {\n   |                               \
    \          ^^^^^ method not found in `char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    while !string.is_empty() {\n        let mut\
    \ postfix_length = string.len();\n        while postfix_length >= longest_postfix_length\
    \ {\n            let mut postfix = &string[..postfix_length];\n            let\
    \ mut reversed_postfix = &reversed_string[..postfix_length];\n            while\
    \ !postfix.is_empty() {\n                let mut char = postfix.chars().next().unwrap();\n\
    \                reversed_postfix.push(char);\n                postfix.remove(char);\n\
    \            }\n            if postfix_length == reversed_postfix.len() {\n  \
    \              longest_postfix_length = postfix_length;\n                break;\n\
    \            }\n        }\n        string = &string[longest_postfix_length..];\n\
    \        reversed_string += &reversed_string[..longest_postfix_length];\n    }\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpaq_rnyjr.rs:22:34\n   |\n22 |                 reversed_postfix.push(char);\n\
    \   |                                  ^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `remove` found for reference `&str` in the current scope\n \
    \ --> /tmp/tmpaq_rnyjr.rs:23:25\n   |\n23 |                 postfix.remove(char);\n\
    \   |                         ^^^^^^ method not found in `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaq_rnyjr.rs:30:18\n   |\n12 |     let mut string\
    \ = string;\n   |                      ------ expected due to this value\n...\n\
    30 |         string = &string[longest_postfix_length..];\n   |               \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n30 |         string = (&string[longest_postfix_length..]).to_string();\n\
    \   |                  +                                 +++++++++++++\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpaq_rnyjr.rs:31:9\n\
    \   |\n31 |         reversed_string += &reversed_string[..longest_postfix_length];\n\
    \   |         ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&str`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0368,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo69wv1oh.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo69wv1oh.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string_to_reverse = string;\n    let mut reversed_string = string;\n\
    \    let mut i = 0;\n    while i < string_to_reverse.len() {\n        let mut\
    \ j = string_to_reverse.len() - 1;\n        while j >= i {\n            if string_to_reverse[j]\
    \ != string_to_reverse[i] {\n                break;\n            }\n         \
    \   j -= 1;\n        }\n        reversed_string.push_str(&string_to_reverse[i..j\
    \ + 1]);\n        i += j;\n    }\n    reversed_string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp04ozz80k.rs:18:16\n\
    \   |\n18 |             if string_to_reverse[j] != string_to_reverse[i] {\n  \
    \ |                ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp04ozz80k.rs:18:40\n   |\n18 |             if string_to_reverse[j]\
    \ != string_to_reverse[i] {\n   |                                        ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut i =\
    \ 0;\n    while i < string.len() {\n        if string[i] != string[string::len()\
    \ - i - 1] {\n            break;\n        }\n        reverse = reverse.chars().collect::<String>().rev().collect();\n\
    \        i += 1;\n    }\n    string += &reverse;\n    string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `string`\n\
    \  --> /tmp/tmp_pdarrzw.rs:16:32\n   |\n16 |         if string[i] != string[string::len()\
    \ - i - 1] {\n   |                                ^^^^^^ use of undeclared crate\
    \ or module `string`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_pdarrzw.rs:16:12\n   |\n16 |         if string[i] != string[string::len()\
    \ - i - 1] {\n   |            ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmp_pdarrzw.rs:19:55\n\
    \    |\n19  |           reverse = reverse.chars().collect::<String>().rev().collect();\n\
    \    |                                                         ^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0433,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_string = \"\";\n    let mut longest_postfix_string_length\
    \ = 0;\n    let mut longest_postfix_string_index = 0;\n    let mut longest_postfix_string_length_index\
    \ = 0;\n    let mut longest_postfix_string_length_reverse = 0;\n    let mut longest_postfix_string_reverse_index\
    \ = 0;\n    let mut longest_postfix_string_reverse_length = 0;\n    let mut longest_postfix_string_reverse_length_index\
    \ = 0;\n    let mut longest_postfix_string_reverse_length_reverse = 0;\n    let\
    \ mut longest_postfix_string_reverse_length_reverse_index = 0;\n    let mut longest_postfix_string_reverse_length_reverse_length\
    \ = 0;\n    let mut longest_postfix_string_reverse_length_reverse_length_index\
    \ = 0;\n    let mut longest_postfix_string_reverse_length_reverse_length_reverse\
    \ = 0;\n    let mut longest_postfix_string_reverse_length_reverse_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_string_reverse_length_reverse_length_reverse_length\
    \ = 0;\n    let mut longest_postfix_string_reverse_length_reverse_length_reverse_length_index\
    \ = 0;\n    let mut longest_postfix_string_reverse_length_reverse_length_reverse_length_reverse\
    \ = 0;\n    let mut longest_postfix_string_reverse_length_reverse_length_reverse_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_string_reverse_length_reverse_length_reverse_length_reverse_length\
    \ = 0;\n    let mut longest_postfix_string_reverse_length_reverse_length_reverse_length_reverse_length_index\
    \ = 0;\n    let mut longest_postfix_string_reverse_length_reverse_length_reverse_length_reverse_length_reverse\
    \ = 0;\n    let mut longest_postfix_string_reverse_length_reverse_length_reverse_length_reverse_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_string_reverse_length_reverse_length_reverse_length_reverse_length_reverse_length\
    \ = 0;\n    let mut longest_postfix_string_reverse_length_reverse_length_reverse_length_reverse_length_reverse_length_index\
    \ = 0;\n    let mut longest_postfix_string_reverse_length_reverse_length_reverse_length_reverse_length_reverse_length_reverse\
    \ = 0;\n    let mut longest_postfix_string_reverse_length_reverse_length_reverse_length_reverse_length_reverse_length_reverse_index\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1gvddqmy.rs:41:124\n   |\n\
    41 |     let mut longest_postfix_string_reverse_length_reverse_length_reverse_length_reverse_length_reverse_length_reverse_index\n\
    \   |                                                                        \
    \                                                    ^ help: add `;` here\n42\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1gvddqmy.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut reversed_palindrome = string;\n\
    \    let mut suffix_len = 0;\n    let mut prefix_len = 0;\n    while !palindrome.is_empty()\
    \ {\n        let mut suffix_len = palindrome.len();\n        while suffix_len\
    \ > 0 {\n            let mut prefix_len = palindrome.len();\n            while\
    \ prefix_len > 0 {\n                let mut i = suffix_len - 1;\n            \
    \    let mut j = prefix_len - 1;\n                while i >= 0 && j >= 0 {\n \
    \                   if palindrome[i] == palindrome[j] {\n                    \
    \    suffix_len -= 1;\n                        i -= 1;\n                     \
    \   j -= 1;\n                    } else {\n                        i -= 1;\n \
    \                   }\n                }\n                if i >= 0 {\n      \
    \              break;\n                }\n                j -= 1;\n          \
    \  }\n            if j >= 0 {\n                break;\n            }\n       \
    \     suffix_len -= 1;\n        }\n        if suffix_len > 0 {\n            palindrome\
    \ = &palindrome[..suffix_len];\n        } else {\n            break;\n       \
    \ }\n        reversed_palindrome = &reversed_palindrome[..prefix_len];\n    }\n\
    \    palindrome.push_str(&reversed_palindrome);\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `j` in this scope\n  --> /tmp/tmp9vy6d53n.rs:37:16\n\
    \   |\n37 |             if j >= 0 {\n   |                ^ not found in this scope\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9vy6d53n.rs:24:24\n\
    \   |\n24 |                     if palindrome[i] == palindrome[j] {\n   |    \
    \                    ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9vy6d53n.rs:24:41\n\
    \   |\n24 |                     if palindrome[i] == palindrome[j] {\n   |    \
    \                                     ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9vy6d53n.rs:43:26\n\
    \   |\n12 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n43 |             palindrome = &palindrome[..suffix_len];\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n43 |        \
    \     palindrome = (&palindrome[..suffix_len]).to_string("
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    while suffix_length < reversed_string.len() {\n\
    \        let mut suffix_start = suffix_length;\n        let mut suffix_end = suffix_length;\n\
    \        while suffix_start < reversed_string.len() && reversed_string[suffix_start]\
    \ == reversed_string[suffix_end - 1] {\n            suffix_start += 1;\n     \
    \       suffix_end += 1;\n        }\n        if suffix_start == suffix_end {\n\
    \            break;\n        }\n        let mut prefix_start = prefix_length;\n\
    \        let mut prefix_end = prefix_length;\n        while prefix_start < reversed_string.len()\
    \ && reversed_string[prefix_start] == reversed_string[prefix_end - 1] {\n    \
    \        prefix_start += 1;\n            prefix_end += 1;\n        }\n       \
    \ if prefix_start == prefix_end {\n            break;\n        }\n        reversed_string\
    \ = reversed_string[prefix_start..prefix_end];\n        suffix_length -= prefix_end\
    \ - prefix_start;\n        prefix_length -= suffix_end - suffix_start;\n    }\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgh4_zqnt.rs:18:55\n\
    \   |\n18 |         while suffix_start < reversed_string.len() && reversed_string[suffix_start]\
    \ == reversed_string[suffix_end - 1] {\n   |                                 \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgh4_zqnt.rs:18:88\n   |\n18 |         while suffix_start < reversed_string.len()\
    \ && reversed_string[suffix_start] == reversed_string[suffix_end - 1] {\n   |\
    \                                                                            \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgh4_zqnt.rs:27:55\n   |\n27 |         while prefix_start < reversed_string.len()\
    \ && reversed_string[prefix_start] == reversed_string[prefix_end - 1] {\n   |\
    \                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    while\
    \ !reversed_string.starts_with(string) {\n        reversed_string = reversed_string[..prefix_length];\n\
    \        prefix_length += 1;\n    }\n    reversed_string += &string[prefix_length..];\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpknfjsfij.rs:14:40\n     |\n14   |     while !reversed_string.starts_with(string)\
    \ {\n     |                            ----------- ^^^^^^ expected an implementor\
    \ of trait `Pattern<'_>`\n     |                            |\n     |        \
    \                    required by a bound introduced by this call\n     |\n   \
    \  = note: the trait bound `String: Pattern<'_>` is not satisfied\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `String`\n\
    note: required by a bound in `core::str::<impl str>::starts_with`\nhelp: consider\
    \ borrowing here\n     |\n14   |     while !reversed_string.starts_with(&string)\
    \ {\n     |                                        +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpknfjsfij.rs:15:27\n   |\n12 |     let mut reversed_string\
    \ = string;\n   |                               ------ expected due to this value\n\
    ...\n15 |         reversed_string = reversed_string[..prefix_length];\n   |  \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                           |\n   |  \
    \                         expected struct `String`, found `str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    while\
    \ !reversed_string.is_empty() {\n        let mut current_char = reversed_string[0];\n\
    \        reversed_string = reversed_string.chars().skip(1).collect();\n      \
    \  if current_char == current_char.to_string().chars().last().unwrap() {\n   \
    \         prefix_length += 1;\n        }\n    }\n    reversed_string.push_str(&string[prefix_length..]);\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmp1im9zcto.rs:15:32\n   |\n15 |         let mut current_char = reversed_string[0];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_char: char;\n    let mut longest_postfix_char_length = 0;\n\
    \    let mut longest_postfix_char_length_index = 0;\n    let mut longest_postfix_char_length_index2\
    \ = 0;\n    let mut longest_postfix_char_length_index3 = 0;\n    let mut longest_postfix_char_length_index4\
    \ = 0;\n    let mut longest_postfix_char_length_index5 = 0;\n    let mut longest_postfix_char_length_index6\
    \ = 0;\n    let mut longest_postfix_char_length_index7 = 0;\n    let mut longest_postfix_char_length_index8\
    \ = 0;\n    let mut longest_postfix_char_length_index9 = 0;\n    let mut longest_postfix_char_length_index10\
    \ = 0;\n    let mut longest_postfix_char_length_index11 = 0;\n    let mut longest_postfix_char_length_index12\
    \ = 0;\n    let mut longest_postfix_char_length_index13 = 0;\n    let mut longest_postfix_char_length_index14\
    \ = 0;\n    let mut longest_postfix_char_length_index15 = 0;\n    let mut longest_postfix_char_length_index16\
    \ = 0;\n    let mut longest_postfix_char_length_index17 = 0;\n    let mut longest_postfix_char_length_index18\
    \ = 0;\n    let mut longest_postfix_char_length_index19 = 0;\n    let mut longest_postfix_char_length_index20\
    \ = 0;\n    let mut longest_postfix_char_length_index21 = 0;\n    let mut longest_postfix_char_length_index22\
    \ = 0;\n    let mut longest_postfix_char_length_index23 = 0;\n    let mut longest_postfix_char_length_index24\
    \ = 0;\n    let mut longest_postfix_char_length_index25 = 0;\n    let mut longest_postfix_char_length_index26\
    \ = 0;\n    let mut longest_postfix_char_length_index27 = 0;\n    let mut longest_postfix_char_length_index28\
    \ = 0;\n    let mut longest_postfix_char_length_index29 = 0;\n    let mut longest_postfix_char_length_index30\
    \ = 0;\n    let mut longest_postfix_char_length_index31 = 0;\n    let mut longest_postfix_char_length_index32\
    \ = 0;\n    let mut longest_postfix_char_length_index33 = 0;\n    let mut longest_postfix_char_length_index34\
    \ = 0;\n    let mut longest_postfix_char_length_index35 = 0;\n    let mut longest_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjx55h4o7.rs:53:21\n   |\n\
    53 |     let mut longest_\n   |                     ^ help: add `;` here\n54 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjx55h4o7.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo69wv1oh.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo69wv1oh.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    for c in string.chars() {\n        if longest_postfix_length < c.len_utf8()\
    \ {\n            longest_postfix_length = c.len_utf8();\n        }\n    }\n  \
    \  let mut postfix_length = longest_postfix_length;\n    let mut postfix_start\
    \ = longest_postfix_length;\n    while postfix_start < string.len() {\n      \
    \  let mut postfix_end = postfix_start;\n        while postfix_end < string.len()\
    \ {\n            if string[postfix_end] != string[postfix_end - 1] {\n       \
    \         break;\n            }\n            postfix_end += 1;\n        }\n  \
    \      if postfix_end > postfix_start {\n            let mut postfix_suffix =\
    \ &string[postfix_start..postfix_end - 1];\n            let mut reversed_postfix_suffix\
    \ = &reversed_string[postfix_start..postfix_end - 1];\n            reversed_postfix_suffix.reverse();\n\
    \            postfix_suffix += &reversed_postfix_suffix;\n            postfix_start\
    \ = postfix_end;\n        }\n    }\n    string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7m1gej5n.rs:24:16\n\
    \   |\n24 |             if string[postfix_end] != string[postfix_end - 1] {\n\
    \   |                ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7m1gej5n.rs:24:39\n   |\n24 |             if string[postfix_end]\
    \ != string[postfix_end - 1] {\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `reverse` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmp7m1gej5n.rs:32:37\n   |\n32 |          \
    \   reversed_postfix_suffix.reverse();\n   |                                 \
    \    ^^^^^^^ method not found in `&str`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&str`\n  --> /tmp/tmp7m1gej5n.rs:33:13\n   |\n\
    33 |             postfix_suffix += &reversed_postfix_suffix;\n   |           \
    \  --------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |             |\n   |      \
    \       cannot use `+=` on type `&str`\n\nerror: aborting due t"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    for c in reversed_string.chars() {\n        if longest_postfix_length ==\
    \ 0 {\n            longest_postfix_length = c.len_utf8();\n        }\n       \
    \ if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    let mut reversed_string_reversed = reversed_string;\n\
    \    for c in reversed_string.chars() {\n        if longest_postfix_length ==\
    \ 0 {\n            longest_postfix_length = c.len_utf8();\n        }\n       \
    \ if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    let mut reversed_string_reversed = reversed_string;\n\
    \    for c in reversed_string.chars() {\n        if longest_postfix_length ==\
    \ 0 {\n            longest_postfix_length = c.len_utf8();\n        }\n       \
    \ if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    let mut reversed_string_reversed = reversed_string;\n\
    \    for c in reversed_string.chars() {\n        if longest_postfix_length ==\
    \ 0 {\n            longest_postfix_length = c.len_utf8();\n        }\n       \
    \ if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    let mut reversed_string_reversed = reversed_string;\n\
    \    for c in reversed_string.chars() {\n        if longest_postfix_length ==\
    \ 0 {\n            longest_postfix_length = c.len_utf8();\n        }\n       \
    \ if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    let mut reversed_string_reversed = reversed_string;\n\
    \    for c in reversed_string.chars() {\n        if longest_postfix_length ==\
    \ 0 {\n            longest_postfix_length = c.len_utf8();\n        }\n       \
    \ if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    let mut reversed_string_reversed = reversed_string;\n\
    \    for c in reversed_string.chars() {\n        if longest_postfix_length ==\
    \ 0 {\n            longest_postfix_length = c.len_utf8();\n        }\n       \
    \ if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    let mut reversed_string_reversed = reversed_string;\n\
    \    for c in reversed_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpnfgzer8u.rs:78:1\n   |\n\
    78 | }\n   | ^ expected `{`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_index = 0;\n    let mut longest_postfix_length = 0;\n    while\
    \ !string.is_empty() {\n        let mut index = longest_postfix_index;\n     \
    \   let mut length = longest_postfix_length;\n        while !string[index] ==\
    \ string[index + length] {\n            length += 1;\n            index += 1;\n\
    \        }\n        reversed_string += &string[index..index + length];\n     \
    \   longest_postfix_length = length;\n        longest_postfix_index = index +\
    \ 1;\n        string = &string[index..];\n    }\n    string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpcynq450m.rs:19:16\n   |\n19 |         while !string[index] == string[index\
    \ + length] {\n   |                ^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpcynq450m.rs:19:33\n   |\n19 |         while !string[index] == string[index\
    \ + length] {\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmpcynq450m.rs:23:9\n   |\n23 |         reversed_string\
    \ += &string[index..index + length];\n   |         ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcynq450m.rs:26:18\n   |\n12 |     let mut string\
    \ = string;\n   |                      ------ expected due to this value\n...\n\
    26 |         string = &string[index..];\n   |                  ^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&st"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut palindrome = string;\n   \
    \ let mut suffix_index = string.len();\n    while suffix_index > 0 {\n       \
    \ let mut suffix_index = suffix_index - 1;\n        while suffix_index >= 0 &&\
    \ palindrome[suffix_index] == reversed_string[suffix_index] {\n            suffix_index\
    \ -= 1;\n        }\n        if suffix_index >= 0 {\n            palindrome = &palindrome[..suffix_index\
    \ + 1] + &reversed_string[suffix_index..];\n        }\n    }\n    palindrome\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv3czu4jm.rs:17:36\n\
    \   |\n17 |         while suffix_index >= 0 && palindrome[suffix_index] == reversed_string[suffix_index]\
    \ {\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpv3czu4jm.rs:17:64\n   |\n17 |         while suffix_index >= 0 &&\
    \ palindrome[suffix_index] == reversed_string[suffix_index] {\n   |          \
    \                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot add `&str` to `&str`\n  --> /tmp/tmpv3czu4jm.rs:21:58\n\
    \   |\n21 |             palindrome = &palindrome[..suffix_index + 1] + &reversed_string[suffix_index..];\n\
    \   |                          ------------------------------- ^ --------------------------------\
    \ &str\n   |                          |                               |\n   |\
    \                          |                               `+` cannot be used\
    \ to concatenate two `&str` strings\n   | "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_length = 0;\n    while\
    \ !reversed_string.is_empty() {\n        let mut index = reversed_string.len()\
    \ - 1;\n        while index >= 0 {\n            if reversed_string[index] != reversed_string[index].chars().last().unwrap()\
    \ {\n                break;\n            }\n            index -= 1;\n        }\n\
    \        reverse_length += 1;\n        reversed_string = reversed_string[..index\
    \ + 1].reverse();\n    }\n    string + &reversed_string[..reverse_length]\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnz96giwg.rs:17:16\n\
    \   |\n17 |             if reversed_string[index] != reversed_string[index].chars().last().unwrap()\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpnz96giwg.rs:17:42\n   |\n17 |             if reversed_string[index]\
    \ != reversed_string[index].chars().last().unwrap() {\n   |                  \
    \                        ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `reverse` found for type `str` in\
    \ the current scope\n  --> /tmp/tmpnz96giwg.rs:23:56\n   |\n23 |         reversed_string\
    \ = reversed_string[..index + 1].reverse();\n   |                            \
    \                            ^^^^^^^ method not found in `str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut longest\
    \ = 0;\n    while !string.is_empty() {\n        let mut i = 0;\n        while\
    \ i < string.len() {\n            if string[i] != string[string::len() - 1 - i]\
    \ {\n                break;\n            }\n            i += 1;\n        }\n \
    \       if i == 0 {\n            break;\n        }\n        let mut j = i;\n \
    \       while j > 0 {\n            if string[j] != string[string::len() - 1 -\
    \ j] {\n                break;\n            }\n            j -= 1;\n        }\n\
    \        if j == 0 {\n            break;\n        }\n        let mut length =\
    \ j - i;\n        if length > longest {\n            longest = length;\n     \
    \   }\n        reverse.push_str(&string[i..]);\n        string.push_str(&string[j..]);\n\
    \    }\n    reverse.into()\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `string`\n\
    \  --> /tmp/tmps32f_i6d.rs:18:36\n   |\n18 |             if string[i] != string[string::len()\
    \ - 1 - i] {\n   |                                    ^^^^^^ use of undeclared\
    \ crate or module `string`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `string`\n  --> /tmp/tmps32f_i6d.rs:28:36\n   |\n28 |      \
    \       if string[j] != string[string::len() - 1 - j] {\n   |                \
    \                    ^^^^^^ use of undeclared crate or module `string`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps32f_i6d.rs:18:16\n\
    \   |\n18 |             if string[i] != string[string::len() - 1 - i] {\n   |\
    \                ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmps32f_i6d.rs:28:16\n   |\n28 |             if string[j] != string[string::len()\
    \ - 1 - j] {\n   |                ^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0433.\nFo"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed = string;\n    let mut palindrome = string;\n    let mut\
    \ prefix_len = 0;\n    let mut suffix_len = 0;\n    while palindrome.len() > 0\
    \ {\n        let mut pos = palindrome.rfind('a');\n        if pos == String::npos\
    \ { break; }\n        let mut suffix = palindrome[..pos];\n        let mut prefix\
    \ = palindrome[pos..];\n        if suffix.chars().count() != prefix.chars().count()\
    \ {\n            palindrome = prefix.to_owned() + palindrome[pos..].to_owned();\n\
    \        } else {\n            palindrome = prefix.to_owned() + palindrome[pos..].to_owned();\n\
    \        }\n        prefix_len = prefix.len();\n        suffix_len = suffix.len();\n\
    \    }\n    palindrome = reversed.to_owned() + palindrome[..suffix_len].to_owned();\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `npos` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmph3pct4an.rs:18:27\n   |\n18 | \
    \        if pos == String::npos { break; }\n   |                           ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `RangeTo<Option<usize>>`\n  --> /tmp/tmph3pct4an.rs:19:26\n\
    \   |\n19 |         let mut suffix = palindrome[..pos];\n   |                \
    \          ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `RangeTo<Option<usize>>`\n\
    \   |\n   = help: the trait `Index<RangeTo<Option<usize>>>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \  --> /tmp/tmph3pct4an.rs:20:26\n   |\n20 |         let mut prefix = palindrome[pos..];\n\
    \   |                          ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `RangeFrom<Option<usize>>`\n   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \  --> /tmp/tmph3pct4an.rs:22:46\n   |\n22 |             palindrome = prefix.to_owned()\
    \ + palindrome[pos..].to_owned();\n   |                                      \
    \        ^"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut i =\
    \ 0;\n    while i < string.len() {\n        let mut j = i;\n        while j +\
    \ 1 < string.len() {\n            reverse = reverse.chars().next().unwrap().to_string();\n\
    \            j = j + 1;\n        }\n        if i != j {\n            reverse =\
    \ reverse.chars().next().unwrap().to_string();\n            i = j;\n        }\n\
    \    }\n    string + reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv0z9_apm.rs:26:14\n   |\n\
    26 |     string + reverse\n   |              ^^^^^^^\n   |              |\n  \
    \ |              expected `&str`, found struct `String`\n   |              help:\
    \ consider borrowing here: `&reverse`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_index = 0;\n    let mut longest_postfix_length = 0;\n    while\
    \ !string.is_empty() {\n        let mut postfix_length = string.len();\n     \
    \   let mut postfix_index = 0;\n        while postfix_index < postfix_length {\n\
    \            let mut current_char = string[postfix_index];\n            let mut\
    \ next_char = string[postfix_index + 1];\n            if current_char == next_char\
    \ {\n                postfix_index += 1;\n            } else {\n             \
    \   break;\n            }\n        }\n        if postfix_index == postfix_length\
    \ {\n            break;\n        }\n        let mut postfix_length = postfix_index\
    \ - longest_postfix_index;\n        if postfix_length > longest_postfix_length\
    \ {\n            longest_postfix_length = postfix_length;\n            longest_postfix_index\
    \ = postfix_index;\n        }\n        string = &string[postfix_index..];\n  \
    \  }\n    string = &string[longest_postfix_index..];\n    let mut reversed_string\
    \ = \"\";\n    while !string.is_empty() {\n        let mut current_char = string[0];\n\
    \        let mut next_char = string[1];\n        if current_char == next_char\
    \ {\n            reversed_string += current_char;\n            string = &string[2..];\n\
    \        } else {\n            break;\n        }\n    }\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2jb5w6zw.rs:20:36\n\
    \   |\n20 |             let mut current_char = string[postfix_index];\n   |  \
    \                                  ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2jb5w6zw.rs:21:33\n   |\n21 |             let mut next_char = string[postfix_index\
    \ + 1];\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2jb5w6zw.rs:36:18\n\
    \   |\n12 |     let mut string = string;\n   |                      ------ expected\
    \ due to this value\n...\n36 |         string = &string[postfix_index..];\n  \
    \ |                  ^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n36 |         string\
    \ = (&string[postfix_index..]).to_string();\n   |                  +         \
    \               +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2jb5w6zw.rs:38:14\n\
    \   |\n12 |     let mut string = string;\n  "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2c_ckosp.rs:63:32\n   |\n\
    63 |     let mut longest_postfix_end\n   |                                ^ help:\
    \ add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2c_ckosp.rs:11:39\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    while\
    \ string.len() > 0 {\n        let mut postfix_length = string.len();\n       \
    \ let mut postfix_index = 0;\n        while postfix_length >= longest_postfix_length\
    \ {\n            postfix_length = postfix_length - longest_postfix_length;\n \
    \           postfix_index = postfix_index + 1;\n        }\n        let mut postfix_string\
    \ = string[postfix_index..];\n        let mut postfix_reversed_string = \"\";\n\
    \        while postfix_string.len() > 0 {\n            let mut postfix_reversed_length\
    \ = postfix_string.len();\n            let mut postfix_reversed_index = 0;\n \
    \           while postfix_reversed_length >= longest_postfix_length {\n      \
    \          postfix_reversed_length = postfix_reversed_length - longest_postfix_length;\n\
    \                postfix_reversed_index = postfix_reversed_index + 1;\n      \
    \      }\n            let mut postfix_reversed_string = postfix_string[postfix_reversed_index..];\n\
    \            if postfix_reversed_string == postfix_string {\n                postfix_reversed_string\
    \ = postfix_reversed_string.reverse();\n            }\n            postfix_reversed_string\
    \ = postfix_reversed_string.reverse();\n            postfix_reversed_string =\
    \ postfix_reversed_string.join(\"\");\n            postfix_reversed_string = postfix_reversed_string.reverse();\n\
    \            postfix_reversed_string = postfix_reversed_string.join(\"\");\n \
    \           postfix_reversed_string = postfix_reversed_string.reverse();\n   \
    \         postfix_reversed_string = postfix_reversed_string.join(\"\");\n    \
    \        postfix_reversed_string = postfix_reversed_string.reverse();\n      \
    \      postfix_reversed_string = postfix_reversed_string.join(\"\");\n       \
    \     postfix_reversed_string = postfix_reversed_string.reverse();\n         \
    \   postfix_reversed_string = postfix_reversed_string.join(\"\");\n          \
    \  postfix_reversed_string = postfix_reversed_string.reverse();\n            postfix_reversed_string\
    \ = postfix_reversed_string.join(\"\");\n            postfix_reversed_string =\
    \ postfix_reversed_string.reverse();\n            postfix_reversed_string = postfix_reversed_string.join(\"\
    \");\n            postfix_reversed_string = postfix_reversed_string.reverse();\n\
    \            postfix_reversed_string = postfix_reversed_string.join(\"\");\n \
    \           postfix_reversed_string = postfix_reversed_string.reverse();\n   \
    \         postfix_reversed_string = postfix_reversed_string.join(\"\");\n    \
    \        postfix_reversed_string = postfix_reversed_string.reverse();\n      \
    \      post\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpo6gt5kh6.rs:65:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n16 |     while string.len()\
    \ > 0 {\n   |                            - unclosed delimiter\n...\n25 |     \
    \    while postfix_string.len() > 0 {\n   |                                  \
    \      - this delimiter might not be properly closed...\n...\n56 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n65 | }\n   |   ^\n\n\
    error[E0425]: cannot find value `post` in this scope\n  --> /tmp/tmpo6gt5kh6.rs:55:13\n\
    \   |\n55 |             post\n   |             ^^^^ not found in this scope\n\n\
    error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpo6gt5kh6.rs:23:13\n   |\n23 |         let mut postfix_string\
    \ = string[postfix_index..];\n   |             ^^^^^^^^^^^^^^^^^^ doesn't have\
    \ a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing\
    \ here\n   |\n23 |         let mut postfix_string = &string[postfix_index..];\n\
    \   |                                  +\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n  --> /tmp/tmpo6gt5kh6.rs:32:17\n\
    \   |\n32 |             let mut postfix_reversed_string = postfix_string[postfix_reversed_index..];\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at\
    \ compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    \   = note: all local variables must have a statically known size\n   = help:\
    \ unsized locals are gated as an unstable feature\nhelp: consider borrowing here\n\
    \   |\n32 |             let mut postfix_reversed_string = &postfix_string[postfix_reversed_index..];\n\
    \   |                                               +\n\nerror[E0599]: no method\
    \ named `reverse` found for type `str` in the current scope\n  --> /t"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n  \
    \  let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n\
    \    while longest_postfix_index != longest_postfix_length {\n        longest_postfix_index2\
    \ = longest_postfix_index + 1;\n        longest_postfix_index3 = longest_postfix_index2\
    \ + 1;\n        if longest_postfix_index2 > longest_postfix_length {\n       \
    \     longest_postfix_index2 = longest_postfix_length;\n        }\n        if\
    \ longest_postfix_index3 > longest_postfix_length {\n            longest_postfix_index3\
    \ = longest_postfix_length;\n        }\n        if longest_postfix_index2 == longest_postfix_length\
    \ {\n            longest_postfix_index2 += 1;\n        }\n        if longest_postfix_index3\
    \ == longest_postfix_length {\n            longest_postfix_index3 += 1;\n    \
    \    }\n        if longest_postfix_index2 > longest_postfix_length {\n       \
    \     longest_postfix_length = longest_postfix_index2;\n        }\n        if\
    \ longest_postfix_index3 > longest_postfix_length {\n            longest_postfix_length\
    \ = longest_postfix_index3;\n        }\n        if longest_postfix_index2 == longest_postfix_length\
    \ {\n            longest_postfix_index2 += 1;\n        }\n        if longest_postfix_index3\
    \ == longest_postfix_length {\n            longest_postfix_index3 += 1;\n    \
    \    }\n        if longest_postfix_index2 > longest_postfix_length {\n       \
    \     longest_postfix_length = longest_postfix_index2;\n        }\n        if\
    \ longest_postfix_index3 > longest_postfix_length {\n            longest_postfix_length\
    \ = longest_postfix_index3;\n        }\n        if longest_postfix_index2 == longest_postfix_length\
    \ {\n            longest_postfix_index2 += 1;\n        }\n        if longest_postfix_index3\
    \ == longest_postfix_length {\n            longest_postfix_index3 += 1;\n    \
    \    }\n        if longest_postfix_index2 > longest_postfix_length {\n       \
    \     longest_postfix_length = longest_postfix_index2;\n        }\n        if\
    \ longest_postfix_index3 > longest_postfix_length {\n            longest_postfix_length\
    \ = longest_postfix_index3;\n        }\n        if longest_postfix_index2 == longest_postfix_length\
    \ {\n            longest_postfix_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpntsuy958.rs:74:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n18 |     while longest_postfix_index\
    \ != longest_postfix_length {\n   |                                          \
    \                 - unclosed delimiter\n...\n63 |         if longest_postfix_index2\
    \ == longest_postfix_length {\n   |                                          \
    \                   - this delimiter might not be properly closed...\n64 |   \
    \          longest_postfix_\n65 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n74 | }\n   |   ^\n\nerror[E0425]: cannot find value `longest_postfix_`\
    \ in this scope\n  --> /tmp/tmpntsuy958.rs:64:13\n   |\n64 |             longest_postfix_\n\
    \   |             ^^^^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `longest_postfix_index`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpntsuy958.rs:18:5\n\
    \   |\n11 |   fn make_palindrome(string: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    ...\n18 | /     while longest_postfix_index != longest_postfix_length {\n19 |\
    \ |         longest_postfix_index2 = longest_postfix_index + 1;\n20 | |      \
    \   longest_postfix_index3 = longest_postfix_index2 + 1;\n21 | |         if longest_postfix_index2\
    \ > longest_postfix_length {\n...  |\n73 | |     assert_eq!(candidate(String::from(\"\
    jerry\")), String::from(\"jerryrrej\"));\n74 | | }\n   | |__^ expected struct\
    \ `String`, found `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut postfix = string;\n    let\
    \ mut prefix_len = 0;\n    while !postfix.is_empty() {\n        let mut postfix\
    \ = postfix.chars().collect::<String>().reverse().collect::<String>();\n     \
    \   if postfix.starts_with(string) {\n            reversed_string = reversed_string.chars().collect::<String>().reverse().collect();\n\
    \            prefix_len = string.len() - postfix.len();\n        }\n    }\n  \
    \  String::from(reversed_string.chars().collect::<String>().reverse().collect())\n\
    \        .into_owned()\n        .to_owned()\n        .to_string() + &string[prefix_len..]\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpdip1zpdc.rs:16:63\n   |\n16 |         let mut postfix\
    \ = postfix.chars().collect::<String>().reverse().collect::<String>();\n   | \
    \                                                              ^^^^^^^ help: there\
    \ is an associated function with a similar name: `reserve`\n\nerror[E0599]: no\
    \ method named `reverse` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpdip1zpdc.rs:18:75\n   |\n18 |             reversed_string = reversed_string.chars().collect::<String>().reverse().collect();\n\
    \   |                                                                        \
    \   ^^^^^^^ help: there is an associated function with a similar name: `reserve`\n\
    \nerror[E0599]: no method named `reverse` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpdip1zpdc.rs:22:62\n   |\n22 |     String::from(reversed_string.chars().collect::<String>().reverse().collect())\n\
    \   |                                                              ^^^^^^^ help:\
    \ there is an associated function with a similar name: `reserve`\n\nerror[E0599]:\
    \ no method named `into_owned` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpdip1zpdc.rs:23:10\n   |\n23 |         .into_owned()\n   |     \
    \     ^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut longest_postfix_length = 0;\n    let mut longest_postfix_length_index =\
    \ 0;\n    let mut longest_postfix_length_palindrome = 0;\n    let mut longest_postfix_length_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_index = 0;\n    let mut longest_postfix_length_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix = 0;\n    let mut longest_postfix_length_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_palindrome = 0;\n   \
    \ let mut longest_postfix_length_suffix_suffix_suffix = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_palindrome = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix_suffix_suffix = 0;\n    let\
    \ mut longest_postfix_length_suffix_suffix_suffix_suffix_index = 0;\n    let mut\
    \ longest_postfix_length_suffix_suffix_suffix_suffix_palindrome = 0;\n    let\
    \ mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix = 0;\n    let\
    \ mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_index = 0;\n \
    \   let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_suffix_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffi\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpq8lrpkgo.rs:40:41\n   |\n\
    40 |     let mut longest_postfix_length_suffi\n   |                          \
    \               ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq8lrpkgo.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_palindrome = string;\n\
    \    let mut longest_palindrome_length = 0;\n    let mut longest_palindrome_start\
    \ = -1;\n    for pos in string.char_indices() {\n        let mut palindrome =\
    \ string;\n        let mut palindrome_start = -1;\n        let mut palindrome_end\
    \ = -1;\n        let mut palindrome_length = 0;\n        for (i, c) in palindrome.char_indices()\
    \ {\n            if i == pos {\n                palindrome_start = i;\n      \
    \      }\n            if i == palindrome_end {\n                palindrome_end\
    \ = i;\n            }\n            palindrome_length += 1;\n        }\n      \
    \  if palindrome_length < longest_palindrome_length {\n            longest_palindrome_length\
    \ = palindrome_length;\n            longest_palindrome_start = palindrome_start;\n\
    \            longest_palindrome_end = palindrome_end;\n        }\n    }\n    if\
    \ longest_palindrome_length == 0 {\n        return string;\n    }\n    let mut\
    \ palindrome_start = longest_palindrome_start;\n    let mut palindrome_end = longest_palindrome_end;\n\
    \    let mut palindrome_length = 0;\n    for (i, c) in string.char_indices() {\n\
    \        if i == palindrome_end {\n            palindrome_end = i;\n        }\n\
    \        if i == palindrome_start {\n            palindrome_start = i;\n     \
    \   }\n        palindrome_length += 1;\n    }\n    let mut palindrome = string;\n\
    \    for _ in 0..palindrome_length {\n        palindrome = String::from(&palindrome[..]);\n\
    \    }\n    palindrome = String::from(&palindrome[..palindrome_end]);\n    palindrome\
    \ = String::from(&palindrome[..palindrome_start]);\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `longest_palindrome_end` in this scope\n\
    \  --> /tmp/tmpfb720l5s.rs:33:13\n   |\n33 |             longest_palindrome_end\
    \ = palindrome_end;\n   |             ^^^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `longest_palindrome`\n\nerror[E0425]: cannot find\
    \ value `longest_palindrome_end` in this scope\n  --> /tmp/tmpfb720l5s.rs:40:30\n\
    \   |\n40 |     let mut palindrome_end = longest_palindrome_end;\n   |       \
    \                       ^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `longest_palindrome`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfb720l5s.rs:22:21\n\
    \   |\n22 |             if i == pos {\n   |                     ^^^ expected `usize`,\
    \ found tuple\n   |\n   = note: expected type `usize`\n             found tuple\
    \ `(usize, char)`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpfb720l5s.rs:18:36\n   |\n18 |         let mut palindrome_start\
    \ = -1;\n   |                                    ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmpfb720l5s.rs:19:34\n   |\n19 |         let mut palindrome_end\
    \ = -1;\n   |                                  ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmpfb720l5s.rs:15:40\n   |\n15 |     let mut longest_palindrome_start\
    \ = -1;\n   |                                        ^^ the trait `Neg` is not\
    \ implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    for c in string.chars() {\n        if longest_postfix_length == 0 {\n   \
    \         longest_postfix_length = c.len_utf8();\n        }\n        if longest_postfix_length\
    \ < c.len_utf8() {\n            longest_postfix_length = c.len_utf8();\n     \
    \   }\n    }\n    let mut postfix_length = 0;\n    let mut postfix_start = longest_postfix_length;\n\
    \    while longest_postfix_length > 0 {\n        let mut postfix_end = longest_postfix_length;\n\
    \        while longest_postfix_length > 0 {\n            let mut postfix_length\
    \ = longest_postfix_length;\n            while longest_postfix_length > 0 {\n\
    \                let c = string.chars().nth(postfix_end).unwrap();\n         \
    \       if longest_postfix_length == 0 {\n                    longest_postfix_length\
    \ = c.len_utf8();\n                }\n                if longest_postfix_length\
    \ < c.len_utf8() {\n                    longest_postfix_length = c.len_utf8();\n\
    \                }\n                postfix_length -= 1;\n                postfix_end\
    \ -= 1;\n            }\n            if postfix_length == 0 {\n               \
    \ break;\n            }\n            postfix_start += 1;\n            postfix_end\
    \ += 1;\n        }\n        if postfix_end == 0 {\n            break;\n      \
    \  }\n        reversed_string.push_front(string[postfix_start..postfix_end]);\n\
    \        postfix_length -= 1;\n        postfix_start += 1;\n        postfix_end\
    \ += 1;\n    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push_front` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp91_zx5ec.rs:48:25\n   |\n48 |         reversed_string.push_front(string[postfix_start..postfix_end]);\n\
    \   |                         ^^^^^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut postfix_length = 0;\n    while\
    \ !reversed_string.is_empty() {\n        let mut postfix_start = reversed_string.len()\
    \ - 1;\n        while postfix_start >= 0 && reversed_string[postfix_start] !=\
    \ reversed_string[postfix_start + 1] {\n            postfix_start -= 1;\n    \
    \    }\n        if postfix_start < 0 {\n            break;\n        }\n      \
    \  let mut postfix_end = postfix_start + 1;\n        while postfix_end < reversed_string.len()\
    \ && reversed_string[postfix_end] != reversed_string[postfix_end - 1] {\n    \
    \        postfix_end += 1;\n        }\n        if postfix_end > postfix_length\
    \ {\n            postfix_length = postfix_end;\n        }\n        reversed_string\
    \ = reversed_string[..postfix_end - 1];\n    }\n    reversed_string += &string[..postfix_length];\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp28lm4hdv.rs:16:37\n\
    \   |\n16 |         while postfix_start >= 0 && reversed_string[postfix_start]\
    \ != reversed_string[postfix_start + 1] {\n   |                              \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp28lm4hdv.rs:16:71\n   |\n16 |         while postfix_start >= 0\
    \ && reversed_string[postfix_start] != reversed_string[postfix_start + 1] {\n\
    \   |                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp28lm4hdv.rs:23:54\n   |\n23 |         while postfix_end < reversed_string.len()\
    \ && reversed_string[postfix_end] != reversed_string[postfix_end - 1] {\n   |\
    \                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix = \"\";\n    let mut\
    \ longest_postfix_index = 0;\n    let mut longest_postfix_index_length = 0;\n\
    \    let mut longest_prefix_length = 0;\n    let mut longest_prefix = \"\";\n\
    \    let mut longest_prefix_index = 0;\n    let mut longest_prefix_index_length\
    \ = 0;\n    while !string.is_empty() {\n        let mut postfix_index = string.len();\n\
    \        while postfix_index > 0 {\n            let mut postfix = string[postfix_index..];\n\
    \            let mut postfix_index_length = postfix_index.len();\n           \
    \ while postfix_index_length > 0 {\n                let mut prefix = string[postfix_index_length..];\n\
    \                let mut prefix_length = prefix.len();\n                while\
    \ prefix_length > 0 {\n                    if prefix == postfix.rev() {\n    \
    \                    longest_postfix_length = postfix_index_length;\n        \
    \                longest_postfix = postfix;\n                        longest_postfix_index\
    \ = postfix_index;\n                        longest_postfix_index_length = postfix_index_length;\n\
    \                        longest_prefix_length = prefix_length;\n            \
    \            longest_prefix = prefix;\n                        longest_prefix_index\
    \ = postfix_index_length;\n                        longest_prefix_index_length\
    \ = postfix_index_length;\n                        break;\n                  \
    \  }\n                    prefix_length -= 1;\n                }\n           \
    \     postfix_index_length -= 1;\n            }\n            postfix_index -=\
    \ 1;\n        }\n        string = string[..];\n    }\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmpr3sark6w.rs:26:58\n   |\n26 |             let mut postfix_index_length\
    \ = postfix_index.len();\n   |                                               \
    \           ^^^ method not found in `usize`\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n  --> /tmp/tmpr3sark6w.rs:25:17\n\
    \   |\n25 |             let mut postfix = string[postfix_index..];\n   |     \
    \            ^^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n   =\
    \ help: the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\nhelp: consider borrowing here\n   |\n25 |             let\
    \ mut postfix = &string[postfix_index..];\n   |                              \
    \ +\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpr3sark6w.rs:28:21\n   |\n28 |                 let mut prefix\
    \ = string[postfix_index_length..];\n   |                     ^^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\nhelp:\
    \ consider borrowing here\n   |\n28 |                 let mut prefix = &string[postfix_index_length..];\n\
    \   |                                  +\n\nerror[E0599]: `str` is not an iterator\n\
    \  --> /tmp/tmpr3sark6w.rs:31:42\n   |\n31 |                     if prefix ==\
    \ postfix.rev() {\n   |                                          ^^^ `str` is\
    \ not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `str: Iterator`\n           which is required by `&mut str: Iterator`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpr3sark6w.rs:33:43\n   |\n15 |\
    \     let mut longest_postfix = \"\";\n   |                               -- expected\
    \ due to this value\n...\n33 |                         longest_postfix = postfix;\n\
    \   |  "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut palindrome = string;\n    let mut suffix\
    \ = string;\n    let mut prefix_len = 0;\n    while !suffix.is_empty() {\n   \
    \     let mut suffix_len = suffix.len();\n        while suffix_len > 0 {\n   \
    \         let mut suffix_char = suffix.chars().nth(suffix_len).unwrap();\n   \
    \         if suffix_char == suffix.chars().nth(suffix_len - 1).unwrap() {\n  \
    \              suffix_len -= 1;\n            } else {\n                break;\n\
    \            }\n        }\n        if suffix_len > 0 {\n            suffix.push_str(&suffix.chars().nth(suffix_len).unwrap());\n\
    \        }\n        let mut suffix_len = suffix.len();\n        while suffix_len\
    \ > 0 {\n            let mut suffix_char = suffix.chars().nth(suffix_len).unwrap();\n\
    \            if suffix_char == suffix.chars().nth(suffix_len - 1).unwrap() {\n\
    \                suffix_len -= 1;\n            } else {\n                break;\n\
    \            }\n        }\n        if suffix_len > 0 {\n            suffix.push_str(&suffix.chars().nth(suffix_len).unwrap());\n\
    \        }\n        let mut suffix_len = suffix.len();\n        while suffix_len\
    \ > 0 {\n            let mut suffix_char = suffix.chars().nth(suffix_len).unwrap();\n\
    \            if suffix_char == suffix.chars().nth(suffix_len - 1).unwrap() {\n\
    \                suffix_len -= 1;\n            } else {\n                break;\n\
    \            }\n        }\n        if suffix_len > 0 {\n            suffix.push_str(&suffix.chars().nth(suffix_len).unwrap());\n\
    \        }\n        let mut suffix_len = suffix.len();\n        while suffix_len\
    \ > 0 {\n            let mut suffix_char = suffix.chars().nth(suffix_len).unwrap();\n\
    \            if suffix_char == suffix.chars().nth(suffix_len - 1).unwrap() {\n\
    \                suffix_len -= 1;\n            } else {\n                break;\n\
    \            }\n        }\n        if suffix_len > 0 {\n            suffix.push_str(&suffix.chars().nth(suffix_len).unwrap());\n\
    \        }\n        let mut suffix_len = suffix.len();\n        while suffix_len\
    \ > 0 {\n            let mut suffix_char = suffix.chars().nth(suffix_len).unwrap();\n\
    \            if suffix_char == suffix.chars().nth(suffix_len - 1).unwrap() {\n\
    \                suffix_len -= 1;\n            } else {\n                break;\n\
    \            }\n        }\n        if suffix_len > 0 {\n            suffix.push_str(&suffi\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp45zf2_6_.rs:85:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n16 |     while !suffix.is_empty()\
    \ {\n   |                              - unclosed delimiter\n...\n74 |       \
    \  if suffix_len > 0 {\n   |                           - this delimiter might\
    \ not be properly closed...\n75 |             suffix.push_str(&suffi\n76 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n85 | }\n\
    \   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp45zf2_6_.rs:75:28\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - closing delimiter possibly meant for this\n\
    ...\n75 |             suffix.push_str(&suffi\n   |                           \
    \ ^ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0425]:\
    \ cannot find value `suffi` in this scope\n  --> /tmp/tmp45zf2_6_.rs:75:30\n \
    \  |\n75 |             suffix.push_str(&suffi\n   |                          \
    \    ^^^^^ help: a local variable with a similar name exists: `suffix`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp45zf2_6_.rs:27:29\n   |\n27 |             suffix.push_str(&suffix.chars().nth(suffix_len).unwrap());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp45zf2_6_.rs:39:29\n\
    \   |\n39 |             suffix.push_str(&suffix.chars().nth(suffix_len).unwrap());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp45zf2_6_.rs:51:29\n\
    \   |\n51 |             suffix.push_str(&suffix.chars().nth(suffix_len).unwrap());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `str`, found `char`"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_length = 0;\n    let\
    \ mut prefix_length = 0;\n    while !reversed_string.is_empty() {\n        let\
    \ mut current_char = reversed_string[0];\n        reversed_string = reversed_string.chars().skip_while(|c|\
    \ c != current_char).collect();\n        reverse_length += 1;\n        if reverse_length\
    \ == string.len() {\n            break;\n        }\n        if current_char ==\
    \ string[prefix_length] {\n            prefix_length += 1;\n        }\n    }\n\
    \    prefix_length\n        .checked_add(reverse_length)\n        .and_then(|length|\
    \ {\n            let mut reversed_string = string;\n            let mut reverse_length\
    \ = 0;\n            let mut prefix_length = 0;\n            while !reversed_string.is_empty()\
    \ {\n                let mut current_char = reversed_string[0];\n            \
    \    reversed_string = reversed_string.chars().skip_while(|c| c != current_char).collect();\n\
    \                reverse_length += 1;\n                if reverse_length == string.len()\
    \ {\n                    break;\n                }\n                if current_char\
    \ == string[prefix_length] {\n                    prefix_length += 1;\n      \
    \          }\n            }\n            prefix_length\n        })\n        .and_then(|length|\
    \ {\n            let mut reversed_string = string;\n            let mut reverse_length\
    \ = 0;\n            let mut prefix_length = 0;\n            while !reversed_string.is_empty()\
    \ {\n                let mut current_char = reversed_string[0];\n            \
    \    reversed_string = reversed_string.chars().skip_while(|c| c != current_char).collect();\n\
    \                reverse_length += 1;\n                if reverse_length == string.len()\
    \ {\n                    break;\n                }\n                if current_char\
    \ == string[prefix_length] {\n                    prefix_length += 1;\n      \
    \          }\n            }\n            prefix_length\n        })\n        .and_then(|length|\
    \ {\n            let mut reversed_string = string;\n            let mut reverse_length\
    \ = 0;\n            let mut prefix_length = 0;\n            while !reversed_string.is_empty()\
    \ {\n                let mut current_char = reversed_string[0];\n            \
    \    reversed_string = reversed_string.chars().skip_while(|c| c != current_char).collect();\n\
    \                reverse_length += 1;\n                if reverse_length == string.len()\
    \ {\n                    break;\n                }\n                if current_char\
    \ == string[prefix_length] {\n                    prefix_length += 1;\n      \
    \          }\n            }\n            prefix_length\n        })\n        .and_then(|length|\
    \ {\n            let mut reversed_string = string;\n            let mut reverse_length\
    \ = 0;\n            let mut prefix_length = 0;\n            while !reversed_string.is_empty()\
    \ {\n                let mut current_char = reversed_string[0];\n            \
    \    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpg2v2lg5z.rs:95:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n79 |         .and_then(|length|\
    \ {\n   |                  -         - unclosed delimiter\n   |              \
    \    |\n   |                  unclosed delimiter\n...\n83 |             while\
    \ !reversed_string.is_empty() {\n   |                                        \
    \       - this delimiter might not be properly closed...\n...\n86 | }\n   | -\
    \ ...as it matches this but it has different indentation\n...\n95 | }\n   |  \
    \ ^\n\nerror[E0425]: cannot find value `reverse` in this scope\n  --> /tmp/tmpg2v2lg5z.rs:85:17\n\
    \   |\n85 |                 reverse\n   |                 ^^^^^^^ not found in\
    \ this scope\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpg2v2lg5z.rs:16:32\n   |\n16 |         let mut current_char = reversed_string[0];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpg2v2lg5z.rs:22:28\n   |\n22 |         if current_char == string[prefix_length]\
    \ {\n   |                            ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<Range"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut suffix_length = 0;\n    let\
    \ mut prefix_length = 0;\n    while suffix_length != 0 || prefix_length != 0 {\n\
    \        if suffix_length == 0 {\n            suffix_length = string.len();\n\
    \        }\n        if prefix_length == 0 {\n            prefix_length = string.len()\
    \ - suffix_length;\n        }\n        let mut suffix_postfix = &string[suffix_length..];\n\
    \        let mut prefix_postfix = &string[prefix_length..];\n        let mut suffix_reversed_string\
    \ = reverse(&suffix_postfix);\n        let mut prefix_reversed_string = reverse(&prefix_postfix);\n\
    \        if suffix_reversed_string == prefix_reversed_string {\n            suffix_length\
    \ -= 1;\n            prefix_length -= 1;\n            suffix_postfix = &string[suffix_length..];\n\
    \            prefix_postfix = &string[prefix_length..];\n            suffix_reversed_string\
    \ = reverse(&suffix_postfix);\n            prefix_reversed_string = reverse(&prefix_postfix);\n\
    \        }\n        reversed_string = reversed_string\n            .split_last_mut()\n\
    \            .chain(suffix_reversed_string.split_last_mut())\n            .chain(prefix_reversed_string.split_last_mut())\n\
    \            .collect();\n    }\n    reversed_string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmpsvmiiti3.rs:24:42\n\
    \   |\n24 |         let mut suffix_reversed_string = reverse(&suffix_postfix);\n\
    \   |                                          ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmpsvmiiti3.rs:25:42\n\
    \   |\n25 |         let mut prefix_reversed_string = reverse(&prefix_postfix);\n\
    \   |                                          ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmpsvmiiti3.rs:31:38\n\
    \   |\n31 |             suffix_reversed_string = reverse(&suffix_postfix);\n \
    \  |                                      ^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `reverse` in this scope\n  --> /tmp/tmpsvmiiti3.rs:32:38\n\
    \   |\n32 |             prefix_reversed_string = reverse(&prefix_postfix);\n \
    \  |                                      ^^^^^^^ not found in this scope\n\n\
    error[E0599]: no method named `split_last_mut` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpsvmiiti3.rs:35:14\n   |\n35 |             .split_last_mut()\n\
    \   |              ^^^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `split_at`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut i =\
    \ 0;\n    while i < string.len() {\n        let mut j = i;\n        while j +\
    \ 1 < string.len() && string[j] == string[j + 1] {\n            j += 1\n     \
    \   }\n        reverse.push_str(&string[i..j]);\n        i = j;\n    }\n    reverse\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9_t7vix0.rs:17:39\n\
    \   |\n17 |         while j + 1 < string.len() && string[j] == string[j + 1] {\n\
    \   |                                       ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9_t7vix0.rs:17:52\n   |\n17 |         while j + 1 < string.len()\
    \ && string[j] == string[j + 1] {\n   |                                      \
    \              ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = string;\n    let mut palindrome = string;\n    let mut\
    \ suffix_length = 0;\n    while palindrome.len() > 0 {\n        let mut suffix_length\
    \ = 0;\n        for ch in reverse.chars() {\n            if ch != palindrome[suffix_length]\
    \ {\n                break;\n            }\n            suffix_length += 1;\n\
    \        }\n        palindrome = &palindrome[..suffix_length];\n        reverse\
    \ = &reverse[..suffix_length];\n    }\n    palindrome\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpqbbyptqw.rs:18:22\n   |\n18 |             if ch != palindrome[suffix_length]\
    \ {\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqbbyptqw.rs:23:22\n\
    \   |\n13 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n23 |         palindrome = &palindrome[..suffix_length];\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n23 |        \
    \ palindrome = (&palindrome[..suffix_length]).to_string();\n   |             \
    \         +                            +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqbbyptqw.rs:24:19\n   |\n12 |     let mut reverse = string;\n\
    \   |                       ------ expected due to this value\n...\n24 |     \
    \    reverse = &reverse[..suffix_length];\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n24 |         reverse = (&reverse[..suffix_length]).to_string();\n   | \
    \                  +                         +++++++++++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_length = 0;\n    let\
    \ mut longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n  \
    \  let mut longest_postfix_chars = String::new();\n    let mut longest_postfix_char_index\
    \ = 0;\n    let mut longest_postfix_char_length = 0;\n    let mut longest_postfix_char_length_index\
    \ = 0;\n    let mut longest_postfix_char_length_reverse = 0;\n    let mut longest_postfix_char_length_reverse_index\
    \ = 0;\n    let mut longest_postfix_char_length_reverse_chars = String::new();\n\
    \    let mut longest_postfix_char_length_reverse_char_index = 0;\n    let mut\
    \ longest_postfix_char_length_reverse_char_index = 0;\n    let mut longest_postfix_char_length_reverse_char_index\
    \ = 0;\n    let mut longest_postfix_char_length_reverse_char_index = 0;\n    let\
    \ mut longest_postfix_char_length_reverse_char_index = 0;\n    let mut longest_postfix_char_length_reverse_char_index\
    \ = 0;\n    let mut longest_postfix_char_length_reverse_char_index = 0;\n    let\
    \ mut longest_postfix_char_length_reverse_char_index = 0;\n    let mut longest_postfix_char_length_reverse_char_index\
    \ = 0;\n    let mut longest_postfix_char_length_reverse_char_index = 0;\n    let\
    \ mut longest_postfix_char_length_reverse_char_index = 0;\n    let mut longest_postfix_char_length_reverse_char_index\
    \ = 0;\n    let mut longest_postfix_char_length_reverse_char_index = 0;\n    let\
    \ mut longest_postfix_char_length_reverse_char_index = 0;\n    let mut longest_postfix_char_length_reverse_char_index\
    \ = 0;\n    let mut longest_postfix_char_length_reverse_char_index = 0;\n    let\
    \ mut longest_postfix_char_length_reverse_char_index = 0;\n    let mut longest_postfix_char_length_reverse_char_index\
    \ = 0;\n    let mut longest_postfix_char_length_reverse_char_index = 0;\n    let\
    \ mut longest_postfix_char_length_reverse_char_index = 0;\n    let mut longest_postfix_char_length_reverse_char_index\
    \ = 0;\n    let mut longest_postfix_char_length_reverse_char_index = 0;\n    let\
    \ mut longest_postfix_char_length_reverse_char_index = 0;\n    let mut longest_postfix_char_length_reverse_char_index\
    \ = 0;\n    let mut longest_postfix_char_length_reverse_char_index = 0;\n    let\
    \ mut longest_postfix_char_length\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpld5ss5zx.rs:48:40\n   |\n\
    48 |     let mut longest_postfix_char_length\n   |                           \
    \             ^ help: add `;` here\n49 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpld5ss5zx.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut reverse_length = 0;\n    let mut longest_postfix_length = 0;\n    while\
    \ !string.is_empty() {\n        let mut postfix_length = string.len();\n     \
    \   while postfix_length >= longest_postfix_length {\n            let mut postfix\
    \ = &mut string[reverse_length..];\n            let mut postfix_reverse = &mut\
    \ reversed_string[reverse_length..];\n            while postfix.len() > 0 {\n\
    \                let mut char = postfix.pop();\n                postfix_reverse.push(char);\n\
    \                if char == char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp2xu443bm.rs:34:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n16 |     while !string.is_empty()\
    \ {\n   |                              - unclosed delimiter\n17 |         let\
    \ mut postfix_length = string.len();\n18 |         while postfix_length >= longest_postfix_length\
    \ {\n   |                                                        - unclosed delimiter\n\
    ...\n21 |             while postfix.len() > 0 {\n   |                        \
    \             - this delimiter might not be properly closed...\n...\n25 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n34 | }\n\
    \   |   ^\n\nerror: expected identifier, found `)`\n  --> /tmp/tmp2xu443bm.rs:25:1\n\
    \   |\n25 | }\n   | ^ expected identifier\n\nerror: expected `{`, found `}`\n\
    \  --> /tmp/tmp2xu443bm.rs:25:1\n   |\n24 |                 if char == char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char:...\n\
    \   |                 -- this `if` expression has a condition, but no block\n\
    25 | }\n   | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp2xu443bm.rs:24:1467\n   |\n11 | fn make_palindrome(string: String) ->\
    \ String {\n   |                                              - closing delimiter\
    \ possibly meant for this\n...\n24 |                 if char == char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(char::from_u32(cha"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut i = 0;\n    while i < string.len() {\n        let mut j = i;\n        while\
    \ j < string.len() && string[j] != string[string.len() - j] {\n            j =\
    \ j + 1;\n        }\n        reversed_string = reversed_string\n            .chars()\n\
    \            .skip(i)\n            .take(j)\n            .collect();\n       \
    \ i = j;\n    }\n    string = reversed_string;\n    string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvawe5mpn.rs:17:35\n\
    \   |\n17 |         while j < string.len() && string[j] != string[string.len()\
    \ - j] {\n   |                                   ^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvawe5mpn.rs:17:48\n   |\n17 |         while j < string.len() &&\
    \ string[j] != string[string.len() - j] {\n   |                              \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_length = 0;\n    while\
    \ !reversed_string.is_empty() {\n        let mut index = reversed_string.len()\
    \ - 1;\n        while index >= 0 {\n            if reversed_string[index] != reversed_string[index].to_lowercase().rev()\
    \ {\n                break;\n            }\n            index -= 1;\n        }\n\
    \        reverse_length += 1;\n        reversed_string = reversed_string[..index].to_lowercase()\
    \ + reversed_string[index..].to_lowercase();\n    }\n    reversed_string\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp81qxhl5p.rs:17:16\n\
    \   |\n17 |             if reversed_string[index] != reversed_string[index].to_lowercase().rev()\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp81qxhl5p.rs:17:42\n   |\n17 |             if reversed_string[index]\
    \ != reversed_string[index].to_lowercase().rev() {\n   |                     \
    \                     ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp81qxhl5p.rs:23:69\n\
    \   |\n23 |         reversed_string = reversed_string[..index].to_lowercase()\
    \ + reversed_string[index..].to_lowercase();\n   |                           \
    \                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                                                     |\n\
    \   |                                                                     expected\
    \ `&str`, found struct `String`\n   |                                        \
    \    "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_len = 0;\n\
    \    let mut longest_postfix_len = 0;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start_index\
    \ = -1;\n    let mut longest_postfix_end_index = -1;\n    let mut longest_postfix_start_index2\
    \ = 0;\n    let mut longest_postfix_end_index2 = 0;\n    let mut longest_postfix_start_index3\
    \ = 0;\n    let mut longest_postfix_end_index3 = 0;\n    let mut longest_postfix_start_index4\
    \ = 0;\n    let mut longest_postfix_end_index4 = 0;\n    let mut longest_postfix_start_index5\
    \ = 0;\n    let mut longest_postfix_end_index5 = 0;\n    let mut longest_postfix_start_index6\
    \ = 0;\n    let mut longest_postfix_end_index6 = 0;\n    let mut longest_postfix_start_index7\
    \ = 0;\n    let mut longest_postfix_end_index7 = 0;\n    let mut longest_postfix_start_index8\
    \ = 0;\n    let mut longest_postfix_end_index8 = 0;\n    let mut longest_postfix_start_index9\
    \ = 0;\n    let mut longest_postfix_end_index9 = 0;\n    let mut longest_postfix_start_index10\
    \ = 0;\n    let mut longest_postfix_end_index10 = 0;\n    let mut longest_postfix_start_index11\
    \ = 0;\n    let mut longest_postfix_end_index11 = 0;\n    let mut longest_postfix_start_index12\
    \ = 0;\n    let mut longest_postfix_end_index12 = 0;\n    let mut longest_postfix_start_index13\
    \ = 0;\n    let mut longest_postfix_end_index13 = 0;\n    let mut longest_postfix_start_index14\
    \ = 0;\n    let mut longest_postfix_end_index14 = 0;\n    let mut longest_postfix_start_index15\
    \ = 0;\n    let mut longest_postfix_end_index15 = 0;\n    let mut longest_postfix_start_index16\
    \ = 0;\n    let mut longest_postfix_end_index16 = 0;\n    let mut longest_postfix_start_index17\
    \ = 0;\n    let mut longest_postfix_end_index17 = 0;\n    let mut longest_postfix_start_index18\
    \ = 0;\n    let mut longest_postfix_end_index18 = 0;\n    let mut longest_postfix_start_index19\
    \ = 0;\n    let mut longest_postfix_end_index19 = 0;\n    let mut longest_postfix_start_index20\
    \ = 0;\n    let mut longest_postfix_\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphlz6wbpg.rs:56:29\n   |\n\
    56 |     let mut longest_postfix_\n   |                             ^ help: add\
    \ `;` here\n57 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphlz6wbpg.rs:11:39\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_end\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpelq0fepp.rs:63:32\n   |\n\
    63 |     let mut longest_postfix_end\n   |                                ^ help:\
    \ add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpelq0fepp.rs:11:39\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    let mut longest_postfix_start = -1;\n    for pos in string.char_indices()\
    \ {\n        let (prefix, suffix) = string.split_at(pos);\n        let prefix_length\
    \ = prefix.len();\n        if prefix_length > longest_postfix_length {\n     \
    \       longest_postfix_length = prefix_length;\n            longest_postfix_start\
    \ = pos;\n        }\n        let suffix_length = suffix.len();\n        if suffix_length\
    \ > longest_postfix_length {\n            longest_postfix_length = suffix_length;\n\
    \            longest_postfix_start = pos;\n        }\n    }\n    let mut reversed_prefix\
    \ = &string[longest_postfix_start..];\n    reversed_prefix.reverse();\n    let\
    \ mut reversed_suffix = &string[longest_postfix_start..];\n    reversed_suffix.reverse();\n\
    \    String::from(\n        &string[longest_postfix_start..longest_postfix_start\
    \ + longest_postfix_length]\n            .join(&reversed_prefix)\n           \
    \ .join(&reversed_suffix),\n    )\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpak03ctt2.rs:16:48\n   |\n\
    16 |         let (prefix, suffix) = string.split_at(pos);\n   |              \
    \                                  ^^^ expected `usize`, found tuple\n   |\n \
    \  = note: expected type `usize`\n             found tuple `(usize, char)`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpak03ctt2.rs:20:37\n   |\n14 |  \
    \   let mut longest_postfix_start = -1;\n   |                                \
    \     -- expected due to this value\n...\n20 |             longest_postfix_start\
    \ = pos;\n   |                                     ^^^ expected integer, found\
    \ tuple\n   |\n   = note: expected type `{integer}`\n             found tuple\
    \ `(usize, char)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpak03ctt2.rs:25:37\n\
    \   |\n14 |     let mut longest_postfix_start = -1;\n   |                    \
    \                 -- expected due to this value\n...\n25 |             longest_postfix_start\
    \ = pos;\n   |                                     ^^^ expected integer, found\
    \ tuple\n   |\n   = note: expected type `{integer}`\n             found tuple\
    \ `(usize, char)`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpak03ctt2.rs:14:37\n   |\n14 |     let mut longest_postfix_start\
    \ = -1;\n   |                                     ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0599]: no method named `reverse` found for\
    \ reference `&str` in the current scope\n  --> /tmp/tmpak03ctt2.rs:29:21\n   |\n\
    29 |     reversed_prefix.reverse();\n   |                     ^^^^^^^ method not\
    \ found in `&str`\n\nerror[E0599]: no method named `reverse` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpak03ctt2.rs:31:21\n   |\n31 |   \
    \  reversed_suffix.reverse();\n   |                     ^^^^^^^ method not found\
    \ in `&str`\n\nerror[E0599]: no method named `join` found for type `str`"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    while !string.is_empty() {\n        let mut\
    \ postfix_length = 0;\n        for c in string.chars() {\n            if !c.is_alphanumeric()\
    \ {\n                postfix_length += 1;\n            }\n        }\n        if\
    \ postfix_length > longest_postfix_length {\n            longest_postfix_length\
    \ = postfix_length;\n        }\n        let mut postfix_start = longest_postfix_length\
    \ - postfix_length;\n        for c in string.chars() {\n            if !c.is_alphanumeric()\
    \ {\n                postfix_start += 1;\n            }\n        }\n        reversed_string\
    \ += &string[postfix_start..postfix_length];\n        string = &string[postfix_length..];\n\
    \    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n  --> /tmp/tmpfixepoau.rs:31:9\n   |\n31 |         reversed_string +=\
    \ &string[postfix_start..postfix_length];\n   |         ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfixepoau.rs:32:18\n   |\n12 |     let mut string\
    \ = string;\n   |                      ------ expected due to this value\n...\n\
    32 |         string = &string[postfix_length..];\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n32 |         string = (&string[postfix_length..]).to_string();\n   |  \
    \                +                         +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfixepoau.rs:34:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n34 |     reversed_string\n   |     ^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut reversed_string = string;\n   \
    \ let mut last_char: char;\n    let mut last_char_index: usize;\n    let mut first_char:\
    \ char;\n    let mut first_char_index: usize;\n    let mut last_char_is_palindrome:\
    \ &mut bool;\n    let mut first_char_is_palindrome: &mut bool;\n    let mut last_char_is_palindrome_backwards:\
    \ &mut bool;\n    let mut first_char_is_palindrome_backwards: &mut bool;\n   \
    \ let mut last_char_is_palindrome_forwards: &mut bool;\n    let mut first_char_is_palindrome_forwards:\
    \ &mut bool;\n    let mut last_char_is_palindrome_backwards_forwards: &mut bool;\n\
    \    let mut first_char_is_palindrome_backwards_forwards: &mut bool;\n    let\
    \ mut last_char_is_palindrome_backwards_forwards_backwards: &mut bool;\n    let\
    \ mut first_char_is_palindrome_backwards_forwards_backwards: &mut bool;\n    let\
    \ mut last_char_is_palindrome_backwards_forwards_backwards_backwards: &mut bool;\n\
    \    let mut first_char_is_palindrome_backwards_forwards_backwards_backwards:\
    \ &mut bool;\n    let mut last_char_is_palindrome_backwards_forwards_backwards_backwards_backwards:\
    \ &mut bool;\n    let mut first_char_is_palindrome_backwards_forwards_backwards_backwards_backwards:\
    \ &mut bool;\n    let mut last_char_is_palindrome_backwards_forwards_backwards_backwards_backwards_backwards:\
    \ &mut bool;\n    let mut first_char_is_palindrome_backwards_forwards_backwards_backwards_backwards_backwards:\
    \ &mut bool;\n    let mut last_char_is_palindrome_backwards_forwards_backwards_backwards_backwards_backwards_backwards:\
    \ &mut bool;\n    let mut first_char_is_palindrome_backwards_forwards_backwards_backwards_backwards_backwards_backwards_backwards:\
    \ &mut bool;\n    let mut last_char_is_palindrome_backwards_forwards_backwards_backwards_backwards_backwards_backwards_backwards:\
    \ &mut bool;\n    let mut first_char_is_palindrome_backwards_forwards_backwards_\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjz9wdv3y.rs:37:67\n   |\n\
    37 |     let mut first_char_is_palindrome_backwards_forwards_backwards_\n   |\
    \                                                                   ^ help: add\
    \ `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjz9wdv3y.rs:11:39\n   |\n11 | fn make_palindrome(string: String)\
    \ -> String {\n   |    ---------------                    ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    let mut longest_postfix_index = 0;\n    let mut longest_postfix_string =\
    \ \"\";\n    while longest_postfix_length < string.len() {\n        let mut postfix_length\
    \ = longest_postfix_length;\n        let mut postfix_index = longest_postfix_index;\n\
    \        let mut postfix_string = longest_postfix_string;\n        for index in\
    \ 0..string.len() - longest_postfix_length {\n            let mut current_char\
    \ = string[index + longest_postfix_length];\n            let mut current_char_length\
    \ = string[index + longest_postfix_length].len();\n            while current_char_length\
    \ > 0 {\n                if current_char != string[index + longest_postfix_length\
    \ + current_char_length] {\n                    break;\n                }\n  \
    \              current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= 1;\n                current_char_length\
    \ -= 1;\n                current_char_length -= \n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpnzsoa8cw.rs:95:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n16 |     while longest_postfix_length\
    \ < string.len() {\n   |                                                 - unclosed\
    \ delimiter\n...\n20 |         for index in 0..string.len() - longest_postfix_length\
    \ {\n   |                                                               - unclosed\
    \ delimiter\n...\n23 |             while current_char_length > 0 {\n   |     \
    \                                      - this delimiter might not be properly\
    \ closed...\n...\n86 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n95 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpnzsoa8cw.rs:86:1\n\
    \   |\n86 | }\n   | ^ expected expression\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpnzsoa8cw.rs:21:36\n   |\n21 |         \
    \    let mut current_char = string[index + longest_postfix_length];\n   |    \
    \                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpnzsoa8cw.rs:22:43\n   |\n22 |             let mut current_char_length\
    \ = string[index + longest_postfix_length].len();\n   |                      \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    while\
    \ let Some(index) = string.rfind('a') {\n        let mut postfix_length = index\
    \ - longest_postfix_index;\n        if postfix_length > longest_postfix_length\
    \ {\n            longest_postfix_length = postfix_length;\n            longest_postfix_index\
    \ = index;\n        }\n        string = &string[index..];\n    }\n    let mut\
    \ postfix_length = longest_postfix_index - longest_postfix_length;\n    if postfix_length\
    \ > 0 {\n        reversed_string = &string[longest_postfix_length..];\n    }\n\
    \    string += &reversed_string[..postfix_length];\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7etggdwi.rs:22:18\n   |\n\
    12 |     let mut string = string;\n   |                      ------ expected due\
    \ to this value\n...\n22 |         string = &string[index..];\n   |          \
    \        ^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp:\
    \ try using a conversion method\n   |\n22 |         string = (&string[index..]).to_string();\n\
    \   |                  +                +++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_len2\
    \ = 0;\n    let mut longest_postfix_len3 = 0;\n    let mut longest_postfix_len4\
    \ = 0;\n    let mut longest_postfix_len5 = 0;\n    let mut longest_postfix_len6\
    \ = 0;\n    let mut longest_postfix_len7 = 0;\n    let mut longest_postfix_len8\
    \ = 0;\n    let mut longest_postfix_len9 = 0;\n    let mut longest_postfix_len10\
    \ = 0;\n    let mut longest_postfix_len11 = 0;\n    let mut longest_postfix_len12\
    \ = 0;\n    let mut longest_postfix_len13 = 0;\n    let mut longest_postfix_len14\
    \ = 0;\n    let mut longest_postfix_len15 = 0;\n    let mut longest_postfix_len16\
    \ = 0;\n    let mut longest_postfix_len17 = 0;\n    let mut longest_postfix_len18\
    \ = 0;\n    let mut longest_postfix_len19 = 0;\n    let mut longest_postfix_len20\
    \ = 0;\n    let mut longest_postfix_len21 = 0;\n    let mut longest_postfix_len22\
    \ = 0;\n    let mut longest_postfix_len23 = 0;\n    let mut longest_postfix_len24\
    \ = 0;\n    let mut longest_postfix_len25 = 0;\n    let mut longest_postfix_len26\
    \ = 0;\n    let mut longest_postfix_len27 = 0;\n    let mut longest_postfix_len28\
    \ = 0;\n    let mut longest_postfix_len29 = 0;\n    let mut longest_postfix_len30\
    \ = 0;\n    let mut longest_postfix_len31 = 0;\n    let mut longest_postfix_len32\
    \ = 0;\n    let mut longest_postfix_len33 = 0;\n    let mut longest_postfix_len34\
    \ = 0;\n    let mut longest_postfix_len35 = 0;\n    let mut longest_postfix_len36\
    \ = 0;\n    let mut longest_postfix_len37 = 0;\n    let mut longest_postfix_len38\
    \ = 0;\n    let mut longest_postfix_len39 = 0;\n    let mut longest_postfix_len40\
    \ = 0;\n    let mut longest_postfix_len41 = 0;\n    let mut longest_postfix_len42\
    \ = 0;\n    let mut longest_postfix_len43 = 0;\n    let mut longest_postfix_len44\
    \ = 0;\n    let mut longest_postfix_len45\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp19i240ne.rs:59:34\n   |\n\
    59 |     let mut longest_postfix_len45\n   |                                 \
    \ ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp19i240ne.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_len = 0;\n\
    \    let mut longest_postfix_len = 0;\n    let mut longest_postfix = \"\";\n\n\
    \    while !reversed_string.is_empty() {\n        let mut postfix_len = reversed_string.len();\n\
    \        let mut postfix = reversed_string.clone();\n        let mut i = 0;\n\
    \        while i < postfix_len {\n            if postfix_len > longest_postfix_len\
    \ {\n                longest_postfix_len = postfix_len;\n                longest_postfix\
    \ = postfix.clone();\n            }\n            i += 1;\n            postfix.next();\n\
    \        }\n        reversed_string = postfix.clone();\n        reversed_string_len\
    \ += 1;\n    }\n\n    longest_postfix.reverse();\n    longest_postfix.append(&reversed_string[..]);\n\
    \    longest_postfix_len\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp05e5xnxn.rs:24:35\n   |\n\
    15 |     let mut longest_postfix = \"\";\n   |                               --\
    \ expected due to this value\n...\n24 |                 longest_postfix = postfix.clone();\n\
    \   |                                   ^^^^^^^^^^^^^^^\n   |                \
    \                   |\n   |                                   expected `&str`,\
    \ found struct `String`\n   |                                   help: consider\
    \ borrowing here: `&postfix`\n\nerror[E0599]: no method named `next` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp05e5xnxn.rs:27:21\n   |\n\
    27 |             postfix.next();\n   |                     ^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `reverse` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmp05e5xnxn.rs:33:21\n   |\n33 |     longest_postfix.reverse();\n\
    \   |                     ^^^^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `append` found for reference `&str` in the current scope\n \
    \ --> /tmp/tmp05e5xnxn.rs:34:21\n   |\n34 |     longest_postfix.append(&reversed_string[..]);\n\
    \   |                     ^^^^^^ method not found in `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp05e5xnxn.rs:35:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n35 |     longest_postfix_len\n   |   \
    \  ^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `usize`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    while\
    \ !reversed_string.starts_with(string) {\n        reversed_string = reversed_string[..prefix_length];\n\
    \        prefix_length += 1;\n    }\n    reversed_string += &string[prefix_length..];\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpknfjsfij.rs:14:40\n     |\n14   |     while !reversed_string.starts_with(string)\
    \ {\n     |                            ----------- ^^^^^^ expected an implementor\
    \ of trait `Pattern<'_>`\n     |                            |\n     |        \
    \                    required by a bound introduced by this call\n     |\n   \
    \  = note: the trait bound `String: Pattern<'_>` is not satisfied\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `String`\n\
    note: required by a bound in `core::str::<impl str>::starts_with`\nhelp: consider\
    \ borrowing here\n     |\n14   |     while !reversed_string.starts_with(&string)\
    \ {\n     |                                        +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpknfjsfij.rs:15:27\n   |\n12 |     let mut reversed_string\
    \ = string;\n   |                               ------ expected due to this value\n\
    ...\n15 |         reversed_string = reversed_string[..prefix_length];\n   |  \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                           |\n   |  \
    \                         expected struct `String`, found `str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut longest\
    \ = 0;\n    while !string.is_empty() {\n        let mut i = 0;\n        while\
    \ i < string.len() && string[i] == string[string.len() - 1 - i] {\n          \
    \  i += 1;\n        }\n        if i == 0 {\n            break;\n        }\n  \
    \      let mut j = string.len() - 1;\n        while j > 0 && string[j] == string[string.len()\
    \ - 1 - j] {\n            j -= 1;\n        }\n        if j == 0 {\n          \
    \  break;\n        }\n        if i > j {\n            longest = i;\n         \
    \   reverse.push_str(&string[j..]);\n        } else {\n            longest = j;\n\
    \            reverse.push_str(&string[i..]);\n        }\n        string = &string[longest\
    \ + longest..];\n    }\n    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgm59u2of.rs:17:35\n\
    \   |\n17 |         while i < string.len() && string[i] == string[string.len()\
    \ - 1 - i] {\n   |                                   ^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgm59u2of.rs:17:48\n   |\n17 |         while i < string.len() &&\
    \ string[i] == string[string.len() - 1 - i] {\n   |                          \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgm59u2of.rs:24:24\n   |\n24 |         while j > 0 && string[j]\
    \ == string[string.len() - 1 - j] {\n   |                        ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_pos\
    \ = 0;\n    let mut longest_postfix_len2 = 0;\n    let mut longest_postfix_pos2\
    \ = 0;\n    let mut longest_postfix_len3 = 0;\n    let mut longest_postfix_pos3\
    \ = 0;\n    let mut longest_postfix_len4 = 0;\n    let mut longest_postfix_pos4\
    \ = 0;\n    let mut longest_postfix_len5 = 0;\n    let mut longest_postfix_pos5\
    \ = 0;\n    let mut longest_postfix_len6 = 0;\n    let mut longest_postfix_pos6\
    \ = 0;\n    let mut longest_postfix_len7 = 0;\n    let mut longest_postfix_pos7\
    \ = 0;\n    let mut longest_postfix_len8 = 0;\n    let mut longest_postfix_pos8\
    \ = 0;\n    let mut longest_postfix_len9 = 0;\n    let mut longest_postfix_pos9\
    \ = 0;\n    let mut longest_postfix_len10 = 0;\n    let mut longest_postfix_pos10\
    \ = 0;\n    let mut longest_postfix_len11 = 0;\n    let mut longest_postfix_pos11\
    \ = 0;\n    let mut longest_postfix_len12 = 0;\n    let mut longest_postfix_pos12\
    \ = 0;\n    let mut longest_postfix_len13 = 0;\n    let mut longest_postfix_pos13\
    \ = 0;\n    let mut longest_postfix_len14 = 0;\n    let mut longest_postfix_pos14\
    \ = 0;\n    let mut longest_postfix_len15 = 0;\n    let mut longest_postfix_pos15\
    \ = 0;\n    let mut longest_postfix_len16 = 0;\n    let mut longest_postfix_pos16\
    \ = 0;\n    let mut longest_postfix_len17 = 0;\n    let mut longest_postfix_pos17\
    \ = 0;\n    let mut longest_postfix_len18 = 0;\n    let mut longest_postfix_pos18\
    \ = 0;\n    let mut longest_postfix_len19 = 0;\n    let mut longest_postfix_pos19\
    \ = 0;\n    let mut longest_postfix_len20 = 0;\n    let mut longest_postfix_pos20\
    \ = 0;\n    let mut longest_postfix_len21 = 0;\n    let mut longest_postfix_pos21\
    \ = 0;\n    let mut longest_postfix_len22 = 0;\n    let mut longest_postfix_pos22\
    \ = 0;\n    let mut longest_postfix_len23 = 0;\n    let mut \n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmppsk_hg5n.rs:61:1\n\
    \   |\n61 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_size = string.len();\n\
    \    let mut i = 0;\n    while i < reversed_string_size {\n        let mut j =\
    \ reversed_string_size - 1;\n        while j >= i {\n            if reversed_string[j]\
    \ != string[i] {\n                break;\n            }\n            j -= 1;\n\
    \        }\n        reversed_string = reversed_string\n            .split_last_mut()\n\
    \            .unwrap()\n            .reverse()\n            .collect();\n    \
    \    reversed_string_size -= 1;\n        i += 1;\n    }\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_lqocwwk.rs:18:16\n\
    \   |\n18 |             if reversed_string[j] != string[i] {\n   |           \
    \     ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_lqocwwk.rs:18:38\n   |\n18 |             if reversed_string[j]\
    \ != string[i] {\n   |                                      ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `split_last_mut` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp_lqocwwk.rs:24:14\n   |\n24 | \
    \            .split_last_mut()\n   |              ^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `split_at`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_length_index = 0;\n\
    \    let mut longest_postfix_length_palindrome = 0;\n    let mut longest_postfix_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length = 0;\n    let mut\
    \ longest_postfix_length_palindrome_length_index = 0;\n    let mut longest_postfix_length_suffix\
    \ = 0;\n    let mut longest_postfix_length_suffix_index = 0;\n    let mut longest_postfix_length_suffix_palindrome\
    \ = 0;\n    let mut longest_postfix_length_suffix_palindrome_index = 0;\n    let\
    \ mut longest_postfix_length_suffix_palindrome_length = 0;\n    let mut longest_postfix_length_suffix_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix = 0;\n    let mut longest_postfix_length_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_palindrome = 0;\n   \
    \ let mut longest_postfix_length_suffix_suffix_palindrome_index = 0;\n    let\
    \ mut longest_postfix_length_suffix_suffix_palindrome_length = 0;\n    let mut\
    \ longest_postfix_length_suffix_suffix_palindrome_length_index = 0;\n    let mut\
    \ longest_postfix_length_suffix_suffix_suffix = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_palindrome = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix_suffix_palindrome_index = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix_suffix_palindrome_length = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix_suffix_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix_suffix_suffix_index = 0;\n \
    \   let mut longest_postfix_length_suffix_suffix_suffix_suffix_palindrome = 0;\n\
    \    let mut longest_postfix_length_suffix_suffix_suffix_suffix_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_suffix_suffix_suffix_suffix_palindrome_length\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = make_palindrome;\n   \
    \ assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpw0thodv5.rs:44:1\n  \
    \ |\n44 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_index = -1;\n    let mut longest_postfix_length =\
    \ 0;\n    let mut longest_postfix_suffix;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mut longest_postfix_suffix_index;\n\
    \    let mut longest_postfix_suffix_length;\n    let mu\n}\n\nfn main() {\n  \
    \  let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\"\
    )), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqcavfkzy.rs:59:11\n   |\n\
    59 |     let mu\n   |           ^ help: add `;` here\n60 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqcavfkzy.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut suffix = 0;\n    while palindrome.len()\
    \ > 0 {\n        let mut prefix = palindrome.clone();\n        prefix.reverse();\n\
    \        if palindrome.starts_with(prefix) {\n            palindrome = palindrome.clone();\n\
    \            palindrome.insert(0, suffix);\n            suffix += 1;\n       \
    \ }\n    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp5mtixdxr.rs:16:16\n   |\n16 |         prefix.reverse();\n\
    \   |                ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found\
    \ `String`\n    --> /tmp/tmp5mtixdxr.rs:17:35\n     |\n17   |         if palindrome.starts_with(prefix)\
    \ {\n     |                       ----------- ^^^^^^ expected an implementor of\
    \ trait `Pattern<'_>`\n     |                       |\n     |                \
    \       required by a bound introduced by this call\n     |\n     = note: the\
    \ trait bound `String: Pattern<'_>` is not satisfied\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `String`\nnote: required\
    \ by a bound in `core::str::<impl str>::starts_with`\nhelp: consider borrowing\
    \ here\n     |\n17   |         if palindrome.starts_with(&prefix) {\n     |  \
    \                                 +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5mtixdxr.rs:19:34\n\
    \   |\n19 |             palindrome.insert(0, suffix);\n   |                  \
    \                ^^^^^^ expected `char`, found integer\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_string = \"\";\n    let mut longest_postfix_string_length\
    \ = 0;\n    let mut longest_postfix_string_index = 0;\n    let mut longest_postfix_string_length_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index = 0;\n    let mut\
    \ longest_postfix_string_length_index_index_index = 0;\n    let mut longest_postfix_string_length_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    let mut longest_postfix_string_length_index_index_\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp07ssurq3.rs:40:55\n   |\n\
    40 |     let mut longest_postfix_string_length_index_index_\n   |            \
    \                                           ^ help: add `;` here\n41 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp07ssurq3.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length =\
    \ 0;\n    let mut longest_postfix_suffix_index = 0;\n    let mut longest_postfix_suffix_length\
    \ = 0;\n    while longest_postfix_length < longest_postfix_length {\n        longest_postfix_length\
    \ = longest_postfix.len();\n        longest_postfix_suffix_length = reversed_string.len();\n\
    \        longest_postfix_suffix_index = reversed_string.len() - 1;\n        for\
    \ suffix in longest_postfix.chars().rev() {\n            if longest_postfix_length\
    \ == 0 {\n                break;\n            }\n            if longest_postfix_length\
    \ == 1 {\n                longest_postfix_length = longest_postfix.len();\n  \
    \              longest_postfix_suffix_length = reversed_string.len();\n      \
    \          longest_postfix_suffix_index = reversed_string.len() - 1;\n       \
    \         break;\n            }\n            if longest_postfix_length == 2 {\n\
    \                longest_postfix_length = longest_postfix.len();\n           \
    \     longest_postfix_suffix_length = reversed_string.len();\n               \
    \ longest_postfix_suffix_index = reversed_string.len() - 1;\n                break;\n\
    \            }\n            if longest_postfix_length == 3 {\n               \
    \ longest_postfix_length = longest_postfix.len();\n                longest_postfix_suffix_length\
    \ = reversed_string.len();\n                longest_postfix_suffix_index = reversed_string.len()\
    \ - 1;\n                break;\n            }\n            if longest_postfix_length\
    \ == 4 {\n                longest_postfix_length = longest_postfix.len();\n  \
    \              longest_postfix_suffix_length = reversed_string.len();\n      \
    \          longest_postfix_suffix_index = reversed_string.len() - 1;\n       \
    \         break;\n            }\n            if longest_postfix_length == 5 {\n\
    \                longest_postfix_length = longest_postfix.len();\n           \
    \     longest_postfix_suffix_length = reversed_string.len();\n               \
    \ longest_postfix_suffix_index = reversed_string.len() - 1;\n                break;\n\
    \            }\n            if longest_postfix_length == 6 {\n               \
    \ longest_postfix_length = longest_postfix.len();\n                longest_postfix_suffix_length\
    \ = reversed_string.len();\n                longest_postfix_suffix_index = reversed_string.len()\
    \ - 1;\n                break;\n            }\n            if longest_postfix_length\
    \ == 7 {\n                longest_postfix_length = longest_postfix.len();\n  \
    \              longest_postfix_suffix_length = \n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpesz4hwwv.rs:74:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n18 |     while longest_postfix_length\
    \ < longest_postfix_length {\n   |                                           \
    \                - unclosed delimiter\n...\n22 |         for suffix in longest_postfix.chars().rev()\
    \ {\n   |                                                     - unclosed delimiter\n\
    ...\n62 |             if longest_postfix_length == 7 {\n   |                 \
    \                           - this delimiter might not be properly closed...\n\
    ...\n65 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    74 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpesz4hwwv.rs:65:1\n\
    \   |\n65 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpesz4hwwv.rs:18:5\n   |\n11 |   fn make_palindrome(string: String)\
    \ -> String {\n   |                                         ------ expected `String`\
    \ because of return type\n...\n18 | /     while longest_postfix_length < longest_postfix_length\
    \ {\n19 | |         longest_postfix_length = longest_postfix.len();\n20 | |  \
    \       longest_postfix_suffix_length = reversed_string.len();\n21 | |       \
    \  longest_postfix_suffix_index = reversed_string.len() - 1;\n...  |\n73 | | \
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n74 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_pos = 0;\n    let\
    \ mut longest_postfix_len = string.len();\n    while reverse_pos < longest_postfix_len\
    \ {\n        let mut postfix_len = longest_postfix_len - reverse_pos;\n      \
    \  if postfix_len > 0 {\n            let mut postfix = &string[reverse_pos..(reverse_pos\
    \ + postfix_len)];\n            if postfix.iter().rev().collect::<String>() ==\
    \ postfix {\n                longest_postfix_len = postfix_len;\n            \
    \    reverse_pos += postfix_len;\n            } else {\n                break;\n\
    \            }\n        } else {\n            break;\n        }\n    }\n    reversed_string.push_str(&string[reverse_pos..]);\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmp4x75b3n9.rs:19:24\n   |\n19 |             if postfix.iter().rev().collect::<String>()\
    \ == postfix {\n   |                        ^^^^ method not found in `&str`\n\
    \   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n   |\n19 |             if postfix.chars().rev().collect::<String>()\
    \ == postfix {\n   |                        ~~~~~\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_length = 0;\n\
    \    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length =\
    \ string.len();\n    let mut longest_postfix_index = 0;\n    while longest_postfix_index\
    \ != longest_postfix_length {\n        let mut postfix_length = longest_postfix_length;\n\
    \        let mut postfix_index = longest_postfix_index;\n        while postfix_index\
    \ != postfix_length {\n            let mut postfix = &string[postfix_index..];\n\
    \            let mut postfix_reversed = &reversed_string[..];\n            postfix.reverse();\n\
    \            postfix_reversed.extend(postfix);\n            if postfix_reversed\
    \ == postfix {\n                postfix_length = postfix_index + 1;\n        \
    \        postfix_index = 0;\n            } else {\n                postfix_index\
    \ += 1;\n            }\n        }\n        longest_postfix_length = postfix_length;\n\
    \        longest_postfix_index = postfix_index;\n    }\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpy2vy46_k.rs:25:21\n   |\n25 |             postfix.reverse();\n\
    \   |                     ^^^^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `extend` found for reference `&str` in the current scope\n \
    \ --> /tmp/tmpy2vy46_k.rs:26:30\n   |\n26 |             postfix_reversed.extend(postfix);\n\
    \   |                              ^^^^^^ method not found in `&str`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n\n    while\
    \ !string.is_empty() {\n        let mut index = string.len() - 1;\n        while\
    \ index >= 0 {\n            let char = string[index];\n            reversed_string.insert(0,\
    \ char);\n            index -= 1;\n        }\n        string = reversed_string;\n\
    \        reversed_string = \"\";\n    }\n\n    string\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpiad8eymm.rs:18:24\n\
    \   |\n18 |             let char = string[index];\n   |                      \
    \  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `insert` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpiad8eymm.rs:19:29\n   |\n19 |          \
    \   reversed_string.insert(0, char);\n   |                             ^^^^^^\
    \ method not found in `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiad8eymm.rs:22:18\n\
    \   |\n12 |     let mut string = string;\n   |                      ------ expected\
    \ due to this value\n...\n22 |         string = reversed_string;\n   |       \
    \           ^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                  |\n   |                  expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    while\
    \ !reversed_string.is_empty() {\n        let mut suffix_length = 0;\n        while\
    \ !reversed_string.starts_with(string[prefix_length..]) {\n            suffix_length\
    \ += 1;\n        }\n        reversed_string = reversed_string[..suffix_length];\n\
    \        prefix_length += 1;\n    }\n    reversed_string\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n    --> /tmp/tmpb1ngk3un.rs:16:44\n     |\n16   |         while !reversed_string.starts_with(string[prefix_length..])\
    \ {\n     |                                ----------- ^^^^^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n     |                          \
    \      |\n     |                                required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Sized` is not implemented for\
    \ `str`\nnote: required by a bound in `core::str::<impl str>::starts_with`\n\n\
    error[E0277]: expected a `FnMut<(char,)>` closure, found `str`\n    --> /tmp/tmpb1ngk3un.rs:16:44\n\
    \     |\n16   |         while !reversed_string.starts_with(string[prefix_length..])\
    \ {\n     |                                ----------- ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an implementor of trait `Pattern<'_>`\n     |                     \
    \           |\n     |                                required by a bound introduced\
    \ by this call\n     |\n     = note: the trait bound `str: Pattern<'_>` is not\
    \ satisfied\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `str`\nnote: required by a bound in `core::str::<impl str>::starts_with`\n\
    help: consider borrowing here\n     |\n16   |         while !reversed_string.starts_with(&string[prefix_length..])\
    \ {\n     |                                            +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb1ngk3un.rs:19:27\n   |\n12 |     let mut reversed_string\
    \ = string;\n   |                               ------ expected due to this value\n\
    ...\n19 |         reversed_string = reversed_string[..suffix_length];\n   |  \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                           |\n   |  \
    \                         expected struct `String`, found `str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_pos = 0;\n    let\
    \ mut palindrome = string;\n    while reverse_pos < palindrome.len() {\n     \
    \   let mut pos = palindrome.rfind(&reversed_string[reverse_pos]);\n        if\
    \ pos == -1 {\n            break;\n        }\n        palindrome = &palindrome[..pos];\n\
    \        reverse_pos += pos;\n    }\n    palindrome\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpciutby1j.rs:16:41\n\
    \   |\n16 |         let mut pos = palindrome.rfind(&reversed_string[reverse_pos]);\n\
    \   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpciutby1j.rs:17:19\n\
    \   |\n17 |         if pos == -1 {\n   |                   ^^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n\
    17 |         if pos == Some(-1) {\n   |                   +++++  +\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeTo<Option<usize>>`\n  --> /tmp/tmpciutby1j.rs:20:23\n\
    \   |\n20 |         palindrome = &palindrome[..pos];\n   |                   \
    \    ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `RangeTo<Option<usize>>`\n\
    \   |\n   = help: the trait `Index<RangeTo<Option<usize>>>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpciutby1j.rs:20:22\n\
    \   |\n14 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n2"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_iterator = reversed_string.char_indices().rev().peekable();\n\
    \    let mut reverse_iterator_next = reverse_iterator.next();\n    while let Some(index)\
    \ = reverse_iterator_next.unwrap() {\n        let mut reverse_iterator = reverse_iterator;\n\
    \        let mut reverse_iterator_next = reverse_iterator.next();\n        let\
    \ mut reverse_iterator_next_char = reverse_iterator_next.unwrap();\n        while\
    \ let Some(index) = reverse_iterator_next_char.peek() {\n            if *reverse_iterator_next_char\
    \ == *index {\n                reverse_iterator_next_char = reverse_iterator.next();\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    reversed_string.push(*reverse_iterator_next_char);\n        reverse_iterator\
    \ = reverse_iterator_next;\n        reverse_iterator_next = reverse_iterator.next();\n\
    \    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb8ob36wf.rs:15:15\n   |\n\
    15 |     while let Some(index) = reverse_iterator_next.unwrap() {\n   |      \
    \         ^^^^^^^^^^^   ------------------------------ this expression has type\
    \ `(usize, char)`\n   |               |\n   |               expected tuple, found\
    \ enum `Option`\n   |\n   = note: expected tuple `(usize, char)`\n           \
    \    found enum `Option<_>`\n\nerror[E0599]: no method named `peek` found for\
    \ tuple `(usize, char)` in the current scope\n  --> /tmp/tmpb8ob36wf.rs:19:60\n\
    \   |\n19 |         while let Some(index) = reverse_iterator_next_char.peek()\
    \ {\n   |                                                            ^^^^ method\
    \ not found in `(usize, char)`\n\nerror[E0614]: type `(usize, char)` cannot be\
    \ dereferenced\n  --> /tmp/tmpb8ob36wf.rs:20:16\n   |\n20 |             if *reverse_iterator_next_char\
    \ == *index {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb8ob36wf.rs:21:46\n   |\n18 |         let mut\
    \ reverse_iterator_next_char = reverse_iterator_next.unwrap();\n   |         \
    \                                     ------------------------------ expected\
    \ due to this value\n...\n21 |                 reverse_iterator_next_char = reverse_iterator.next();\n\
    \   |                                              ^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ tuple, found enum `Option`\n   |\n   = note: expected tuple `(usize, char)`\n\
    \               found enum `Option<(usize, char)>`\n\nerror[E0614]: type `(usize,\
    \ char)` cannot be dereferenced\n  --> /tmp/tmpb8ob36wf.rs:26:30\n   |\n26 | \
    \        reversed_string.push(*reverse_iterator_next_char);\n   |            \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpb8ob36wf.rs:27:28\n   |\n16 |         let mut reverse_iterator\
    \ = reverse_iterator;\n   |                                    ----------------\
    \ expected due to this value\n...\n27 |         reverse_iterator = reverse_iterator_next;\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^ expected struct `Peekable`,\
    \ found enum `Option`"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_len = 0;\n\
    \    let mut longest_postfix_len = 0;\n    let mut longest_postfix_start = -1;\n\
    \    for pos in string.rfind('a') {\n        let mut postfix_len = pos - longest_postfix_start;\n\
    \        if postfix_len > longest_postfix_len {\n            longest_postfix_len\
    \ = postfix_len;\n            longest_postfix_start = pos;\n        }\n    }\n\
    \    let mut postfix_len = longest_postfix_len - 1;\n    let mut postfix_start\
    \ = longest_postfix_start;\n    while postfix_len > 0 {\n        let mut postfix_end\
    \ = postfix_start + postfix_len;\n        let mut postfix_end = postfix_end +\
    \ 1;\n        if postfix_end > string.len() {\n            postfix_end = string.len();\n\
    \        }\n        if string[postfix_end] != string[postfix_end - 1] {\n    \
    \        postfix_len -= 1;\n        }\n        postfix_start = postfix_end;\n\
    \    }\n    let mut postfix_end = longest_postfix_start + longest_postfix_len;\n\
    \    let mut postfix_end = postfix_end + 1;\n    if postfix_end > string.len()\
    \ {\n        postfix_end = string.len();\n    }\n    reversed_string = &string[..postfix_end];\n\
    \    reversed_string_len = postfix_end - longest_postfix_start;\n    reversed_string.reverse();\n\
    \    String::from(reversed_string)\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmplpfg312g.rs:15:37\n\
    \   |\n15 |     let mut longest_postfix_start = -1;\n   |                    \
    \                 ^^ the trait `Neg` is not implemented for `usize`\n   |\n  \
    \ = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplpfg312g.rs:31:12\n\
    \   |\n31 |         if string[postfix_end] != string[postfix_end - 1] {\n   |\
    \            ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplpfg312g.rs:31:35\n\
    \   |\n31 |         if string[postfix_end] != string[postfix_end - 1] {\n   |\
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplpfg312g.rs:41:23\n\
    \   |\n12 |     let mut reversed_string = string;\n   |             "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut longest\
    \ = 0;\n    while !string.is_empty() {\n        let mut i = 0;\n        while\
    \ i < string.len() && string[i] == string[string.len() - i - 1] {\n          \
    \  i += 1;\n        }\n        if i == 0 {\n            break;\n        }\n  \
    \      let mut j = string.len() - 1;\n        while j > 0 && string[j] == string[j\
    \ - 1] {\n            j -= 1;\n        }\n        if j == 0 {\n            break;\n\
    \        }\n        if j > i {\n            longest = i;\n            reverse.push_str(&string[longest\
    \ .. j]);\n            string = &string[j..];\n        } else {\n            longest\
    \ = j;\n            reverse.push_str(&string[longest .. i]);\n            string\
    \ = &string[i..];\n        }\n    }\n    reverse\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5vji51fb.rs:17:35\n\
    \   |\n17 |         while i < string.len() && string[i] == string[string.len()\
    \ - i - 1] {\n   |                                   ^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5vji51fb.rs:17:48\n   |\n17 |         while i < string.len() &&\
    \ string[i] == string[string.len() - i - 1] {\n   |                          \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5vji51fb.rs:24:24\n   |\n24 |         while j > 0 && string[j]\
    \ == string[j - 1] {\n   |                        ^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ i = 0;\n    while i < string.len() {\n        let mut j = i;\n        while\
    \ j + 1 < string.len() && string[j] == string[j + 1] {\n            j += 1\n \
    \       }\n        reversed_string.push_str(&string[i..j]);\n        i = j;\n\
    \    }\n    string.push_str(&reversed_string);\n    string\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphbcebv5s.rs:17:39\n\
    \   |\n17 |         while j + 1 < string.len() && string[j] == string[j + 1] {\n\
    \   |                                       ^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphbcebv5s.rs:17:52\n   |\n17 |         while j + 1 < string.len()\
    \ && string[j] == string[j + 1] {\n   |                                      \
    \              ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]:\
    \ no method named `push_str` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmphbcebv5s.rs:20:25\n   |\n20 |         reversed_string.push_str(&string[i..j]);\n\
    \   |                         ^^^^^^^^ method not found in `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = string;\n    let mut postfix = string;\n    let mut prefix_length\
    \ = 0;\n    while postfix.len() > 0 {\n        if postfix.chars().next().unwrap()\
    \ != string.chars().next().unwrap() {\n            break;\n        }\n       \
    \ postfix.pop();\n        prefix_length += 1;\n    }\n    reverse.push_str(&string[prefix_length..]);\n\
    \    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `string`\n  --> /tmp/tmpxt9ti1lq.rs:13:23\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \       ------ move occurs because `string` has type `String`, which does not\
    \ implement the `Copy` trait\n12 |     let mut reverse = string;\n   |       \
    \                ------ value moved here\n13 |     let mut postfix = string;\n\
    \   |                       ^^^^^^ value used here after move\n\nerror[E0382]:\
    \ borrow of moved value: `string`\n  --> /tmp/tmpxt9ti1lq.rs:16:47\n   |\n11 |\
    \ fn make_palindrome(string: String) -> String {\n   |                    ------\
    \ move occurs because `string` has type `String`, which does not implement the\
    \ `Copy` trait\n12 |     let mut reverse = string;\n13 |     let mut postfix =\
    \ string;\n   |                       ------ value moved here\n...\n16 |     \
    \    if postfix.chars().next().unwrap() != string.chars().next().unwrap() {\n\
    \   |                                               ^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n   |\n   = note: borrow occurs due to deref coercion to `str`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_size = string.len();\n\
    \    while reversed_string_size != 0 {\n        reversed_string.swap(0, reversed_string_size\
    \ - 1);\n        reversed_string_size -= 1;\n    }\n    reversed_string\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpwu56d36m.rs:15:25\n   |\n15 |         reversed_string.swap(0,\
    \ reversed_string_size - 1);\n   |                         ^^^^ method not found\
    \ in `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n\n    while\
    \ string.len() > 0 {\n        let mut index = string.len() - 1;\n        let mut\
    \ char = string[index];\n\n        while index >= 0 {\n            reversed_string.insert(0,\
    \ char);\n            index -= 1;\n            char = string[index];\n       \
    \ }\n        string = &string[1..];\n    }\n\n    reversed_string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzey9uuk3.rs:17:24\n\
    \   |\n17 |         let mut char = string[index];\n   |                      \
    \  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `insert` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpzey9uuk3.rs:20:29\n   |\n20 |          \
    \   reversed_string.insert(0, char);\n   |                             ^^^^^^\
    \ method not found in `&str`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpzey9uuk3.rs:22:20\n   |\n22 |             char = string[index];\n\
    \   |                    ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzey9uuk3.rs:24:18\n\
    \   |\n12 |     let mut string = string;\n   |                      ------ expected\
    \ due to this value\n...\n24 |         string = &string[1..];\n   |          \
    \        ^^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try\
    \ using a conversion method\n   |\n24 |         string = (&string[1..]).to_string();\n\
    \   |                  +            +++++++++++++\n\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_len = string.len();\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mut longest_postfix_start\
    \ = -1;\n    let mut longest_postfix_end = -1;\n    let mu\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1uonu5nu.rs:63:11\n   |\n\
    63 |     let mu\n   |           ^ help: add `;` here\n64 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1uonu5nu.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    while\
    \ !string.is_empty() {\n        let mut current_postfix_length = string.len();\n\
    \        while current_postfix_length >= longest_postfix_length {\n          \
    \  let mut current_postfix_index = longest_postfix_index;\n            while current_postfix_index\
    \ >= 0 {\n                let current_postfix_char = string[current_postfix_index];\n\
    \                if current_postfix_char == string[current_postfix_index].to_lowercase().rev()\
    \ {\n                    break;\n                }\n                current_postfix_index\
    \ -= 1;\n            }\n            longest_postfix_length = current_postfix_length;\n\
    \            longest_postfix_index = current_postfix_index;\n        }\n     \
    \   reversed_string += string[longest_postfix_index];\n        string = &string[longest_postfix_index..];\n\
    \    }\n    String::from(reversed_string)\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpt8p6_k4b.rs:21:44\n   |\n21 |                 let current_postfix_char\
    \ = string[current_postfix_index];\n   |                                     \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpt8p6_k4b.rs:22:44\n   |\n22 |                 if current_postfix_char\
    \ == string[current_postfix_index].to_lowercase().rev() {\n   |              \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpt8p6_k4b.rs:30:28\n   |\n30 |         reversed_string += string[longest_postfix_index];\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut postfix_length = 0;\n    let\
    \ mut prefix_length = 0;\n    while !reversed_string.is_empty() {\n        let\
    \ mut current_char = reversed_string.chars().next().unwrap();\n        if current_char\
    \ == current_char.to_string().rev() {\n            postfix_length += 1;\n    \
    \    } else {\n            prefix_length += 1;\n        }\n        reversed_string\
    \ = reversed_string.chars().next().unwrap();\n    }\n    let mut reversed_string\
    \ = string;\n    while !reversed_string.is_empty() {\n        let mut current_char\
    \ = reversed_string.chars().next().unwrap();\n        if current_char == current_char.to_string().rev()\
    \ {\n            reversed_string = reversed_string.chars().next().unwrap();\n\
    \        } else {\n            break;\n        }\n    }\n    prefix_length\n \
    \       .to_string()\n        .into_owned()\n        + &reversed_string\n    \
    \        .chars()\n            .take(postfix_length)\n            .collect::<String>()\n\
    \            .join(\"_\")\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpg2boxhiy.rs:17:53\n\
    \    |\n17  |           if current_char == current_char.to_string().rev() {\n\
    \    |                                                       ^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg2boxhiy.rs:22:27\n   |\n12 |     let mut reversed_string\
    \ = string;\n   |                               ------ expected due to this value\n\
    ...\n22 |         reversed_string = reversed_string.chars().next().unwrap();\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \   |\n   |                           expected struct `String`, found `char`\n\
    \nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpg2boxhiy.rs:27:53\n\
    \    |\n27  |           if current_char == current_char.to_string().rev() {\n\
    \    |                                                       ^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg2boxhiy.rs:28:31\n   |\n24 |     let mut reversed_string\
    \ = string;\n   |                               ------ expected due to this value\n\
    ...\n28 |             reversed_string = reversed_string.chars().next().unwrap();\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \       |\n   |                               expected struct `String`, found\
    \ `char`\n\nerror[E0599]: no method named `int"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    for c in reversed_string.chars() {\n        if longest_postfix_length ==\
    \ 0 {\n            longest_postfix_length = c.len_utf8();\n        }\n       \
    \ if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    let mut reversed_string = string;\n \
    \   let mut prefix_length = 0;\n    for c in reversed_string.chars() {\n     \
    \   if prefix_length == 0 {\n            prefix_length = c.len_utf8();\n     \
    \   }\n        if prefix_length < c.len_utf8() {\n            prefix_length =\
    \ c.len_utf8();\n        }\n    }\n    let mut reversed_string = string;\n   \
    \ let mut suffix_length = 0;\n    for c in reversed_string.chars() {\n       \
    \ if suffix_length == 0 {\n            suffix_length = c.len_utf8();\n       \
    \ }\n        if suffix_length < c.len_utf8() {\n            suffix_length = c.len_utf8();\n\
    \        }\n    }\n    let mut reversed_string = string;\n    let mut suffix_length\
    \ = 0;\n    for c in reversed_string.chars() {\n        if suffix_length == 0\
    \ {\n            suffix_length = c.len_utf8();\n        }\n        if suffix_length\
    \ < c.len_utf8() {\n            suffix_length = c.len_utf8();\n        }\n   \
    \ }\n    let mut reversed_string = string;\n    let mut suffix_length = 0;\n \
    \   for c in reversed_string.chars() {\n        if suffix_length == 0 {\n    \
    \        suffix_length = c.len_utf8();\n        }\n        if suffix_length <\
    \ c.len_utf8() {\n            suffix_length = c.len_utf8();\n        }\n    }\n\
    \    let mut reversed_string = string;\n    let mut suffix_length = 0;\n    for\
    \ c in reversed_string.chars() {\n        if suffix_length == 0 {\n          \
    \  suffix_length = c.len_utf8();\n        }\n        if suffix_length < c.len_utf8()\
    \ {\n            suffix_length = c.len_utf8();\n        }\n    }\n    let mut\
    \ reversed_string = string;\n    let mut suffix_length = 0;\n    for c in reversed_string.chars()\
    \ {\n        if suffix_length == 0 {\n            suffix_length = c.len_utf8();\n\
    \        }\n        if suffix_length < c.len_utf8() {\n            suffix_length\
    \ = c.len_utf8();\n        }\n    }\n    let mut reversed_string = string;\n \
    \   let mut suffix_length = 0;\n    for c in reversed_string.chars() {\n     \
    \   if suffix_length == 0 {\n            suffix_length = c.len_utf8();\n     \
    \   }\n        if suffix_length < c.len_utf8() {\n\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1a698czz.rs:99:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n84 |     for c in\
    \ reversed_string.chars() {\n   |                                      - unclosed\
    \ delimiter\n...\n88 |         if suffix_length < c.len_utf8() {\n   |       \
    \                                  - this delimiter might not be properly closed...\n\
    89 | \n90 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n99 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1a698czz.rs:84:5\n\
    \   |\n11 |   fn make_palindrome(string: String) -> String {\n   |           \
    \                              ------ expected `String` because of return type\n\
    ...\n84 | /     for c in reversed_string.chars() {\n85 | |         if suffix_length\
    \ == 0 {\n86 | |             suffix_length = c.len_utf8();\n87 | |         }\n\
    ...  |\n98 | |     assert_eq!(candidate(String::from(\"jerry\")), String::from(\"\
    jerryrrej\"));\n99 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    while suffix_length < reversed_string.len() {\n\
    \        let mut suffix_start = suffix_length;\n        while suffix_start < reversed_string.len()\
    \ && reversed_string[suffix_start] != string[suffix_start] {\n            suffix_start\
    \ += 1;\n        }\n        let mut suffix_end = suffix_start;\n        while\
    \ suffix_end < reversed_string.len() && reversed_string[suffix_end] != string[suffix_end]\
    \ {\n            suffix_end += 1;\n        }\n        if suffix_start < suffix_end\
    \ {\n            suffix_length = suffix_end - suffix_start;\n            reversed_string\
    \ = &reversed_string[..suffix_start];\n            prefix_length = suffix_start\
    \ - suffix_length;\n        }\n    }\n    String::from(&reversed_string[..prefix_length])\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdaz35jx9.rs:17:55\n\
    \   |\n17 |         while suffix_start < reversed_string.len() && reversed_string[suffix_start]\
    \ != string[suffix_start] {\n   |                                            \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdaz35jx9.rs:17:88\n   |\n17 |         while suffix_start < reversed_string.len()\
    \ && reversed_string[suffix_start] != string[suffix_start] {\n   |           \
    \                                                                            \
    \ ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdaz35jx9.rs:21:53\n   |\n21 |         while suffix_end < reversed_string.len()\
    \ && reversed_string[suffix_end] != string[suffix_end] {\n   |               \
    \                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    while !reversed_string.starts_with(string) {\n \
    \       reversed_string = reversed_string[..].to_owned();\n        prefix_length\
    \ += 1;\n    }\n    while !string.ends_with(reversed_string) {\n        suffix_length\
    \ += 1;\n        reversed_string = reversed_string[..].to_owned();\n    }\n  \
    \  let mut reversed_string = reversed_string[..].to_owned();\n    while !reversed_string.starts_with(string)\
    \ {\n        reversed_string = reversed_string[..].to_owned();\n        prefix_length\
    \ += 1;\n    }\n    while !string.ends_with(reversed_string) {\n        suffix_length\
    \ += 1;\n        reversed_string = reversed_string[..].to_owned();\n    }\n  \
    \  let mut reversed_string = reversed_string[..].to_owned();\n    while !reversed_string.starts_with(string)\
    \ {\n        reversed_string = reversed_string[..].to_owned();\n        prefix_length\
    \ += 1;\n    }\n    while !string.ends_with(reversed_string) {\n        suffix_length\
    \ += 1;\n        reversed_string = reversed_string[..].to_owned();\n    }\n  \
    \  let mut reversed_string = reversed_string[..].to_owned();\n    while !reversed_string.starts_with(string)\
    \ {\n        reversed_string = reversed_string[..].to_owned();\n        prefix_length\
    \ += 1;\n    }\n    while !string.ends_with(reversed_string) {\n        suffix_length\
    \ += 1;\n        reversed_string = reversed_string[..].to_owned();\n    }\n  \
    \  let mut reversed_string = reversed_string[..].to_owned();\n    while !reversed_string.starts_with(string)\
    \ {\n        reversed_string = reversed_string[..].to_owned();\n        prefix_length\
    \ += 1;\n    }\n    while !string.ends_with(reversed_string) {\n        suffix_length\
    \ += 1;\n        reversed_string = reversed_string[..].to_owned();\n    }\n  \
    \  let mut reversed_string = reversed_string[..].to_owned();\n    while !reversed_string.starts_with(string)\
    \ {\n        reversed_string = reversed_string[..].to_owned();\n        prefix_length\
    \ += 1;\n    }\n    while !string.ends_with(reversed_string) {\n        suffix_length\
    \ += 1;\n        re\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp_zugcpml.rs:76:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n64 |     while !string.ends_with(reversed_string)\
    \ {\n   |                                              - this delimiter might\
    \ not be properly closed...\n...\n67 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n76 | }\n   |   ^\n\nerror[E0425]: cannot find\
    \ value `re` in this scope\n  --> /tmp/tmp_zugcpml.rs:66:9\n   |\n66 |       \
    \  re\n   |         ^^ not found in this scope\n\nerror[E0277]: expected a `FnMut<(char,)>`\
    \ closure, found `String`\n    --> /tmp/tmp_zugcpml.rs:15:40\n     |\n15   | \
    \    while !reversed_string.starts_with(string) {\n     |                    \
    \        ----------- ^^^^^^ expected an implementor of trait `Pattern<'_>`\n \
    \    |                            |\n     |                            required\
    \ by a bound introduced by this call\n     |\n     = note: the trait bound `String:\
    \ Pattern<'_>` is not satisfied\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::starts_with`\nhelp: consider borrowing here\n     |\n15   |     while\
    \ !reversed_string.starts_with(&string) {\n     |                            \
    \            +\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n\
    \  --> /tmp/tmp_zugcpml.rs:19:29\n   |\n19 |     while !string.ends_with(reversed_string)\
    \ {\n   |                   --------- ^^^^^^^^^^^^^^^ expected an implementor\
    \ of trait `Pattern<'_>`\n   |                   |\n   |                   required\
    \ by a bound introduced by this call\n   |\n   = note: the trait bound `String:\
    \ Pattern<'_>` is not satisfied\n   = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `String`\nhelp: consider borrowing here\n \
    \  |\n19 |     while !string.ends_with(&reversed_string) {\n   |             \
    \                +\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found\
    \ `String`\n "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo69wv1oh.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo69wv1oh.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string_to_reverse = string;\n    let mut reversed_string = string;\n\
    \n    while !string_to_reverse.ends_with(string) {\n        let mut reversed_string_to_reverse\
    \ = reversed_string;\n        let mut reversed_reversed_string = reversed_string;\n\
    \n        while !reversed_string_to_reverse.ends_with(string) {\n            let\
    \ mut reversed_reversed_string_to_reverse = reversed_reversed_string;\n      \
    \      let mut reversed_reversed_reversed_string = reversed_reversed_string;\n\
    \n            while !reversed_reversed_string_to_reverse.ends_with(string) {\n\
    \                let mut reversed_reversed_reversed_string_to_reverse = reversed_reversed_reversed_string;\n\
    \                let mut reversed_reversed_reversed_reversed_string = reversed_reversed_reversed_string;\n\
    \n                while !reversed_reversed_reversed_string_to_reverse.ends_with(string)\
    \ {\n                    let mut reversed_reversed_reversed_reversed_string_to_reverse\
    \ = reversed_reversed_reversed_reversed_string;\n                    let mut reversed_reversed_reversed_reversed_reversed_string\
    \ = reversed_reversed_reversed_reversed_string;\n\n                    while !reversed_reversed_reversed_reversed_string_to_reverse.ends_with(string)\
    \ {\n                        let mut reversed_reversed_reversed_reversed_reversed_string_to_reverse\
    \ = reversed_reversed_reversed_reversed_reversed_string;\n                   \
    \     let mut reversed_reversed_reversed_reversed_reversed_reversed_string = reversed_reversed_reversed_reversed_reversed_reversed_string;\n\
    \n                        while !reversed_reversed_reversed_reversed_reversed_string_to_reverse.ends_with(string)\
    \ {\n                            let mut reversed_reversed_reversed_reversed_reversed_reversed_string_to_reverse\
    \ = reversed_reversed_reversed_reversed_reversed_reversed_string;\n          \
    \                  let mut reversed_reversed_reversed_reversed_reversed_reversed_string\
    \ = reversed_reversed_reversed_reversed_reversed_reversed_reversed_string;\n\n\
    \                            while !reversed_reversed_reversed_reversed_reversed_reversed_string_to_reverse.ends_with(string)\
    \ {\n                                let mut reversed_reversed_reversed_reversed_reversed_reversed_reversed_string_to_reverse\
    \ = reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversestring;\n\
    \                                let mut reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversestring\
    \ = reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversestring;\n\
    \n                                while !reversed_reversed_reverse\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpmc4_k437.rs:53:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n15 |     while !string_to_reverse.ends_with(string)\
    \ {\n   |                                                - unclosed delimiter\n\
    ...\n19 |         while !reversed_string_to_reverse.ends_with(string) {\n   |\
    \                                                             - unclosed delimiter\n\
    ...\n23 |             while !reversed_reversed_string_to_reverse.ends_with(string)\
    \ {\n   |                                                                    \
    \      - unclosed delimiter\n...\n27 |                 while !reversed_reversed_reversed_string_to_reverse.ends_with(string)\
    \ {\n   |                                                                    \
    \                   - unclosed delimiter\n...\n31 |                     while\
    \ !reversed_reversed_reversed_reversed_string_to_reverse.ends_with(string) {\n\
    \   |                                                                        \
    \                            - unclosed delimiter\n...\n35 |                 \
    \        while !reversed_reversed_reversed_reversed_reversed_string_to_reverse.ends_with(string)\
    \ {\n   |                                                                    \
    \                                             - unclosed delimiter\n...\n39 |\
    \                             while !reversed_reversed_reversed_reversed_reversed_reversed_string_to_reverse.ends_with(string)\
    \ {\n   |                                                                    \
    \                                                          - this delimiter might\
    \ not be properly closed...\n...\n44 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n53 | }\n   |   ^\n\nerror: expected `{`, found\
    \ `}`\n  --> /tmp/tmpmc4_k437.rs:44:1\n   |\n43 |                            \
    \     while !reversed_reversed_reverse\n   |                                 -----\
    \ -------------------------- this `while` condition successfully parsed\n   |\
    \  "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n\n    while\
    \ !string.is_empty() {\n        let mut index = string.len() - 1;\n        let\
    \ mut char = string[index];\n\n        while index >= 0 {\n            reversed_string.insert(0,\
    \ char);\n            index -= 1;\n            char = string[index];\n       \
    \ }\n\n        string = string.chars().collect();\n    }\n\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpub2kvlv7.rs:17:24\n\
    \   |\n17 |         let mut char = string[index];\n   |                      \
    \  ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `insert` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpub2kvlv7.rs:20:29\n   |\n20 |          \
    \   reversed_string.insert(0, char);\n   |                             ^^^^^^\
    \ method not found in `&str`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpub2kvlv7.rs:22:20\n   |\n22 |             char = string[index];\n\
    \   |                    ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpub2kvlv7.rs:28:5\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                          ------ expected `String` because of return type\n...\n\
    28 |     reversed_string\n   |     ^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 4 previous errors\n\nSom"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = string;\n    let mut longest = 0;\n    for pos in string.char_indices()\
    \ {\n        let mut suffix = &mut reverse[..pos];\n        let mut prefix = &mut\
    \ reverse[pos..];\n        let mut palindrome = suffix;\n        while palindrome.chars().any(|c|\
    \ !c.is_alphanumeric()) {\n            palindrome = prefix.to_owned() + palindrome;\n\
    \            prefix += suffix;\n        }\n        if palindrome.len() > longest\
    \ {\n            longest = palindrome.len();\n        }\n    }\n    reverse.push_str(&string[longest..]);\n\
    \    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeTo<(usize, char)>`\n\
    \  --> /tmp/tmpxelgqqqy.rs:15:31\n   |\n15 |         let mut suffix = &mut reverse[..pos];\n\
    \   |                               ^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `RangeTo<(usize, char)>`\n   |\n   = help: the trait `Index<RangeTo<(usize,\
    \ char)>>` is not implemented for `String`\n   = help: the following other types\
    \ implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `RangeFrom<(usize,\
    \ char)>`\n  --> /tmp/tmpxelgqqqy.rs:16:31\n   |\n16 |         let mut prefix\
    \ = &mut reverse[pos..];\n   |                               ^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `RangeFrom<(usize, char)>`\n   |\n   = help: the trait\
    \ `Index<RangeFrom<(usize, char)>>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_index = 0;\n    let mut longest_postfix_length = 0;\n    let\
    \ mut longest_postfix_string = \"\";\n    while string.len() > 0 {\n        let\
    \ mut index = string.rfind('a');\n        if index == -1 {\n            break;\n\
    \        }\n        let mut length = string.len() - index;\n        if length\
    \ > longest_postfix_length {\n            longest_postfix_length = length;\n \
    \           longest_postfix_index = index;\n            longest_postfix_string\
    \ = string;\n        }\n        reversed_string.insert(0, &string[index..]);\n\
    \        string = &string[index..];\n    }\n    longest_postfix_string.insert(0,\
    \ &reversed_string);\n    longest_postfix_string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyvc7x6qr.rs:19:21\n   |\n\
    19 |         if index == -1 {\n   |                     ^^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n\
    19 |         if index == Some(-1) {\n   |                     +++++  +\n\nerror[E0277]:\
    \ cannot subtract `Option<usize>` from `usize`\n  --> /tmp/tmpyvc7x6qr.rs:22:39\n\
    \   |\n22 |         let mut length = string.len() - index;\n   |             \
    \                          ^ no implementation for `usize - Option<usize>`\n \
    \  |\n   = help: the trait `Sub<Option<usize>>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyvc7x6qr.rs:25:37\n   |\n14 |     let mut longest_postfix_index\
    \ = 0;\n   |                                     - expected due to this value\n\
    ...\n25 |             longest_postfix_index = index;\n   |                   \
    \                  ^^^^^ expected integer, found enum `Option`\n   |\n   = note:\
    \ expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyvc7x6qr.rs:26:38\n   |\n16 |     let mut longest_postfix_string\
    \ = \"\";\n   |                                      -- expected due to this value\n\
    ...\n26 |             longest_postfix_string = string;\n   |                 \
    \                     ^^^^^^\n   |                                      |\n  \
    \ |                                      expected `&str`, found struct `String`\n\
    \   |                                      help: consider borrowing here: `&string`\n\
    \nerror[E0599]: no method named `insert` found for reference `&str` in the current\
    \ scope\n "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n  \
    \  let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n\
    \    let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsrpo0pam.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsrpo0pam.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_end = 0;\n    let mut longest_postfix_start = 0;\n    let\
    \ mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n   \
    \ let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start = 0;\n\
    \    let mut longest_postfix_start = 0;\n    let mut longest_postfix_start\n}\n\
    \nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpu804dcsc.rs:63:34\n   |\n\
    63 |     let mut longest_postfix_start\n   |                                 \
    \ ^ help: add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpu804dcsc.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_len = 0;\n   \
    \ let mut longest_postfix_start = String::new();\n    let mut longest_postfix_start_len\
    \ = 0;\n    let mut longest_postfix_end = String::new();\n    let mut longest_postfix_end_len\
    \ = 0;\n    let mut longest_postfix_start_end = String::new();\n    let mut longest_postfix_start_end_len\
    \ = 0;\n    let mut longest_postfix_start_end_start = String::new();\n    let\
    \ mut longest_postfix_start_end_start_len = 0;\n    let mut longest_postfix_start_end_start_start\
    \ = String::new();\n    let mut longest_postfix_start_end_start_start_len = 0;\n\
    \    let mut longest_postfix_start_end_start_start_start = String::new();\n  \
    \  let mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut longest_postfix_start_end_start_start_start\
    \ = String::new();\n    let mut longest_postfix_start_end_start_start_start_len\
    \ = 0;\n    let mut longest_postfix_start_end_start_start_start_start = String::new();\n\
    \    let mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut\
    \ longest_postfix_start_end_start_start_start_start = String::new();\n    let\
    \ mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut longest_postfix_start_end_start_start_start_start\
    \ = String::new();\n    let mut longest_postfix_start_end_start_start_start_len\
    \ = 0;\n    let mut longest_postfix_start_end_start_start_start_start = String::new();\n\
    \    let mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut\
    \ longest_postfix_start_end_start_start_start_start = String::new();\n    let\
    \ mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut longest_postfix_start_end_start_start_start_start\
    \ = String::new();\n    let mut longest_postfix_start_end_start_start_start_len\
    \ = 0;\n    let mut longest_postfix_start_end_start_start_start_start = String::new();\n\
    \    let mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut\
    \ longest_postfix_start_end_start_start_start_start = String::new();\n    let\
    \ mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut longest_postfix_start_end_start_start_start_start\
    \ = String::\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp2a2r7_st.rs:47:1\n\
    \   |\n47 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut i = 0;\n    while i < string.len() {\n        let mut j = string.len() -\
    \ 1;\n        while j >= i {\n            if string[j] != string[i] {\n      \
    \          break;\n            }\n            j -= 1;\n        }\n        if j\
    \ >= i {\n            i += 1;\n        } else {\n            reversed_string =\
    \ reversed_string\n                .chars()\n                .filter(|c| c !=\
    \ string[i])\n                .collect::<String>();\n            i += 1;\n   \
    \     }\n    }\n    string + reversed_string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpg4jtlrlh.rs:18:16\n\
    \   |\n18 |             if string[j] != string[i] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpg4jtlrlh.rs:18:29\n   |\n18 |             if string[j] != string[i]\
    \ {\n   |                             ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpg4jtlrlh.rs:28:34\n   |\n28 |                 .filter(|c| c !=\
    \ string[i])\n   |                                  ^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Ra"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    while !reversed_string.is_empty() {\n        let\
    \ mut current_char = reversed_string[0];\n        reversed_string = reversed_string.chars().skip_while(|&c|\
    \ c != current_char).collect();\n        suffix_length += 1;\n        if suffix_length\
    \ == 2 {\n            prefix_length += 1;\n            suffix_length = 0;\n  \
    \      }\n    }\n    let mut suffix_char = reversed_string[0];\n    reversed_string\
    \ = reversed_string.chars().skip_while(|&c| c != suffix_char).collect();\n   \
    \ prefix_length += 1;\n    suffix_length += 1;\n    let mut reversed_suffix_string\
    \ = reversed_string.chars().collect::<String>();\n    reversed_suffix_string.insert(0,\
    \ suffix_char);\n    reversed_suffix_string.insert(0, &reversed_string[prefix_length..]);\n\
    \    reversed_suffix_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpv38zog1v.rs:16:32\n   |\n16 |         let mut current_char = reversed_string[0];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpv38zog1v.rs:24:27\n   |\n24 |     let mut suffix_char = reversed_string[0];\n\
    \   |                           ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv38zog1v.rs:30:38\n\
    \   |\n30 |     reversed_suffix_string.insert(0, &reversed_string[prefix_length..]);\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_len = string.len();\n    let mut longest_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_len = string.len();\n    let\
    \ mut longest_postfix_postfix_postfix = string;\n    let mut longest_postfix_postfix_postfix_len\
    \ = string.len();\n    let mut longest_postfix_postfix_postfix_postfix = string;\n\
    \    let mut longest_postfix_postfix_postfix_len = string.len();\n    let mut\
    \ longest_postfix_postfix_postfix_postfix = string;\n    let mut longest_postfix_postfix_postfix_postfix_len\
    \ = string.len();\n    let mut longest_postfix_postfix_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_len =\
    \ string.len();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_len =\
    \ string.len();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_len =\
    \ string.len();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_len\
    \ = string.len();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_len\
    \ = string.len();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_len\
    \ = string.len();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_len\
    \ = string.len();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = string;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_len\
    \ = string.len();\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = \n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp3y30nktz.rs:40:1\n\
    \   |\n40 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = string;\n    let mut postfix = string;\n    let mut i =\
    \ 0;\n    while i < reverse.len() {\n        if reverse[i] != string[i - reverse.len()\
    \ + 1] {\n            break;\n        }\n        i += 1;\n    }\n    reverse =\
    \ reverse.clone();\n    postfix = postfix.clone();\n    reverse.push_str(&string[i\
    \ - reverse.len() + 1]);\n    postfix.push_str(&string[i - postfix.len() + 1]);\n\
    \    reverse\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgy_onlvh.rs:16:12\n\
    \   |\n16 |         if reverse[i] != string[i - reverse.len() + 1] {\n   |   \
    \         ^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgy_onlvh.rs:16:26\n   |\n16 |         if reverse[i] != string[i\
    \ - reverse.len() + 1] {\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgy_onlvh.rs:23:23\n   |\n23 |     reverse.push_str(&string[i -\
    \ reverse.len() + 1]);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<R"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo69wv1oh.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo69wv1oh.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_index = -1;\n    let mut longest_postfix_length =\
    \ 0;\n    let mut longest_postfix_postfix = \"\";\n    let mut longest_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_index = -1;\n    let mut\
    \ longest_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_index = -1;\n \
    \   let mut longest_postfix_postfix_postfix_postfix_length = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_postfix_index =\
    \ -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_length = 0;\n\
    \    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix = \"\";\n\
    \    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_index = -1;\n\
    \    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_length =\
    \ 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = \"\";\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_index\
    \ = -1;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = 0;\n    let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_post\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2ls0qzx8.rs:40:73\n   |\n\
    40 |     let mut longest_postfix_postfix_postfix_postfix_postfix_postfix_post\n\
    \   |                                                                        \
    \ ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2ls0qzx8.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut i = 0;\n    while i < string.len() {\n        let mut j = i;\n        while\
    \ j < string.len() {\n            if string[j] != string[i] {\n              \
    \  break;\n            }\n            i += 1;\n            j += 1;\n        }\n\
    \        if j == i {\n            i += 1;\n        }\n        reversed_string.push((string[..i].chars().collect::<String>().rev().collect()));\n\
    \    }\n    string.push((reversed_string.chars().collect::<String>().rev().collect()));\n\
    \    string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmp804avcem.rs:27:30\n\
    \   |\n27 |         reversed_string.push((string[..i].chars().collect::<String>().rev().collect()));\n\
    \   |                              ^                                         \
    \              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp:\
    \ remove these parentheses\n   |\n27 -         reversed_string.push((string[..i].chars().collect::<String>().rev().collect()));\n\
    27 +         reversed_string.push(string[..i].chars().collect::<String>().rev().collect());\n\
    \   | \n\nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmp804avcem.rs:29:17\n\
    \   |\n29 |     string.push((reversed_string.chars().collect::<String>().rev().collect()));\n\
    \   |                 ^                                                      \
    \     ^\n   |\nhelp: remove these parentheses\n   |\n29 -     string.push((reversed_string.chars().collect::<String>().rev().collect()));\n\
    29 +     string.push(reversed_string.chars().collect::<String>().rev().collect());\n\
    \   | \n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmp804avcem.rs:18:16\n   |\n18 |             if string[j] != string[i]\
    \ {\n   |                ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp804avcem.rs:18:29\n\
    \   |\n18 |             if string[j] != string[i] {\n   |                    \
    \         ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    for c in reversed_string.chars() {\n        if longest_postfix_length ==\
    \ 0 {\n            longest_postfix_length = c.len_utf8();\n        }\n       \
    \ if longest_postfix_length < c.len_utf8() {\n            longest_postfix_length\
    \ = c.len_utf8();\n        }\n    }\n    let mut reversed_string_reversed = reversed_string;\n\
    \    let mut longest_postfix_length_reversed = longest_postfix_length;\n    for\
    \ c in reversed_string.chars() {\n        if longest_postfix_length_reversed ==\
    \ 0 {\n            longest_postfix_length_reversed = c.len_utf8();\n        }\n\
    \        if longest_postfix_length_reversed < c.len_utf8() {\n            longest_postfix_length_reversed\
    \ = c.len_utf8();\n        }\n    }\n    let mut reversed_string_reversed_reversed\
    \ = reversed_string_reversed;\n    let mut longest_postfix_length_reversed_reversed\
    \ = longest_postfix_length_reversed;\n    for c in reversed_string_reversed.chars()\
    \ {\n        if longest_postfix_length_reversed_reversed == 0 {\n            longest_postfix_length_reversed_reversed\
    \ = c.len_utf8();\n        }\n        if longest_postfix_length_reversed_reversed\
    \ < c.len_utf8() {\n            longest_postfix_length_reversed_reversed = c.len_utf8();\n\
    \        }\n    }\n    let mut reversed_string_reversed_reversed_reversed = reversed_string_reversed_reversed;\n\
    \    let mut longest_postfix_length_reversed_reversed_reversed = longest_postfix_length_reversed_reversed;\n\
    \    for c in reversed_string_reversed_reversed.chars() {\n        if longest_postfix_length_reversed_reversed_reversed\
    \ == 0 {\n            longest_postfix_length_reversed_reversed_reversed = c.len_utf8();\n\
    \        }\n        if longest_postfix_length_reversed_reversed_reversed < c.len_utf8()\
    \ {\n            longest_postfix_length_reversed_reversed_reversed = c.len_utf8();\n\
    \        }\n    }\n    let mut reversed_string_reversed_reversed_reversed_reversed\
    \ = reversed_string_reversed_reversed_reversed;\n    let mut longest_postfix_length_reversed_reversed_reversed_reversed\
    \ = longest_postfix_length_reversed_reversed_reversed;\n    for c in reversed_string_reversed_reversed_reversed.chars()\
    \ {\n        if longest_postfix_length_reversed_\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmppy0fuljx.rs:65:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n54 |     for c in\
    \ reversed_string_reversed_reversed_reversed.chars() {\n   |                 \
    \                                                - this delimiter might not be\
    \ properly closed...\n55 |         if longest_postfix_length_reversed_\n56 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n65 | }\n\
    \   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmppy0fuljx.rs:56:1\n\
    \   |\n55 |         if longest_postfix_length_reversed_\n   |         -- this\
    \ `if` expression has a condition, but no block\n56 | }\n   | ^ expected `{`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppy0fuljx.rs:11:39\n   |\n11 |\
    \ fn make_palindrome(string: String) -> String {\n   |    ---------------    \
    \                ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut prefix_length = 0;\n    let mut\
    \ suffix_length = 0;\n    while !palindrome.is_empty() {\n        let mut prefix_length\
    \ = 0;\n        let mut suffix_length = 0;\n        for c in palindrome {\n  \
    \          if c.is_lowercase() {\n                prefix_length += 1;\n      \
    \      } else {\n                suffix_length += 1;\n            }\n        }\n\
    \        if prefix_length >= suffix_length {\n            palindrome = palindrome.chars().skip_while(|c|\
    \ !c.is_lowercase()).collect();\n        } else {\n            palindrome = palindrome.chars().skip_while(|c|\
    \ !c.is_lowercase()).collect();\n            palindrome.push(palindrome.chars().skip_while(|c|\
    \ !c.is_lowercase()).collect());\n        }\n    }\n    palindrome\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmprshslhb5.rs:18:18\n\
    \   |\n18 |         for c in palindrome {\n   |                  ^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ a value of type `char` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmprshslhb5.rs:29:82\n     |\n29   |             palindrome.push(palindrome.chars().skip_while(|c|\
    \ !c.is_lowercase()).collect());\n     |                                     \
    \                                             ^^^^^^^ value of type `char` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `char`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_length = string.len();\n\
    \    let mut prefix_length = 0;\n    while reverse_length > 0 {\n        let mut\
    \ current_char = reversed_string[reverse_length - 1];\n        reversed_string\
    \ = reversed_string[..reverse_length - 1];\n        reverse_length -= 1;\n   \
    \     if current_char == current_char.rev() {\n            prefix_length += 1;\n\
    \        }\n    }\n    reversed_string += &string[prefix_length..];\n    reversed_string\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpt0n05g7y.rs:16:32\n\
    \   |\n16 |         let mut current_char = reversed_string[reverse_length - 1];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt0n05g7y.rs:17:27\n\
    \   |\n12 |     let mut reversed_string = string;\n   |                      \
    \         ------ expected due to this value\n...\n17 |         reversed_string\
    \ = reversed_string[..reverse_length - 1];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \         |\n   |                           expected struct `String`, found `str`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_len = 0;\n    let mut longest_postfix_start = -1;\n\
    \    let mut longest_postfix_end = -1;\n    while longest_postfix_len < longest_postfix.len()\
    \ {\n        let mut postfix_start = -1;\n        let mut postfix_end = -1;\n\
    \        while postfix_end < longest_postfix.len() {\n            let mut postfix_len\
    \ = longest_postfix.len() - postfix_end;\n            while postfix_len > 0 {\n\
    \                let mut postfix_char = longest_postfix.chars().nth(postfix_end).unwrap();\n\
    \                if postfix_char == &mut reversed_string[postfix_end] {\n    \
    \                postfix_len -= 1;\n                } else {\n               \
    \     break;\n                }\n                postfix_end += 1;\n         \
    \   }\n            if postfix_end >= longest_postfix.len() {\n               \
    \ break;\n            }\n            if postfix_len > longest_postfix_len {\n\
    \                longest_postfix_len = postfix_len;\n                longest_postfix_start\
    \ = postfix_start;\n                longest_postfix_end = postfix_end;\n     \
    \       }\n        }\n        if longest_postfix_end >= longest_postfix.len()\
    \ {\n            break;\n        }\n        reversed_string[longest_postfix_end..].swap(reversed_string[longest_postfix_start..]);\n\
    \    }\n    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpobgcsdqg.rs:19:31\n\
    \   |\n19 |         let mut postfix_end = -1;\n   |                          \
    \     ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpobgcsdqg.rs:24:41\n\
    \   |\n24 |                 if postfix_char == &mut reversed_string[postfix_end]\
    \ {\n   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpobgcsdqg.rs:24:36\n\
    \   |\n24 |                 if postfix_char == &mut reversed_string[postfix_end]\
    \ {\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&mut _`\n   |\n   = note:           expected type `char`\n\
    \           found mutable reference `&mut _`\nhelp: consider removing the borrow\n\
    \   |\n24 -                 if postfix_char == &mut reversed_string[postfix_end]\
    \ {\n24 +                 if postfix_char == reversed_string[postfix_end] {\n\
    \   | \n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpobgcsdqg.rs:16:35\n\
    \   |\n16 |     let mut longest_postfix_end = -1;\n   |                      \
    \             ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help:\
    \ the following other types implement trait `Neg`:\n "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix = string;\n\
    \    let mut longest_postfix_len = 0;\n    let mut longest_postfix_start = -1;\n\
    \    for pos in string.char_indices() {\n        let mut postfix = &mut reversed_string[..pos];\n\
    \        let mut postfix_len = postfix.len();\n        let mut postfix_start =\
    \ -1;\n        while postfix_len > longest_postfix_len {\n            let mut\
    \ postfix_end = pos;\n            while postfix_end > 0 && postfix[postfix_end\
    \ - 1] == postfix[postfix_end] {\n                postfix_end -= 1;\n        \
    \    }\n            if postfix_end > 0 {\n                longest_postfix_len\
    \ = postfix_len;\n                longest_postfix_start = postfix_start;\n   \
    \         }\n            postfix_len -= 1;\n        }\n        if longest_postfix_start\
    \ != -1 {\n            postfix.append(&mut reversed_string[longest_postfix_start..pos]);\n\
    \        }\n        reversed_string = &mut reversed_string[pos..];\n    }\n  \
    \  longest_postfix\n}\n\nfn main() {\n    let candidate = make_palindrome;\n \
    \   assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeTo<(usize, char)>`\n\
    \  --> /tmp/tmp1alcm3on.rs:17:32\n   |\n17 |         let mut postfix = &mut reversed_string[..pos];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `RangeTo<(usize, char)>`\n   |\n   = help: the trait `Index<RangeTo<(usize,\
    \ char)>>` is not implemented for `String`\n   = help: the following other types\
    \ implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1alcm3on.rs:22:33\n\
    \   |\n22 |             while postfix_end > 0 && postfix[postfix_end - 1] == postfix[postfix_end]\
    \ {\n   |                                 ^ expected tuple, found integer\n  \
    \ |\n   = note: expected tuple `(usize, char)`\n               found type `{integer}`\n\
    \nerror[E0369]: cannot subtract `{integer}` from `(usize, char)`\n  --> /tmp/tmp1alcm3on.rs:22:58\n\
    \   |\n22 |             while postfix_end > 0 && postfix[postfix_end - 1] == postfix[postfix_end]\
    \ {\n   |                                              ----------- ^ - {integer}\n\
    \   |                                              |\n   |                   \
    \                           (usize, char)\n\nerror[E0368]: binary assignment operation\
    \ `-=` cannot be applied to type `(usize, char)`\n  --> /tmp/tmp1alcm3on.rs:23:17\n\
    \   |\n23 |                 postfix_end -= 1;\n   |                 -----------^^^^^\n\
    \   |                 |\n   |                 cannot use `-=` on type `(usize,\
    \ char)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1alcm3on.rs:25:30\n\
    \   |\n25 |             if postfix_end > 0 {\n   |                           \
    \   ^ expected tuple, found integer\n   |\n   = note: expected tuple `(usize,\
    \ char)`\n               found type `{integer}`\n\nerror[E0308]: misma"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut is_palindrome\
    \ = false;\n    while !is_palindrome {\n        let mut pos = 0;\n        while\
    \ pos < string.len() - 1 {\n            let mut char = string[pos];\n        \
    \    let mut next_char = string[pos + 1];\n            if char == next_char {\n\
    \                pos += 1;\n            } else {\n                is_palindrome\
    \ = true;\n                string = string.to_owned() + &reverse[..pos];\n   \
    \             break;\n            }\n        }\n    }\n    string\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptfum93z0.rs:18:28\n\
    \   |\n18 |             let mut char = string[pos];\n   |                    \
    \        ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptfum93z0.rs:19:33\n   |\n19 |             let mut next_char = string[pos\
    \ + 1];\n   |                                 ^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_len = 0;\n   \
    \ let mut longest_postfix_start = String::new();\n    let mut longest_postfix_start_len\
    \ = 0;\n    let mut longest_postfix_end = String::new();\n    let mut longest_postfix_end_len\
    \ = 0;\n    let mut longest_postfix_start_end = String::new();\n    let mut longest_postfix_start_end_len\
    \ = 0;\n    let mut longest_postfix_start_end_start = String::new();\n    let\
    \ mut longest_postfix_start_end_start_len = 0;\n    let mut longest_postfix_start_end_start_start\
    \ = String::new();\n    let mut longest_postfix_start_end_start_start_len = 0;\n\
    \    let mut longest_postfix_start_end_start_start_start = String::new();\n  \
    \  let mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut longest_postfix_start_end_start_start_start\
    \ = String::new();\n    let mut longest_postfix_start_end_start_start_start_len\
    \ = 0;\n    let mut longest_postfix_start_end_start_start_start_start = String::new();\n\
    \    let mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut\
    \ longest_postfix_start_end_start_start_start_start = String::new();\n    let\
    \ mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut longest_postfix_start_end_start_start_start_start\
    \ = String::new();\n    let mut longest_postfix_start_end_start_start_start_len\
    \ = 0;\n    let mut longest_postfix_start_end_start_start_start_start = String::new();\n\
    \    let mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut\
    \ longest_postfix_start_end_start_start_start_start = String::new();\n    let\
    \ mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut longest_postfix_start_end_start_start_start_start\
    \ = String::new();\n    let mut longest_postfix_start_end_start_start_start_len\
    \ = 0;\n    let mut longest_postfix_start_end_start_start_start_start = String::new();\n\
    \    let mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut\
    \ longest_postfix_start_end_start_start_start_start = String::new();\n    let\
    \ mut longest_postfix_start_end_start_start_start_len = 0;\n    let mut longest_postfix_start_end_start_start_start_start\
    \ = String::\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp2a2r7_st.rs:47:1\n\
    \   |\n47 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_length = 0;\n\
    \    for pos in string.rfind('a') {\n        if pos == 0 {\n            break;\n\
    \        }\n        let mut suffix = &string[..pos];\n        let mut prefix =\
    \ &string[..pos];\n        while !suffix.is_empty() {\n            if prefix.len()\
    \ > longest_postfix_length {\n                longest_postfix_length = prefix.len();\n\
    \            }\n            reversed_string = reversed_string[..].to_string()\
    \ + &suffix;\n            suffix = &string[..pos];\n            prefix = &string[..pos];\n\
    \        }\n    }\n    reversed_string\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `string`\n  --> /tmp/tmp0dl935_o.rs:14:16\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \       ------ move occurs because `string` has type `String`, which does not\
    \ implement the `Copy` trait\n12 |     let mut reversed_string = string;\n   |\
    \                               ------ value moved here\n13 |     let mut longest_postfix_length\
    \ = 0;\n14 |     for pos in string.rfind('a') {\n   |                ^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n   |\n   = note: borrow occurs due to deref\
    \ coercion to `str`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    while suffix_length < string.len() {\n        let\
    \ mut suffix_start = suffix_length;\n        let mut suffix_end = suffix_length;\n\
    \        while suffix_start < string.len() && suffix_end < string.len() {\n  \
    \          if string[suffix_start] != string[suffix_end] {\n                break;\n\
    \            }\n            suffix_start += 1;\n            suffix_end += 1;\n\
    \        }\n        if suffix_start == suffix_end {\n            break;\n    \
    \    }\n        let mut prefix_start = prefix_length;\n        let mut prefix_end\
    \ = prefix_length;\n        while prefix_start < string.len() && prefix_end <\
    \ string.len() {\n            if string[prefix_start] != string[prefix_end] {\n\
    \                break;\n            }\n            prefix_start += 1;\n     \
    \       prefix_end += 1;\n        }\n        if prefix_start == prefix_end {\n\
    \            break;\n        }\n        reversed_string.push_str(&string[prefix_start..prefix_end]);\n\
    \        suffix_length -= prefix_end - prefix_start;\n        prefix_length -=\
    \ suffix_end - suffix_start;\n    }\n    reversed_string\n}\n\nfn main() {\n \
    \   let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy5d2te__.rs:19:16\n\
    \   |\n19 |             if string[suffix_start] != string[suffix_end] {\n   |\
    \                ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpy5d2te__.rs:19:40\n   |\n19 |             if string[suffix_start]\
    \ != string[suffix_end] {\n   |                                        ^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpy5d2te__.rs:31:16\n   |\n31 |             if string[prefix_start]\
    \ != string[prefix_end] {\n   |                ^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <Stri"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = string;\n    let mut prefix = string;\n    let mut suffix\
    \ = string;\n    let mut palindrome = string;\n    let mut i = 1;\n    while i\
    \ < prefix.len() {\n        if prefix[i] != suffix[prefix.len() - i] {\n     \
    \       palindrome = prefix.to_owned() + palindrome.to_owned();\n            reverse\
    \ = suffix.to_owned() + reverse.to_owned();\n            prefix = prefix.to_owned();\n\
    \            suffix = suffix.to_owned();\n            i += 1;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    palindrome = prefix.to_owned()\
    \ + palindrome.to_owned();\n    reverse = suffix.to_owned() + reverse.to_owned();\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxty30zq_.rs:18:12\n\
    \   |\n18 |         if prefix[i] != suffix[prefix.len() - i] {\n   |         \
    \   ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxty30zq_.rs:18:25\n   |\n18 |         if prefix[i] != suffix[prefix.len()\
    \ - i] {\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxty30zq_.rs:19:46\n\
    \   |\n19 |             palindrome = prefix.to_owned() + palindrome.to_owned();\n\
    \   |                                              ^^^^^^^^^^^^^^^^^^^^^\n   |\
    \                                              |\n   |                       \
    \                       expected `&str`, found struct `String`\n   |         \
    \                                     help: consider borrowing here: `&palindrome.to_owned()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxty30zq_.rs:20:43\n   |\n20 |\
    \             reverse = suffix.to_owned() + reverse.to_owned();\n   |        \
    \                          "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_string = \"\";\n    let mut longest_postfix_index2 = 0;\n\
    \    let mut longest_postfix_string2 = \"\";\n    let mut longest_postfix_index3\
    \ = 0;\n    let mut longest_postfix_string3 = \"\";\n    let mut longest_postfix_index4\
    \ = 0;\n    let mut longest_postfix_string4 = \"\";\n    let mut longest_postfix_index5\
    \ = 0;\n    let mut longest_postfix_string5 = \"\";\n    let mut longest_postfix_index6\
    \ = 0;\n    let mut longest_postfix_string6 = \"\";\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_string7 = \"\";\n    let mut longest_postfix_index8\
    \ = 0;\n    let mut longest_postfix_string8 = \"\";\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_string9 = \"\";\n    let mut longest_postfix_index10\
    \ = 0;\n    let mut longest_postfix_string10 = \"\";\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_string11 = \"\";\n    let mut longest_postfix_index12\
    \ = 0;\n    let mut longest_postfix_string12 = \"\";\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_string13 = \"\";\n    let mut longest_postfix_index14\
    \ = 0;\n    let mut longest_postfix_string14 = \"\";\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_string15 = \"\";\n    let mut longest_postfix_index16\
    \ = 0;\n    let mut longest_postfix_string16 = \"\";\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_string17 = \"\";\n    let mut longest_postfix_index18\
    \ = 0;\n    let mut longest_postfix_string18 = \"\";\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_string19 = \"\";\n    let mut longest_postfix_index20\
    \ = 0;\n    let mut longest_postfix_string20 = \"\";\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_string21 = \"\";\n    let mut longest_postfix_index22\
    \ = 0;\n    let mut longest_postfix_string22 = \"\";\n    let mut longest_postfix_index23\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzieaxgtp.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index23\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzieaxgtp.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_char = 0;\n    let mut longest_postfix_char_index = 0;\n\
    \    let mut longest_postfix_char_length = 0;\n    let mut longest_postfix_char_length_index\
    \ = 0;\n    let mut longest_postfix_char_length_index2 = 0;\n    let mut longest_postfix_char_length_index3\
    \ = 0;\n    let mut longest_postfix_char_length_index4 = 0;\n    let mut longest_postfix_char_length_index5\
    \ = 0;\n    let mut longest_postfix_char_length_index6 = 0;\n    let mut longest_postfix_char_length_index7\
    \ = 0;\n    let mut longest_postfix_char_length_index8 = 0;\n    let mut longest_postfix_char_length_index9\
    \ = 0;\n    let mut longest_postfix_char_length_index10 = 0;\n    let mut longest_postfix_char_length_index11\
    \ = 0;\n    let mut longest_postfix_char_length_index12 = 0;\n    let mut longest_postfix_char_length_index13\
    \ = 0;\n    let mut longest_postfix_char_length_index14 = 0;\n    let mut longest_postfix_char_length_index15\
    \ = 0;\n    let mut longest_postfix_char_length_index16 = 0;\n    let mut longest_postfix_char_length_index17\
    \ = 0;\n    let mut longest_postfix_char_length_index18 = 0;\n    let mut longest_postfix_char_length_index19\
    \ = 0;\n    let mut longest_postfix_char_length_index20 = 0;\n    let mut longest_postfix_char_length_index21\
    \ = 0;\n    let mut longest_postfix_char_length_index22 = 0;\n    let mut longest_postfix_char_length_index23\
    \ = 0;\n    let mut longest_postfix_char_length_index24 = 0;\n    let mut longest_postfix_char_length_index25\
    \ = 0;\n    let mut longest_postfix_char_length_index26 = 0;\n    let mut longest_postfix_char_length_index27\
    \ = 0;\n    let mut longest_postfix_char_length_index28 = 0;\n    let mut longest_postfix_char_length_index29\
    \ = 0;\n    let mut longest_postfix_char_length_index30 = 0;\n    let mut longest_postfix_char_length_index31\
    \ = 0;\n    let mut longest_postfix_char_length_index32 = 0;\n    let mut longest_postfix_char_length_index33\
    \ = 0;\n    let mut longest_postfix_char_length_index34 = 0;\n    let mut longest_postfix_char_length\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpeb4jvber.rs:53:40\n   |\n\
    53 |     let mut longest_postfix_char_length\n   |                           \
    \             ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpeb4jvber.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_length = 0;\n    while\
    \ !string.ends_with(&reversed_string) {\n        let mut postfix = string;\n \
    \       let mut postfix_length = 0;\n        while !postfix.ends_with(&reversed_string)\
    \ {\n            postfix.push_str(&reversed_string);\n            postfix_length\
    \ += 1;\n        }\n        longest_postfix = postfix.clone();\n        longest_postfix_length\
    \ = postfix_length;\n        string = postfix.clone();\n        reversed_string\
    \ = &string[..postfix_length];\n    }\n    longest_postfix.push_str(&reversed_string);\n\
    \    longest_postfix_length\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsy53_zqe.rs:23:27\n   |\n\
    14 |     let mut longest_postfix = \"\";\n   |                               --\
    \ expected due to this value\n...\n23 |         longest_postfix = postfix.clone();\n\
    \   |                           ^^^^^^^^^^^^^^^\n   |                        \
    \   |\n   |                           expected `&str`, found struct `String`\n\
    \   |                           help: consider borrowing here: `&postfix`\n\n\
    error[E0599]: no method named `push_str` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmpsy53_zqe.rs:28:21\n   |\n28 |     longest_postfix.push_str(&reversed_string);\n\
    \   |                     ^^^^^^^^ method not found in `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsy53_zqe.rs:29:5\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |                                       ------ expected\
    \ `String` because of return type\n...\n29 |     longest_postfix_length\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `usize`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    let mut longest_postfix_index = 0;\n    let\
    \ mut longest_postfix_index2 = 0;\n    let mut longest_postfix_index3 = 0;\n \
    \   let mut longest_postfix_index4 = 0;\n    let mut longest_postfix_index5 =\
    \ 0;\n    let mut longest_postfix_index6 = 0;\n    let mut longest_postfix_index7\
    \ = 0;\n    let mut longest_postfix_index8 = 0;\n    let mut longest_postfix_index9\
    \ = 0;\n    let mut longest_postfix_index10 = 0;\n    let mut longest_postfix_index11\
    \ = 0;\n    let mut longest_postfix_index12 = 0;\n    let mut longest_postfix_index13\
    \ = 0;\n    let mut longest_postfix_index14 = 0;\n    let mut longest_postfix_index15\
    \ = 0;\n    let mut longest_postfix_index16 = 0;\n    let mut longest_postfix_index17\
    \ = 0;\n    let mut longest_postfix_index18 = 0;\n    let mut longest_postfix_index19\
    \ = 0;\n    let mut longest_postfix_index20 = 0;\n    let mut longest_postfix_index21\
    \ = 0;\n    let mut longest_postfix_index22 = 0;\n    let mut longest_postfix_index23\
    \ = 0;\n    let mut longest_postfix_index24 = 0;\n    let mut longest_postfix_index25\
    \ = 0;\n    let mut longest_postfix_index26 = 0;\n    let mut longest_postfix_index27\
    \ = 0;\n    let mut longest_postfix_index28 = 0;\n    let mut longest_postfix_index29\
    \ = 0;\n    let mut longest_postfix_index30 = 0;\n    let mut longest_postfix_index31\
    \ = 0;\n    let mut longest_postfix_index32 = 0;\n    let mut longest_postfix_index33\
    \ = 0;\n    let mut longest_postfix_index34 = 0;\n    let mut longest_postfix_index35\
    \ = 0;\n    let mut longest_postfix_index36 = 0;\n    let mut longest_postfix_index37\
    \ = 0;\n    let mut longest_postfix_index38 = 0;\n    let mut longest_postfix_index39\
    \ = 0;\n    let mut longest_postfix_index40 = 0;\n    let mut longest_postfix_index41\
    \ = 0;\n    let mut longest_postfix_index42 = 0;\n    let mut longest_postfix_index43\
    \ = 0;\n    let mut longest_postfix_index44 = 0;\n    let mut longest_postfix_index45\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo69wv1oh.rs:59:36\n   |\n\
    59 |     let mut longest_postfix_index45\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo69wv1oh.rs:11:39\n   |\n11 | fn make_palindrome(string:\
    \ String) -> String {\n   |    ---------------                    ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012115
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut reversed_string = string;\n\n \
    \   while !palindrome.is_empty() {\n        let mut index = palindrome.rfind('a');\n\
    \        if index == -1 {\n            break;\n        }\n        let mut suffix\
    \ = palindrome[index..].chars().collect::<String>();\n        reversed_string.push(palindrome[index..]);\n\
    \        palindrome = &palindrome[index..];\n        reversed_string.push(palindrome[..index].chars().collect::<String>());\n\
    \        palindrome = &palindrome[index..];\n        reversed_string.push(suffix);\n\
    \        palindrome = &palindrome[index..];\n    }\n    reversed_string\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7r_m3chy.rs:17:21\n   |\n\
    17 |         if index == -1 {\n   |                     ^^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n\
    17 |         if index == Some(-1) {\n   |                     +++++  +\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n  --> /tmp/tmp7r_m3chy.rs:20:26\n\
    \   |\n20 |         let mut suffix = palindrome[index..].chars().collect::<String>();\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `RangeFrom<Option<usize>>`\n   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \  --> /tmp/tmp7r_m3chy.rs:21:30\n   |\n21 |         reversed_string.push(palindrome[index..]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `RangeFrom<Option<usize>>`\n   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n\
    \  --> /tmp/tmp7r_m3chy.rs:"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = string;\n    let mut prefix = string;\n    let mut suffix_index\
    \ = string.len();\n    let mut suffix_length = 0;\n    let mut suffix_char: char;\n\
    \    while suffix_index >= 0 {\n        suffix_char = string[suffix_index];\n\
    \        suffix_length += 1;\n        if suffix_length == 2 {\n            suffix_index\
    \ -= 1;\n            suffix_length = 0;\n        }\n        if suffix_char ==\
    \ string[suffix_index] {\n            suffix_index -= 1;\n            suffix_length\
    \ = 0;\n        } else {\n            break;\n        }\n    }\n    let mut suffix_length\
    \ = suffix_length;\n    let mut suffix_char = suffix_char;\n    while suffix_index\
    \ >= 0 {\n        suffix_char = string[suffix_index];\n        suffix_length +=\
    \ 1;\n        if suffix_length == 2 {\n            suffix_index -= 1;\n      \
    \      suffix_length = 0;\n        }\n        if suffix_char == string[suffix_index]\
    \ {\n            suffix_index -= 1;\n            suffix_length = 0;\n        }\
    \ else {\n            break;\n        }\n    }\n    let mut suffix_length = suffix_length;\n\
    \    let mut suffix_char = suffix_char;\n    while suffix_index >= 0 {\n     \
    \   suffix_char = string[suffix_index];\n        suffix_length += 1;\n       \
    \ if suffix_length == 2 {\n            suffix_index -= 1;\n            suffix_length\
    \ = 0;\n        }\n        if suffix_char == string[suffix_index] {\n        \
    \    suffix_index -= 1;\n            suffix_length = 0;\n        } else {\n  \
    \          break;\n        }\n    }\n    let mut suffix_length = suffix_length;\n\
    \    let mut suffix_char = suffix_char;\n    while suffix_index >= 0 {\n     \
    \   suffix_char = string[suffix_index];\n        suffix_length += 1;\n       \
    \ if suffix_length == 2 {\n            suffix_index -= 1;\n            suffix_length\
    \ = 0;\n        }\n        if suffix_char == string[suffix_index] {\n        \
    \    suffix_index -= 1;\n            suffix_length = 0;\n        } else {\n  \
    \          break;\n        }\n    }\n    let mut suffix_length = suffix_length;\n\
    \    let mut suffix_char = suffix_char;\n    while suffix_index >= 0 {\n     \
    \   suffix_char = string[suffix_index];\n        suffix_length += 1;\n       \
    \ if suffix_length == 2 {\n            suffix_index -= 1;\n            suffix_length\
    \ = 0;\n        }\n        if suffix_char == string[suffix_index] {\n        \
    \    suffix_index -= 1;\n            \n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpviglk1ae.rs:100:3\n\
    \    |\n11  | fn make_palindrome(string: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n81  |     while\
    \ suffix_index >= 0 {\n    |                             - unclosed delimiter\n\
    ...\n88  |         if suffix_char == string[suffix_index] {\n    |           \
    \                                     - this delimiter might not be properly closed...\n\
    ...\n91  | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n100 | }\n    |   ^\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpviglk1ae.rs:18:23\n   |\n18 |         suffix_char = string[suffix_index];\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpviglk1ae.rs:24:27\n   |\n24 |         if suffix_char == string[suffix_index]\
    \ {\n   |                           ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usi"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut palindrome = string;\n   \
    \ let mut prefix_length = 0;\n    let mut suffix_length = 0;\n    while !reversed_string.is_empty()\
    \ {\n        let mut current_char = reversed_string.chars().next().unwrap();\n\
    \        if current_char == current_char.to_ascii_lowercase().rev() {\n      \
    \      palindrome.append(&current_char);\n            suffix_length += 1;\n  \
    \      } else {\n            prefix_length += 1;\n        }\n        reversed_string\
    \ = reversed_string.chars().next().unwrap();\n    }\n    palindrome.append(&string[prefix_length..suffix_length]);\n\
    \    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `char` is not an iterator\n  --> /tmp/tmp5rft1h45.rs:18:62\n\
    \   |\n18 |         if current_char == current_char.to_ascii_lowercase().rev()\
    \ {\n   |                                                              ^^^ `char`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `char: Iterator`\n           which is required by `&mut char: Iterator`\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp5rft1h45.rs:19:24\n   |\n19 |             palindrome.append(&current_char);\n\
    \   |                        ^^^^^^ method not found in `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5rft1h45.rs:24:27\n   |\n12 |     let mut reversed_string\
    \ = string;\n   |                               ------ expected due to this value\n\
    ...\n24 |         reversed_string = reversed_string.chars().next().unwrap();\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \   |\n   |                           expected struct `String`, found `char`\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp5rft1h45.rs:26:16\n   |\n26 |     palindrome.append(&string[prefix_length..suffix_length]);\n\
    \   |                ^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut palindrome = string;\n   \
    \ let mut suffix_length = 0;\n    let mut prefix_length = 0;\n    while !reversed_string.is_empty()\
    \ {\n        let mut suffix_start = suffix_length;\n        let mut suffix_end\
    \ = suffix_length;\n        let mut prefix_start = prefix_length;\n        let\
    \ mut prefix_end = prefix_length;\n        while suffix_end < reversed_string.len()\
    \ {\n            let mut suffix_char = reversed_string[suffix_end];\n        \
    \    suffix_end += 1;\n            suffix_char = match suffix_char {\n       \
    \         'a' => \"b\",\n                'b' => \"a\",\n                'c' =>\
    \ \"t\",\n                't' => \"c\",\n                'd' => \"g\",\n     \
    \           'g' => \"d\",\n                'f' => \"h\",\n                'h'\
    \ => \"f\",\n                'i' => \"j\",\n                'j' => \"i\",\n  \
    \              'k' => \"l\",\n                'l' => \"k\",\n                'm'\
    \ => \"n\",\n                'n' => \"m\",\n                'o' => \"p\",\n  \
    \              'p' => \"o\",\n                'q' => \"r\",\n                'r'\
    \ => \"q\",\n                's' => \"u\",\n                'u' => \"s\",\n  \
    \              'v' => \"w\",\n                'w' => \"v\",\n                'y'\
    \ => \"z\",\n                'z' => \"y\",\n                _ => panic!(\"Invalid\
    \ character in string: {}\", suffix_char),\n            };\n            if suffix_char\
    \ == reversed_string[suffix_end - 1] {\n                suffix_end += 1;\n   \
    \         } else {\n                break;\n            }\n        }\n       \
    \ while prefix_end < reversed_string.len() {\n            let mut prefix_char\
    \ = reversed_string[prefix_end];\n            prefix_end += 1;\n            prefix_char\
    \ = match prefix_char {\n                'a' => \"b\",\n                'b' =>\
    \ \"a\",\n                'c' => \"t\",\n                't' => \"c\",\n     \
    \           'd' => \"g\",\n                'g' => \"d\",\n                'f'\
    \ => \"h\",\n                'h' => \"f\",\n                'i' => \"j\",\n  \
    \              'j' => \"i\",\n                'k' => \"l\",\n                'l'\
    \ => \"k\",\n                'm' => \"n\",\n                'n' => \"m\",\n  \
    \              'o' => \"p\",\n                'p' => \"o\",\n                'q'\
    \ => \"r\",\n                'r' => \"q\",\n                's' => \"u\",\n  \
    \              'u' => \"s\",\n                'v' => \"w\",\n                'w'\
    \ => \"v\",\n                'y' => \"\n}\n\nfn main() {\n    let candidate =\
    \ make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp370plh19.rs:92:73\n\
    \   |\n92 |       assert_eq!(candidate(String::from(\"jerry\")), String::from(\"\
    jerryrrej\"));\n   |  _________________________________________________________________________^\n\
    93 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string_to_reverse = string;\n    let mut reversed_string = \"\";\n\
    \    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length =\
    \ 0;\n    let mut longest_postfix_string = \"\";\n    let mut longest_postfix_string_length\
    \ = 0;\n    while longest_postfix_index < string_to_reverse.len() {\n        let\
    \ mut current_postfix_length = string_to_reverse.len() - longest_postfix_index;\n\
    \        if current_postfix_length >= longest_postfix_length {\n            longest_postfix_length\
    \ = current_postfix_length;\n            longest_postfix_string = string_to_reverse.chars().take(longest_postfix_length).collect::<String>();\n\
    \            longest_postfix_string_length = longest_postfix_string.len();\n \
    \       }\n        let mut current_postfix_index = longest_postfix_index + longest_postfix_string_length\
    \ - 1;\n        while current_postfix_index >= 0 {\n            let mut current_postfix_char\
    \ = string_to_reverse[current_postfix_index];\n            if current_postfix_char\
    \ == string_to_reverse[current_postfix_index + 1] {\n                current_postfix_index\
    \ -= 1;\n            } else {\n                break;\n            }\n       \
    \ }\n        reversed_string += longest_postfix_string;\n        string_to_reverse\
    \ = string_to_reverse.chars().skip(longest_postfix_index).collect();\n       \
    \ longest_postfix_index += longest_postfix_string_length;\n    }\n    reversed_string\
    \ += longest_postfix_string;\n    reversed_string\n}\n\nfn main() {\n    let candidate\
    \ = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"x\"));\n\
    \    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"));\n\
    \    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n  \
    \  assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpthz6v4lq.rs:22:38\n   |\n\
    16 |     let mut longest_postfix_string = \"\";\n   |                        \
    \              -- expected due to this value\n...\n22 |             longest_postfix_string\
    \ = string_to_reverse.chars().take(longest_postfix_length).collect::<String>();\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                      |\n   |                           \
    \           expected `&str`, found struct `String`\n   |                     \
    \                 help: consider borrowing here: `&string_to_reverse.chars().take(longest_postfix_length).collect::<String>()`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpthz6v4lq.rs:27:44\n\
    \   |\n27 |             let mut current_postfix_char = string_to_reverse[current_postfix_index];\n\
    \   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpthz6v4lq.rs:28:40\n   |\n28 |             if current_postfix_char\
    \ == string_to_reverse[current_postfix_index + 1] {\n   |                    \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \         "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = \"\";\n    let mut longest_postfix_len = 0;\n    let mut longest_postfix_start\
    \ = 0;\n    let mut longest_postfix_end = 0;\n    let mut longest_postfix_start2\
    \ = 0;\n    let mut longest_postfix_end2 = 0;\n    let mut longest_postfix_start3\
    \ = 0;\n    let mut longest_postfix_end3 = 0;\n    let mut longest_postfix_start4\
    \ = 0;\n    let mut longest_postfix_end4 = 0;\n    let mut longest_postfix_start5\
    \ = 0;\n    let mut longest_postfix_end5 = 0;\n    let mut longest_postfix_start6\
    \ = 0;\n    let mut longest_postfix_end6 = 0;\n    let mut longest_postfix_start7\
    \ = 0;\n    let mut longest_postfix_end7 = 0;\n    let mut longest_postfix_start8\
    \ = 0;\n    let mut longest_postfix_end8 = 0;\n    let mut longest_postfix_start9\
    \ = 0;\n    let mut longest_postfix_end9 = 0;\n    let mut longest_postfix_start10\
    \ = 0;\n    let mut longest_postfix_end10 = 0;\n    let mut longest_postfix_start11\
    \ = 0;\n    let mut longest_postfix_end11 = 0;\n    let mut longest_postfix_start12\
    \ = 0;\n    let mut longest_postfix_end12 = 0;\n    let mut longest_postfix_start13\
    \ = 0;\n    let mut longest_postfix_end13 = 0;\n    let mut longest_postfix_start14\
    \ = 0;\n    let mut longest_postfix_end14 = 0;\n    let mut longest_postfix_start15\
    \ = 0;\n    let mut longest_postfix_end15 = 0;\n    let mut longest_postfix_start16\
    \ = 0;\n    let mut longest_postfix_end16 = 0;\n    let mut longest_postfix_start17\
    \ = 0;\n    let mut longest_postfix_end17 = 0;\n    let mut longest_postfix_start18\
    \ = 0;\n    let mut longest_postfix_end18 = 0;\n    let mut longest_postfix_start19\
    \ = 0;\n    let mut longest_postfix_end19 = 0;\n    let mut longest_postfix_start20\
    \ = 0;\n    let mut longest_postfix_end20 = 0;\n    let mut longest_postfix_start21\
    \ = 0;\n    let mut longest_postfix_end21 = 0;\n    let mut longest_postfix_start22\
    \ = 0;\n    let mut longest_postfix_end22 = 0;\n    let mut lon\n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbptpvpn_.rs:60:16\n   |\n\
    60 |     let mut lon\n   |                ^ help: add `;` here\n61 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbptpvpn_.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reverse = String::from(\"\");\n    let mut postfix = String::from(\"\
    \");\n    let mut prefix_len = string.len();\n    while prefix_len > 0 {\n   \
    \     let mut prefix_char = string[prefix_len - 1];\n        let mut suffix_len\
    \ = string.len();\n        while suffix_len > 0 {\n            let mut suffix_char\
    \ = string[suffix_len - 1];\n            if suffix_char == prefix_char {\n   \
    \             suffix_len -= 1;\n            } else {\n                let mut\
    \ suffix_char = string[suffix_len - 1];\n                while suffix_len > 0\
    \ && suffix_char == prefix_char {\n                    suffix_len -= 1;\n    \
    \                suffix_char = string[suffix_len - 1];\n                }\n  \
    \              postfix.push_str(&string[prefix_len..suffix_len]);\n          \
    \      prefix_len -= suffix_len;\n                suffix_len -= 1;\n         \
    \   }\n        }\n        reverse.push_str(&string[prefix_len..]);\n        prefix_len\
    \ -= 1;\n    }\n    reverse.push_str(&postfix);\n    reverse\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgb0e_3v9.rs:16:31\n\
    \   |\n16 |         let mut prefix_char = string[prefix_len - 1];\n   |      \
    \                         ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgb0e_3v9.rs:19:35\n   |\n19 |             let mut suffix_char =\
    \ string[suffix_len - 1];\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgb0e_3v9.rs:23:39\n   |\n23 |                 let mut suffix_char\
    \ = string[suffix_len - 1];\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_length = 0;\n    let\
    \ mut longest_postfix_length = 0;\n    let mut longest_postfix_start = -1;\n \
    \   let mut longest_postfix_end = -1;\n    while !reversed_string.is_empty() {\n\
    \        let mut current_postfix_length = 0;\n        let mut current_postfix_start\
    \ = -1;\n        let mut current_postfix_end = -1;\n        for (i, c) in reversed_string.chars().enumerate()\
    \ {\n            if c == 'a' {\n                current_postfix_start = i;\n \
    \           }\n            if c == 'z' {\n                current_postfix_end\
    \ = i;\n            }\n            current_postfix_length += 1;\n        }\n \
    \       if current_postfix_length >= longest_postfix_length {\n            longest_postfix_length\
    \ = current_postfix_length;\n            longest_postfix_start = current_postfix_start;\n\
    \            longest_postfix_end = current_postfix_end;\n        }\n        reversed_string\
    \ = reversed_string[..current_postfix_end].to_string();\n        reverse_length\
    \ += 1;\n    }\n    if longest_postfix_length == 0 {\n        return string;\n\
    \    }\n    let mut reversed_string = string;\n    let mut reverse_length = 0;\n\
    \    let mut longest_postfix_length = 0;\n    let mut longest_postfix_start =\
    \ -1;\n    let mut longest_postfix_end = -1;\n    while !reversed_string.is_empty()\
    \ {\n        let mut current_postfix_length = 0;\n        let mut current_postfix_start\
    \ = -1;\n        let mut current_postfix_end = -1;\n        for (i, c) in reversed_string.chars().enumerate()\
    \ {\n            if c == 'a' {\n                current_postfix_start = i;\n \
    \           }\n            if c == 'z' {\n                current_postfix_end\
    \ = i;\n            }\n            current_postfix_length += 1;\n        }\n \
    \       if current_postfix_length >= longest_postfix_length {\n            longest_postfix_length\
    \ = current_postfix_length;\n            longest_postfix_start = current_postfix_start;\n\
    \            longest_postfix_end = current_postfix_end;\n        }\n        reversed_string\
    \ = reversed_string[..current_postfix_end].to_string();\n        reverse_length\
    \ += 1;\n    }\n    if longest_postfix_length == 0 {\n        return string;\n\
    \    }\n    let mut reversed_string = string;\n    let mut reverse_length = 0;\n\
    \    let mut longest_postfix_length = 0;\n    let mut longest_postfix_start =\
    \ -1;\n    let mut longest_postfix_end = -1;\n    while !reversed_string.is_empty()\
    \ {\n        let mut current_postfix_length = 0;\n        let mut current_postfix_start\
    \ = -1;\n        let mu\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp2najnvdx.rs:88:3\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |             \
    \                                 - unclosed delimiter\n...\n75 |     while !reversed_string.is_empty()\
    \ {\n   |                                       - this delimiter might not be\
    \ properly closed...\n...\n79 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n88 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  -->\
    \ /tmp/tmp2najnvdx.rs:78:15\n   |\n78 |         let mu\n   |               ^ help:\
    \ add `;` here\n79 | }\n   | - unexpected token\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmp2najnvdx.rs:19:41\n   |\n19 | \
    \        let mut current_postfix_start = -1;\n   |                           \
    \              ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help:\
    \ the following other types implement trait `Neg`:\n             &f32\n      \
    \       &f64\n             &i128\n             &i16\n             &i32\n     \
    \        &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp2najnvdx.rs:20:39\n\
    \   |\n20 |         let mut current_postfix_end = -1;\n   |                  \
    \                     ^^ the trait `Neg` is not implemented for `usize`\n   |\n\
    \   = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp2najnvdx.rs:15:37\n\
    \   |\n15 |     let mut longest_postfix_start = -1;\n   |                    \
    \                 ^^ the trait `Neg` is not implemented for `usize`\n   |\n  \
    \ = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0277]: the trait bou"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix_length = 0;\n    while !string.is_empty() {\n        let mut\
    \ postfix_length = string.len();\n        while postfix_length >= longest_postfix_length\
    \ {\n            let mut postfix_substring = &string[..postfix_length];\n    \
    \        let mut reversed_substring = &reversed_string[..postfix_length];\n  \
    \          if postfix_substring == reversed_substring {\n                longest_postfix_length\
    \ = postfix_length;\n                break;\n            }\n            postfix_substring\
    \ = &string[postfix_length..];\n            reversed_substring = &reversed_string[postfix_length..];\n\
    \        }\n        string = &string[longest_postfix_length..];\n        reversed_string\
    \ += &string[..longest_postfix_length];\n    }\n    String::from(reversed_string)\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppll63nfl.rs:27:18\n   |\n\
    12 |     let mut string = string;\n   |                      ------ expected due\
    \ to this value\n...\n27 |         string = &string[longest_postfix_length..];\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n27 |        \
    \ string = (&string[longest_postfix_length..]).to_string();\n   |            \
    \      +                                 +++++++++++++\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmppll63nfl.rs:28:9\n\
    \   |\n28 |         reversed_string += &string[..longest_postfix_length];\n  \
    \ |         ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |       \
    \  |\n   |         cannot use `+=` on type `&str`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_pos = 0;\n    let\
    \ mut longest_postfix_len = 0;\n    while reverse_pos < reversed_string.len()\
    \ {\n        let mut postfix_len = reversed_string.len();\n        while postfix_len\
    \ > reverse_pos && reversed_string[reverse_pos] == reversed_string[postfix_len\
    \ - 1] {\n            postfix_len -= 1;\n        }\n        if postfix_len > longest_postfix_len\
    \ {\n            longest_postfix_len = postfix_len;\n        }\n        reverse_pos\
    \ += longest_postfix_len;\n    }\n    reversed_string.push_str(&string[reverse_pos..]);\n\
    \    reversed_string\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7gyib0mt.rs:17:44\n\
    \   |\n17 |         while postfix_len > reverse_pos && reversed_string[reverse_pos]\
    \ == reversed_string[postfix_len - 1] {\n   |                                \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7gyib0mt.rs:17:76\n   |\n17 |         while postfix_len > reverse_pos\
    \ && reversed_string[reverse_pos] == reversed_string[postfix_len - 1] {\n   |\
    \                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed = string;\n    let mut prefix = string;\n    let mut suffix\
    \ = string;\n    let mut prefix_len = prefix.len();\n    let mut suffix_len =\
    \ suffix.len();\n    let mut i = 0;\n    while i < prefix_len {\n        if suffix[suffix_len\
    \ - i - 1] != prefix[prefix_len - i - 1] {\n            break;\n        }\n  \
    \      i += 1;\n    }\n    suffix_len = i;\n    prefix_len = i;\n    while i <\
    \ suffix_len {\n        if suffix[suffix_len - i - 1] != prefix[prefix_len - i\
    \ - 1] {\n            break;\n        }\n        i += 1;\n    }\n    suffix_len\
    \ = i;\n    prefix_len = i;\n    let mut i = 0;\n    while i < prefix_len {\n\
    \        if suffix[suffix_len - i - 1] != prefix[prefix_len - i - 1] {\n     \
    \       break;\n        }\n        i += 1;\n    }\n    suffix_len = i;\n    prefix_len\
    \ = i;\n    while i < suffix_len {\n        if suffix[suffix_len - i - 1] != prefix[prefix_len\
    \ - i - 1] {\n            break;\n        }\n        i += 1;\n    }\n    suffix_len\
    \ = i;\n    prefix_len = i;\n    let mut i = 0;\n    while i < prefix_len {\n\
    \        if suffix[suffix_len - i - 1] != prefix[prefix_len - i - 1] {\n     \
    \       break;\n        }\n        i += 1;\n    }\n    suffix_len = i;\n    prefix_len\
    \ = i;\n    let mut i = 0;\n    while i < prefix_len {\n        if suffix[suffix_len\
    \ - i - 1] != prefix[prefix_len - i - 1] {\n            break;\n        }\n  \
    \      i += 1;\n    }\n    suffix_len = i;\n    prefix_len = i;\n    let mut i\
    \ = 0;\n    while i < prefix_len {\n        if suffix[suffix_len - i - 1] != prefix[prefix_len\
    \ - i - 1] {\n            break;\n        }\n        i += 1;\n    }\n    suffix_len\
    \ = i;\n    prefix_len = i;\n    let mut i = 0;\n    while i < prefix_len {\n\
    \        if suffix[suffix_len - i - 1] != prefix[prefix_len - i - 1] {\n     \
    \       break;\n        }\n        i += 1;\n    }\n    suffix_len = i;\n    prefix_len\
    \ = i;\n    let mut i = 0;\n    while i < prefix_len {\n        if suffix[suffix_len\
    \ - i - 1] != prefix[prefix_len - i - 1] {\n            break;\n        }\n  \
    \      i += 1;\n    }\n    suffix_len = i;\n    prefix_len = i;\n    let mut i\
    \ = 0;\n    while i < prefix_len {\n        if suffix[suffix_len - i - 1] != prefix[prefix_len\
    \ - i - 1] {\n            break;\n        }\n        i += 1;\n    }\n    suffix_len\
    \ = i;\n    prefix_len = i;\n    let mut i = 0;\n    while i < prefix_len {\n\n\
    }\n\nfn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp116d3kr3.rs:117:3\n\
    \    |\n11  | fn make_palindrome(string: String) -> String {\n    |          \
    \                                    - unclosed delimiter\n...\n106 |     while\
    \ i < prefix_len {\n    |                          - this delimiter might not\
    \ be properly closed...\n107 | \n108 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n117 | }\n    |   ^\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp116d3kr3.rs:19:12\n   |\n\
    19 |         if suffix[suffix_len - i - 1] != prefix[prefix_len - i - 1] {\n \
    \  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp116d3kr3.rs:19:42\n   |\n19 |         if suffix[suffix_len - i\
    \ - 1] != prefix[prefix_len - i - 1] {\n   |                                 \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp116d3kr3.rs:27:12\n   |\n27 |         if suffix[suffix_le"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut palindrome = string;\n    let mut prefix_length = 0;\n    let mut\
    \ suffix_length = 0;\n    while !palindrome.is_empty() {\n        let mut prefix_length\
    \ = 0;\n        let mut suffix_length = 0;\n        while !palindrome.starts_with(&string[prefix_length..])\
    \ {\n            prefix_length += 1;\n        }\n        while !palindrome.ends_with(&string[suffix_length..])\
    \ {\n            suffix_length += 1;\n        }\n        palindrome = &string[prefix_length..suffix_length];\n\
    \    }\n    palindrome\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvkbwk4sq.rs:24:22\n   |\n\
    12 |     let mut palindrome = string;\n   |                          ------ expected\
    \ due to this value\n...\n24 |         palindrome = &string[prefix_length..suffix_length];\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\nhelp: try using a conversion method\n   |\n24\
    \ |         palindrome = (&string[prefix_length..suffix_length]).to_string();\n\
    \   |                      +                                     +++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = string;\n    let\
    \ mut longest_postfix_length = 0;\n    let mut longest_postfix_length_index =\
    \ 0;\n    let mut longest_postfix_length_palindrome = 0;\n    let mut longest_postfix_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length = 0;\n    let mut\
    \ longest_postfix_length_palindrome_length_index = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_index\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length_palindrome_length\
    \ = 0;\n    let mut longest_postfix_length_palindrome_length\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6w2r1i47.rs:35:53\n   |\n\
    35 |     let mut longest_postfix_length_palindrome_length\n   |              \
    \                                       ^ help: add `;` here\n36 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6w2r1i47.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reverse = string;\n    let mut palindrome\
    \ = string;\n    let mut i = 1;\n    while i < string.len() {\n        let mut\
    \ j = i;\n        while j < string.len() {\n            if string[j] != string[i\
    \ - j] {\n                break;\n            }\n            j = j + 1;\n    \
    \    }\n        if j == i {\n            palindrome = &string[..i];\n        \
    \    i = i + 1;\n        } else {\n            reverse = &string[..j];\n     \
    \       i = j;\n        }\n    }\n    palindrome + reverse\n}\n\nfn main() {\n\
    \    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9uyu3zmm.rs:19:16\n\
    \   |\n19 |             if string[j] != string[i - j] {\n   |                ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9uyu3zmm.rs:19:29\n   |\n19 |             if string[j] != string[i\
    \ - j] {\n   |                             ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9uyu3zmm.rs:25:26\n\
    \   |\n14 |     let mut palindrome = string;\n   |                          ------\
    \ expected due to this value\n...\n25 |             palindrome = &string[..i];\n\
    \   |                          ^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n25 |             palindrome\
    \ = (&string[..i]).to_string();\n   |                          +            +++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9uyu3zmm.rs:28:23\n   |\n13 |\
    \     let mut reverse = string;\n   |                       ------ expected due\
    \ to this value\n...\n28 |             reve"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut string = string;\n    let mut reversed_string = \"\";\n    let mut\
    \ longest_postfix = String::new();\n    let mut longest_postfix_length = 0;\n\
    \    let mut longest_postfix_index = 0;\n    let mut longest_postfix_length_index\
    \ = 0;\n    let mut longest_postfix_index2 = 0;\n    let mut longest_postfix_length_index2\
    \ = 0;\n    let mut longest_postfix_length_index3 = 0;\n    let mut longest_postfix_length_index4\
    \ = 0;\n    let mut longest_postfix_length_index5 = 0;\n    let mut longest_postfix_length_index6\
    \ = 0;\n    let mut longest_postfix_length_index7 = 0;\n    let mut longest_postfix_length_index8\
    \ = 0;\n    let mut longest_postfix_length_index9 = 0;\n    let mut longest_postfix_length_index10\
    \ = 0;\n    let mut longest_postfix_length_index11 = 0;\n    let mut longest_postfix_length_index12\
    \ = 0;\n    let mut longest_postfix_length_index13 = 0;\n    let mut longest_postfix_length_index14\
    \ = 0;\n    let mut longest_postfix_length_index15 = 0;\n    let mut longest_postfix_length_index16\
    \ = 0;\n    let mut longest_postfix_length_index17 = 0;\n    let mut longest_postfix_length_index18\
    \ = 0;\n    let mut longest_postfix_length_index19 = 0;\n    let mut longest_postfix_length_index20\
    \ = 0;\n    let mut longest_postfix_length_index21 = 0;\n    let mut longest_postfix_length_index22\
    \ = 0;\n    let mut longest_postfix_length_index23 = 0;\n    let mut longest_postfix_length_index24\
    \ = 0;\n    let mut longest_postfix_length_index25 = 0;\n    let mut longest_postfix_length_index26\
    \ = 0;\n    let mut longest_postfix_length_index27 = 0;\n    let mut longest_postfix_length_index28\
    \ = 0;\n    let mut longest_postfix_length_index29 = 0;\n    let mut longest_postfix_length_index30\
    \ = 0;\n    let mut longest_postfix_length_index31 = 0;\n    let mut longest_postfix_length_index32\
    \ = 0;\n    let mut longest_postfix_length_index33 = 0;\n    let mut longest_postfix_length_index34\
    \ = 0;\n    let mut longest_postfix_length_index35 = 0;\n    let mut longest_postfix_length_index36\
    \ = 0;\n    let mut longest_postfix_length_index37 = 0;\n    let mut longest_postfix_length_index38\
    \ = 0;\n    let mut lon\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsewj6g28.rs:56:16\n   |\n\
    56 |     let mut lon\n   |                ^ help: add `;` here\n57 | }\n   | -\
    \ unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsewj6g28.rs:11:39\n\
    \   |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reversed_string_size = string.len();\n\
    \    while reversed_string_size != 0 {\n        reversed_string.swap(0, reversed_string_size\
    \ - 1);\n        reversed_string_size -= 1;\n    }\n    reversed_string\n}\n\n\
    fn main() {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpwu56d36m.rs:15:25\n   |\n15 |         reversed_string.swap(0,\
    \ reversed_string_size - 1);\n   |                         ^^^^ method not found\
    \ in `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut reverse_length = 0;\n    let\
    \ mut prefix_length = 0;\n    while !reversed_string.is_empty() {\n        let\
    \ mut current_char = reversed_string[0];\n        reversed_string = reversed_string.split_last_mut().unwrap();\n\
    \        reverse_length += 1;\n        if current_char == current_char.rev() {\n\
    \            prefix_length += 1;\n        }\n    }\n    let mut result = string;\n\
    \    while prefix_length > 0 {\n        let mut current_char = result[0];\n  \
    \      result = result.split_last_mut().unwrap();\n        prefix_length -= 1;\n\
    \        if current_char == current_char.rev() {\n            break;\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = make_palindrome;\n\
    \    assert_eq!(candidate(String::from(\"\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"\
    x\")), String::from(\"x\"));\n    assert_eq!(candidate(String::from(\"xyz\")),\
    \ String::from(\"xyzyx\"));\n    assert_eq!(candidate(String::from(\"xyx\")),\
    \ String::from(\"xyx\"));\n    assert_eq!(candidate(String::from(\"jerry\")),\
    \ String::from(\"jerryrrej\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmprwz2s490.rs:16:32\n   |\n16 |         let mut current_char = reversed_string[0];\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `split_last_mut` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmprwz2s490.rs:17:43\n   |\n17 | \
    \        reversed_string = reversed_string.split_last_mut().unwrap();\n   |  \
    \                                         ^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `split_at`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmprwz2s490.rs:25:32\n   |\n25\
    \ |         let mut current_char = result[0];\n   |                          \
    \      ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the\
    \ trait `Index<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `split_last_mut` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmprwz2s490.rs:26:25\n   |\n26 | \
    \        result = result.split_last_mut().unwrap();\n   |                    \
    \     ^^^^^^^^^^^^^^ help: there is an associated "
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut prefix_length = 0;\n    let\
    \ mut suffix_length = 0;\n    let mut suffix_start = 0;\n    let mut suffix_end\
    \ = 0;\n    let mut suffix_length = 0;\n    let mut suffix_start = 0;\n    let\
    \ mut suffix_end = 0;\n    let mut suffix_length = 0;\n    let mut suffix_start\
    \ = 0;\n    let mut suffix_end = 0;\n    let mut suffix_length = 0;\n    let mut\
    \ suffix_start = 0;\n    let mut suffix_end = 0;\n    let mut suffix_length =\
    \ 0;\n    let mut suffix_start = 0;\n    let mut suffix_end = 0;\n    let mut\
    \ suffix_length = 0;\n    let mut suffix_start = 0;\n    let mut suffix_end =\
    \ 0;\n    let mut suffix_length = 0;\n    let mut suffix_start = 0;\n    let mut\
    \ suffix_end = 0;\n    let mut suffix_length = 0;\n    let mut suffix_start =\
    \ 0;\n    let mut suffix_end = 0;\n    let mut suffix_length = 0;\n    let mut\
    \ suffix_start = 0;\n    let mut suffix_end = 0;\n    let mut suffix_length =\
    \ 0;\n    let mut suffix_start = 0;\n    let mut suffix_end = 0;\n    let mut\
    \ suffix_length = 0;\n    let mut suffix_start = 0;\n    let mut suffix_end =\
    \ 0;\n    let mut suffix_length = 0;\n    let mut suffix_start = 0;\n    let mut\
    \ suffix_end = 0;\n    let mut suffix_length = 0;\n    let mut suffix_start =\
    \ 0;\n    let mut suffix_end = 0;\n    let mut suffix_length = 0;\n    let mut\
    \ suffix_start = 0;\n    let mut suffix_end = 0;\n    let mut suffix_length =\
    \ 0;\n    let mut suffix_start = 0;\n    let mut suffix_end = 0;\n    let mut\
    \ suffix_length = 0;\n    let mut suffix_start = 0;\n    let mut suffix_end =\
    \ 0;\n    let mut suffix_length = 0;\n    let mut suffix_start = 0;\n    let mut\
    \ suffix_end = 0;\n    let mut suffix_length = 0;\n    let mut suffix_start =\
    \ 0;\n    let mut suffix_end = 0;\n    let mut suffix_length = 0;\n    let mut\
    \ suffix_start = 0;\n    let mut suffix_end = 0;\n    let mut suffix_length =\
    \ 0;\n    let mut suffix_start = 0;\n    let mut suffix_end = 0;\n    let mut\
    \ suffix_length = 0;\n    let mut suffix_start = 0;\n    let \n}\n\nfn main()\
    \ {\n    let candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp11jclo4o.rs:77:1\n  \
    \ |\n77 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660012116
- exit_code: 1
  program: "/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome(String::from(\"\
    \"))\n/// String::from(\"\")\n/// >>> make_palindrome(String::from(\"cat\"))\n\
    /// String::from(\"catac\")\n/// >>> make_palindrome(String::from(\"cata\"))\n\
    /// String::from(\"catac\")\nfn make_palindrome(string: String) -> String {\n\
    \    let mut reversed_string = string;\n    let mut longest_postfix_len = string.len();\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mut longest_postfix_end = -1;\n\
    \    let mut longest_postfix_start = -1;\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = make_palindrome;\n    assert_eq!(candidate(String::from(\"\")),\
    \ String::from(\"\"));\n    assert_eq!(candidate(String::from(\"x\")), String::from(\"\
    x\"));\n    assert_eq!(candidate(String::from(\"xyz\")), String::from(\"xyzyx\"\
    ));\n    assert_eq!(candidate(String::from(\"xyx\")), String::from(\"xyx\"));\n\
    \    assert_eq!(candidate(String::from(\"jerry\")), String::from(\"jerryrrej\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzu1eeo25.rs:63:11\n   |\n\
    63 |     let mu\n   |           ^ help: add `;` here\n64 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzu1eeo25.rs:11:39\n \
    \  |\n11 | fn make_palindrome(string: String) -> String {\n   |    ---------------\
    \                    ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660012116
