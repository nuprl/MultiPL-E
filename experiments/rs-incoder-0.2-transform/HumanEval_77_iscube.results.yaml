language: rs
name: HumanEval_77_iscube
results:
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10 || a == 11 || a == 12 ||\
    \ a == 13 || a == 14 || a == 15 || a == 16 || a == 17 || a == 18 || a == 19 ||\
    \ a == 20 || a == 21 || a == 22 || a == 23 || a == 24 || a == 25 || a == 26 ||\
    \ a == 27 || a == 28 || a == 29 || a == 30 || a == 31 || a == 32 || a == 33 ||\
    \ a == 34 || a == 35 || a == 36 || a == 37 || a == 38 || a == 39 || a == 40\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9i8w10y2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 3 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpty9o6ot5.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 3 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 9\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwoe3gytr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    debug_assert!(a >= 0);\n    debug_assert!(a <= 180);\n\
    \    if a == 1 {\n        return true;\n    }\n    if a == 2 {\n        return\
    \ true;\n    }\n    if a == 3 {\n        return true;\n    }\n    if a == 4 {\n\
    \        return true;\n    }\n    if a == 5 {\n        return true;\n    }\n \
    \   if a == 6 {\n        return true;\n    }\n    if a == 7 {\n        return\
    \ true;\n    }\n    if a == 8 {\n        return true;\n    }\n    if a == 9 {\n\
    \        return true;\n    }\n    if a == 10 {\n        return true;\n    }\n\
    \    if a == 11 {\n        return true;\n    }\n    if a == 12 {\n        return\
    \ true;\n    }\n    if a == 13 {\n        return true;\n    }\n    if a == 14\
    \ {\n        return true;\n    }\n    if a == 15 {\n        return true;\n   \
    \ }\n    if a == 16 {\n        return true;\n    }\n    if a == 17 {\n       \
    \ return true;\n    }\n    if a == 18 {\n        return true;\n    }\n    if a\
    \ == 19 {\n        return true;\n    }\n    if a == 20 {\n        return true;\n\
    \    }\n    if a == 21 {\n        return true;\n    }\n    if a == 22 {\n    \
    \    return true;\n    }\n    if a == 23 {\n        return true;\n    }\n    if\
    \ a == 24 {\n        return true;\n    }\n    if a == 25 {\n        return true;\n\
    \    }\n    if a == 26 {\n        return true;\n    }\n    if a == 27 {\n    \
    \    return true;\n    }\n    if a == 28 {\n        return true;\n    }\n    if\
    \ a == 29 {\n        return true;\n    }\n    if a == 30 {\n        return true;\n\
    \    }\n    if a == 31 {\n        return true;\n    }\n    if a == 32 {\n    \
    \    return true;\n    }\n    if a == 33 {\n        return true;\n    }\n    if\
    \ a == 34 {\n        return true;\n    }\n    if a == 35 {\n        return true;\n\
    \    }\n    if a == 36 {\n        return true;\n    }\n    if a == 37 {\n    \
    \    return true;\n    }\n    if a == 38 {\n        return true;\n    }\n    if\
    \ a == 39 {\n        return true;\n    }\n    if a == 40 {\n        return true;\n\
    \    }\n    if a == 41 {\n        return true;\n    }\n    if a == 42 {\n    \
    \    return true;\n    }\n    if a == 43 {\n        return true;\n    }\n    if\
    \ a == 44 {\n        return true;\n    }\n    if a == 45 {\n        return true;\n\
    \    }\n    if a == 46 {\n        return true;\n    }\n    if a == 47 {\n    \
    \    return true;\n    }\n    if a == 48 {\n        return true;\n    }\n    if\
    \ a == 49 {\n        return true;\n    }\n    if a == 50 {\n        return true;\n\
    \    }\n    if a == 51 {\n        return true;\n    }\n    if a == 52 {\n    \
    \    return true;\n    }\n    if a == 53 {\n        return true;\n    }\n    if\
    \ a == 54 {\n        return true;\n    }\n    if a == 55 {\n        return true;\n\
    \    }\n    if a == 56 {\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp442260sh.rs:198:3\n\
    \    |\n17  | fn iscube(a: isize) -> bool {\n    |                           \
    \  - unclosed delimiter\n...\n185 |     if a == 56 {\n    |                - this\
    \ delimiter might not be properly closed...\n186 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n198 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp442260sh.rs:17:24\n   |\n17 | fn iscube(a: isize)\
    \ -> bool {\n   |    ------              ^^^^ expected `bool`, found `()`\n  \
    \ |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == \n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpyimxdw_t.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    debug_assert!(a >= 0);\n    debug_assert!(a <= 180);\n\
    \    if a == 1 {\n        return true;\n    }\n    if a == 2 {\n        return\
    \ true;\n    }\n    if a == 3 {\n        return true;\n    }\n    if a == 4 {\n\
    \        return true;\n    }\n    if a == 5 {\n        return true;\n    }\n \
    \   if a == 6 {\n        return true;\n    }\n    if a == 7 {\n        return\
    \ true;\n    }\n    if a == 8 {\n        return true;\n    }\n    if a == 9 {\n\
    \        return true;\n    }\n    if a == 10 {\n        return true;\n    }\n\
    \    if a == 11 {\n        return true;\n    }\n    if a == 12 {\n        return\
    \ true;\n    }\n    if a == 13 {\n        return true;\n    }\n    if a == 14\
    \ {\n        return true;\n    }\n    if a == 15 {\n        return true;\n   \
    \ }\n    if a == 16 {\n        return true;\n    }\n    if a == 17 {\n       \
    \ return true;\n    }\n    if a == 18 {\n        return true;\n    }\n    if a\
    \ == 19 {\n        return true;\n    }\n    if a == 20 {\n        return true;\n\
    \    }\n    if a == 21 {\n        return true;\n    }\n    if a == 22 {\n    \
    \    return true;\n    }\n    if a == 23 {\n        return true;\n    }\n    if\
    \ a == 24 {\n        return true;\n    }\n    if a == 25 {\n        return true;\n\
    \    }\n    if a == 26 {\n        return true;\n    }\n    if a == 27 {\n    \
    \    return true;\n    }\n    if a == 28 {\n        return true;\n    }\n    if\
    \ a == 29 {\n        return true;\n    }\n    if a == 30 {\n        return true;\n\
    \    }\n    if a == 31 {\n        return true;\n    }\n    if a == 32 {\n    \
    \    return true;\n    }\n    if a == 33 {\n        return true;\n    }\n    if\
    \ a == 34 {\n        return true;\n    }\n    if a == 35 {\n        return true;\n\
    \    }\n    if a == 36 {\n        return true;\n    }\n    if a == 37 {\n    \
    \    return true;\n    }\n    if a == 38 {\n        return true;\n    }\n    if\
    \ a == 39 {\n        return true;\n    }\n    if a == 40 {\n        return true;\n\
    \    }\n    if a == 41 {\n        return true;\n    }\n    if a == 42 {\n    \
    \    return true;\n    }\n    if a == 43 {\n        return true;\n    }\n    if\
    \ a == 44 {\n        return true;\n    }\n    if a == 45 {\n        return true;\n\
    \    }\n    if a == 46 {\n        return true;\n    }\n    if a == 47 {\n    \
    \    return true;\n    }\n    if a == 48 {\n        return true;\n    }\n    if\
    \ a == 49 {\n        return true;\n    }\n    if a == 50 {\n        return true;\n\
    \    }\n    if a == 51 {\n        return true;\n    }\n    if a == 52 {\n    \
    \    return true;\n    }\n    if a == 53 {\n        return true;\n    }\n    if\
    \ a == 54 {\n        return true;\n    }\n    if a == 55 {\n        return true;\n\
    \    }\n    if a == 56 {\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp442260sh.rs:198:3\n\
    \    |\n17  | fn iscube(a: isize) -> bool {\n    |                           \
    \  - unclosed delimiter\n...\n185 |     if a == 56 {\n    |                - this\
    \ delimiter might not be properly closed...\n186 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n198 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp442260sh.rs:17:24\n   |\n17 | fn iscube(a: isize)\
    \ -> bool {\n   |    ------              ^^^^ expected `bool`, found `()`\n  \
    \ |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10 || a == 11 || a == 12 ||\
    \ a == 13 || a == 14 || a == 15 || a == 16 || a == 17 || a == 18 || a == 19 ||\
    \ a == 20 || a == 21 || a == 22 || a == 23 || a == 24 || a == 25 || a == 26 ||\
    \ a == 27 || a == 28 || a == 29 || a == 30 || a == 31 || a == 32 || a == 33 ||\
    \ a == 34 || a == 35 || a == 36 || a == 37 || a == 38 || a == 39 || a == 40\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9i8w10y2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 180 && a * a == a\n}\n\nfn main() {\n \
    \   let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpozwuwym8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a\
    \ == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1\
    \ || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || \n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpceprwfw3.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10 || a == 11 || a == 12 ||\
    \ a == 13 || a == 14 || a == 15 || a == 16 || a == 17 || a == 18 || a == 19 ||\
    \ a == 20 || a == 21 || a == 22 || a == 23 || a == 24 || a == 25 || a == 26 ||\
    \ a == 27 || a == 28 || a == 29 || a == 30 || a == 31 || a == 32 || a == 33 ||\
    \ a == 34 || a == 35 || a == 36 || a == 37 || a == 38 || a == 39 || a == 40\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9i8w10y2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 8 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp_nswmnws.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 8 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() &&\n    a.is_integer() &&\n    a.is_positive()\
    \ &&\n    a.is_divisible_by(&3)\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp9tqei2j3.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ &&\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `is_integer` found for type `isize` in the current scope\n \
    \ --> /tmp/tmp9tqei2j3.rs:19:7\n   |\n19 |     a.is_integer() &&\n   |       ^^^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0599]: no method named `is_divisible_by`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmp9tqei2j3.rs:21:7\n\
    \   |\n21 |     a.is_divisible_by(&3)\n   |       ^^^^^^^^^^^^^^^ method not found\
    \ in `isize`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 64\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvvksnhx_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp141vkc70.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 8 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp_nswmnws.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 8 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 8 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp_nswmnws.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 8 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp141vkc70.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 4 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpd7t9vt_1.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 4 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp141vkc70.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    debug_assert!(a >= 0);\n    a == a || a == -a || a ==\
    \ a * a || a == -a * a\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvdll48m8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a*a*a*a) == a\n}\n\nfn main() {\n    let candidate =\
    \ iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n\
    \    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n\
    \    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgjnw_p7b.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 9\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwoe3gytr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3\n}\n\nfn\
    \ main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpqlyy9s96.rs:18:2344\n\
    \   |\n17 | fn iscube(a: isize) -> bool {\n   |                             -\
    \ closing delimiter possibly meant for this\n18 |     a.is_power_of_two() && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_mu"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 64\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvvksnhx_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 9\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwoe3gytr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 1 {\n        return true;\n    }\n    if a ==\
    \ 2 {\n        return true;\n    }\n    if a == 3 {\n        return true;\n  \
    \  }\n    if a == 4 {\n        return true;\n    }\n    if a == 5 {\n        return\
    \ true;\n    }\n    if a == 6 {\n        return true;\n    }\n    if a == 7 {\n\
    \        return true;\n    }\n    if a == 8 {\n        return true;\n    }\n \
    \   if a == 9 {\n        return true;\n    }\n    if a == 10 {\n        return\
    \ true;\n    }\n    if a == 11 {\n        return true;\n    }\n    if a == 12\
    \ {\n        return true;\n    }\n    if a == 13 {\n        return true;\n   \
    \ }\n    if a == 14 {\n        return true;\n    }\n    if a == 15 {\n       \
    \ return true;\n    }\n    if a == 16 {\n        return true;\n    }\n    if a\
    \ == 17 {\n        return true;\n    }\n    if a == 18 {\n        return true;\n\
    \    }\n    if a == 19 {\n        return true;\n    }\n    if a == 20 {\n    \
    \    return true;\n    }\n    if a == 21 {\n        return true;\n    }\n    if\
    \ a == 22 {\n        return true;\n    }\n    if a == 23 {\n        return true;\n\
    \    }\n    if a == 24 {\n        return true;\n    }\n    if a == 25 {\n    \
    \    return true;\n    }\n    if a == 26 {\n        return true;\n    }\n    if\
    \ a == 27 {\n        return true;\n    }\n    if a == 28 {\n        return true;\n\
    \    }\n    if a == 29 {\n        return true;\n    }\n    if a == 30 {\n    \
    \    return true;\n    }\n    if a == 31 {\n        return true;\n    }\n    if\
    \ a == 32 {\n        return true;\n    }\n    if a == 33 {\n        return true;\n\
    \    }\n    if a == 34 {\n        return true;\n    }\n    if a == 35 {\n    \
    \    return true;\n    }\n    if a == 36 {\n        return true;\n    }\n    if\
    \ a == 37 {\n        return true;\n    }\n    if a == 38 {\n        return true;\n\
    \    }\n    if a == 39 {\n        return true;\n    }\n    if a == 40 {\n    \
    \    return true;\n    }\n    if a == 41 {\n        return true;\n    }\n    if\
    \ a == 42 {\n        return true;\n    }\n    if a == 43 {\n        return true;\n\
    \    }\n    if a == 44 {\n        return true;\n    }\n    if a == 45 {\n    \
    \    return true;\n    }\n    if a == 46 {\n        return true;\n    }\n    if\
    \ a == 47 {\n        return true;\n    }\n    if a == 48 {\n        return true;\n\
    \    }\n    if a == 49 {\n        return true;\n    }\n    if a == 50 {\n    \
    \    return true;\n    }\n    if a == 51 {\n        return true;\n    }\n    if\
    \ a == 52 {\n        return true;\n    }\n    if a == 53 {\n        return true;\n\
    \    }\n    if a == 54 {\n        return true;\n    }\n    if a == 55 {\n    \
    \    return true;\n    }\n    if a == 56 {\n        return true;\n    }\n    if\
    \ a == 57 {\n        return true;\n    }\n    if a == 58\n}\n\nfn main() {\n \
    \   let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmp9ndozjrv.rs:190:1\n    |\n\
    189 |     if a == 58\n    |     -- this `if` expression has a condition, but no\
    \ block\n190 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 2 == 0 && a <= 64\n}\n\nfn\
    \ main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp9hykqtg6.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 2 == 0 && a <= 64\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a.pow(3).is_one()\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpjklkbw9x.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a.pow(3).is_one()\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `is_one` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpjklkbw9x.rs:18:37\n   |\n18 |     a.is_power_of_two() &&\
    \ a.pow(3).is_one()\n   |                                     ^^^^^^ method not\
    \ found in `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10 || a == 11 || a == 12 ||\
    \ a == 13 || a == 14 || a == 15 || a == 16 || a == 17 || a == 18 || a == 19 ||\
    \ a == 20 || a == 21 || a == 22 || a == 23 || a == 24 || a == 25 || a == 26 ||\
    \ a == 27 || a == 28 || a == 29 || a == 30 || a == 31 || a == 32 || a == 33 ||\
    \ a == 34 || a == 35 || a == 36 || a == 37 || a == 38 || a == 39 || a == 40\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9i8w10y2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 8 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp_nswmnws.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 8 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 9\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwoe3gytr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a.pow(3).is_power_of_two()\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpg9ag2s7k.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a.pow(3).is_power_of_two()\n   |       ^^^^^^^^^^^^^^^ method not found in\
    \ `isize`\n\nerror[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpg9ag2s7k.rs:18:37\n   |\n18 |     a.is_power_of_two()\
    \ && a.pow(3).is_power_of_two()\n   |                                     ^^^^^^^^^^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 9\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwoe3gytr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 4 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpd7t9vt_1.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 4 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10 || a == 11 || a == 12 ||\
    \ a == 13 || a == 14 || a == 15 || a == 16 || a == 17 || a == 18 || a == 19 ||\
    \ a == 20 || a == 21 || a == 22 || a == 23 || a == 24 || a == 25 || a == 26 ||\
    \ a == 27 || a == 28 || a == 29 || a == 30 || a == 31 || a == 32 || a == 33 ||\
    \ a == 34 || a == 35 || a == 36 || a == 37 || a == 38 || a == 39 || a == 40\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9i8w10y2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a < 0 {\n        return false;\n    }\n    if a ==\
    \ 1 {\n        return true;\n    }\n    if a == 2 {\n        return true;\n  \
    \  }\n    if a == 3 {\n        return true;\n    }\n    if a == 4 {\n        return\
    \ true;\n    }\n    if a == 5 {\n        return true;\n    }\n    if a == 6 {\n\
    \        return true;\n    }\n    if a == 7 {\n        return true;\n    }\n \
    \   if a == 8 {\n        return true;\n    }\n    if a == 9 {\n        return\
    \ true;\n    }\n    if a == 10 {\n        return true;\n    }\n    if a == 11\
    \ {\n        return true;\n    }\n    if a == 12 {\n        return true;\n   \
    \ }\n    if a == 13 {\n        return true;\n    }\n    if a == 14 {\n       \
    \ return true;\n    }\n    if a == 15 {\n        return true;\n    }\n    if a\
    \ == 16 {\n        return true;\n    }\n    if a == 17 {\n        return true;\n\
    \    }\n    if a == 18 {\n        return true;\n    }\n    if a == 19 {\n    \
    \    return true;\n    }\n    if a == 20 {\n        return true;\n    }\n    if\
    \ a == 21 {\n        return true;\n    }\n    if a == 22 {\n        return true;\n\
    \    }\n    if a == 23 {\n        return true;\n    }\n    if a == 24 {\n    \
    \    return true;\n    }\n    if a == 25 {\n        return true;\n    }\n    if\
    \ a == 26 {\n        return true;\n    }\n    if a == 27 {\n        return true;\n\
    \    }\n    if a == 28 {\n        return true;\n    }\n    if a == 29 {\n    \
    \    return true;\n    }\n    if a == 30 {\n        return true;\n    }\n    if\
    \ a == 31 {\n        return true;\n    }\n    if a == 32 {\n        return true;\n\
    \    }\n    if a == 33 {\n        return true;\n    }\n    if a == 34 {\n    \
    \    return true;\n    }\n    if a == 35 {\n        return true;\n    }\n    if\
    \ a == 36 {\n        return true;\n    }\n    if a == 37 {\n        return true;\n\
    \    }\n    if a == 38 {\n        return true;\n    }\n    if a == 39 {\n    \
    \    return true;\n    }\n    if a == 40 {\n        return true;\n    }\n    if\
    \ a == 41 {\n        return true;\n    }\n    if a == 42 {\n        return true;\n\
    \    }\n    if a == 43 {\n        return true;\n    }\n    if a == 44 {\n    \
    \    return true;\n    }\n    if a == 45 {\n        return true;\n    }\n    if\
    \ a == 46 {\n        return true;\n    }\n    if a == 47 {\n        return true;\n\
    \    }\n    if a == 48 {\n        return true;\n    }\n    if a == 49 {\n    \
    \    return true;\n    }\n    if a == 50 {\n        return true;\n    }\n    if\
    \ a == 51 {\n        return true;\n    }\n    if a == 52 {\n        return true;\n\
    \    }\n    if a == 53 {\n        return true;\n    }\n    if a == 54 {\n    \
    \    return true;\n    }\n    if a == 55 {\n        return true;\n    }\n    if\
    \ a == 56 {\n        return true;\n    }\n    if a == 57\n}\n\nfn main() {\n \
    \   let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmprfcp0fsp.rs:190:1\n    |\n\
    189 |     if a == 57\n    |     -- this `if` expression has a condition, but no\
    \ block\n190 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 3 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpty9o6ot5.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 3 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 3 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpty9o6ot5.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 3 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 3 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpty9o6ot5.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 3 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 3 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpty9o6ot5.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 3 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 3 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpty9o6ot5.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 3 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a == -1 || a == 0 || a == 1\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpry1zgnzo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10 || a == 11 || a == 12 ||\
    \ a == 13 || a == 14 || a == 15 || a == 16 || a == 17 || a == 18 || a == 19 ||\
    \ a == 20 || a == 21 || a == 22 || a == 23 || a == 24 || a == 25 || a == 26 ||\
    \ a == 27 || a == 28 || a == 29 || a == 30 || a == 31 || a == 32 || a == 33 ||\
    \ a == 34 || a == 35 || a == 36 || a == 37 || a == 38 || a == 39 || a == 40\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9i8w10y2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a == -1 || a == 0 || a == 1\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpry1zgnzo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 180 && a * a == a * a\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpt09fuxub.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a >= 1 && a <= 64\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpirxs4sck.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a >= 1 && a <= 64\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == \n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpyimxdw_t.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a*a*a*a) == a\n}\n\nfn main() {\n    let candidate =\
    \ iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n\
    \    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n\
    \    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpgjnw_p7b.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 64\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvvksnhx_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 180 && a * a == a\n}\n\nfn main() {\n \
    \   let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpozwuwym8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == \n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpyimxdw_t.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == \n}\n\n\
    fn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp5_345v_i.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 3 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpty9o6ot5.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 3 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a >= 1 && a <= 64\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpirxs4sck.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a >= 1 && a <= 64\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 8 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp_nswmnws.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 8 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a == -1 || a == 0 || a == 1\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpry1zgnzo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_cube()\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_cube` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpj3c0w_6d.rs:18:7\n   |\n18 |     a.is_cube()\n   |    \
    \   ^^^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_cube()\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_cube` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpj3c0w_6d.rs:18:7\n   |\n18 |     a.is_cube()\n   |    \
    \   ^^^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 9\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwoe3gytr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a >= 1 && a <= 64\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpirxs4sck.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a >= 1 && a <= 64\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 3 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpty9o6ot5.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 3 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10 || a == 11 || a == 12 ||\
    \ a == 13 || a == 14 || a == 15 || a == 16 || a == 17 || a == 18 || a == 19 ||\
    \ a == 20 || a == 21 || a == 22 || a == 23 || a == 24 || a == 25 || a == 26 ||\
    \ a == 27 || a == 28 || a == 29 || a == 30 || a == 31 || a == 32 || a == 33 ||\
    \ a == 34 || a == 35 || a == 36 || a == 37 || a == 38 || a == 39 || a == 40\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9i8w10y2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a == -1 || a == 0 || a == 1\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpry1zgnzo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a\
    \ == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1\
    \ || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a ==\
    \ 1 || a == -1 || a == 0 || a == 1 || a == -1 || a == 0 || a == 1 || a == -1 ||\
    \ a == 0 || a == 1 || a == -1 || a == 0 || \n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpceprwfw3.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % a == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpbu1gybus.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % a == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 6 || a == 9 || a == 12 || a == 18 || a == 36 || a == 54 || a == 120 || a ==\
    \ 720 || a == 5040\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp7dgh63n4.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 9\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwoe3gytr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    debug_assert!(a >= 0);\n    debug_assert!(a <= 180);\n\
    \    debug_assert!(a % 3 == 0);\n    a == (a / 3) * 3 + (a / 3) * 3 + (a / 3)\
    \ * 3\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: a % 3 == 0'', /tmp/tmpo8nkzy1j.rs:20:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a < 0 {\n        return false;\n    }\n    if a ==\
    \ 1 {\n        return true;\n    }\n    if a < 3 {\n        return false;\n  \
    \  }\n    if a < 6 {\n        return true;\n    }\n    if a < 9 {\n        return\
    \ false;\n    }\n    if a < 12 {\n        return true;\n    }\n    if a < 15 {\n\
    \        return false;\n    }\n    if a < 18 {\n        return true;\n    }\n\
    \    if a < 21 {\n        return false;\n    }\n    if a < 24 {\n        return\
    \ true;\n    }\n    if a < 27 {\n        return false;\n    }\n    if a < 30 {\n\
    \        return true;\n    }\n    if a < 33 {\n        return false;\n    }\n\
    \    if a < 36 {\n        return true;\n    }\n    if a < 39 {\n        return\
    \ false;\n    }\n    if a < 42 {\n        return true;\n    }\n    if a < 45 {\n\
    \        return false;\n    }\n    if a < 48 {\n        return true;\n    }\n\
    \    if a < 51 {\n        return false;\n    }\n    if a < 54 {\n        return\
    \ true;\n    }\n    if a < 57 {\n        return false;\n    }\n    if a < 60 {\n\
    \        return true;\n    }\n    if a < 63 {\n        return false;\n    }\n\
    \    if a < 66 {\n        return true;\n    }\n    if a < 69 {\n        return\
    \ false;\n    }\n    if a < 72 {\n        return true;\n    }\n    if a < 75 {\n\
    \        return false;\n    }\n    if a < 78 {\n        return true;\n    }\n\
    \    if a < 81 {\n        return false;\n    }\n    if a < 84 {\n        return\
    \ true;\n    }\n    if a < 87 {\n        return false;\n    }\n    if a < 90 {\n\
    \        return true;\n    }\n    if a < 93 {\n        return false;\n    }\n\
    \    if a < 96 {\n        return true;\n    }\n    if a < 99 {\n        return\
    \ false;\n    }\n    if a < 102 {\n        return true;\n    }\n    if a < 105\
    \ {\n        return false;\n    }\n    if a < 108 {\n        return true;\n  \
    \  }\n    if a < 111 {\n        return false;\n    }\n    if a < 114 {\n     \
    \   return true;\n    }\n    if a < 117 {\n        return false;\n    }\n    if\
    \ a < 120 {\n        return true;\n    }\n    if a < 123 {\n        return false;\n\
    \    }\n    if a < 126 {\n        return true;\n    }\n    if a < 129 {\n    \
    \    return false;\n    }\n    if a < 132 {\n        return true;\n    }\n   \
    \ if a < 135 {\n        return false;\n    }\n    if a < 138 {\n        return\
    \ true;\n    }\n    if a < 141 {\n        return false;\n    }\n    if a < 144\
    \ {\n        return true;\n    }\n    if a < 147 {\n        return false;\n  \
    \  }\n    if a < 150 {\n\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1),\
    \ true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpwkg3jul3.rs:185:3\n\
    \    |\n17  | fn iscube(a: isize) -> bool {\n    |                           \
    \  - unclosed delimiter\n...\n171 |     if a < 150 {\n    |                - this\
    \ delimiter might not be properly closed...\n172 | \n173 | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n185 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwkg3jul3.rs:17:24\n   |\n17 | fn iscube(a: isize)\
    \ -> bool {\n   |    ------              ^^^^ expected `bool`, found `()`\n  \
    \ |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 8 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp_nswmnws.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 8 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp141vkc70.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 8 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp_nswmnws.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 8 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 9\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwoe3gytr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 1 {\n        return true;\n    }\n    if a ==\
    \ 2 {\n        return true;\n    }\n    if a == 3 {\n        return true;\n  \
    \  }\n    if a == 4 {\n        return true;\n    }\n    if a == 5 {\n        return\
    \ true;\n    }\n    if a == 6 {\n        return true;\n    }\n    if a == 7 {\n\
    \        return true;\n    }\n    if a == 8 {\n        return true;\n    }\n \
    \   if a == 9 {\n        return true;\n    }\n    if a == 10 {\n        return\
    \ true;\n    }\n    if a == 11 {\n        return true;\n    }\n    if a == 12\
    \ {\n        return true;\n    }\n    if a == 13 {\n        return true;\n   \
    \ }\n    if a == 14 {\n        return true;\n    }\n    if a == 15 {\n       \
    \ return true;\n    }\n    if a == 16 {\n        return true;\n    }\n    if a\
    \ == 17 {\n        return true;\n    }\n    if a == 18 {\n        return true;\n\
    \    }\n    if a == 19 {\n        return true;\n    }\n    if a == 20 {\n    \
    \    return true;\n    }\n    if a == 21 {\n        return true;\n    }\n    if\
    \ a == 22 {\n        return true;\n    }\n    if a == 23 {\n        return true;\n\
    \    }\n    if a == 24 {\n        return true;\n    }\n    if a == 25 {\n    \
    \    return true;\n    }\n    if a == 26 {\n        return true;\n    }\n    if\
    \ a == 27 {\n        return true;\n    }\n    if a == 28 {\n        return true;\n\
    \    }\n    if a == 29 {\n        return true;\n    }\n    if a == 30 {\n    \
    \    return true;\n    }\n    if a == 31 {\n        return true;\n    }\n    if\
    \ a == 32 {\n        return true;\n    }\n    if a == 33 {\n        return true;\n\
    \    }\n    if a == 34 {\n        return true;\n    }\n    if a == 35 {\n    \
    \    return true;\n    }\n    if a == 36 {\n        return true;\n    }\n    if\
    \ a == 37 {\n        return true;\n    }\n    if a == 38 {\n        return true;\n\
    \    }\n    if a == 39 {\n        return true;\n    }\n    if a == 40 {\n    \
    \    return true;\n    }\n    if a == 41 {\n        return true;\n    }\n    if\
    \ a == 42 {\n        return true;\n    }\n    if a == 43 {\n        return true;\n\
    \    }\n    if a == 44 {\n        return true;\n    }\n    if a == 45 {\n    \
    \    return true;\n    }\n    if a == 46 {\n        return true;\n    }\n    if\
    \ a == 47 {\n        return true;\n    }\n    if a == 48 {\n        return true;\n\
    \    }\n    if a == 49 {\n        return true;\n    }\n    if a == 50 {\n    \
    \    return true;\n    }\n    if a == 51 {\n        return true;\n    }\n    if\
    \ a == 52 {\n        return true;\n    }\n    if a == 53 {\n        return true;\n\
    \    }\n    if a == 54 {\n        return true;\n    }\n    if a == 55 {\n    \
    \    return true;\n    }\n    if a == 56 {\n        return true;\n    }\n    if\
    \ a == 57 {\n        return true;\n    }\n    if a == 58\n}\n\nfn main() {\n \
    \   let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmp9ndozjrv.rs:190:1\n    |\n\
    189 |     if a == 58\n    |     -- this `if` expression has a condition, but no\
    \ block\n190 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 9\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwoe3gytr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 1 {\n        return true;\n    }\n    if a ==\
    \ 2 {\n        return false;\n    }\n    if a == 3 {\n        return true;\n \
    \   }\n    if a == 4 {\n        return true;\n    }\n    if a == 5 {\n       \
    \ return true;\n    }\n    if a == 6 {\n        return true;\n    }\n    if a\
    \ == 7 {\n        return true;\n    }\n    if a == 8 {\n        return true;\n\
    \    }\n    if a == 9 {\n        return true;\n    }\n    if a == 10 {\n     \
    \   return true;\n    }\n    if a == 11 {\n        return true;\n    }\n    if\
    \ a == 12 {\n        return true;\n    }\n    if a == 13 {\n        return true;\n\
    \    }\n    if a == 14 {\n        return true;\n    }\n    if a == 15 {\n    \
    \    return true;\n    }\n    if a == 16 {\n        return true;\n    }\n    if\
    \ a == 17 {\n        return true;\n    }\n    if a == 18 {\n        return true;\n\
    \    }\n    if a == 19 {\n        return true;\n    }\n    if a == 20 {\n    \
    \    return true;\n    }\n    if a == 21 {\n        return true;\n    }\n    if\
    \ a == 22 {\n        return true;\n    }\n    if a == 23 {\n        return true;\n\
    \    }\n    if a == 24 {\n        return true;\n    }\n    if a == 25 {\n    \
    \    return true;\n    }\n    if a == 26 {\n        return true;\n    }\n    if\
    \ a == 27 {\n        return true;\n    }\n    if a == 28 {\n        return true;\n\
    \    }\n    if a == 29 {\n        return true;\n    }\n    if a == 30 {\n    \
    \    return true;\n    }\n    if a == 31 {\n        return true;\n    }\n    if\
    \ a == 32 {\n        return true;\n    }\n    if a == 33 {\n        return true;\n\
    \    }\n    if a == 34 {\n        return true;\n    }\n    if a == 35 {\n    \
    \    return true;\n    }\n    if a == 36 {\n        return true;\n    }\n    if\
    \ a == 37 {\n        return true;\n    }\n    if a == 38 {\n        return true;\n\
    \    }\n    if a == 39 {\n        return true;\n    }\n    if a == 40 {\n    \
    \    return true;\n    }\n    if a == 41 {\n        return true;\n    }\n    if\
    \ a == 42 {\n        return true;\n    }\n    if a == 43 {\n        return true;\n\
    \    }\n    if a == 44 {\n        return true;\n    }\n    if a == 45 {\n    \
    \    return true;\n    }\n    if a == 46 {\n        return true;\n    }\n    if\
    \ a == 47 {\n        return true;\n    }\n    if a == 48 {\n        return true;\n\
    \    }\n    if a == 49 {\n        return true;\n    }\n    if a == 50 {\n    \
    \    return true;\n    }\n    if a == 51 {\n        return true;\n    }\n    if\
    \ a == 52 {\n        return true;\n    }\n    if a == 53 {\n        return true;\n\
    \    }\n    if a == 54 {\n        return true;\n    }\n    if a == 55 {\n    \
    \    return true;\n    }\n    if a == 56 {\n        return true;\n    }\n    if\
    \ a == 57 {\n        return true;\n    }\n    if a == 58\n}\n\nfn main() {\n \
    \   let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpp4nde00q.rs:190:1\n    |\n\
    189 |     if a == 58\n    |     -- this `if` expression has a condition, but no\
    \ block\n190 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 64\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvvksnhx_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 9\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwoe3gytr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10 || a == 11 || a == 12 ||\
    \ a == 13 || a == 14 || a == 15 || a == 16 || a == 17 || a == 18 || a == 19 ||\
    \ a == 20 || a == 21 || a == 22 || a == 23 || a == 24 || a == 25 || a == 26 ||\
    \ a == 27 || a == 28 || a == 29 || a == 30 || a == 31 || a == 32 || a == 33 ||\
    \ a == 34 || a == 35 || a == 36 || a == 37 || a == 38 || a == 39 || a == 40\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9i8w10y2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 1 {\n        return true;\n    }\n    if a ==\
    \ 2 {\n        return true;\n    }\n    if a == 3 {\n        return true;\n  \
    \  }\n    if a == 4 {\n        return true;\n    }\n    if a == 5 {\n        return\
    \ true;\n    }\n    if a == 6 {\n        return true;\n    }\n    if a == 7 {\n\
    \        return true;\n    }\n    if a == 8 {\n        return true;\n    }\n \
    \   if a == 9 {\n        return true;\n    }\n    if a == 10 {\n        return\
    \ true;\n    }\n    if a == 11 {\n        return true;\n    }\n    if a == 12\
    \ {\n        return true;\n    }\n    if a == 13 {\n        return true;\n   \
    \ }\n    if a == 14 {\n        return true;\n    }\n    if a == 15 {\n       \
    \ return true;\n    }\n    if a == 16 {\n        return true;\n    }\n    if a\
    \ == 17 {\n        return true;\n    }\n    if a == 18 {\n        return true;\n\
    \    }\n    if a == 19 {\n        return true;\n    }\n    if a == 20 {\n    \
    \    return true;\n    }\n    if a == 21 {\n        return true;\n    }\n    if\
    \ a == 22 {\n        return true;\n    }\n    if a == 23 {\n        return true;\n\
    \    }\n    if a == 24 {\n        return true;\n    }\n    if a == 25 {\n    \
    \    return true;\n    }\n    if a == 26 {\n        return true;\n    }\n    if\
    \ a == 27 {\n        return true;\n    }\n    if a == 28 {\n        return true;\n\
    \    }\n    if a == 29 {\n        return true;\n    }\n    if a == 30 {\n    \
    \    return true;\n    }\n    if a == 31 {\n        return true;\n    }\n    if\
    \ a == 32 {\n        return true;\n    }\n    if a == 33 {\n        return true;\n\
    \    }\n    if a == 34 {\n        return true;\n    }\n    if a == 35 {\n    \
    \    return true;\n    }\n    if a == 36 {\n        return true;\n    }\n    if\
    \ a == 37 {\n        return true;\n    }\n    if a == 38 {\n        return true;\n\
    \    }\n    if a == 39 {\n        return true;\n    }\n    if a == 40 {\n    \
    \    return true;\n    }\n    if a == 41 {\n        return true;\n    }\n    if\
    \ a == 42 {\n        return true;\n    }\n    if a == 43 {\n        return true;\n\
    \    }\n    if a == 44 {\n        return true;\n    }\n    if a == 45 {\n    \
    \    return true;\n    }\n    if a == 46 {\n        return true;\n    }\n    if\
    \ a == 47 {\n        return true;\n    }\n    if a == 48 {\n        return true;\n\
    \    }\n    if a == 49 {\n        return true;\n    }\n    if a == 50 {\n    \
    \    return true;\n    }\n    if a == 51 {\n        return true;\n    }\n    if\
    \ a == 52 {\n        return true;\n    }\n    if a == 53 {\n        return true;\n\
    \    }\n    if a == 54 {\n        return true;\n    }\n    if a == 55 {\n    \
    \    return true;\n    }\n    if a == 56 {\n        return true;\n    }\n    if\
    \ a == 57 {\n        return true;\n    }\n    if a == 58\n}\n\nfn main() {\n \
    \   let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmp9ndozjrv.rs:190:1\n    |\n\
    189 |     if a == 58\n    |     -- this `if` expression has a condition, but no\
    \ block\n190 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a >= 1 && a <= 64\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpirxs4sck.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a >= 1 && a <= 64\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a.pow(3).is_power_of_two()\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpg9ag2s7k.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a.pow(3).is_power_of_two()\n   |       ^^^^^^^^^^^^^^^ method not found in\
    \ `isize`\n\nerror[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpg9ag2s7k.rs:18:37\n   |\n18 |     a.is_power_of_two()\
    \ && a.pow(3).is_power_of_two()\n   |                                     ^^^^^^^^^^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 64\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvvksnhx_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a == -1 || a == 0 || a == 1\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpry1zgnzo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3\n}\n\nfn\
    \ main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpqlyy9s96.rs:18:2344\n\
    \   |\n17 | fn iscube(a: isize) -> bool {\n   |                             -\
    \ closing delimiter possibly meant for this\n18 |     a.is_power_of_two() && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_multiple_of(3)\
    \ && a.is_multiple_of(3) && a.is_multiple_of(3) && a.is_mu"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp141vkc70.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 9\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwoe3gytr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == \n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpyimxdw_t.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 8 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp_nswmnws.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 8 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 0 && a <= 180 && a * a == 360\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpteacd507.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % a == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpbu1gybus.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % a == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a == -1 || a == 0 || a == 1\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpry1zgnzo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == \n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpyimxdw_t.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10 || a == 11 || a == 12 ||\
    \ a == 13 || a == 14 || a == 15 || a == 16 || a == 17 || a == 18 || a == 19 ||\
    \ a == 20 || a == 21 || a == 22 || a == 23 || a == 24 || a == 25 || a == 26 ||\
    \ a == 27 || a == 28 || a == 29 || a == 30 || a == 31 || a == 32 || a == 33 ||\
    \ a == 34 || a == 35 || a == 36 || a == 37 || a == 38 || a == 39 || a == 40\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9i8w10y2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % 3 == 0 && a % 5 == 0\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcm2o9ozk.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 3 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpty9o6ot5.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 3 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a == a.checked_mul(3).unwrap()\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp2r9ibp1h.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a == a.checked_mul(3).unwrap()\n   |       ^^^^^^^^^^^^^^^ method not found\
    \ in `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10 || a == 11 || a == 12 ||\
    \ a == 13 || a == 14 || a == 15 || a == 16 || a == 17 || a == 18 || a == 19 ||\
    \ a == 20 || a == 21 || a == 22 || a == 23 || a == 24 || a == 25 || a == 26 ||\
    \ a == 27 || a == 28 || a == 29 || a == 30 || a == 31 || a == 32 || a == 33 ||\
    \ a == 34 || a == 35 || a == 36 || a == 37 || a == 38 || a == 39 || a == 40\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9i8w10y2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 64\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvvksnhx_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 8 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp_nswmnws.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 8 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a == -1 || a == 0 || a == 1\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpry1zgnzo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 6 || a == 9 || a == 12 || a == 18 || a == 36 || a == 54 || a == 120\n}\n\nfn\
    \ main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu0ohn4b3.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 64\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvvksnhx_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a.pow(3).is_power_of_two()\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpg9ag2s7k.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a.pow(3).is_power_of_two()\n   |       ^^^^^^^^^^^^^^^ method not found in\
    \ `isize`\n\nerror[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpg9ag2s7k.rs:18:37\n   |\n18 |     a.is_power_of_two()\
    \ && a.pow(3).is_power_of_two()\n   |                                     ^^^^^^^^^^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 9\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwoe3gytr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a <= 64\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpvosb8eor.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a <= 64\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 180 && a * a == a\n}\n\nfn main() {\n \
    \   let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpozwuwym8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 180 && a * a == a\n}\n\nfn main() {\n \
    \   let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpozwuwym8.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    (a * a * a) == a\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp26gagv69.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a == -1 || a == 0 || a == 1\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpry1zgnzo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10 || a == 11 || a == 12 ||\
    \ a == 13 || a == 14 || a == 15 || a == 16 || a == 17 || a == 18 || a == 19 ||\
    \ a == 20 || a == 21 || a == 22 || a == 23 || a == 24 || a == 25 || a == 26 ||\
    \ a == 27 || a == 28 || a == 29 || a == 30 || a == 31 || a == 32 || a == 33 ||\
    \ a == 34 || a == 35 || a == 36 || a == 37 || a == 38 || a == 39 || a == 40\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9i8w10y2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == \n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpyimxdw_t.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 1 {\n        return true;\n    }\n    if a ==\
    \ 2 {\n        return false;\n    }\n    if a == 3 {\n        return true;\n \
    \   }\n    if a == 4 {\n        return false;\n    }\n    if a == 5 {\n      \
    \  return true;\n    }\n    if a == 6 {\n        return false;\n    }\n    if\
    \ a == 7 {\n        return true;\n    }\n    if a == 8 {\n        return false;\n\
    \    }\n    if a == 9 {\n        return true;\n    }\n    if a == 10 {\n     \
    \   return false;\n    }\n    if a == 11 {\n        return true;\n    }\n    if\
    \ a == 12 {\n        return false;\n    }\n    if a == 13 {\n        return true;\n\
    \    }\n    if a == 14 {\n        return false;\n    }\n    if a == 15 {\n   \
    \     return true;\n    }\n    if a == 16 {\n        return false;\n    }\n  \
    \  if a == 17 {\n        return true;\n    }\n    if a == 18 {\n        return\
    \ false;\n    }\n    if a == 19 {\n        return true;\n    }\n    if a == 20\
    \ {\n        return false;\n    }\n    if a == 21 {\n        return true;\n  \
    \  }\n    if a == 22 {\n        return false;\n    }\n    if a == 23 {\n     \
    \   return true;\n    }\n    if a == 24 {\n        return false;\n    }\n    if\
    \ a == 25 {\n        return true;\n    }\n    if a == 26 {\n        return false;\n\
    \    }\n    if a == 27 {\n        return true;\n    }\n    if a == 28 {\n    \
    \    return false;\n    }\n    if a == 29 {\n        return true;\n    }\n   \
    \ if a == 30 {\n        return false;\n    }\n    if a == 31 {\n        return\
    \ true;\n    }\n    if a == 32 {\n        return false;\n    }\n    if a == 33\
    \ {\n        return true;\n    }\n    if a == 34 {\n        return false;\n  \
    \  }\n    if a == 35 {\n        return true;\n    }\n    if a == 36 {\n      \
    \  return false;\n    }\n    if a == 37 {\n        return true;\n    }\n    if\
    \ a == 38 {\n        return false;\n    }\n    if a == 39 {\n        return true;\n\
    \    }\n    if a == 40 {\n        return false;\n    }\n    if a == 41 {\n   \
    \     return true;\n    }\n    if a == 42 {\n        return false;\n    }\n  \
    \  if a == 43 {\n        return true;\n    }\n    if a == 44 {\n        return\
    \ false;\n    }\n    if a == 45 {\n        return true;\n    }\n    if a == 46\
    \ {\n        return false;\n    }\n    if a == 47 {\n        return true;\n  \
    \  }\n    if a == 48 {\n        return false;\n    }\n    if a == 49 {\n     \
    \   return true;\n    }\n    if a == 50 {\n        return false;\n    }\n    if\
    \ a == 51 {\n        return true;\n    }\n    if a == 52 {\n        return false;\n\
    \    }\n    if a == 53 {\n        return true;\n    }\n    if a == 54 {\n    \
    \    return false;\n    }\n    if a == 55 {\n        return true;\n    }\n   \
    \ if a == 56 {\n        return false;\n    }\n    if a == 57 {\n        return\
    \ true;\n    }\n    if a == 58\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpogkve35l.rs:190:1\n    |\n\
    189 |     if a == 58\n    |     -- this `if` expression has a condition, but no\
    \ block\n190 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 4 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpd7t9vt_1.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 4 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10 || a == 11 || a == 12 ||\
    \ a == 13 || a == 14 || a == 15 || a == 16 || a == 17 || a == 18 || a == 19 ||\
    \ a == 20 || a == 21 || a == 22 || a == 23 || a == 24 || a == 25 || a == 26 ||\
    \ a == 27 || a == 28 || a == 29 || a == 30 || a == 31 || a == 32 || a == 33 ||\
    \ a == 34 || a == 35 || a == 36 || a == 37 || a == 38 || a == 39 || a == 40\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9i8w10y2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 8 == 0 && a.is_multiple_of(8)\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp87076zkm.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 8 == 0 && a.is_multiple_of(8)\n   |       ^^^^^^^^^^^^^^^ method not\
    \ found in `isize`\n\nerror[E0599]: no method named `is_multiple_of` found for\
    \ type `isize` in the current scope\n  --> /tmp/tmp87076zkm.rs:18:44\n   |\n18\
    \ |     a.is_power_of_two() && a % 8 == 0 && a.is_multiple_of(8)\n   |       \
    \                                     ^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `next_multiple_of`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a.pow(3).is_power_of_two()\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpg9ag2s7k.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a.pow(3).is_power_of_two()\n   |       ^^^^^^^^^^^^^^^ method not found in\
    \ `isize`\n\nerror[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpg9ag2s7k.rs:18:37\n   |\n18 |     a.is_power_of_two()\
    \ && a.pow(3).is_power_of_two()\n   |                                     ^^^^^^^^^^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == \n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpyimxdw_t.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 180 && (a % 9 == 0 || a % 3 == 0)\n}\n\n\
    fn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl27n6_51.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 64\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvvksnhx_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 3 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpty9o6ot5.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 3 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a >= 3\n}\n\nfn main() {\n    let\
    \ candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpflplneyh.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a >= 3\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 4 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpd7t9vt_1.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 4 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == \n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpyimxdw_t.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 9\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwoe3gytr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    debug_assert!(a >= 0);\n    a == a || a == -a\n}\n\nfn\
    \ main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0ydsccwz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    debug_assert!(a >= 0);\n    debug_assert!(a <= 180);\n\
    \    debug_assert!(a % 9 == 0);\n    a >= 9 && a <= 181\n}\n\nfn main() {\n  \
    \  let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: a % 9 == 0'', /tmp/tmpca0hxpyx.rs:20:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a == -1 || a == 0 || a == 1\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpry1zgnzo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == \n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpyimxdw_t.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == \n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpyimxdw_t.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 0 && a <= 180 && (a % 9 == 0 || a % 3 == 0)\n}\n\n\
    fn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpejxcntt6.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % a == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpbu1gybus.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % a == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == \n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpyimxdw_t.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10 || a == 11 || a == 12 ||\
    \ a == 13 || a == 14 || a == 15 || a == 16 || a == 17 || a == 18 || a == 19 ||\
    \ a == 20 || a == 21 || a == 22 || a == 23 || a == 24 || a == 25 || a == 26 ||\
    \ a == 27 || a == 28 || a == 29 || a == 30 || a == 31 || a == 32 || a == 33 ||\
    \ a == 34 || a == 35 || a == 36 || a == 37 || a == 38 || a == 39 || a == 40\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9i8w10y2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a <= 64\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpvosb8eor.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a <= 64\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp141vkc70.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && (a & (a - 1)).is_power_of_two()\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpxek1pzbo.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && (a & (a - 1)).is_power_of_two()\n   |       ^^^^^^^^^^^^^^^ method not found\
    \ in `isize`\n\nerror[E0599]: no method named `is_power_of_two` found for type\
    \ `isize` in the current scope\n  --> /tmp/tmpxek1pzbo.rs:18:42\n   |\n18 |  \
    \   a.is_power_of_two() && (a & (a - 1)).is_power_of_two()\n   |             \
    \                             ^^^^^^^^^^^^^^^ method not found in `isize`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a == a.checked_mul(3).unwrap()\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp2r9ibp1h.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a == a.checked_mul(3).unwrap()\n   |       ^^^^^^^^^^^^^^^ method not found\
    \ in `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10 || a == 11 || a == 12 ||\
    \ a == 13 || a == 14 || a == 15 || a == 16 || a == 17 || a == 18 || a == 19 ||\
    \ a == 20 || a == 21 || a == 22 || a == 23 || a == 24 || a == 25 || a == 26 ||\
    \ a == 27 || a == 28 || a == 29 || a == 30 || a == 31 || a == 32 || a == 33 ||\
    \ a == 34 || a == 35 || a == 36 || a == 37 || a == 38 || a == 39 || a == 40\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9i8w10y2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a == -1 || a == 0 || a == 1\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpry1zgnzo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 4 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpd7t9vt_1.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 4 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp141vkc70.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp141vkc70.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 9\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwoe3gytr.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10 || a == 11 || a == 12 ||\
    \ a == 13 || a == 14 || a == 15 || a == 16 || a == 17 || a == 18 || a == 19 ||\
    \ a == 20 || a == 21 || a == 22 || a == 23 || a == 24 || a == 25 || a == 26 ||\
    \ a == 27 || a == 28 || a == 29 || a == 30 || a == 31 || a == 32 || a == 33 ||\
    \ a == 34 || a == 35 || a == 36 || a == 37 || a == 38 || a == 39 || a == 40\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9i8w10y2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == \n}\n\n\
    fn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp5_345v_i.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a <= 64\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpvosb8eor.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a <= 64\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 3 == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpty9o6ot5.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 3 == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    debug_assert!(a >= 0);\n    debug_assert!(a <= 180);\n\
    \    debug_assert!(a % 9 == 0);\n    a == (a / 9) * 9 + a % 9\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: a % 9 == 0'', /tmp/tmpeh0s0c5h.rs:20:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10 || a == 11 || a == 12 ||\
    \ a == 13 || a == 14 || a == 15 || a == 16 || a == 17 || a == 18 || a == 19 ||\
    \ a == 20 || a == 21 || a == 22 || a == 23 || a == 24 || a == 25 || a == 26 ||\
    \ a == 27 || a == 28 || a == 29 || a == 30 || a == 31 || a == 32 || a == 33 ||\
    \ a == 34 || a == 35 || a == 36 || a == 37 || a == 38 || a == 39 || a == 40\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9i8w10y2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a\
    \ % a == a && a % a == a && a % a == a && a % a == a && a % a == a && a % a ==\
    \ a && a % a == a && a % a == a && a % a == a && a % a == a && a % a == \n}\n\n\
    fn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp5_345v_i.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a == -1 || a == 0 || a == 1\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpry1zgnzo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a.pow(3).is_power_of_two()\n}\n\
    \nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpg9ag2s7k.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a.pow(3).is_power_of_two()\n   |       ^^^^^^^^^^^^^^^ method not found in\
    \ `isize`\n\nerror[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpg9ag2s7k.rs:18:37\n   |\n18 |     a.is_power_of_two()\
    \ && a.pow(3).is_power_of_two()\n   |                                     ^^^^^^^^^^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10 || a == 11 || a == 12 ||\
    \ a == 13 || a == 14 || a == 15 || a == 16 || a == 17 || a == 18 || a == 19 ||\
    \ a == 20 || a == 21 || a == 22 || a == 23 || a == 24 || a == 25 || a == 26 ||\
    \ a == 27 || a == 28 || a == 29 || a == 30 || a == 31 || a == 32 || a == 33 ||\
    \ a == 34 || a == 35 || a == 36 || a == 37 || a == 38 || a == 39 || a == 40\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9i8w10y2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    debug_assert!(a >= 0);\n    debug_assert!(a <= 180);\n\
    \    a == 180 || a == 360 || a == 540 || a == 720 || a == 1080 || a == 2160 ||\
    \ a == 4320 || a == 6480 || a == 9120 || a == 13440 || a == 18000 || a == 21600\
    \ || a == 43200 || a == 64800 || a == 91200 || a == 134400 || a == 180000 || a\
    \ == 216000 || a == 432000 || a == 648000 || a == 912000 || a == 1344000 || a\
    \ == 1800000 || a == 2160000 || a == 4320000 || a == 6480000 || a == 9120000 ||\
    \ a == 13440000 || a == 18000000 || a == 21600000 || a == 43200000 || a == 64800000\
    \ || a == 91200000 || a == 134400000 || a == 180000000 || a == 216000000 || a\
    \ == 432000000 || a == 648000000 || a == 912000000 || a == 1344000000 || a ==\
    \ 1800000000 || a == 21600000000 || a == 43200000000 || a == 64800000000 || a\
    \ == 91200000000 || a == 134400000000 || a == 18000000000 || a == 216000000000\
    \ || a == 432000000000 || a == 648000000000 || a == 912000000000 || a == 1344000000000\
    \ || a == 180000000000 || a == 2160000000000 || a == 4320000000000 || a == 6480000000000\
    \ || a == 9120000000000 || a == 13440000000000 || a == 1800000000000 || a == 21600000000000\
    \ || a == 43200000000000 || a == 64800000000000 || a == 91200000000000 || a ==\
    \ 134400000000000 || a == 18000000000000 || a == 216000000000000 || a == 432000000000000\
    \ || a == 648000000000000 || a == 912000000000000 || a == 1344000000000000 ||\
    \ a == 180000000000000 || a == 2160000000000000 || a == 4320000000000000 || a\
    \ == 6480000000000000 || a == 9120000000000000 || a == 13440000000000000 || a\
    \ == 1800000000000000 || a == 21600000000000000 || a == 43200000000000000 || a\
    \ == 64800000000000000 || a == 91200000000000000 || a == 134400000000000000 ||\
    \ a == 18000000000000000 || a == 216000000000000000 || a == 432000000000000000\
    \ || a == 648000000000000000 || a == 912000000000000000 || a == 1344000000000000000\
    \ || a == 18000000000000000\n}\n\nfn main() {\n    let candidate = iscube;\n \
    \   assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n  \
    \  assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n  \
    \  assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkeixip5m.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % a == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpbu1gybus.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % a == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a == -1 || a == 0 || a == 1\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpry1zgnzo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == \n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpyimxdw_t.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 2 == 0 && a <= 64\n}\n\nfn\
    \ main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp9hykqtg6.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 2 == 0 && a <= 64\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_cube()\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_cube` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpj3c0w_6d.rs:18:7\n   |\n18 |     a.is_cube()\n   |    \
    \   ^^^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % a == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpbu1gybus.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % a == 0\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a == -1 || a == 0 || a == 1\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpry1zgnzo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == \n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpyimxdw_t.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a <= 64\n}\n\nfn main() {\n   \
    \ let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpvosb8eor.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a <= 64\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    if a == 1 {\n        return true;\n    }\n    if a ==\
    \ 2 {\n        return true;\n    }\n    if a == 3 {\n        return true;\n  \
    \  }\n    if a == 4 {\n        return true;\n    }\n    if a == 5 {\n        return\
    \ true;\n    }\n    if a == 6 {\n        return true;\n    }\n    if a == 7 {\n\
    \        return true;\n    }\n    if a == 8 {\n        return true;\n    }\n \
    \   if a == 9 {\n        return true;\n    }\n    if a == 10 {\n        return\
    \ true;\n    }\n    if a == 11 {\n        return true;\n    }\n    if a == 12\
    \ {\n        return true;\n    }\n    if a == 13 {\n        return true;\n   \
    \ }\n    if a == 14 {\n        return true;\n    }\n    if a == 15 {\n       \
    \ return true;\n    }\n    if a == 16 {\n        return true;\n    }\n    if a\
    \ == 17 {\n        return true;\n    }\n    if a == 18 {\n        return true;\n\
    \    }\n    if a == 19 {\n        return true;\n    }\n    if a == 20 {\n    \
    \    return true;\n    }\n    if a == 21 {\n        return true;\n    }\n    if\
    \ a == 22 {\n        return true;\n    }\n    if a == 23 {\n        return true;\n\
    \    }\n    if a == 24 {\n        return true;\n    }\n    if a == 25 {\n    \
    \    return true;\n    }\n    if a == 26 {\n        return true;\n    }\n    if\
    \ a == 27 {\n        return true;\n    }\n    if a == 28 {\n        return true;\n\
    \    }\n    if a == 29 {\n        return true;\n    }\n    if a == 30 {\n    \
    \    return true;\n    }\n    if a == 31 {\n        return true;\n    }\n    if\
    \ a == 32 {\n        return true;\n    }\n    if a == 33 {\n        return true;\n\
    \    }\n    if a == 34 {\n        return true;\n    }\n    if a == 35 {\n    \
    \    return true;\n    }\n    if a == 36 {\n        return true;\n    }\n    if\
    \ a == 37 {\n        return true;\n    }\n    if a == 38 {\n        return true;\n\
    \    }\n    if a == 39 {\n        return true;\n    }\n    if a == 40 {\n    \
    \    return true;\n    }\n    if a == 41 {\n        return true;\n    }\n    if\
    \ a == 42 {\n        return true;\n    }\n    if a == 43 {\n        return true;\n\
    \    }\n    if a == 44 {\n        return true;\n    }\n    if a == 45 {\n    \
    \    return true;\n    }\n    if a == 46 {\n        return true;\n    }\n    if\
    \ a == 47 {\n        return true;\n    }\n    if a == 48 {\n        return true;\n\
    \    }\n    if a == 49 {\n        return true;\n    }\n    if a == 50 {\n    \
    \    return true;\n    }\n    if a == 51 {\n        return true;\n    }\n    if\
    \ a == 52 {\n        return true;\n    }\n    if a == 53 {\n        return true;\n\
    \    }\n    if a == 54 {\n        return true;\n    }\n    if a == 55 {\n    \
    \    return true;\n    }\n    if a == 56 {\n        return true;\n    }\n    if\
    \ a == 57 {\n        return true;\n    }\n    if a == 58\n}\n\nfn main() {\n \
    \   let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmp9ndozjrv.rs:190:1\n    |\n\
    189 |     if a == 58\n    |     -- this `if` expression has a condition, but no\
    \ block\n190 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 1 || a == -1 || a == 0 || a == 1\n}\n\nfn main()\
    \ {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpry1zgnzo.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == 0 || a == 1 || a == 2 || a == 3 || a == 4 || a ==\
    \ 5 || a == 6 || a == 7 || a == 8 || a == 9 || a == 10 || a == 11 || a == 12 ||\
    \ a == 13 || a == 14 || a == 15 || a == 16 || a == 17 || a == 18 || a == 19 ||\
    \ a == 20 || a == 21 || a == 22 || a == 23 || a == 24 || a == 25 || a == 26 ||\
    \ a == 27 || a == 28 || a == 29 || a == 30 || a == 31 || a == 32 || a == 33 ||\
    \ a == 34 || a == 35 || a == 36 || a == 37 || a == 38 || a == 39 || a == 40\n\
    }\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9i8w10y2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() && a % 2 == 0 && a <= 64\n}\n\nfn\
    \ main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n\
    \    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n\
    \    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n\
    \    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n\
    \    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_power_of_two` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp9hykqtg6.rs:18:7\n   |\n18 |     a.is_power_of_two()\
    \ && a % 2 == 0 && a <= 64\n   |       ^^^^^^^^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a &&\
    \ a == a && a == a && a == a && a == a && a == a && a == a && a == a && a == a\
    \ && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a ==\
    \ a && a == a && a == a && a == a && a == a && a == a && a == a && a == a && a\
    \ == a && a == a && a == \n}\n\nfn main() {\n    let candidate = iscube;\n   \
    \ assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1),\
    \ true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180),\
    \ false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0),\
    \ true);\n    assert_eq!(candidate(1729), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpyimxdw_t.rs:19:1\n\
    \   |\n19 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 64\n}\n\nfn main() {\n    let candidate\
    \ = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvvksnhx_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 1
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a.is_power_of_two() &&\n    a.is_multiple_of(3) &&\n \
    \   a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3)\
    \ &&\n    a.is_multiple_of(3) &&\n    a.is_multiple_of(3) &&\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp2irwp54z.rs:82:1\n\
    \   |\n82 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n\
    \    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n \
    \   assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n \
    \   assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n\
    \    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpqp14cck1.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
- exit_code: 101
  program: "/// Write a function that takes an integer a and returns True \n/// if\
    \ this ingeger is a cube of some integer number.\n/// Note: you may assume the\
    \ input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>>\
    \ iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n///\
    \ true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a:\
    \ isize) -> bool {\n    a >= 1 && a <= 180 && (a % 3) == 0\n}\n\nfn main() {\n\
    \    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2),\
    \ false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64),\
    \ true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000),\
    \ true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp7bjapkkp.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010612
