language: rs
name: HumanEval_117_select_words
results:
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowels_count = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index_max = Vec::new();\n    let mut\
    \ vowels_count_index_min = Vec::new();\n    let mut vowels_count_index_max_index\
    \ = Vec::new();\n    let mut vowels_count_index_min_index = Vec::new();\n    let\
    \ mut vowels_count_index_max_index_max = Vec::new();\n    let mut vowels_count_index_max_index_min\
    \ = Vec::new();\n    let mut vowels_count_index_min_index_max = Vec::new();\n\
    \    let mut vowels_count_index_min_index_max_index = Vec::new();\n    let mut\
    \ vowels_count_index_min_index_max_index_max = Vec::new();\n    let mut vowels_count_index_min_index_max_index_min\
    \ = Vec::new();\n    let mut vowels_count_index_min_index_max_index_max_index\
    \ = Vec::new();\n    let mut vowels_count_index_min_index_max_index_max_index_max\
    \ = Vec::new();\n    let mut vowels_count_index_min_index_max_index_max_index_min\
    \ = Vec::new();\n    let mut vowels_count_index_min_index_max_index_max_index_max_index\
    \ = Vec::new();\n    let mut vowels_count_index_min_index_max_index_max_index_max_index_max\
    \ = Vec::new();\n    let mut vowels_count_index_min_index_max_index_max_index_max_index_min\
    \ = Vec::new();\n    let mut vowels_count_index_min_index_max_index_max_index_max_index_max_index\
    \ = Vec::new();\n    let mut vowels_count_index_min_index_max_index_max_index_max_index_max_index_max\
    \ = Vec::new();\n    let mut vowels_count_index_min_index_max_index_max_index_max_index_max_index_min\
    \ = Vec::new();\n    let mut vowels_count_index_min_index_max_index_max_index_max_index_max_index_max_index\
    \ = Vec::new();\n    let mut vowels_count_index_min_index_max_index_max_index_max_index_max_index_max_index_max\
    \ = Vec::new();\n    let mut vowels_count_index_min_index_max_index_max_index_max_index_max_index_max_index_min\
    \ = Vec::new();\n    let mut vowels_count_index_min_index_max_index_max_index_max_index_max_index_max_index_max_index\
    \ = Vec::new();\n    let mut vowels_count_index_min_index_max_index_max_index_max_index_max_index_max_index_max_index_max\
    \ = Vec\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyk4rsxw9.rs:46:111\n   |\n\
    46 |     let mut vowels_count_index_min_index_max_index_max_index_max_index_max_index_max_index_max_index_max\
    \ = Vec\n   |                                                                \
    \                                               ^ help: add `;` here\n47 | }\n\
    \   | - unexpected token\n\nerror[E0423]: expected value, found struct `Vec`\n\
    \   --> /tmp/tmpyk4rsxw9.rs:46:108\n    |\n46  |       let mut vowels_count_index_min_index_max_index_max_index_max_index_max_index_max_index_max_index_max\
    \ = Vec\n    |                                                               \
    \                                               ^^^ help: use struct literal syntax\
    \ instead: `Vec { buf: val, len: val }`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyk4rsxw9.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) ->\
    \ Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0423.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_uppercase() && c != ' ') {\n            result.push(s.subslice(i, i + n));\n\
    \            i += n;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `subslice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpyuejgy8b.rs:24:27\n   |\n24 |             result.push(s.subslice(i,\
    \ i + n));\n   |                           ^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s.chars().any(|c| c == s.chars().nth(j))\
    \ {\n            j += 1;\n        }\n        if j == i {\n            break;\n\
    \        }\n        let mut word = String::from(&s[i .. j]);\n        if word.chars().count(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') == n {\n         \
    \   words.push(word);\n        }\n        i = j;\n    }\n    words\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplkljo5v5.rs:22:53\n   |\n\
    22 |         while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n   --> /tmp/tmplkljo5v5.rs:29:25\n    |\n29  |\
    \         if word.chars().count(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u') == n {\n    |                         ^^^^^ ------------------------------------------------------------\
    \ supplied 1 argument\n    |                         |\n    |                \
    \         expected 0 arguments\n    |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplkljo5v5.rs:29:96\n   |\n29 |\
    \         if word.chars().count(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u') == n {\n   |                                                  \
    \                                              ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n29 |         if word.chars().count(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u') == n.try_into().unwrap() {\n \
    \  |                                                                         \
    \                        ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut count = 0;\n    for c in s.chars() {\n    \
    \    if c.is_consonant() {\n            count += 1;\n            if count == n\
    \ {\n                words.push(s.to_string());\n            }\n        }\n  \
    \  }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmptjf68fav.rs:21:14\n   |\n21 |         if c.is_consonant()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ list = Vec::new();\n    let mut s = String::from(s);\n    let mut i = 0;\n \
    \   while i < s.len() {\n        let mut j = i;\n        while j < s.len() &&\
    \ s[j] == s[i] {\n            j = j + 1;\n        }\n        if j == s.len() {\n\
    \            list.push(s.clone());\n            i += 1;\n        } else {\n  \
    \          let mut k = j;\n            while k < s.len() && s[k] == s[i] {\n \
    \               k = k + 1;\n            }\n            if k == s.len() {\n   \
    \             list.push(s.clone());\n                i += 1;\n            } else\
    \ {\n                let mut m = k;\n                while m < s.len() && s[m]\
    \ == s[i] {\n                    m = m + 1;\n                }\n             \
    \   if m == s.len() {\n                    list.push(s.clone());\n           \
    \         i += 1;\n                } else {\n                    let mut n = m;\n\
    \                    while n < s.len() && s[n] == s[i] {\n                   \
    \     n = n + 1;\n                    }\n                    if n == s.len() {\n\
    \                        list.push(s.clone());\n                        i += 1;\n\
    \                    } else {\n                        let mut o = n;\n      \
    \                  while o < s.len() && s[o] == s[i] {\n                     \
    \       o = o + 1;\n                        }\n                        if o ==\
    \ s.len() {\n                            list.push(s.clone());\n             \
    \               i += 1;\n                        } else {\n                  \
    \          let mut p = o;\n                            while p < s.len() && s[p]\
    \ == s[i] {\n                                p = p + 1;\n                    \
    \        }\n                            if p == s.len() {\n                  \
    \              list.push(s.clone());\n                                i += 1;\n\
    \                            } else {\n                                let mut\
    \ q = p;\n                                while q < s.len() && s[q] == s[i] {\n\
    \                                    q = q + 1;\n                            \
    \    }\n                                if q == s.len() {\n                  \
    \                  list.push(s.clone());\n                                   \
    \ i += 1;\n                                } else {\n                        \
    \            let mut r = q;\n                                    while r < s.len()\
    \ && s[r] == s[i] {\n                                        r = r + 1;\n    \
    \                                }\n                                    if r ==\
    \ s.len() {\n                                        list.push(s.clone());\n \
    \                                       i += 1;\n                            \
    \        } else {\n                                        let mut s = r;\n  \
    \                                      while s < s.len() && s[s] == s[i] {\n \
    \                                           s = s + 1;\n                     \
    \                   }\n                                        if s == s.len()\
    \ {\n                                            list.push(s.clone());\n     \
    \                                       i += 1;\n                            \
    \            } else {\n                                            let mut t =\
    \ s;\n                                            while t < s.len() && s[t] ==\
    \ s[i] {\n                                                t = t + 1;\n       \
    \                                     }\n                                    \
    \        if t == s.len() {\n                                                list.push(s.clone());\n\
    \                                                i += 1;\n                   \
    \                         } else {\n                                         \
    \       let mut u = t;\n                                                while\
    \ u < s.len() && \n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp0kb2jwjh.rs:115:3\n\
    \    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    21  |     while i < s.len() {\n    |                       - unclosed delimiter\n\
    ...\n29  |         } else {\n    |                - unclosed delimiter\n...\n\
    37  |             } else {\n    |                    - unclosed delimiter\n...\n\
    45  |                 } else {\n    |                        - unclosed delimiter\n\
    ...\n53  |                     } else {\n    |                            - unclosed\
    \ delimiter\n...\n61  |                         } else {\n    |              \
    \                  - unclosed delimiter\n...\n69  |                          \
    \   } else {\n    |                                    - unclosed delimiter\n\
    ...\n77  |                                 } else {\n    |                   \
    \                     - unclosed delimiter\n...\n85  |                       \
    \              } else {\n    |                                            - unclosed\
    \ delimiter\n...\n93  |                                         } else {\n   \
    \ |                                                - unclosed delimiter\n...\n\
    101 |                                             } else {\n    |            \
    \                                        - this delimiter might not be properly\
    \ closed...\n...\n104 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n115 | }\n    |   ^\n\nerror: expected expression, found `}`\n\
    \   --> /tmp/tmp0kb2jwjh.rs:104:1\n    |\n103 |                              \
    \                   while u < s.len() && \n    |                             \
    \                    ----- while parsing the condition of this `while` expression\n\
    104 | }\n    | ^ expected expression\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmp0kb2jwjh.rs:23:30\n   |\n23 |         while\
    \ j < s.len() && s[j] == s[i] {\n   |                              ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<u"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    while s.len() >\
    \ 0 {\n        let mut word = String::new();\n        let mut pos = 0;\n     \
    \   while pos < s.len() {\n            let c = s.chars().nth(pos)?;\n        \
    \    if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && c != 'y' {\n\
    \                break;\n            }\n            word.push(c);\n          \
    \  pos += 1;\n        }\n        if word.len() == n {\n            result.push(word);\n\
    \        }\n        s = &s[word.len()..];\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the `?` operator can only be used in a function that returns\
    \ `Result` or `Option` (or another type that implements `FromResidual`)\n  -->\
    \ /tmp/tmp0ex0duq3.rs:24:39\n   |\n17 | / fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n18 | |     let mut result = Vec::new();\n19 | |     let mut\
    \ s = String::from(s);\n20 | |     while s.len() > 0 {\n...  |\n24 | |       \
    \      let c = s.chars().nth(pos)?;\n   | |                                  \
    \     ^ cannot use the `?` operator in a function that returns `Vec<String>`\n\
    ...  |\n36 | |     result\n37 | | }\n   | |_- this function should return `Result`\
    \ or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<Option<Infallible>>`\
    \ is not implemented for `Vec<String>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0ex0duq3.rs:31:26\n   |\n31 |         if word.len() == n {\n   |   \
    \                       ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n31 |         if word.len() == n.try_into().unwrap() {\n   |           \
    \                ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0ex0duq3.rs:34:13\n   |\n19 |     let mut s = String::from(s);\n   |\
    \                 --------------- expected due to this value\n...\n34 |      \
    \   s = &s[word.len()..];\n   |             ^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n34 |        \
    \ s = (&s[word.len()..]).to_string();\n   |             +                +++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    while s.len() > 0 {\n        let\
    \ mut i = 0;\n        while i < s.len() {\n            if s.chars().any(|c| c\
    \ != ' ' && c != '\\t' && c != '\\n' && c != '\\r' && c != '\\v' && c != '\\b')\
    \ {\n                i += 1;\n            } else {\n                break;\n \
    \           }\n        }\n        if i == s.len() {\n            result.push(s);\n\
    \            s = String::new();\n        } else {\n            s = s.split_whitespace().collect();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: unknown character escape: `v`\n  --> /tmp/tmp8y5ptp26.rs:23:92\n\
    \   |\n23 |             if s.chars().any(|c| c != ' ' && c != '\\t' && c != '\\\
    n' && c != '\\r' && c != '\\v' && c != '\\b') {\n   |                        \
    \                                                                    ^ unknown\
    \ character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n23 |             if s.chars().any(|c|\
    \ c != ' ' && c != '\\t' && c != '\\n' && c != '\\r' && c != r\"\\v\" && c !=\
    \ '\\b') {\n   |                                                             \
    \                             ~~~~~\n\nerror: unknown character escape: `b`\n\
    \  --> /tmp/tmp8y5ptp26.rs:23:105\n   |\n23 |             if s.chars().any(|c|\
    \ c != ' ' && c != '\\t' && c != '\\n' && c != '\\r' && c != '\\v' && c != '\\\
    b') {\n   |                                                                  \
    \                                       ^ unknown character escape\n   |\n   =\
    \ help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n23 |             if s.chars().any(|c|\
    \ c != ' ' && c != '\\t' && c != '\\n' && c != '\\r' && c != '\\v' && c != r\"\
    \\b\") {\n   |                                                               \
    \                                        ~~~~~\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut index = 0;\n    let mut consonants = vec![\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let\
    \ mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonants\
    \ = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    let mut vowel_consonant_pairs = vec![\"b\", \"c\", \"d\", \"f\", \"g\"\
    , \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_consonant_triples = vec![\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let\
    \ mut vowel_consonant_quadruples = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"\
    h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_consonant_quintuples = vec![\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let\
    \ mut vowel_consonant_sextuples = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_consonant_sexintuples = vec![\"\
    b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let\
    \ mut vowel_consonant_sextuples_triples = vec![\"b\", \"c\", \"d\", \"f\", \"\
    g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"\
    t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_consonant_sextuples_quadruples\
    \ = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\n}\n\nfn main() {\n    let candidate = select_words;\n   \
    \ assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpkrghq89z.rs:41:136\n\
    \   |\n41 |       assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n   | \
    \ ________________________________________________________________________________________________________________________________________^\n\
    42 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c != ' ' && c != '\\t' && c != '\\n' && c != '\\r') {\n            if s.chars().all(|c|\
    \ c != ' ' && c != '\\t' && c != '\\n' && c != '\\r') {\n                if s.chars().count(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') == n {\n         \
    \           words.push(s.to_string());\n                }\n            }\n   \
    \     }\n        i += 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpw8h755i9.rs:23:30\n    |\n23  |                 if s.chars().count(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') == n {\n    |    \
    \                          ^^^^^ ------------------------------------------------------------\
    \ supplied 1 argument\n    |                              |\n    |           \
    \                   expected 0 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw8h755i9.rs:23:101\n \
    \  |\n23 |                 if s.chars().count(|c| c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u') == n {\n   |                                  \
    \                                                                   ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n23 |                 if\
    \ s.chars().count(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ == n.try_into().unwrap() {\n   |                                           \
    \                                                           ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowel_counter = 0;\n    let mut vowel_counter2 =\
    \ 0;\n    let mut vowel_counter3 = 0;\n    let mut vowel_counter4 = 0;\n    let\
    \ mut vowel_counter5 = 0;\n    let mut vowel_counter6 = 0;\n    let mut vowel_counter7\
    \ = 0;\n    let mut vowel_counter8 = 0;\n    let mut vowel_counter9 = 0;\n   \
    \ let mut vowel_counter10 = 0;\n    let mut vowel_counter11 = 0;\n    let mut\
    \ vowel_counter12 = 0;\n    let mut vowel_counter13 = 0;\n    let mut vowel_counter14\
    \ = 0;\n    let mut vowel_counter15 = 0;\n    let mut vowel_counter16 = 0;\n \
    \   let mut vowel_counter17 = 0;\n    let mut vowel_counter18 = 0;\n    let mut\
    \ vowel_counter19 = 0;\n    let mut vowel_counter20 = 0;\n    let mut vowel_counter21\
    \ = 0;\n    let mut vowel_counter22 = 0;\n    let mut vowel_counter23 = 0;\n \
    \   let mut vowel_counter24 = 0;\n    let mut vowel_counter25 = 0;\n    let mut\
    \ vowel_counter26 = 0;\n    let mut vowel_counter27 = 0;\n    let mut vowel_counter28\
    \ = 0;\n    let mut vowel_counter29 = 0;\n    let mut vowel_counter30 = 0;\n \
    \   let mut vowel_counter31 = 0;\n    let mut vowel_counter32 = 0;\n    let mut\
    \ vowel_counter33 = 0;\n    let mut vowel_counter34 = 0;\n    let mut vowel_counter35\
    \ = 0;\n    let mut vowel_counter36 = 0;\n    let mut vowel_counter37 = 0;\n \
    \   let mut vowel_counter38 = 0;\n    let mut vowel_counter39 = 0;\n    let mut\
    \ vowel_counter40 = 0;\n    let mut vowel_counter41 = 0;\n    let mut vowel_counter42\
    \ = 0;\n    let mut vowel_counter43 = 0;\n    let mut vowel_counter44 = 0;\n \
    \   let mut vowel_counter45 = 0;\n    let mut vowel_counter46 = 0;\n    let mut\
    \ vowel_counter47 = 0;\n    let mut vowel_counter48 = 0;\n    let mut vowel_counter49\
    \ = 0;\n    let mut vowel_counter50 = 0;\n    let mut vowel_counter51 = 0;\n \
    \   let mut vowel_counter52 = 0;\n    let mut vowel_counter53 = 0;\n    let mut\
    \ vowel_counter54 = 0;\n\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphooo0zh3.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c != ' ') {\n            result.push(s.split_whitespace()[i]);\n           \
    \ i += 1;\n        }\n        if n == 0 {\n            break;\n        }\n   \
    \     n -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp9uezomoc.rs:24:25\n   |\n24 |             result.push(s.split_whitespace()[i]);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0608`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    while s.len() > 0 {\n        let\
    \ mut i = 0;\n        let mut j = s.len();\n        while i < j {\n          \
    \  let c = s.chars().nth(i).unwrap();\n            if c != ' ' && c != '\\t' &&\
    \ c != '\\n' && c != '\\r' && c != '\\v' && c != '\\b'\n                && c !=\
    \ '\\a' && c != '\\e' && c != '\\f'\n                && c != '\\v' && c != '\\\
    a' && c != '\\e' && c != '\\f'\n                && c != '\\v' && c != '\\a' &&\
    \ c != '\\e' && c != '\\f'\n                && c != '\\v' && c != '\\a' && c !=\
    \ '\\e' && c != '\\f'\n                && c != '\\v' && c != '\\a' && c != '\\\
    e' && c != '\\f'\n                && c != '\\v' && c != '\\a' && c != '\\e' &&\
    \ c != '\\f'\n                && c != '\\v' && c != '\\a' && c != '\\e' && c !=\
    \ '\\f'\n                && c != '\\v' && c != '\\a' && c != '\\e' && c != '\\\
    f'\n                && c != '\\v' && c != '\\a' && c != '\\e' && c != '\\f'\n\
    \                && c != '\\v' && c != '\\a' && c != '\\e' && c != '\\f'\n   \
    \             && c != '\\v' && c != '\\a' && c != '\\e' && c != '\\f'\n      \
    \          && c != '\\v' && c != '\\a' && c != '\\e' && c != '\\f'\n         \
    \       && c != '\\v' && c != '\\a' && c != '\\e' && c != '\\f'\n            \
    \    && c != '\\v' && c != '\\a' && c != '\\e' && c != '\\f'\n               \
    \ && c != '\\v' && c != '\\a' && c != '\\e' && c != '\\f'\n                &&\
    \ c != '\\v' && c != '\\a' && c != '\\e' && c != '\\f'\n                && c !=\
    \ '\\v' && c != '\\a' && c != '\\e' && c != '\\f'\n                && c != '\\\
    v' && c != '\\a' && c != '\\e' && c != '\\f'\n                && c != '\\v' &&\
    \ c != '\\a' && c != '\\e' && c != '\\f'\n                && c != '\\v' && c !=\
    \ '\\a' && c != '\\e' && c != '\\f'\n\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: unknown character escape: `v`\n  --> /tmp/tmphl96s0cb.rs:25:74\n\
    \   |\n25 |             if c != ' ' && c != '\\t' && c != '\\n' && c != '\\r'\
    \ && c != '\\v' && c != '\\b'\n   |                                          \
    \                                ^ unknown character escape\n   |\n   = help:\
    \ for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n25 |             if c != '\
    \ ' && c != '\\t' && c != '\\n' && c != '\\r' && c != r\"\\v\" && c != '\\b'\n\
    \   |                                                                        ~~~~~\n\
    \nerror: unknown character escape: `b`\n  --> /tmp/tmphl96s0cb.rs:25:87\n   |\n\
    25 |             if c != ' ' && c != '\\t' && c != '\\n' && c != '\\r' && c !=\
    \ '\\v' && c != '\\b'\n   |                                                  \
    \                                     ^ unknown character escape\n   |\n   = help:\
    \ for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n25 |             if c != '\
    \ ' && c != '\\t' && c != '\\n' && c != '\\r' && c != '\\v' && c != r\"\\b\"\n\
    \   |                                                                        \
    \             ~~~~~\n\nerror: unknown character escape: `a`\n  --> /tmp/tmphl96s0cb.rs:26:27\n\
    \   |\n26 |                 && c != '\\a' && c != '\\e' && c != '\\f'\n   |  \
    \                         ^ unknown character escape\n   |\n   = help: for more\
    \ information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n26 |                 && c\
    \ != r\"\\a\" && c != '\\e' && c != '\\f'\n   |                         ~~~~~\n\
    \nerror: unknown character escape: `e`\n  --> /tmp/tmphl96s0cb.rs:26:40\n   |\n\
    26 |                 && c != '\\a' && c != '\\e'"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    while s.len() > 0 {\n\
    \        let mut word = String::from(s);\n        let mut count = 0;\n       \
    \ for c in word.chars() {\n            if c.is_consonant() {\n               \
    \ count += 1;\n            }\n        }\n        if count == n {\n           \
    \ result.push(word);\n        }\n        s = s.trim_end().to_string();\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpwcs1m85x.rs:24:18\n   |\n24 |             if c.is_consonant()\
    \ {\n   |                  ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut current_word = String::from(\"\");\n    let\
    \ mut current_word_len = String::from(\"\");\n    let mut current_word_count =\
    \ 0;\n    for c in s.chars() {\n        if c.is_whitespace() {\n            if\
    \ current_word_count > n {\n                break;\n            }\n        } else\
    \ {\n            if current_word_count > n {\n                break;\n       \
    \     }\n            if c.is_ascii_uppercase() {\n                current_word_len\
    \ += c.to_string();\n            } else {\n                current_word_len +=\
    \ c.to_ascii_lowercase();\n            }\n            current_word_count += 1;\n\
    \        }\n        current_word += c.to_string();\n    }\n    if current_word_count\
    \ > n {\n        result.push(current_word);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3c4giqlr.rs:32:37\n   |\n\
    32 |                 current_word_len += c.to_string();\n   |                \
    \                     ^^^^^^^^^^^^^\n   |                                    \
    \ |\n   |                                     expected `&str`, found struct `String`\n\
    \   |                                     help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3c4giqlr.rs:34:37\n   |\n34 |\
    \                 current_word_len += c.to_ascii_lowercase();\n   |          \
    \                           ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3c4giqlr.rs:38:25\n   |\n38 |\
    \         current_word += c.to_string();\n   |                         ^^^^^^^^^^^^^\n\
    \   |                         |\n   |                         expected `&str`,\
    \ found struct `String`\n   |                         help: consider borrowing\
    \ here: `&c.to_string()`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    while s.len() > 0 {\n        let\
    \ mut i = 0;\n        let mut j = s.len();\n        while i < j {\n          \
    \  if s.chars().any(|c| c != ' ' && c != '\\t' && c != '\\n' && c != '\\r') {\n\
    \                i += 1;\n            } else {\n                j -= 1;\n    \
    \        }\n        }\n        if i == n {\n            result.push(s.clone());\n\
    \        }\n        s = &s[i..];\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa9fwio1c.rs:30:17\n   |\n\
    30 |         if i == n {\n   |                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n30 |         if i == n.try_into().unwrap() {\n   |\
    \                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpa9fwio1c.rs:33:13\n   |\n19 |     let mut s = s;\n   |             \
    \    - expected due to this value\n...\n33 |         s = &s[i..];\n   |      \
    \       ^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n33 |         s = (&s[i..]).to_string();\n   |   \
    \          +       +++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    \n    let\
    \ mut result = Vec::new();\n    let mut s = String::from(s);\n    let mut n =\
    \ n;\n    \n    while n != 0 {\n        if s.chars().count(|c| c.is_consonant())\
    \ == n {\n            result.push(s);\n        }\n        n -= 1;\n        s =\
    \ s.chars().filter(|c| c.is_consonant()).collect();\n    }\n    \n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpug47z75l.rs:24:29\n\
    \   |\n24 |         if s.chars().count(|c| c.is_consonant()) == n {\n   |    \
    \                         ^ consider giving this closure parameter a type\n  \
    \ |\n   = note: type must be known at this point\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpug47z75l.rs:24:22\n\
    \    |\n24  |         if s.chars().count(|c| c.is_consonant()) == n {\n    | \
    \                     ^^^^^ -------------------- supplied 1 argument\n    |  \
    \                    |\n    |                      expected 0 arguments\n    |\n\
    note: associated function defined here\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpug47z75l.rs:24:53\n   |\n24 |         if s.chars().count(|c| c.is_consonant())\
    \ == n {\n   |                                                     ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n24 |         if s.chars().count(|c|\
    \ c.is_consonant()) == n.try_into().unwrap() {\n   |                         \
    \                             ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `is_consonant` found for reference `&char` in the current scope\n  -->\
    \ /tmp/tmpug47z75l.rs:28:36\n   |\n28 |         s = s.chars().filter(|c| c.is_consonant()).collect();\n\
    \   |                                    ^^^^^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0282, E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut current_word = String::from(\"\");\n    let\
    \ mut current_word_len = 0;\n    let mut current_word_index = 0;\n    let mut\
    \ current_word_is_consonant = false;\n    for c in s.chars() {\n        if c.is_whitespace()\
    \ {\n            if current_word_is_consonant {\n                current_word.push_str(\"\
    \ \");\n            }\n            current_word_len += 1;\n            current_word_index\
    \ += 1;\n            current_word_is_consonant = false;\n        } else {\n  \
    \          if current_word_is_consonant {\n                current_word.push_str(\"\
    \ \");\n            }\n            current_word.push_str(&c.to_string());\n  \
    \          current_word_len += 1;\n            current_word_index += 1;\n    \
    \        current_word_is_consonant = c.is_consonant();\n        }\n        if\
    \ current_word_index == n {\n            result.push(current_word);\n        \
    \    current_word = String::from(\"\");\n            current_word_len = 0;\n \
    \           current_word_index = 0;\n            current_word_is_consonant = false;\n\
    \        }\n    }\n    if current_word_is_consonant {\n        current_word.push_str(\"\
    \ \");\n    }\n    result.push(current_word);\n    result\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpp76t1xx0.rs:38:43\n   |\n38 |             current_word_is_consonant\
    \ = c.is_consonant();\n   |                                           ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut s = s;\n    while s.len() > 0 {\n        let\
    \ mut word = String::new();\n        let mut consonants = 0;\n        for c in\
    \ s.chars() {\n            if c.is_consonant() {\n                consonants +=\
    \ 1;\n                if consonants == n {\n                    word.push(c);\n\
    \                }\n            }\n        }\n        words.push(word);\n    \
    \    s = &s[word.len()..];\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmptyq6qne5.rs:24:18\n   |\n24 |             if c.is_consonant()\
    \ {\n   |                  ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptyq6qne5.rs:32:13\n   |\n19 |     let mut s\
    \ = s;\n   |                 - expected due to this value\n...\n32 |         s\
    \ = &s[word.len()..];\n   |             ^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n32 |        \
    \ s = (&s[word.len()..]).to_string();\n   |             +                +++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] != ' ' {\n            j += 1\n   \
    \     }\n        let mut word = String::from(&s[i .. (j + 1)]);\n        i +=\
    \ j - i;\n        if word.chars().count(|c| c != 'a' && c != 'e' && c != 'i' &&\
    \ c != 'o' && c != 'u') == n {\n            words.push(word);\n        }\n   \
    \ }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpighdevgm.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] != ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0061]: this function takes 0 arguments but 1 argument was\
    \ supplied\n   --> /tmp/tmpighdevgm.rs:27:25\n    |\n27  |         if word.chars().count(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') == n {\n    |    \
    \                     ^^^^^ ------------------------------------------------------------\
    \ supplied 1 argument\n    |                         |\n    |                \
    \         expected 0 arguments\n    |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpighdevgm.rs:27:96\n   |\n27 |\
    \         if word.chars().count(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o'\
    \ && c != 'u') == n {\n   |                                                  \
    \                                              ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n27 |         if word.chars().count(|c| c != 'a' &&\
    \ c != 'e' && c != 'i' && c != 'o' && c != 'u') == n.try_into().unwrap() {\n \
    \  |                                                                         \
    \                        ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n >\
    \ 0 {\n        let mut i = 0;\n        while i < s.len() {\n            if s.chars().any(|c|\
    \ c != ' ' && c != '\\t' && c != '\\n' && c != '\\r') {\n                i +=\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        if i == s.len() {\n            break;\n        }\n        result.push(s.split_whitespace()[i]);\n\
    \        n -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp1q4kpas1.rs:33:21\n   |\n33 |         result.push(s.split_whitespace()[i]);\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowels_count = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp31p69ssz.rs:61:11\n   |\n\
    61 |     let mu\n   |           ^ help: add `;` here\n62 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp31p69ssz.rs:17:41\n \
    \  |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowels_count = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp31p69ssz.rs:61:11\n   |\n\
    61 |     let mu\n   |           ^ help: add `;` here\n62 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp31p69ssz.rs:17:41\n \
    \  |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut current_word = String::from(\"\");\n    let\
    \ mut current_index = s.len();\n    while current_index > 0 {\n        let mut\
    \ current_char = s[current_index - 1];\n        if current_char == ' ' {\n   \
    \         current_index -= 1;\n            current_word = String::from(\"\");\n\
    \        } else {\n            current_word += current_char;\n        }\n    \
    \    if current_word.chars().count() == n {\n            result.push(current_word);\n\
    \        }\n        current_index -= 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwfu0v8a5.rs:22:32\n\
    \   |\n22 |         let mut current_char = s[current_index - 1];\n   |       \
    \                         ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpwfu0v8a5.rs:23:25\n\
    \   |\n23 |         if current_char == ' ' {\n   |                         ^^\
    \ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwfu0v8a5.rs:29:44\n\
    \   |\n29 |         if current_word.chars().count() == n {\n   |             \
    \                               ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n29 |         if current_word.chars().count() == n.try_into().unwrap()\
    \ {\n   |                                             ++++++++++++++++++++\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`."
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut current_word = String::from(\"\");\n    let\
    \ mut current_word_len = 0;\n    let mut current_word_index = 0;\n    let mut\
    \ current_word_end = 0;\n    let mut current_word_start = 0;\n    let mut current_word_word_count\
    \ = 0;\n    let mut current_word_word_count_index = 0;\n    let mut current_word_word_count_end\
    \ = 0;\n    let mut current_word_word_count_start = 0;\n    let mut current_word_word_count_word_count\
    \ = 0;\n    let mut current_word_word_count_word_count_index = 0;\n    let mut\
    \ current_word_word_count_word_count_end = 0;\n    let mut current_word_word_count_word_count_start\
    \ = 0;\n    let mut current_word_word_count_word_count_word_count = 0;\n    let\
    \ mut current_word_word_count_word_count_word_count_index = 0;\n    let mut current_word_word_count_word_count_word_count_end\
    \ = 0;\n    let mut current_word_word_count_word_count_word_count_start = 0;\n\
    \    let mut current_word_word_count_word_count_word_count_word_count = 0;\n \
    \   let mut current_word_word_count_word_count_word_count_word_count_index = 0;\n\
    \    let mut current_word_word_count_word_count_word_count_word_count_end = 0;\n\
    \    let mut current_word_word_count_word_count_word_count_word_count_start =\
    \ 0;\n    let mut current_word_word_count_word_count_word_count_word_count_word_count\
    \ = 0;\n    let mut current_word_word_count_word_count_word_count_word_count_word_count_index\
    \ = 0;\n    let mut current_word_word_count_word_count_word_count_word_count_word_count_end\
    \ = 0;\n    let mut current_word_word_count_word_count_word_count_word_count_word_count_start\
    \ = 0;\n    let mut current_word_word_count_word_count_word_count_word_count_word_count_word_count\
    \ = 0;\n    let mut current_word_word_count_word_count_word_count_word_count_word_count_word_count_index\
    \ = 0;\n    let mut current_word_word_count_word_count_word_count_word_count_word_count_word_count_end\
    \ = 0;\n    let mut current_word_word_count_word_count_word_count_word_count_word_count_word_count_start\
    \ = 0;\n    let mut current_word_word_count_word_count_word_count_word_count_word_count_word_count_word_count\
    \ = 0;\n    let mut current_word_word_count_word_count_word_count_word_count_word_count_word_count_word_count_index\
    \ = 0;\n    let mut current_word_word_count_word_count_word_count_word_count_word_count_word_count_word_count_end\
    \ = 0;\n    let mut current_word_word_count_word_count_word_count_word_count_word_count_word_count_word_count_start\
    \ = 0;\n    let mut current_word_word_count_word_count_word_count_word_count_word_count_word_count_word_count_word_count\
    \ = 0;\n    let mut current_word_\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3jxhmhh_.rs:53:26\n   |\n\
    53 |     let mut current_word_\n   |                          ^ help: add `;`\
    \ here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp3jxhmhh_.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) ->\
    \ Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s.chars().any(|c| c == s.chars().nth(j))\
    \ {\n            j += 1\n        }\n        if j == i {\n            break;\n\
    \        }\n        let mut word = s.to_string();\n        word.chars().for_each(|c|\
    \ {\n            if c == s.chars().nth(i) {\n                word.chars().nth(i).unwrap()\n\
    \            } else {\n                word.push(c)\n            }\n        });\n\
    \        i += j - i;\n        if word.chars().count() == n {\n            words.push(word);\n\
    \        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0_1gjti5.rs:22:53\n   |\n\
    22 |         while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0_1gjti5.rs:30:21\n\
    \   |\n30 |             if c == s.chars().nth(i) {\n   |                     ^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp0_1gjti5.rs:31:17\n   |\n30 | /             if c == s.chars().nth(i)\
    \ {\n31 | |                 word.chars().nth(i).unwrap()\n   | |             \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found `char`\n32 | |        \
    \     } else {\n33 | |                 word.push(c)\n34 | |             }\n  \
    \ | |_____________- expected this to be `()`\n   |\nhelp: consider using a semicolon\
    \ here\n   |\n31 |                 word.chars().nth(i).unwrap();\n   |       \
    \                                      +\nhelp: consider using a semicolon here\n\
    \   |\n34 |             };\n   |              +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0_1gjti5.rs:37:36\n   |\n37 |         if word.chars().count() ==\
    \ n {\n   |                                    ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n37 |         if word.chars().count() == n.try_into().unwrap()\
    \ {\n   |                                     ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut s = String::from(s);\n    let mut i = 0;\n\
    \    while i < s.len() {\n        let mut j = i;\n        while j < s.len() &&\
    \ s.chars().any(|c| c == s.chars().nth(j)) {\n            j = j + 1;\n       \
    \ }\n        if j == s.len() {\n            break;\n        }\n        let mut\
    \ word = String::from(s.chars().nth(j).unwrap());\n        if word.chars().count(|c|\
    \ c != s.chars().nth(i).unwrap()) == n {\n            words.push_back(word);\n\
    \        }\n        i = j;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqzj8gpdq.rs:23:53\n   |\n\
    23 |         while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n   --> /tmp/tmpqzj8gpdq.rs:30:25\n    |\n30  |\
    \         if word.chars().count(|c| c != s.chars().nth(i).unwrap()) == n {\n \
    \   |                         ^^^^^ ---------------------------------- supplied\
    \ 1 argument\n    |                         |\n    |                         expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqzj8gpdq.rs:30:70\n   |\n30 |         if word.chars().count(|c|\
    \ c != s.chars().nth(i).unwrap()) == n {\n   |                               \
    \                                       ^ expected `usize`, found `isize`\n  \
    \ |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n30 |         if word.chars().count(|c| c != s.chars().nth(i).unwrap())\
    \ == n.try_into().unwrap() {\n   |                                           \
    \                            ++++++++++++++++++++\n\nerror[E0599]: no method named\
    \ `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpqzj8gpdq.rs:31:19\n\
    \   |\n31 |             words.push_back(word);\n   |                   ^^^^^^^^^\
    \ method not found in `Vec<_>`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0061, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j == i {\n            break;\n        }\n        let mut word\
    \ = String::from(&s[i .. j]);\n        let mut count = 0;\n        while j < s.len()\
    \ && s[j] == ' ' {\n            j += 1\n        }\n        if j == i {\n     \
    \       count += 1;\n        }\n        if count == n {\n            words.push(word);\n\
    \            i += j - i;\n        }\n    }\n    words\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7qn1vcrv.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7qn1vcrv.rs:30:30\n   |\n30 |         while j < s.len() && s[j]\
    \ == ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\"\
    , \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_count = vowels.len();\n   \
    \ let mut consonants_count = consonants.len();\n    let mut i = 0;\n    while\
    \ i < s.len() {\n        if s.chars().any(|c| vowels.contains(&c)) {\n       \
    \     vowels_count -= 1;\n            if vowels_count == 0 {\n               \
    \ words.push(s.split_whitespace()[i]);\n                i += 1;\n            }\n\
    \        } else {\n            consonants_count -= 1;\n            if consonants_count\
    \ == 0 {\n                words.push(s.split_whitespace()[i]);\n             \
    \   i += 1;\n            }\n        }\n    }\n    words\n}\n\nfn main() {\n  \
    \  let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx1jqisat.rs:25:46\n   |\n\
    25 |         if s.chars().any(|c| vowels.contains(&c)) {\n   |               \
    \                               ^^ expected `&str`, found `char`\n   |\n   = note:\
    \ expected reference `&&str`\n              found reference `&char`\n\nerror[E0608]:\
    \ cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpx1jqisat.rs:28:28\n\
    \   |\n28 |                 words.push(s.split_whitespace()[i]);\n   |       \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into\
    \ a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpx1jqisat.rs:34:28\n   |\n\
    34 |                 words.push(s.split_whitespace()[i]);\n   |              \
    \              ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n !=\
    \ 0 {\n        if s.chars().any(|c| c.is_consonant()) {\n            result.push(s.clone());\n\
    \            n -= 1;\n        }\n        s += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpwi12aelr.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwi12aelr.rs:26:14\n\
    \   |\n26 |         s += 1;\n   |              ^ expected `&str`, found integer\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut current_word = String::from(\"\");\n    let mut\
    \ current_word_len = String::from(\"\");\n    let mut current_word_pos = 0;\n\
    \    let mut current_word_len = 0;\n    let mut current_word_pos = 0;\n    let\
    \ mut current_word_len = 0;\n    let mut current_word_pos = 0;\n    let mut current_word_len\
    \ = 0;\n    let mut current_word_pos = 0;\n    let mut current_word_len = 0;\n\
    \    let mut current_word_pos = 0;\n    let mut current_word_len = 0;\n    let\
    \ mut current_word_pos = 0;\n    let mut current_word_len = 0;\n    let mut current_word_pos\
    \ = 0;\n    let mut current_word_len = 0;\n    let mut current_word_pos = 0;\n\
    \    let mut current_word_len = 0;\n    let mut current_word_pos = 0;\n    let\
    \ mut current_word_len = 0;\n    let mut current_word_pos = 0;\n    let mut current_word_len\
    \ = 0;\n    let mut current_word_pos = 0;\n    let mut current_word_len = 0;\n\
    \    let mut current_word_pos = 0;\n    let mut current_word_len = 0;\n    let\
    \ mut current_word_pos = 0;\n    let mut current_word_len = 0;\n    let mut current_word_pos\
    \ = 0;\n    let mut current_word_len = 0;\n    let mut current_word_pos = 0;\n\
    \    let mut current_word_len = 0;\n    let mut current_word_pos = 0;\n    let\
    \ mut current_word_len = 0;\n    let mut current_word_pos = 0;\n    let mut current_word_len\
    \ = 0;\n    let mut current_word_pos = 0;\n    let mut current_word_len = 0;\n\
    \    let mut current_word_pos = 0;\n    let mut current_word_len = 0;\n    let\
    \ mut current_word_pos = 0;\n    let mut current_word_len = 0;\n    let mut current_word_pos\
    \ = 0;\n    let mut current_word_len = 0;\n    let mut current_word_pos = 0;\n\
    \    let mut current_word_len = 0;\n    let mut current_word_pos = 0;\n    let\
    \ mut current_word_len = 0;\n    let mut current_word_pos = 0;\n    let mut current_word_len\
    \ = 0;\n    let mut current_word_pos = 0;\n    let mut current_word_len = 0;\n\
    \    let mut current_word_pos = 0;\n    let mut current_word_len = 0;\n    let\
    \ mut current_word_pos = 0;\n    let mut current_word_len = 0;\n    let mut current_word_pos\
    \ = 0;\n    let mut current_word_len = 0;\n    let mut current_word_pos = 0;\n\
    \    let mut current_word_len = 0;\n    let mut current_word_pos = 0;\n    let\
    \ mut current_word_len = 0;\n    let mut \n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp9wf5f0ed.rs:82:1\n\
    \   |\n82 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        if\
    \ s.chars().all(|c| c.is_consonant() && c != ' ') {\n            result.push(s.split_at(i).collect::<Vec<_>>().join(\"\
    \"));\n            i += n;\n        }\n        i += 1;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpspgme57p.rs:21:32\n   |\n21 |         if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: `(&str, &str)` is not an iterator\n\
    \  --> /tmp/tmpspgme57p.rs:22:39\n   |\n22 |             result.push(s.split_at(i).collect::<Vec<_>>().join(\"\
    \"));\n   |                                       ^^^^^^^ `(&str, &str)` is not\
    \ an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(&str, &str): Iterator`\n           which is required by `&mut (&str,\
    \ &str): Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpspgme57p.rs:23:18\n\
    \   |\n23 |             i += n;\n   |                  ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmpspgme57p.rs:23:15\n\
    \   |\n23 |             i += n;\n   |               ^^ no implementation for `usize\
    \ += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j].is_ascii_letter() {\n            j\
    \ = j + 1;\n        }\n        let mut k = i;\n        while k < s.len() && s[k].is_ascii_letter()\
    \ {\n            k = k + 1;\n        }\n        if j == i {\n            words.push(s.to_string());\n\
    \            i = k;\n        } else {\n            if j > i {\n              \
    \  let mut s = String::from(\"\");\n                for c in s.chars().take(n\
    \ - 1) {\n                    s = s.push_str(&c.to_string());\n              \
    \  }\n                words.push(s);\n            }\n            i = k;\n    \
    \    }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpa4_1e6tu.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpa4_1e6tu.rs:26:30\n\
    \   |\n26 |         while k < s.len() && s[k].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa4_1e6tu.rs:35:41\n   |\n35 |              \
    \   for c in s.chars().take(n - 1) {\n   |                                   \
    \      ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n35 |      \
    \           for c in s.chars().take((n - 1).try_into().unwrap()) {\n   |     \
    \                                    +     +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa4_1e6tu.rs:36:25\n   |\n34 |              \
    \   let mut s = String::from(\"\");\n   |                             ----------------\
    \ expec"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s.chars().any(|c| c == s.chars().nth(j))\
    \ {\n            j += 1\n        }\n        if j == i {\n            break;\n\
    \        }\n        let mut word = String::from(s.chars().nth(i).unwrap());\n\
    \        while j < s.len() && s.chars().any(|c| c != s.chars().nth(j)) {\n   \
    \         word += String::from(s.chars().nth(j).unwrap());\n            j += 1\n\
    \        }\n        if word == s.chars().nth(i).unwrap() {\n            words.push(word);\n\
    \        }\n        i += j - i;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsmgksv3l.rs:22:53\n   |\n\
    22 |         while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsmgksv3l.rs:29:53\n\
    \   |\n29 |         while j < s.len() && s.chars().any(|c| c != s.chars().nth(j))\
    \ {\n   |                                                     ^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpsmgksv3l.rs:30:21\n   |\n30 |             word += String::from(s.chars().nth(j).unwrap());\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |      \
    \               |\n   |                     expected `&str`, found struct `String`\n\
    \   |                     help: consider borrowing here: `&String::from(s.chars().nth(j).unwrap())`\n\
    \nerror[E0277]: can't compare `String` with `char`\n  --> /tmp/tmpsmgksv3l.rs:33:17\n\
    \   |\n33 |         if word == s.chars().nth(i).unwrap() {\n   |             \
    \    ^^ no implementation for `String == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    while n != 0 {\n        if s.contains(&consonants[n % consonants.len()])\
    \ {\n            result.push(s.clone());\n        }\n        n /= consonants.len();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `consonants` in this scope\n  --> /tmp/tmpnvyr62mg.rs:22:24\n\
    \   |\n22 |         if s.contains(&consonants[n % consonants.len()]) {\n   | \
    \                       ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `consonants` in this scope\n  --> /tmp/tmpnvyr62mg.rs:22:39\n   |\n\
    22 |         if s.contains(&consonants[n % consonants.len()]) {\n   |        \
    \                               ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `consonants` in this scope\n  --> /tmp/tmpnvyr62mg.rs:25:14\n\
    \   |\n25 |         n /= consonants.len();\n   |              ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowel_counter = 0;\n    let mut vowel_counter2 =\
    \ 0;\n    let mut vowel_counter3 = 0;\n    let mut vowel_counter4 = 0;\n    let\
    \ mut vowel_counter5 = 0;\n    let mut vowel_counter6 = 0;\n    let mut vowel_counter7\
    \ = 0;\n    let mut vowel_counter8 = 0;\n    let mut vowel_counter9 = 0;\n   \
    \ let mut vowel_counter10 = 0;\n    let mut vowel_counter11 = 0;\n    let mut\
    \ vowel_counter12 = 0;\n    let mut vowel_counter13 = 0;\n    let mut vowel_counter14\
    \ = 0;\n    let mut vowel_counter15 = 0;\n    let mut vowel_counter16 = 0;\n \
    \   let mut vowel_counter17 = 0;\n    let mut vowel_counter18 = 0;\n    let mut\
    \ vowel_counter19 = 0;\n    let mut vowel_counter20 = 0;\n    let mut vowel_counter21\
    \ = 0;\n    let mut vowel_counter22 = 0;\n    let mut vowel_counter23 = 0;\n \
    \   let mut vowel_counter24 = 0;\n    let mut vowel_counter25 = 0;\n    let mut\
    \ vowel_counter26 = 0;\n    let mut vowel_counter27 = 0;\n    let mut vowel_counter28\
    \ = 0;\n    let mut vowel_counter29 = 0;\n    let mut vowel_counter30 = 0;\n \
    \   let mut vowel_counter31 = 0;\n    let mut vowel_counter32 = 0;\n    let mut\
    \ vowel_counter33 = 0;\n    let mut vowel_counter34 = 0;\n    let mut vowel_counter35\
    \ = 0;\n    let mut vowel_counter36 = 0;\n    let mut vowel_counter37 = 0;\n \
    \   let mut vowel_counter38 = 0;\n    let mut vowel_counter39 = 0;\n    let mut\
    \ vowel_counter40 = 0;\n    let mut vowel_counter41 = 0;\n    let mut vowel_counter42\
    \ = 0;\n    let mut vowel_counter43 = 0;\n    let mut vowel_counter44 = 0;\n \
    \   let mut vowel_counter45 = 0;\n    let mut vowel_counter46 = 0;\n    let mut\
    \ vowel_counter47 = 0;\n    let mut vowel_counter48 = 0;\n    let mut vowel_counter49\
    \ = 0;\n    let mut vowel_counter50 = 0;\n    let mut vowel_counter51 = 0;\n \
    \   let mut vowel_counter52 = 0;\n    let mut vowel_counter53 = 0;\n    let mut\
    \ vowel_counter54 = 0;\n\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphooo0zh3.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ list = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s[j] == s[i] {\n            j += 1\n\
    \        }\n        if j == i {\n            list.push(s.to_string());\n     \
    \       i += 1;\n        } else {\n            i += j - i;\n        }\n    }\n\
    \    if list.len() == 0 {\n        vec![]\n    } else {\n        list.iter().cloned().collect::<Vec<_>>().sort_by_key(|x|\
    \ x.len()).collect()\n    }\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8p5ugwi3.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == s[i] {\n   |                \
    \              ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8p5ugwi3.rs:22:38\n   |\n22 |         while j < s.len() && s[j]\
    \ == s[i] {\n   |                                      ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmp8p5ugwi3.rs:35:75\n\
    \   |\n35 |         list.iter().cloned().collect::<Vec<_>>().sort_by_key(|x| x.len()).collect()\n\
    \   |                                                                        \
    \   ^^^^^^^ `()` is not an iterator\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `(): Iterator`\n           which is required\
    \ by `&mut (): Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut index = 0;\n    let mut consonants = 0;\n \
    \   let mut vowels = 0;\n    while index < s.len() {\n        let c = s[index];\n\
    \        if c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n     \
    \       consonants += 1;\n        } else {\n            vowels += 1;\n       \
    \ }\n        index += 1;\n        if consonants == n {\n            words.push(s.to_owned());\n\
    \            consonants = 0;\n        }\n    }\n    if consonants == n {\n   \
    \     words.push(s.to_owned());\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9a0dbzfn.rs:23:17\n\
    \   |\n23 |         let c = s[index];\n   |                 ^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    let mut index = 0;\n    while index\
    \ < s.len() {\n        if s[index] == ' ' {\n            count += 1;\n       \
    \ }\n        if count == n {\n            words.push(s.split_whitespace()[index..]);\n\
    \            count = 0;\n        }\n        index += 1;\n    }\n    words\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuxh9qhaa.rs:22:12\n\
    \   |\n22 |         if s[index] == ' ' {\n   |            ^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpuxh9qhaa.rs:26:24\n   |\n26 |             words.push(s.split_whitespace()[index..]);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0608.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowels_count = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp31p69ssz.rs:61:11\n   |\n\
    61 |     let mu\n   |           ^ help: add `;` here\n62 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp31p69ssz.rs:17:41\n \
    \  |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ list = Vec::new();\n    let mut count = 0;\n    for c in s.chars() {\n     \
    \   if c.is_consonant() {\n            count += 1;\n            if count == n\
    \ {\n                list.push(c.to_string());\n            }\n        }\n   \
    \ }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpsr_pynlk.rs:21:14\n   |\n21 |         if c.is_consonant()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowels_count = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp31p69ssz.rs:61:11\n   |\n\
    61 |     let mu\n   |           ^ help: add `;` here\n62 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp31p69ssz.rs:17:41\n \
    \  |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    while s.len() > 0 {\n        let\
    \ mut i = 0;\n        let mut j = s.len();\n        while i < j {\n          \
    \  if s[i] == ' ' {\n                i += 1;\n                j = i;\n       \
    \     } else {\n                i += 1;\n            }\n        }\n        if\
    \ i == j {\n            result.push(s.clone());\n            i += 1;\n       \
    \ }\n        while i < j {\n            if s[i] == ' ' {\n                i +=\
    \ 1;\n                j = i;\n            } else {\n                i += 1;\n\
    \            }\n        }\n        if i == j {\n            result.push(s.clone());\n\
    \        }\n        s = &s[i..];\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpeni7ca4w.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpeni7ca4w.rs:36:16\n   |\n36 |             if s[i] == ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeni7ca4w.rs:46:13\n\
    \   |\n19 |     let mut s = s;\n   |                 - expected due to this value\n\
    ...\n46 |         s = &s[i..];\n   |             ^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n46 |        \
    \ s = (&s[i..]).to_string();\n   |             +       +++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            i += 1;\n        } else {\n   \
    \         words.push(s.subslice(i, i + n));\n            i += n;\n        }\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp_miawcrr.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp_miawcrr.rs:24:26\n\
    \   |\n24 |             words.push(s.subslice(i, i + n));\n   |              \
    \            ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_miawcrr.rs:24:42\n   |\n24 |             words.push(s.subslice(i,\
    \ i + n));\n   |                                          ^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmp_miawcrr.rs:24:40\n\
    \   |\n24 |             words.push(s.subslice(i, i + n));\n   |              \
    \                          ^ no implementation for `usize + isize`\n   |\n   =\
    \ help: the trait `Add<isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `Add<Rhs>`:\n             <&'a f32 as\
    \ Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n\
    \             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n    \
    \         <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n          \
    \   <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_miawcrr.rs:25:18\n   |\n25 |             i += n;\n   |\
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmp_miawcrr.rs:25:15\n   |\n25 |            \
    \ i += n;\n   |               ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `AddAssign<Rhs>`:\n        \
    \     <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n            \
    \ <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as A"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n !=\
    \ 0 {\n        if s.chars().any(|c| c.is_consonant()) {\n            result.push(s.clone());\n\
    \            n -= 1;\n        }\n        s = s.chars().filter(|c| c.is_consonant()).collect::<String>();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpiap94w8p.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_consonant` found for\
    \ reference `&char` in the current scope\n  --> /tmp/tmpiap94w8p.rs:26:36\n  \
    \ |\n26 |         s = s.chars().filter(|c| c.is_consonant()).collect::<String>();\n\
    \   |                                    ^^^^^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n >\
    \ 0 {\n        let mut i = s.find(' ').unwrap();\n        let mut j = s.find('\
    \ ', i + 1).unwrap();\n        let mut k = s.find(' ', j + 1).unwrap();\n    \
    \    if s.len() == 0 {\n            break;\n        }\n        if s.chars().any(|c|\
    \ c != ' ') {\n            result.push(s.to_string());\n        }\n        while\
    \ i <= j && j <= k {\n            if s.chars().any(|c| c != ' ') {\n         \
    \       result.push(s.to_string());\n            }\n            i += 1;\n    \
    \        j += 1;\n            k += 1;\n        }\n        n -= 1;\n        s =\
    \ s.to_string();\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpkr_64sqv.rs:23:23\n     |\n23   |         let mut j = s.find('\
    \ ', i + 1).unwrap();\n     |                       ^^^^ ---  ----- supplied 2\
    \ arguments\n     |                       |\n     |                       expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpkr_64sqv.rs:24:23\n\
    \     |\n24   |         let mut k = s.find(' ', j + 1).unwrap();\n     |     \
    \                  ^^^^ ---  ----- supplied 2 arguments\n     |              \
    \         |\n     |                       expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n >\
    \ 0 {\n        let mut i = 0;\n        while i < s.len() {\n            if s[i]\
    \ == ' ' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i]\
    \ == 'u' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'y' || s[i] == 'o' || s[i] == 'u' {\n                i\
    \ += 1;\n                continue;\n            }\n            if s[i] == 'h'\
    \ || s[i] == 'e' || s[i] == 'l' || s[i] == 'l' || s[i] == 'o' || s[i] == 'r' ||\
    \ s[i] == 's' || s[i] == 't' || s[i] == 'w' || s[i] == 'y' {\n               \
    \ i += 1;\n                continue;\n            }\n            if s[i] == 'd'\
    \ || s[i] == 'a' || s[i] == 'm' || s[i] == 'o' || s[i] == 'u' {\n            \
    \    i += 1;\n                continue;\n            }\n            if s[i] ==\
    \ 'b' || s[i] == 'l' || s[i] == 'u' {\n                i += 1;\n             \
    \   continue;\n            }\n            if s[i] == 'c' || s[i] == 'h' || s[i]\
    \ == 'l' || s[i] == 'l' || s[i] == 'o' || s[i] == 'r' || s[i] == 's' || s[i] ==\
    \ 't' || s[i] == 'w' || s[i] == 'y' {\n                i += 1;\n             \
    \   continue;\n            }\n            if s[i] == 'f' || s[i] == 'e' || s[i]\
    \ == 'l' || s[i] == 'l' || s[i] == 'o' || s[i] == 'r' || s[i] == 's' || s[i] ==\
    \ 't' || s[i] == 'w' || s[i] == 'y' {\n                i += 1;\n             \
    \   continue;\n            }\n            if s[i] == 'g' || s[i] == 'l' || s[i]\
    \ == 'l' || s[i] == 'o' || s[i] == 'r' || s[i] == 's' || s[i] == 't' || s[i] ==\
    \ 'w' || s[i] == 'y' {\n                i += 1;\n                continue;\n \
    \           }\n            if s[i] == 'p' || s[i] == 'r' || s[i] == 'o' || s[i]\
    \ == 'u' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'v' || s[i] == 'e' || s[i] == 'r' || s[i] == 's' || s[i]\
    \ == 't' || s[i] == 'w' || s[i] == 'y' {\n                i += 1;\n          \
    \      continue;\n            }\n            if s[i] == 'k' || s[i] == 'e' ||\
    \ s[i] == 'r' || s[i] == 's' || s[i] == 't' || s[i] == 'w' || s[i] == 'y' {\n\
    \                i += 1;\n                continue;\n            }\n         \
    \   if s[i] == 'j' || s[i] == 'a' || s[i] == 'm' || s[i] == 'o' || s[i] == 'u'\
    \ {\n                i += 1;\n                continue;\n            }\n     \
    \       if s[i] == 'q\n}\n\nfn main() {\n    let candidate = select_words;\n \
    \   assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpwl576obj.rs:88:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n21\
    \ |     while n > 0 {\n   |                 - unclosed delimiter\n22 |       \
    \  let mut i = 0;\n23 |         while i < s.len() {\n   |                    \
    \       - this delimiter might not be properly closed...\n...\n77 | }\n   | -\
    \ ...as it matches this but it has different indentation\n...\n88 | }\n   |  \
    \ ^\n\nerror: expected `while`, `for`, `loop` or `{` after a label\n  --> /tmp/tmpwl576obj.rs:77:1\n\
    \   |\n77 | }\n   | ^ expected `while`, `for`, `loop` or `{` after a label\n\n\
    error: expected expression, found `}`\n  --> /tmp/tmpwl576obj.rs:77:1\n   |\n\
    77 | }\n   | ^ expected expression\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpwl576obj.rs:24:16\n   |\n24 |            \
    \ if s[i] == ' ' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwl576obj.rs:28:16\n   |\n28 |             if s[i] == 'a' || s[i]\
    \ == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n   |                ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<us"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut words = s.split_whitespace();\n    let mut\
    \ count = 0;\n    while count < n && words.len() > 0 {\n        let word = words.remove(0);\n\
    \        if word.chars().all(|c| c.is_consonant()) {\n            result.push(word);\n\
    \            count += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpom9nm_um.rs:21:30\n   |\n21 |     while\
    \ count < n && words.len() > 0 {\n   |                              ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `remove`\
    \ found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpom9nm_um.rs:22:26\n\
    \   |\n22 |         let word = words.remove(0);\n   |                        \
    \  ^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\"\
    , \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\"\
    , \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels = vec![\"a\"\
    , \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonants = vec![\"a\", \"\
    e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_pairs = vec![\"a\", \"\
    e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_triples = vec![\"a\",\
    \ \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_quadruples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_quintuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_sextuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_septuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_octuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_nonuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_pairs = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_triples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_quadruples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_quintuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_sextuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_septuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_octuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_nonuples = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_pairs = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonant_triple\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp356oh0a4.rs:39:35\n   |\n\
    39 |     let mut vowel_consonant_triple\n   |                                \
    \   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp356oh0a4.rs:17:41\n   |\n17 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowel_consonants = Vec::new();\n    let mut vowel_consonant_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels = Vec::new();\n   \
    \ let mut vowel_consonant_vowels_consonants = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_vowels_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_vowels_consonants_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_consonants_vowels_consonants_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_consonants_vowels_consonants_consonants_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_conson\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx4e56y_9.rs:35:104\n   |\n\
    35 |     let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_conson\n\
    \   |                                                                        \
    \                                ^ help: add `;` here\n36 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx4e56y_9.rs:17:41\n \
    \  |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut index = 0;\n    while index < s.len() {\n \
    \       let mut word = String::new();\n        let mut consonants = 0;\n     \
    \   while index < s.len() && consonants < n {\n            if s[index] == ' '\
    \ {\n                index += 1;\n                continue;\n            }\n \
    \           if s[index] == 'a' || s[index] == 'e' || s[index] == 'i' || s[index]\
    \ == 'o' || s[index] == 'u' {\n                consonants += 1;\n            }\n\
    \            word.push(s[index]);\n            index += 1;\n        }\n      \
    \  if consonants == n {\n            words.push(word);\n        }\n    }\n   \
    \ words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn6gzlc_y.rs:24:16\n\
    \   |\n24 |             if s[index] == ' ' {\n   |                ^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpn6gzlc_y.rs:28:16\n   |\n28 |             if s[index] == 'a' ||\
    \ s[index] == 'e' || s[index] == 'i' || s[index] == 'o' || s[index] == 'u' {\n\
    \   |                ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn6gzlc_y.rs:28:35\n\
    \   |\n28 |             if s[index] == 'a' || s[index] == 'e' || s[index] == 'i'\
    \ || s[index] == 'o' || s[index] == 'u' {\n   |                              \
    \     ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<Ran"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n\
    \        while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n   \
    \         j += 1\n        }\n        if j == i {\n            result.push(s.clone());\n\
    \            i += 1;\n        } else {\n            if j > i {\n             \
    \   let mut j = i;\n                while j < s.len() && s.chars().any(|c| c ==\
    \ s.chars().nth(j)) {\n                    j += 1\n                }\n       \
    \         if j == i {\n                    result.push(s.clone());\n         \
    \           i += 1;\n                } else {\n                    result.push(s.clone());\n\
    \                    i += j - i;\n                }\n            } else {\n  \
    \              result.push(s.clone());\n                i += j - i;\n        \
    \    }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw293ajrz.rs:24:53\n   |\n\
    24 |         while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw293ajrz.rs:33:61\n\
    \   |\n33 |                 while j < s.len() && s.chars().any(|c| c == s.chars().nth(j))\
    \ {\n   |                                                             ^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut vowels_count = vec![];\n    let mut vowels_count_index = vec![];\n\
    \    let mut vowels_count_index_count = vec![];\n    let mut vowels_count_index_count_index\
    \ = vec![];\n    let mut vowels_count_index_count_index_count = vec![];\n    let\
    \ mut vowels_count_index_count_index_count_index = vec![];\n    let mut vowels_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut vowels_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let \n}\n\nfn main() {\n    let candidate = select_words;\n \
    \   assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp0oc3ls9q.rs:45:1\n  \
    \ |\n45 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowels_count = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp31p69ssz.rs:61:11\n   |\n\
    61 |     let mu\n   |           ^ help: add `;` here\n62 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp31p69ssz.rs:17:41\n \
    \  |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut current_word = String::from(\"\");\n    let\
    \ mut current_word_len = 0;\n    let mut current_word_pos = 0;\n    let mut current_word_end\
    \ = s.len();\n    while current_word_pos < current_word_end {\n        let mut\
    \ current_word_start = current_word_pos;\n        while current_word_start < current_word_end\
    \ && s[current_word_start] != '\\0' {\n            current_word_start += 1;\n\
    \        }\n        let mut current_word_len = current_word_start - current_word_pos;\n\
    \        if current_word_len == n {\n            result.push(current_word);\n\
    \            current_word = String::from(\"\");\n            current_word_pos\
    \ = current_word_start;\n            current_word_len = 0;\n        }\n      \
    \  current_word += s[current_word_pos..current_word_pos].to_string();\n      \
    \  current_word_pos += 1;\n    }\n    if current_word_len > 0 {\n        result.push(current_word);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6zu_z495.rs:25:56\n\
    \   |\n25 |         while current_word_start < current_word_end && s[current_word_start]\
    \ != '\\0' {\n   |                                                        ^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6zu_z495.rs:29:32\n\
    \   |\n29 |         if current_word_len == n {\n   |                         \
    \       ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n29 |      \
    \   if current_word_len == n.try_into().unwrap() {\n   |                     \
    \            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6zu_z495.rs:35:25\n\
    \   |\n35 |         current_word += s[current_word_pos..current_word_pos].to_string();\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                         |\n   |                         expected `&str`,\
    \ found struct `String`\n   |                         help: consider borrowing\
    \ here: `&s[current_word_pos..current_word_pos].to_string()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j - i == n {\n            words.push(s.split_whitespace()[..j].collect::<Vec<_>>());\n\
    \            i = j;\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxn7pcxhd.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxn7pcxhd.rs:25:21\n\
    \   |\n25 |         if j - i == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0608]: cannot index\
    \ into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpxn7pcxhd.rs:26:24\n\
    \   |\n26 |             words.push(s.split_whitespace()[..j].collect::<Vec<_>>());\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0608.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] != ' ' {\n            j = j + 1;\n\
    \        }\n        if j == s.len() {\n            break;\n        }\n       \
    \ let mut k = i;\n        while k < j {\n            if s[k] == ' ' {\n      \
    \          break;\n            }\n            k = k + 1;\n        }\n        let\
    \ mut word = String::from(&s[i .. k]);\n        let mut count = 0;\n        while\
    \ k < j {\n            if s[k] == ' ' {\n                count = count + 1;\n\
    \            }\n            k = k + 1;\n        }\n        if count == n {\n \
    \           words.push(word);\n        }\n        i = k + 1;\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5hkrajoy.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] != ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5hkrajoy.rs:30:16\n   |\n30 |             if s[k] == ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5hkrajoy.rs:38:16\n   |\n38 |             if s[k] == ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: abo"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n\
    \        while j < s.len() && s.chars().any(|c| c != s.chars().nth(j)) {\n   \
    \         j += 1\n        }\n        if j == i {\n            result.push(s.clone());\n\
    \            i += 1;\n        } else {\n            if j > i {\n             \
    \   let mut j = i;\n                while j < s.len() && s.chars().any(|c| c !=\
    \ s.chars().nth(j)) {\n                    j += 1\n                }\n       \
    \         if j == i {\n                    result.push(s.clone());\n         \
    \           i += 1;\n                } else {\n                    result.push(s.clone());\n\
    \                    i += j - i;\n                }\n            } else {\n  \
    \              result.push(s.clone());\n                i += j - i;\n        \
    \    }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnvexe2k9.rs:24:53\n   |\n\
    24 |         while j < s.len() && s.chars().any(|c| c != s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnvexe2k9.rs:33:61\n\
    \   |\n33 |                 while j < s.len() && s.chars().any(|c| c != s.chars().nth(j))\
    \ {\n   |                                                             ^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n\
    \        while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n   \
    \         j += 1\n        }\n        if j == i {\n            result.push(s.clone());\n\
    \            i += 1;\n        } else {\n            result.push(s.clone());\n\
    \            i = j;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuh52o03d.rs:24:53\n   |\n\
    24 |         while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n\
    \        while j < s.len() && s.chars().any(|c| c != s.chars().nth(j)) {\n   \
    \         j += 1\n        }\n        if j == i {\n            result.push(s.clone());\n\
    \            i += 1;\n        } else {\n            if s.chars().count(|c| c ==\
    \ s.chars().nth(j)) >= n {\n                result.push(s.clone());\n        \
    \        i += 1;\n            } else {\n                i += j - i;\n        \
    \    }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7l7ey8sj.rs:24:53\n   |\n\
    24 |         while j < s.len() && s.chars().any(|c| c != s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n   --> /tmp/tmp7l7ey8sj.rs:31:26\n    |\n31  |\
    \             if s.chars().count(|c| c == s.chars().nth(j)) >= n {\n    |    \
    \                      ^^^^^ ------------------------- supplied 1 argument\n \
    \   |                          |\n    |                          expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words(s,\
    \ n, s.chars().collect())\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n\
    \  --> /tmp/tmpj7nk9a2s.rs:18:5\n   |\n18 |     select_words(s, n, s.chars().collect())\n\
    \   |     ^^^^^^^^^^^^ -  -  ------------------- supplied 3 arguments\n   |  \
    \   |\n   |     expected 2 arguments\n   |\nnote: function defined here\n  -->\
    \ /tmp/tmpj7nk9a2s.rs:17:4\n   |\n17 | fn select_words(s: String, n: isize) ->\
    \ Vec<String> {\n   |    ^^^^^^^^^^^^ ---------  --------\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowels_count = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp31p69ssz.rs:61:11\n   |\n\
    61 |     let mu\n   |           ^ help: add `;` here\n62 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp31p69ssz.rs:17:41\n \
    \  |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut spaces = vec![];\n    let mut non_spaces = vec![];\n    let mut non_spaces_count\
    \ = vec![];\n    let mut non_spaces_count_max = vec![];\n    let mut non_spaces_count_min\
    \ = vec![];\n    let mut non_spaces_count_sum = vec![];\n    let mut non_spaces_count_product\
    \ = vec![];\n    let mut non_spaces_count_product2 = vec![];\n    let mut non_spaces_count_product3\
    \ = vec![];\n    let mut non_spaces_count_product4 = vec![];\n    let mut non_spaces_count_product5\
    \ = vec![];\n    let mut non_spaces_count_product6 = vec![];\n    let mut non_spaces_count_product7\
    \ = vec![];\n    let mut non_spaces_count_product8 = vec![];\n    let mut non_spaces_count_product9\
    \ = vec![];\n    let mut non_spaces_count_product10 = vec![];\n    let mut non_spaces_count_product11\
    \ = vec![];\n    let mut non_spaces_count_product12 = vec![];\n    let mut non_spaces_count_product13\
    \ = vec![];\n    let mut non_spaces_count_product14 = vec![];\n    let mut non_spaces_count_product15\
    \ = vec![];\n    let mut non_spaces_count_product16 = vec![];\n    let mut non_spaces_count_product17\
    \ = vec![];\n    let mut non_spaces_count_product18 = vec![];\n    let mut non_spaces_count_product19\
    \ = vec![];\n    let mut non_spaces_count_product20 = vec![];\n    let mut non_spaces_count_product21\
    \ = vec![];\n    let mut non_spaces_count_product22 = vec![];\n    let mut non_spaces_count_product23\
    \ = vec![];\n    let mut non_spaces_count_product24 = vec![];\n    let mut non_spaces_count_product25\
    \ = vec![];\n    let mut non_spaces_count_product26 = vec![];\n    let mut non_spaces_count_product27\
    \ = vec![];\n    let mut non_spaces_count_product28 = vec![];\n    let mut non_spaces_count_product29\
    \ = vec![];\n    let mut non_spaces_count_product30 = vec![];\n    let mut non_spaces_count_product31\
    \ = \n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpspt4jpok.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            i += 1;\n        } else {\n   \
    \         words.push(s.to_string());\n            i += 1;\n        }\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp2o5t57b8.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowel_consonants = Vec::new();\n    let mut vowel_consonant_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels = Vec::new();\n   \
    \ let mut vowel_consonant_vowels_vowels_vowels = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut \n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpi9ootj5y.rs:39:1\n\
    \   |\n39 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut spaces = vec![];\n    let mut punctuation = vec![];\n    let mut\
    \ non_letters = vec![];\n    let mut non_spaces = vec![];\n    let mut non_punctuation\
    \ = vec![];\n    let mut non_letters_count = vec![];\n    let mut non_spaces_count\
    \ = vec![];\n    let mut non_punctuation_count = vec![];\n    let mut non_letters_count_max\
    \ = vec![];\n    let mut non_spaces_count_max = vec![];\n    let mut non_punctuation_count_max\
    \ = vec![];\n    let mut non_letters_count_min = vec![];\n    let mut non_spaces_count_min\
    \ = vec![];\n    let mut non_punctuation_count_min = vec![];\n    let mut non_letters_count_max_index\
    \ = vec![];\n    let mut non_spaces_count_max_index = vec![];\n    let mut non_punctuation_count_max_index\
    \ = vec![];\n    let mut non_letters_count_min_index = vec![];\n    let mut non_spaces_count_min_index\
    \ = vec![];\n    let mut non_punctuation_count_min_index = vec![];\n    let mut\
    \ non_letters_count_max_index = vec![];\n    let mut non_spaces_count_max_index\
    \ = vec![];\n    let mut non_punctuation_count_max_index = vec![];\n    let mut\
    \ non_letters_count_min_index = vec![];\n    let mut non_spaces_count_min_index\
    \ = vec![];\n    let mut non_punctuation_count_min_index = vec![];\n    let mut\
    \ non_letters_count_max_index = vec![];\n    let mut non_spaces_count_max_index\
    \ = vec![];\n    let mut non_punctuation_count_max_index = vec![];\n    let mut\
    \ non_letters_count_min_index = vec![];\n    let mut non_spaces_count_min_index\
    \ = vec![];\n    let mut non_punctuation_count_min_index = vec![];\n    let mut\
    \ non_letters_count_max_index = vec![];\n    let mut non_spaces_count_max_index\
    \ = vec![];\n    let mut non_punctuation_count_max_index = vec![];\n    let mut\
    \ non_letters_count_min_index = vec![];\n    let mut non_spaces_count_min_index\
    \ = vec![];\n    let mut non_punctuation_count_min_index = vec![];\n    let mut\
    \ non_letters_count_max_index = vec![];\n    let mut non_spaces_\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjhu4y9q8.rs:60:24\n   |\n\
    60 |     let mut non_spaces_\n   |                        ^ help: add `;` here\n\
    61 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjhu4y9q8.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowel_counter = 0;\n    let mut vowel_counter2 =\
    \ 0;\n    let mut vowel_counter3 = 0;\n    let mut vowel_counter4 = 0;\n    let\
    \ mut vowel_counter5 = 0;\n    let mut vowel_counter6 = 0;\n    let mut vowel_counter7\
    \ = 0;\n    let mut vowel_counter8 = 0;\n    let mut vowel_counter9 = 0;\n   \
    \ let mut vowel_counter10 = 0;\n    let mut vowel_counter11 = 0;\n    let mut\
    \ vowel_counter12 = 0;\n    let mut vowel_counter13 = 0;\n    let mut vowel_counter14\
    \ = 0;\n    let mut vowel_counter15 = 0;\n    let mut vowel_counter16 = 0;\n \
    \   let mut vowel_counter17 = 0;\n    let mut vowel_counter18 = 0;\n    let mut\
    \ vowel_counter19 = 0;\n    let mut vowel_counter20 = 0;\n    let mut vowel_counter21\
    \ = 0;\n    let mut vowel_counter22 = 0;\n    let mut vowel_counter23 = 0;\n \
    \   let mut vowel_counter24 = 0;\n    let mut vowel_counter25 = 0;\n    let mut\
    \ vowel_counter26 = 0;\n    let mut vowel_counter27 = 0;\n    let mut vowel_counter28\
    \ = 0;\n    let mut vowel_counter29 = 0;\n    let mut vowel_counter30 = 0;\n \
    \   let mut vowel_counter31 = 0;\n    let mut vowel_counter32 = 0;\n    let mut\
    \ vowel_counter33 = 0;\n    let mut vowel_counter34 = 0;\n    let mut vowel_counter35\
    \ = 0;\n    let mut vowel_counter36 = 0;\n    let mut vowel_counter37 = 0;\n \
    \   let mut vowel_counter38 = 0;\n    let mut vowel_counter39 = 0;\n    let mut\
    \ vowel_counter40 = 0;\n    let mut vowel_counter41 = 0;\n    let mut vowel_counter42\
    \ = 0;\n    let mut vowel_counter43 = 0;\n    let mut vowel_counter44 = 0;\n \
    \   let mut vowel_counter45 = 0;\n    let mut vowel_counter46 = 0;\n    let mut\
    \ vowel_counter47 = 0;\n    let mut vowel_counter48 = 0;\n    let mut vowel_counter49\
    \ = 0;\n    let mut vowel_counter50 = 0;\n    let mut vowel_counter51 = 0;\n \
    \   let mut vowel_counter52 = 0;\n    let mut vowel_counter53 = 0;\n    let mut\
    \ vowel_counter54 = 0;\n\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphooo0zh3.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n\
    \        while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n   \
    \         j += 1\n        }\n        if j == i {\n            result.push(s.clone());\n\
    \            i += 1;\n        } else {\n            i += j - i;\n        }\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1m64cii0.rs:24:53\n   |\n\
    24 |         while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c.is_alpha()) {\n            if n == 0 {\n             \
    \   break;\n            }\n            i += 1;\n        } else {\n           \
    \ result.push(s.subslice(i, i + 1));\n            i += 1;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpvc7wvbew.rs:23:32\n   |\n23 |         if s.chars().any(|c|\
    \ c.is_consonant() && c.is_alpha()) {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `is_alpha` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpvc7wvbew.rs:23:52\n   |\n\
    23 |         if s.chars().any(|c| c.is_consonant() && c.is_alpha()) {\n   |  \
    \                                                  ^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_alphabetic`\n\nerror[E0599]: no\
    \ method named `subslice` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpvc7wvbew.rs:29:27\n   |\n29 |             result.push(s.subslice(i,\
    \ i + 1));\n   |                           ^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            result.push(s.to_string()[i..i\
    \ + n]);\n            i += n;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpclusergv.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpclusergv.rs:22:46\n\
    \   |\n22 |             result.push(s.to_string()[i..i + n]);\n   |          \
    \                                    ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add `isize` to `usize`\n  --> /tmp/tmpclusergv.rs:22:44\n   |\n22 | \
    \            result.push(s.to_string()[i..i + n]);\n   |                     \
    \                       ^ no implementation for `usize + isize`\n   |\n   = help:\
    \ the trait `Add<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0277]: the size\
    \ for values of type `str` cannot be known at compilation time\n   --> /tmp/tmpclusergv.rs:22:25\n\
    \    |\n22  |             result.push(s.to_string()[i..i + n]);\n    |       \
    \             ---- ^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |                    |\n    |                    required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n   --> /tmp/tmpclusergv.rs:18:22\n\
    \    |\n18  |     let mut result = vec![];\n    |                      ^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec::<T>::new`\n\
    \    = note: this error originates in the macro `vec` (in Nightly builds, "
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    while n > 0 {\n        let mut i = 0;\n        while i < s.len()\
    \ {\n            if s[i] == ' ' {\n                i += 1;\n                continue;\n\
    \            }\n            if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i]\
    \ == 'o' || s[i] == 'u' {\n                i += 1;\n                continue;\n\
    \            }\n            if s[i] == 'y' || s[i] == 'o' || s[i] == 'u' {\n \
    \               i += 1;\n                continue;\n            }\n          \
    \  if s[i] == 's' || s[i] == 't' || s[i] == 'h' || s[i] == 'e' || s[i] == 'd'\
    \ {\n                i += 1;\n                continue;\n            }\n     \
    \       if s[i] == 'd' || s[i] == 'f' || s[i] == 'r' || s[i] == 'l' || s[i] ==\
    \ 'l' {\n                i += 1;\n                continue;\n            }\n \
    \           if s[i] == 'b' || s[i] == 'c' || s[i] == 'm' || s[i] == 'p' || s[i]\
    \ == 't' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'n' || s[i] == 'g' || s[i] == 'p' || s[i] == 'h' || s[i]\
    \ == 'a' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'm' || s[i] == 'a' || s[i] == 'r' || s[i] == 'k' || s[i]\
    \ == 'e' || s[i] == 'r' {\n                i += 1;\n                continue;\n\
    \            }\n            if s[i] == 'p' || s[i] == 'h' || s[i] == 'e' || s[i]\
    \ == 'n' || s[i] == 'g' || s[i] == 'a' {\n                i += 1;\n          \
    \      continue;\n            }\n            if s[i] == 'c' || s[i] == 'h' ||\
    \ s[i] == 'e' || s[i] == 'n' || s[i] == 'g' || s[i] == 'a' {\n               \
    \ i += 1;\n                continue;\n            }\n            if s[i] == 'm'\
    \ || s[i] == 'a' || s[i] == 'r' || s[i] == 'k' || s[i] == 'e' || s[i] == 'r' {\n\
    \                i += 1;\n                continue;\n            }\n         \
    \   if s[i] == 'p' || s[i] == 'h' || s[i] == 'e' || s[i] == 'n' || s[i] == 'g'\
    \ || s[i] == 'a' {\n                i += 1;\n                continue;\n     \
    \       }\n            if s[i] == 'c' || s[i] == 'h' || s[i] == 'e' || s[i] ==\
    \ 'n' || s[i] == 'g' || s[i] == 'a' {\n                i += 1;\n             \
    \   continue;\n            }\n            if s[i] == 'm' || s[i] == 'a' || s[i]\
    \ == 'r' || s[i] == 'k' || s[i] == 'e' || s[i] == 'r' {\n                i +=\
    \ 1;\n                continue;\n            }\n            if s[i] == 'p' ||\
    \ s[i] == 'h' || s[i] == 'e' || s[i] == 'n' || s[i] == '\n}\n\nfn main() {\n \
    \   let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpr96smetd.rs:80:84\n\
    \   |\n80 |             if s[i] == 'p' || s[i] == 'h' || s[i] == 'e' || s[i] ==\
    \ 'n' || s[i] == '\n   |                                                     \
    \                               ^\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowels_count = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp31p69ssz.rs:61:11\n   |\n\
    61 |     let mu\n   |           ^ help: add `;` here\n62 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp31p69ssz.rs:17:41\n \
    \  |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j = j + 1;\n\
    \        }\n        let mut word = String::from(&s[i .. (j + 1)]);\n        let\
    \ mut count = 0;\n        while j < s.len() && s[j] == word[0] {\n           \
    \ count = count + 1;\n            j = j + 1;\n        }\n        if count == n\
    \ {\n            words.push(word);\n            i = j + 1;\n        }\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4zur7wad.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4zur7wad.rs:27:30\n   |\n27 |         while j < s.len() && s[j]\
    \ == word[0] {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp4zur7wad.rs:27:38\n   |\n27 |         while j < s.len() && s[j]\
    \ == word[0] {\n   |                                      ^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \          "
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n >\
    \ 0 {\n        if s.chars().any(|c| c != ' ') {\n            result.push(s.clone());\n\
    \        }\n        n -= 1;\n        s = s.chars().filter(|c| c != ' ').collect();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3c2g20g5.rs:26:36\n\
    \   |\n26 |         s = s.chars().filter(|c| c != ' ').collect();\n   |      \
    \                              ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            result.push(s.subslice(i, i + n));\n\
    \            i += n;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp_vhwsoo8.rs:23:32\n   |\n23 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp_vhwsoo8.rs:24:27\n\
    \   |\n24 |             result.push(s.subslice(i, i + n));\n   |             \
    \              ^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ list = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n\
    \        }\n        if j == i {\n            list.push(s.to_string());\n     \
    \       i += 1;\n        } else {\n            let mut count = 0;\n          \
    \  while j < s.len() {\n                if s[j] == s[i] {\n                  \
    \  count += 1;\n                    j += 1;\n                } else {\n      \
    \              break;\n                }\n            }\n            if count\
    \ == n {\n                list.push(s.to_string());\n                i += 1;\n\
    \            } else {\n                j += 1;\n            }\n        }\n   \
    \ }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpeiu2e8kg.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpeiu2e8kg.rs:31:20\n   |\n31 |                 if s[j] == s[i] {\n\
    \   |                    ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpeiu2e8kg.rs:31:28\n\
    \   |\n31 |                 if s[j] == s[i] {\n   |                          \
    \  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <st"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > 0 {\n        let mut\
    \ i = 0;\n        let mut j = s.len();\n        while i < j {\n            if\
    \ s[i] == ' ' {\n                i += 1;\n                j -= 1;\n          \
    \  } else {\n                i += 1;\n            }\n        }\n        if i ==\
    \ n {\n            result.push(s.clone());\n        }\n        s = &s[j..];\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpi4kovtg4.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi4kovtg4.rs:31:17\n\
    \   |\n31 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n31 |         if i == n.try_into().unwrap()\
    \ {\n   |                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpi4kovtg4.rs:34:13\n   |\n19 |     let mut s = s;\n   |        \
    \         - expected due to this value\n...\n34 |         s = &s[j..];\n   | \
    \            ^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try using\
    \ a conversion method\n   |\n34 |         s = (&s[j..]).to_string();\n   |   \
    \          +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = String::from(s);\n    while s.len() > 0 {\n\
    \        let mut word = String::from(s);\n        let mut count = 0;\n       \
    \ for c in word.chars() {\n            if c.is_consonant() {\n               \
    \ count += 1;\n            }\n        }\n        if count == n {\n           \
    \ result.push(word);\n        }\n        s = s.trim_end().to_string();\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpwcs1m85x.rs:24:18\n   |\n24 |             if c.is_consonant()\
    \ {\n   |                  ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ list = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        if\
    \ s.chars().any(|c| c.is_consonant() && c != ' ') {\n            i += 1;\n   \
    \     } else {\n            list.push(s.split_whitespace()[i]);\n            i\
    \ += 1;\n        }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp9ris_cz9.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmp9ris_cz9.rs:24:23\n   |\n24 |         \
    \    list.push(s.split_whitespace()[i]);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n >\
    \ 0 {\n        let mut i = 0;\n        let mut found = false;\n        while i\
    \ < s.len() && !found {\n            if s[i] == ' ' {\n                found =\
    \ true;\n            } else {\n                i += 1;\n            }\n      \
    \  }\n        if found {\n            result.push(s.subslice(i, s.len()));\n \
    \           n -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9f2uoguj.rs:25:16\n\
    \   |\n25 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `subslice` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp9f2uoguj.rs:32:27\n   |\n32 |          \
    \   result.push(s.subslice(i, s.len()));\n   |                           ^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s[j] == s[i] {\n            j += 1\n\
    \        }\n        if j == i {\n            words.push(s.to_string());\n    \
    \        i += 1;\n        } else {\n            i += j - i;\n        }\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpym3cow4b.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == s[i] {\n   |                \
    \              ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpym3cow4b.rs:22:38\n   |\n22 |         while j < s.len() && s[j]\
    \ == s[i] {\n   |                                      ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s[j] == ' ' {\n            j = j +\
    \ 1;\n        }\n        if j - i > n {\n            words.push_back(s.subslice(i,\
    \ j));\n            i = j;\n        } else {\n            i = j;\n        }\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxgtg5gvn.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxgtg5gvn.rs:25:20\n\
    \   |\n25 |         if j - i > n {\n   |                    ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if j - i > n.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpxgtg5gvn.rs:26:19\n\
    \   |\n26 |             words.push_back(s.subslice(i, j));\n   |             \
    \      ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named\
    \ `subslice` found for struct `String` in the current scope\n  --> /tmp/tmpxgtg5gvn.rs:26:31\n\
    \   |\n26 |             words.push_back(s.subslice(i, j));\n   |             \
    \                  ^^^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut words = s.split_whitespace();\n    let mut\
    \ count = 0;\n    while count < n && words.len() > 0 {\n        let mut word =\
    \ words.remove(0);\n        if word.chars().all(|c| c.is_consonant()) {\n    \
    \        result.push(word);\n            count += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpe26g5j9h.rs:21:30\n   |\n21 |     while\
    \ count < n && words.len() > 0 {\n   |                              ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `remove`\
    \ found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpe26g5j9h.rs:22:30\n\
    \   |\n22 |         let mut word = words.remove(0);\n   |                    \
    \          ^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut spaces = Vec::new();\n    let mut non_spaces = Vec::new();\n\
    \    let mut non_letters = Vec::new();\n    let mut non_letters_spaces = Vec::new();\n\
    \    let mut non_letters_spaces_vowels = Vec::new();\n    let mut non_letters_spaces_vowels_consonants\
    \ = Vec::new();\n    let mut non_letters_spaces_vowels_consonants_spaces = Vec::new();\n\
    \    let mut non_letters_spaces_vowels_consonants_spaces_vowels = Vec::new();\n\
    \    let mut non_letters_spaces_vowels_consonants_spaces_vowels_consonants = Vec::new();\n\
    \    let mut non_letters_spaces_vowels_consonants_spaces_vowels_consonants_spaces\
    \ = Vec::new();\n    let mut non_letters_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowels\
    \ = Vec::new();\n    let mut non_letters_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowels_consonants\
    \ = Vec::new();\n    let mut non_letters_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowels_consonants_spaces\
    \ = Vec::new();\n    let mut non_letters_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowels\
    \ = Vec::new();\n    let mut non_letters_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowels_consonants\
    \ = Vec::new();\n    let mut non_letters_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowels_consonants_spaces\
    \ = Vec::new();\n    let mut non_letters_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowels\
    \ = Vec::new();\n    let mut non_letters_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowel\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppulo3l8n.rs:38:87\n   |\n\
    38 |     let mut non_letters_spaces_vowels_consonants_spaces_vowels_consonants_spaces_vowel\n\
    \   |                                                                        \
    \               ^ help: add `;` here\n39 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppulo3l8n.rs:17:41\n   |\n17 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |    ------------                   \
    \      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut s = s;\n    while s.len() > 0 {\n        let\
    \ mut word = String::new();\n        let mut consonant = false;\n        for c\
    \ in s.chars() {\n            if c.is_uppercase() {\n                consonant\
    \ = true;\n            }\n            if consonant {\n                word.push(c);\n\
    \            }\n            if c.is_lowercase() {\n                consonant =\
    \ false;\n            }\n        }\n        if word.len() == n {\n           \
    \ words.push(word);\n        }\n        s = &s[word.len()..];\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqc1cscfw.rs:34:26\n   |\n\
    34 |         if word.len() == n {\n   |                          ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n34 |         if word.len() == n.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqc1cscfw.rs:37:13\n   |\n19 |     let mut s = s;\n   |\
    \                 - expected due to this value\n...\n37 |         s = &s[word.len()..];\n\
    \   |             ^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n  \
    \ |\nhelp: try using a conversion method\n   |\n37 |         s = (&s[word.len()..]).to_string();\n\
    \   |             +                +++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ list = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n\
    \        }\n        if j == i {\n            list.push(s.to_string());\n     \
    \       i += 1;\n        } else {\n            let mut k = j;\n            while\
    \ k < s.len() && s[k] == ' ' {\n                k += 1\n            }\n      \
    \      if k == j {\n                list.push(s.to_string());\n              \
    \  i += 1;\n            } else {\n                while k < s.len() && s[k] !=\
    \ ' ' {\n                    k += 1\n                }\n                let mut\
    \ j = i;\n                while j < s.len() && s[j] != ' ' {\n               \
    \     j += 1\n                }\n                let mut k = j;\n            \
    \    while k < s.len() && s[k] != ' ' {\n                    k += 1\n        \
    \        }\n                let mut i = j;\n                while i < s.len()\
    \ && s[i] != ' ' {\n                    i += 1\n                }\n          \
    \      let mut j = i;\n                while j < s.len() && s[j] != ' ' {\n  \
    \                  j += 1\n                }\n                let mut k = j;\n\
    \                while k < s.len() && s[k] != ' ' {\n                    k +=\
    \ 1\n                }\n                let mut i = j;\n                while\
    \ i < s.len() && s[i] != ' ' {\n                    i += 1\n                }\n\
    \                let mut j = i;\n                while j < s.len() && s[j] !=\
    \ ' ' {\n                    j += 1\n                }\n                let mut\
    \ k = j;\n                while k < s.len() && s[k] != ' ' {\n               \
    \     k += 1\n                }\n                let mut i = j;\n            \
    \    while i < s.len() && s[i] != ' ' {\n                    i += 1\n        \
    \        }\n                let mut j = i;\n                while j < s.len()\
    \ && s[j] != ' ' {\n                    j += 1\n                }\n          \
    \      let mut k = j;\n                while k < s.len() && s[k] != ' ' {\n  \
    \                  k += 1\n                }\n                let mut i = j;\n\
    \                while i < s.len() && s[i] != ' ' {\n                    i +=\
    \ 1\n                }\n                let mut j = i;\n                while\
    \ j < s.len() && s[j] != ' ' {\n                    j += 1\n                }\n\
    \                let mut k = j;\n                while k < s.len() && s[k] !=\
    \ ' ' {\n                    k += 1\n                }\n                let mut\
    \ i = j;\n                while i < s.len() && s[i] != ' ' {\n               \
    \     i += 1\n                }\n                let mut j = i;\n            \
    \    while j < s.len() && s[j] != ' ' {\n                    j += 1\n        \
    \        }\n                \n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpigir5odz.rs:116:3\n\
    \    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while i < s.len() {\n    |                       - unclosed delimiter\n\
    ...\n28  |         } else {\n    |                - unclosed delimiter\n...\n\
    36  |             } else {\n    |                    - this delimiter might not\
    \ be properly closed...\n...\n105 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n116 | }\n    |   ^\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpigir5odz.rs:22:30\n   |\n22 |  \
    \       while j < s.len() && s[j] == ' ' {\n   |                             \
    \ ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpigir5odz.rs:30:34\n   |\n30 |             while k < s.len() &&\
    \ s[k] == ' ' {\n   |                                  ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  "
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s.chars().any(|c| c == s.chars().nth(j))\
    \ {\n            j += 1\n        }\n        if j == i {\n            break;\n\
    \        }\n        let mut word = String::from(s.chars().nth(i).unwrap());\n\
    \        let mut count = 0;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == s.chars().nth(j)) {\n                count += 1;\n            }\n     \
    \       j += 1\n        }\n        if count == n {\n            words.push(word);\n\
    \        }\n        i = j;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqatwxb3z.rs:22:53\n   |\n\
    22 |         while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqatwxb3z.rs:31:39\n\
    \   |\n31 |             if s.chars().any(|c| c == s.chars().nth(j)) {\n   |  \
    \                                     ^^^^^^^^^^^^^^^^ expected `char`, found\
    \ enum `Option`\n   |\n   = note: expected type `char`\n              found enum\
    \ `Option<char>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n            result.push(s.split_whitespace()[i]);\n\
    \            i += 1;\n        }\n        if i == s.len() {\n            break;\n\
    \        }\n        if s.chars().all(|c| c.is_consonant() && c == ' ') {\n   \
    \         i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpdfhropb4.rs:23:32\n   |\n23 |         if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmpdfhropb4.rs:24:25\n   |\n24 |         \
    \    result.push(s.split_whitespace()[i]);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0599]: no method named `is_consonant` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpdfhropb4.rs:30:32\n   |\n30 |         if s.chars().all(|c|\
    \ c.is_consonant() && c == ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0599, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        if s.chars().any(|c| c.is_consonant() && count < n) {\n         \
    \   words.push(s.subslice(i, i + 1));\n            i += 1;\n            count\
    \ += 1;\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpva2_izx5.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant() && count < n) {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpva2_izx5.rs:23:26\n\
    \   |\n23 |             words.push(s.subslice(i, i + 1));\n   |              \
    \            ^^^^^^^^ method not found in `String`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n !=\
    \ 0 {\n        if s.chars().any(|c| c.is_consonant()) {\n            result.push(s.clone());\n\
    \            n -= 1;\n        }\n        s = s.chars().filter(|c| !c.is_consonant()).collect::<String>();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp3nbar79j.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_consonant` found for\
    \ reference `&char` in the current scope\n  --> /tmp/tmp3nbar79j.rs:26:37\n  \
    \ |\n26 |         s = s.chars().filter(|c| !c.is_consonant()).collect::<String>();\n\
    \   |                                     ^^^^^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut index = 0;\n    let mut consonants = vec![];\n\
    \    let mut vowels = vec![];\n    let mut vowels_index = 0;\n    let mut vowels_consonants\
    \ = vec![];\n    let mut vowels_consonants_index = 0;\n    let mut vowels_consonants_index2\
    \ = 0;\n    let mut vowels_consonants_index3 = 0;\n    let mut vowels_consonants_index4\
    \ = 0;\n    let mut vowels_consonants_index5 = 0;\n    let mut vowels_consonants_index6\
    \ = 0;\n    let mut vowels_consonants_index7 = 0;\n    let mut vowels_consonants_index8\
    \ = 0;\n    let mut vowels_consonants_index9 = 0;\n    let mut vowels_consonants_index10\
    \ = 0;\n    let mut vowels_consonants_index11 = 0;\n    let mut vowels_consonants_index12\
    \ = 0;\n    let mut vowels_consonants_index13 = 0;\n    let mut vowels_consonants_index14\
    \ = 0;\n    let mut vowels_consonants_index15 = 0;\n    let mut vowels_consonants_index16\
    \ = 0;\n    let mut vowels_consonants_index17 = 0;\n    let mut vowels_consonants_index18\
    \ = 0;\n    let mut vowels_consonants_index19 = 0;\n    let mut vowels_consonants_index20\
    \ = 0;\n    let mut vowels_consonants_index21 = 0;\n    let mut vowels_consonants_index22\
    \ = 0;\n    let mut vowels_consonants_index23 = 0;\n    let mut vowels_consonants_index24\
    \ = 0;\n    let mut vowels_consonants_index25 = 0;\n    let mut vowels_consonants_index26\
    \ = 0;\n    let mut vowels_consonants_index27 = 0;\n    let mut vowels_consonants_index28\
    \ = 0;\n    let mut vowels_consonants_index29 = 0;\n    let mut vowels_consonants_index30\
    \ = 0;\n    let mut vowels_consonants_index31 = 0;\n    let mut vowels_consonants_index32\
    \ = 0;\n    let mut vowels_consonants_index33 = 0;\n    let mut vowels_consonants_index34\
    \ = 0;\n    let mut vowels_consonants_index35 = 0;\n    let mut vowels_conson\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfy1l3xz1.rs:59:26\n   |\n\
    59 |     let mut vowels_conson\n   |                          ^ help: add `;`\
    \ here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfy1l3xz1.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) ->\
    \ Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    while n != 0 {\n        if s.contains(&consonants[n % consonants.len()])\
    \ {\n            result.push(s.clone());\n        }\n        n /= consonants.len();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `consonants` in this scope\n  --> /tmp/tmpnvyr62mg.rs:22:24\n\
    \   |\n22 |         if s.contains(&consonants[n % consonants.len()]) {\n   | \
    \                       ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `consonants` in this scope\n  --> /tmp/tmpnvyr62mg.rs:22:39\n   |\n\
    22 |         if s.contains(&consonants[n % consonants.len()]) {\n   |        \
    \                               ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `consonants` in this scope\n  --> /tmp/tmpnvyr62mg.rs:25:14\n\
    \   |\n25 |         n /= consonants.len();\n   |              ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowel_consonants = Vec::new();\n    let mut vowel_consonant_count\
    \ = Vec::new();\n    let mut vowel_consonant_count_max = Vec::new();\n    let\
    \ mut vowel_consonant_count_min = Vec::new();\n    let mut vowel_consonant_count_max_index\
    \ = Vec::new();\n    let mut vowel_consonant_count_min_index = Vec::new();\n \
    \   let mut vowel_consonant_count_max_value = Vec::new();\n    let mut vowel_consonant_count_min_value\
    \ = Vec::new();\n    let mut vowel_consonant_count_max_value_count = Vec::new();\n\
    \    let mut vowel_consonant_count_min_value_count = Vec::new();\n    let mut\
    \ vowel_consonant_count_max_value_count_max = Vec::new();\n    let mut vowel_consonant_count_min_value_count_max\
    \ = Vec::new();\n    let mut vowel_consonant_count_max_value_count_min = Vec::new();\n\
    \    let mut vowel_consonant_count_min_value_count_min = Vec::new();\n    let\
    \ mut vowel_consonant_count_max_value_count_max_index = Vec::new();\n    let mut\
    \ vowel_consonant_count_min_value_count_max_index = Vec::new();\n    let mut vowel_consonant_count_max_value_count_min_index\
    \ = Vec::new();\n    let mut vowel_consonant_count_min_value_count_min_index =\
    \ Vec::new();\n    let mut vowel_consonant_count_max_value_count_max_value = Vec::new();\n\
    \    let mut vowel_consonant_count_min_value_count_max_value = Vec::new();\n \
    \   let mut vowel_consonant_count_max_value_count_min_value = Vec::new();\n  \
    \  let mut vowel_consonant_count_min_value_count_min_value = Vec::new();\n   \
    \ let mut vowel_consonant_count_max_value_count_max_value_max = Vec::new();\n\
    \    let mut vowel_consonant_count_min_value_count_max_value_max = Vec::new();\n\
    \    let mut vowel_consonant_count_max_value_count_min_value_max = Vec::new();\n\
    \    let mut vowel_consonant_count_min_value_count_min_value_max = Vec::new();\n\
    \    let mut vowel_consonant_count_max_value_count_max_value_min = Vec::new();\n\
    \    let \n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpttka_d_q.rs:49:1\n  \
    \ |\n49 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    while n != 0 {\n        if s.chars().any(|c| c.is_consonant()) {\n\
    \            result.push(s.clone());\n        }\n        n -= 1;\n        s =\
    \ s.chars().filter(|c| !c.is_consonant()).collect::<String>();\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp44vsptnc.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_consonant` found for\
    \ reference `&char` in the current scope\n  --> /tmp/tmp44vsptnc.rs:26:37\n  \
    \ |\n26 |         s = s.chars().filter(|c| !c.is_consonant()).collect::<String>();\n\
    \   |                                     ^^^^^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ list = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut spaces = Vec::new();\n    let mut punctuation = Vec::new();\n\
    \    let mut words = Vec::new();\n    let mut spaces_count = s.chars().filter(|c|\
    \ c == ' ').count();\n    let mut punctuation_count = s.chars().filter(|c| c ==\
    \ '.' || c == '!' || c == '?' || c == ';' || c == ':' || c == '-' || c == '_').count();\n\
    \    let mut vowels_count = s.chars().filter(|c| c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u').count();\n    let mut consonants_count = s.chars().filter(|c|\
    \ c == 'b' || c == 'c' || c == 'd' || c == 'f' || c == 'g' || c == 'h' || c ==\
    \ 'j' || c == 'k' || c == 'l' || c == 'm' || c == 'n' || c == 'p' || c == 'q'\
    \ || c == 'r' || c == 's' || c == 't' || c == 'v' || c == 'w' || c == 'x' || c\
    \ == 'y' || c == 'z').count();\n    let mut vowels_count = s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count();\n    let\
    \ mut consonants_count = s.chars().filter(|c| c == 'b' || c == 'c' || c == 'd'\
    \ || c == 'f' || c == 'g' || c == 'h' || c == 'j' || c == 'k' || c == 'l' || c\
    \ == 'm' || c == 'n' || c == 'p' || c == 'q' || c == 'r' || c == 's' || c == 't'\
    \ || c == 'v' || c == 'w' || c == 'x' || c == 'y' || c == 'z').count();\n    let\
    \ mut vowels_count = s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u').count();\n    let mut consonants_count = s.chars().filter(|c|\
    \ c == 'b' || c == 'c' || c == 'd' || c == 'f' || c == 'g' || c == 'h' || c ==\
    \ 'j' || c == 'k' || c == 'l' || c == 'm' || c == 'n' || c == 'p' || c == 'q'\
    \ || c == 'r' || c == 's' || c == 't\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `while`, `for`, `loop` or `{` after a label\n  --> /tmp/tmpsi2tg98p.rs:32:1\n\
    \   |\n32 | }\n   | ^ expected `while`, `for`, `loop` or `{` after a label\n\n\
    error: expected expression, found `)`\n  --> /tmp/tmpsi2tg98p.rs:32:1\n   |\n\
    32 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n\
    \  --> /tmp/tmpsi2tg98p.rs:31:48\n   |\n17 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |                                                     -\
    \ closing delimiter possibly meant for this\n...\n31 |     let mut consonants_count\
    \ = s.chars().filter(|c| c == 'b' || c == 'c' || c == 'd' || c == 'f' || c ==\
    \ 'g' || c == 'h' || c == 'j' || c...\n   |                                  \
    \              ^ unclosed delimiter\n32 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpsi2tg98p.rs:24:51\n\
    \   |\n24 |     let mut spaces_count = s.chars().filter(|c| c == ' ').count();\n\
    \   |                                                   ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpsi2tg98p.rs:25:56\n\
    \   |\n25 |     let mut punctuation_count = s.chars().filter(|c| c == '.' || c\
    \ == '!' || c == '?' || c == ';' || c == ':' || c == '-' || c == '_').co...\n\
    \   |                                                        ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpsi2tg98p.rs:25:68\n\
    \   |\n25 |     let mut punctuation_count = s.chars().filter(|c| c == '.' || c\
    \ == '!' || c == '?' || c == ';' || c == ':' || c == '-' || c == '_').co...\n\
    \   |                                                                    ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&ch"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut spaces = vec![];\n    let mut non_spaces = vec![];\n    let mut non_letters\
    \ = vec![];\n    let mut non_spaces_index = -1;\n    let mut non_letters_index\
    \ = -1;\n    let mut spaces_index = -1;\n    let mut vowels_index = -1;\n    let\
    \ mut consonants_index = -1;\n    let mut non_spaces_len = s.len();\n    let mut\
    \ non_letters_len = s.len();\n    let mut spaces_len = s.len();\n    let mut vowels_len\
    \ = s.len();\n    let mut consonants_len = s.len();\n    let mut non_spaces_index\
    \ = 0;\n    let mut non_letters_index = 0;\n    let mut spaces_index = 0;\n  \
    \  let mut vowels_index = 0;\n    let mut consonants_index = 0;\n    let mut non_spaces_len\
    \ = non_spaces_len;\n    let mut non_letters_len = non_letters_len;\n    let mut\
    \ spaces_len = spaces_len;\n    let mut vowels_len = vowels_len;\n    let mut\
    \ consonants_len = consonants_len;\n    let mut non_spaces_index = 0;\n    let\
    \ mut non_letters_index = 0;\n    let mut spaces_index = 0;\n    let mut vowels_index\
    \ = 0;\n    let mut consonants_index = 0;\n    let mut non_spaces_len = non_spaces_len;\n\
    \    let mut non_letters_len = non_letters_len;\n    let mut spaces_len = spaces_len;\n\
    \    let mut vowels_len = vowels_len;\n    let mut consonants_len = consonants_len;\n\
    \    let mut non_spaces_index = 0;\n    let mut non_letters_index = 0;\n    let\
    \ mut spaces_index = 0;\n    let mut vowels_index = 0;\n    let mut consonants_index\
    \ = 0;\n    let mut non_spaces_len = non_spaces_len;\n    let mut non_letters_len\
    \ = non_letters_len;\n    let mut spaces_len = spaces_len;\n    let mut vowels_len\
    \ = vowels_len;\n    let mut consonants_len = consonants_len;\n    let mut non_spaces_index\
    \ = 0;\n    let mut non_letters_index = 0;\n    let mut spaces_index = 0;\n  \
    \  let mut vowels_index = 0;\n    let mut consonants_index = 0;\n    let mut non_spaces_len\
    \ = \n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp0kmstxfe.rs:70:1\n\
    \   |\n70 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowels_count = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp31p69ssz.rs:61:11\n   |\n\
    61 |     let mu\n   |           ^ help: add `;` here\n62 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp31p69ssz.rs:17:41\n \
    \  |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ list = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        if\
    \ s.chars().any(|c| c.is_consonant() && c != ' ') {\n            i += 1;\n   \
    \     } else {\n            list.push(s.subslice(i, i + n));\n            i +=\
    \ n;\n        }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpq3gazv_6.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpq3gazv_6.rs:24:25\n\
    \   |\n24 |             list.push(s.subslice(i, i + n));\n   |               \
    \          ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpq3gazv_6.rs:24:41\n   |\n24 |             list.push(s.subslice(i,\
    \ i + n));\n   |                                         ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmpq3gazv_6.rs:24:39\n\
    \   |\n24 |             list.push(s.subslice(i, i + n));\n   |               \
    \                        ^ no implementation for `usize + isize`\n   |\n   = help:\
    \ the trait `Add<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq3gazv_6.rs:25:18\n   |\n25 |             i += n;\n   |\
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmpq3gazv_6.rs:25:15\n   |\n25 |            \
    \ i += n;\n   |               ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `AddAssign<Rhs>`:\n        \
    \     <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n            \
    \ <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as AddAssi"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n !=\
    \ 0 {\n        if s.chars().any(|c| c != ' ') {\n            result.push(s.clone());\n\
    \        }\n        n -= 1;\n        s = s.chars().filter(|c| c != ' ').collect();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3wndl7_0.rs:26:36\n\
    \   |\n26 |         s = s.chars().filter(|c| c != ' ').collect();\n   |      \
    \                              ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ list = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = 0;\n        while j < s.len() {\n            if s[i] == s[j] {\n   \
    \             j += 1;\n            } else {\n                break;\n        \
    \    }\n        }\n        if j == n {\n            list.push(s.subslice(i, j));\n\
    \            i += j - 1;\n        }\n        i += 1;\n    }\n    list\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjaupe7g5.rs:23:16\n\
    \   |\n23 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjaupe7g5.rs:23:24\n   |\n23 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjaupe7g5.rs:29:17\n   |\n29 |         if j ==\
    \ n {\n   |                 ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n29 |         if j == n.try_into().unwrap() {\n   |              \
    \    ++++++++++++++++++++\n\nerror[E0599]: no method named `subslice` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpjaupe7g5.rs:30:25\n   |\n\
    30 |             list.push(s.subslice(i, j));\n   |                         ^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0599.\nFor more informati"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n >\
    \ 0 {\n        let mut i = 0;\n        while i < s.len() {\n            if s[i]\
    \ == ' ' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i]\
    \ == 'u' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'y' || s[i] == 'o' || s[i] == 'u' {\n                i\
    \ += 1;\n                continue;\n            }\n            if s[i] == 's'\
    \ || s[i] == 't' || s[i] == 'h' || s[i] == 'r' || s[i] == 'n' {\n            \
    \    i += 1;\n                continue;\n            }\n            if s[i] ==\
    \ 'd' || s[i] == 'f' || s[i] == 'p' || s[i] == 'v' || s[i] == 'c' || s[i] == 'm'\
    \ {\n                i += 1;\n                continue;\n            }\n     \
    \       if s[i] == 'b' || s[i] == 'j' || s[i] == 'k' || s[i] == 'q' || s[i] ==\
    \ 'x' || s[i] == 'z' {\n                i += 1;\n                continue;\n \
    \           }\n            if s[i] == 'p' || s[i] == 'j' || s[i] == 'k' || s[i]\
    \ == 'q' || s[i] == 'x' || s[i] == 'z' {\n                i += 1;\n          \
    \      continue;\n            }\n            if s[i] == 'c' || s[i] == 'm' ||\
    \ s[i] == 'p' || s[i] == 'v' || s[i] == 'z' {\n                i += 1;\n     \
    \           continue;\n            }\n            if s[i] == 'b' || s[i] == 'j'\
    \ || s[i] == 'k' || s[i] == 'q' || s[i] == 'x' || s[i] == 'z' {\n            \
    \    i += 1;\n                continue;\n            }\n            if s[i] ==\
    \ 'p' || s[i] == 'j' || s[i] == 'k' || s[i] == 'q' || s[i] == 'x' || s[i] == 'z'\
    \ {\n                i += 1;\n                continue;\n            }\n     \
    \       if s[i] == 'c' || s[i] == 'm' || s[i] == 'p' || s[i] == 'v' || s[i] ==\
    \ 'z' {\n                i += 1;\n                continue;\n            }\n \
    \           if s[i] == 'b' || s[i] == 'j' || s[i] == 'k' || s[i] == 'q' || s[i]\
    \ == 'x' || s[i] == 'z' {\n                i += 1;\n                continue;\n\
    \            }\n            if s[i] == 'p' || s[i] == 'j' || s[i] == 'k' || s[i]\
    \ == 'q' || s[i] == 'x' || s[i] == 'z' {\n                i += 1;\n          \
    \      continue;\n            }\n            if s[i] == 'c' || s[i] == 'm' ||\
    \ s[i] == 'p' || s[i] == 'v' || s[i] == 'z' {\n                i += 1;\n     \
    \           continue;\n            }\n            if s[i] == 'b' || s[i] == 'j'\
    \ || s[i] == 'k' || s[i] == 'q' || s[i] == 'x' || s[i] == 'z\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpr4npbvtu.rs:92:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n21\
    \ |     while n > 0 {\n   |                 - unclosed delimiter\n22 |       \
    \  let mut i = 0;\n23 |         while i < s.len() {\n   |                    \
    \       - this delimiter might not be properly closed...\n...\n81 | }\n   | -\
    \ ...as it matches this but it has different indentation\n...\n92 | }\n   |  \
    \ ^\n\nerror: expected `while`, `for`, `loop` or `{` after a label\n  --> /tmp/tmpr4npbvtu.rs:81:1\n\
    \   |\n81 | }\n   | ^ expected `while`, `for`, `loop` or `{` after a label\n\n\
    error: expected expression, found `}`\n  --> /tmp/tmpr4npbvtu.rs:81:1\n   |\n\
    81 | }\n   | ^ expected expression\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpr4npbvtu.rs:24:16\n   |\n24 |            \
    \ if s[i] == ' ' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpr4npbvtu.rs:28:16\n   |\n28 |             if s[i] == 'a' || s[i]\
    \ == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' {\n   |                ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<us"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut vowels_count = vec![];\n    let mut vowels_count_max = vec![];\n\
    \    let mut vowels_count_max_index = vec![];\n    let mut vowels_count_min =\
    \ vec![];\n    let mut vowels_count_min_index = vec![];\n    let mut vowels_count_min_max\
    \ = vec![];\n    let mut vowels_count_min_max_index = vec![];\n    let mut vowels_count_min_max_index\
    \ = vec![];\n    let mut vowels_count_min_max_index = vec![];\n    let mut vowels_count_min_max_index\
    \ = vec![];\n    let mut vowels_count_min_max_index = vec![];\n    let mut vowels_count_min_max_index\
    \ = vec![];\n    let mut vowels_count_min_max_index = vec![];\n    let mut vowels_count_min_max_index\
    \ = vec![];\n    let mut vowels_count_min_max_index = vec![];\n    let mut vowels_count_min_max_index\
    \ = vec![];\n    let mut vowels_count_min_max_index = vec![];\n    let mut vowels_count_min_max_index\
    \ = vec![];\n    let mut vowels_count_min_max_index = vec![];\n    let mut vowels_count_min_max_index\
    \ = vec![];\n    let mut vowels_count_min_max_index = vec![];\n    let mut vowels_count_min_max_index\
    \ = vec![];\n    let mut vowels_count_min_max_index = vec![];\n    let mut vowels_count_min_max_index\
    \ = vec![];\n    let mut vowels_count_min_max_index = vec![];\n    let mut vowels_count_min_max_index\
    \ = vec![];\n    let mut vowels_count_min_max_index = vec![];\n    let mut vowels_count_min_max_index\
    \ = vec![];\n    let mut vowels_count_min_max_index = vec![];\n    let mut vowels_count_min_max_index\
    \ = vec![];\n    let mut vowels_count_min_max_index = vec![];\n    let mut vowels_count_min_max_index\
    \ = vec![];\n    let mut vowels_count_min_max_index = vec![];\n    let mut vowels_count_min_max_index\
    \ = vec![];\n    let mut vowels_count_min_max_index = vec![];\n    let mut vowels_count_min_max_index\
    \ = vec![];\n    let mut vowels_count_min_max_index = vec![];\n    let mut vowels_count_min_max_index\
    \ = vec![];\n\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd8oha37q.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j].is_ascii_letter() {\n            j\
    \ = j + 1;\n        }\n        if j == s.len() {\n            break;\n       \
    \ }\n        let mut word = String::from(&s[i .. j]);\n        if word.chars().count(|c|\
    \ c.is_ascii_letter()) == n {\n            words.push(word);\n            i =\
    \ j;\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpaajz4qhp.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpaajz4qhp.rs:29:25\n\
    \    |\n29  |         if word.chars().count(|c| c.is_ascii_letter()) == n {\n\
    \    |                         ^^^^^ ----------------------- supplied 1 argument\n\
    \    |                         |\n    |                         expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpaajz4qhp.rs:29:59\n   |\n29 |         if word.chars().count(|c|\
    \ c.is_ascii_letter()) == n {\n   |                                          \
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    29 |         if word.chars().count(|c| c.is_ascii_letter()) == n.try_into().unwrap()\
    \ {\n   |                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0308.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    while s.len() >\
    \ 0 {\n        let mut cur = s.chars();\n        let mut i = 0;\n        while\
    \ i < n && cur.next().unwrap().is_ascii_lowercase() {\n            i += 1;\n \
    \       }\n        if i == n {\n            result.push(s.clone());\n        }\n\
    \        s = &s[..cur.next().unwrap().len()];\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp2zhn80nw.rs:29:38\n   |\n29 |         s = &s[..cur.next().unwrap().len()];\n\
    \   |                                      ^^^ method not found in `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2zhn80nw.rs:29:13\n   |\n19 |  \
    \   let mut s = String::from(s);\n   |                 --------------- expected\
    \ due to this value\n...\n29 |         s = &s[..cur.next().unwrap().len()];\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n29 |         s = (&s[..cur.next().unwrap().len()]).to_string();\n\
    \   |             +                               +++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j == i {\n            break;\n        }\n        let mut word\
    \ = String::from(&s[i .. j]);\n        let mut count = 0;\n        while j < s.len()\
    \ && s[j] == s[j].to_lowercase() {\n            count += 1;\n            j +=\
    \ 1\n        }\n        if count == n {\n            words.push(word);\n     \
    \       i += j - i;\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpri7_rpi9.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpri7_rpi9.rs:30:30\n   |\n30 |         while j < s.len() && s[j]\
    \ == s[j].to_lowercase() {\n   |                              ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpri7_rpi9.rs:30:38\n   |\n30 |         while j < s.len() && s[j]\
    \ == s[j].to_lowercase() {\n   |                                      ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \ "
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\"\
    , \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\"\
    , \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels = vec![\"a\"\
    , \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonants = vec![\"b\", \"\
    c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"\
    q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_consonant_pairs\
    \ = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    let mut vowel_consonant_triples = vec![\"b\", \"c\", \"d\", \"f\", \"\
    g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"\
    t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_consonant_quadruples\
    \ = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    let mut vowel_consonant_quintuples = vec![\"b\", \"c\", \"d\", \"f\",\
    \ \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\"\
    , \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_consonant_sextuples\
    \ = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    let mut vowel_consonant_sexintuples = vec![\"b\", \"c\", \"d\", \"f\"\
    , \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\"\
    , \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_consonant_sextuple_pairs\
    \ = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\"\
    , \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    let mut vowel_consonant_sextuple_triples = vec![\"b\", \"c\", \"d\", \"\
    f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"\
    s\", \"t\", \"v\", \"w\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpfxqkl23m.rs:40:136\n\
    \   |\n40 |       assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n   | \
    \ ________________________________________________________________________________________________________________________________________^\n\
    41 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut spaces = vec![];\n    let mut punctuation = vec![];\n    let mut\
    \ letters = vec![];\n    let mut spaces_count = s.chars().filter(|c| c == ' ').count();\n\
    \    let mut punctuation_count = s.chars().filter(|c| c == '.' || c == '!' ||\
    \ c == '?' || c == ';' || c == ':' || c == '-' || c == '_').count();\n    let\
    \ mut letters_count = s.chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' &&\
    \ c <= 'Z').count();\n    let mut spaces_count = s.chars().filter(|c| c == ' ').count();\n\
    \    let mut punctuation_count = s.chars().filter(|c| c == '.' || c == '!' ||\
    \ c == '?' || c == ';' || c == ':' || c == '-' || c == '_').count();\n    let\
    \ mut letters_count = s.chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' &&\
    \ c <= 'Z').count();\n    let mut spaces_count = s.chars().filter(|c| c == ' ').count();\n\
    \    let mut punctuation_count = s.chars().filter(|c| c == '.' || c == '!' ||\
    \ c == '?' || c == ';' || c == ':' || c == '-' || c == '_').count();\n    let\
    \ mut letters_count = s.chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' &&\
    \ c <= 'Z').count();\n    let mut spaces_count = s.chars().filter(|c| c == ' ').count();\n\
    \    let mut punctuation_count = s.chars().filter(|c| c == '.' || c == '!' ||\
    \ c == '?' || c == ';' || c == ':' || c == '-' || c == '_').count();\n    let\
    \ mut letters_count = s.chars().filter(|c| c >= 'a' && c <= 'z' || c >= 'A' &&\
    \ c <= 'Z').count();\n    let mut spaces_count = s.chars().filter(|c| c == ' ').count();\n\
    \    let mut punctuation_count = s.chars().filter(|c| c == '.' || c == '!' ||\
    \ c == '?' || c == ';' || c == ':' || c == '-' || c == '_').count\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4hvrkpw9.rs:37:141\n   |\n\
    37 |     let mut punctuation_count = s.chars().filter(|c| c == '.' || c == '!'\
    \ || c == '?' || c == ';' || c == ':' || c == '-' || c == '_').count\n   |   \
    \                                                                            \
    \                                                              ^ help: add `;`\
    \ here\n38 | }\n   | - unexpected token\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp4hvrkpw9.rs:24:51\n   |\n24 |     let mut spaces_count\
    \ = s.chars().filter(|c| c == ' ').count();\n   |                            \
    \                       ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp4hvrkpw9.rs:25:56\n   |\n25 |     let mut punctuation_count\
    \ = s.chars().filter(|c| c == '.' || c == '!' || c == '?' || c == ';' || c ==\
    \ ':' || c == '-' || c == '_').co...\n   |                                   \
    \                     ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp4hvrkpw9.rs:25:68\n   |\n25 |     let mut punctuation_count\
    \ = s.chars().filter(|c| c == '.' || c == '!' || c == '?' || c == ';' || c ==\
    \ ':' || c == '-' || c == '_').co...\n   |                                   \
    \                                 ^^ no implementation for `&char == char`\n \
    \  |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp4hvrkpw9.rs:25:80\n   |\n25 |   \
    \  let mut punctuation_count = s.chars().filter(|c| c == '.' || c == '!' || c\
    \ == '?' || c == ';' || c == ':' || c == '-' || c == '_').co...\n   |        \
    \                                                          "
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n            result.push(s.subslice(i, i + n));\n\
    \            i += n;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpanxk5ere.rs:23:32\n   |\n23 |         if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpanxk5ere.rs:24:27\n\
    \   |\n24 |             result.push(s.subslice(i, i + n));\n   |             \
    \              ^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ list = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = 0;\n        while j < s.len() {\n            if s.chars().nth(i).unwrap()\
    \ == s.chars().nth(j).unwrap() {\n                i += 1;\n                j +=\
    \ 1;\n            } else {\n                j += 1;\n            }\n        }\n\
    \        if i == n {\n            list.push(s.to_string());\n            i +=\
    \ 1;\n        }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpupd483np.rs:30:17\n   |\n\
    30 |         if i == n {\n   |                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n30 |         if i == n.try_into().unwrap() {\n   |\
    \                  ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n !=\
    \ 0 {\n        if s.chars().any(|c| c.is_consonant()) {\n            result.push(s.clone());\n\
    \        }\n        n -= 1;\n        s = s.chars().filter(|c| c.is_consonant()).collect::<String>();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp5oxkwg5w.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_consonant` found for\
    \ reference `&char` in the current scope\n  --> /tmp/tmp5oxkwg5w.rs:26:36\n  \
    \ |\n26 |         s = s.chars().filter(|c| c.is_consonant()).collect::<String>();\n\
    \   |                                    ^^^^^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowels_count = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp31p69ssz.rs:61:11\n   |\n\
    61 |     let mu\n   |           ^ help: add `;` here\n62 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp31p69ssz.rs:17:41\n \
    \  |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowel_consonant = Vec::new();\n    let mut vowel_consonant_vowel\
    \ = Vec::new();\n    let mut vowel_consonant_vowel_consonant = Vec::new();\n \
    \   let mut vowel_consonant_vowel_consonant_vowel = Vec::new();\n    let mut vowel_consonant_vowel_consonant_vowel_consonant\
    \ = Vec::new();\n    let mut vowel_consonant_vowel_consonant_vowel_consonant_vowel\
    \ = Vec::new();\n    let mut vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant\
    \ = Vec::new();\n    let mut vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel\
    \ = Vec::new();\n    let mut vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant\
    \ = Vec::new();\n    let mut vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel\
    \ = Vec::new();\n    let mut vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant\
    \ = Vec::new();\n    let mut vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel\
    \ = Vec::new();\n    let mut vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant\
    \ = Vec::new();\n    let mut vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel\
    \ = Vec::new();\n    let mut vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_vowel\
    \ = Vec::new();\n    let mut vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpp181lke0.rs:36:77\n   |\n\
    36 |     let mut vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_\n\
    \   |                                                                        \
    \     ^ help: add `;` here\n37 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp181lke0.rs:17:41\n   |\n17 | fn select_words(s: String,\
    \ n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        let mut word = String::from(&s[i .. j]);\n        let mut count\
    \ = 0;\n        while j < s.len() && s[j] == s[j].to_lowercase() {\n         \
    \   count += 1;\n            j += 1\n        }\n        if count == n {\n    \
    \        words.push(word);\n            i += j - i;\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbheresw5.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpbheresw5.rs:27:30\n   |\n27 |         while j < s.len() && s[j]\
    \ == s[j].to_lowercase() {\n   |                              ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpbheresw5.rs:27:38\n   |\n27 |         while j < s.len() && s[j]\
    \ == s[j].to_lowercase() {\n   |                                      ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \ "
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n\
    \        while j < s.len() && s.chars().any(|c| c == ' ') {\n            j +=\
    \ 1\n        }\n        if j == i {\n            result.push(s.clone());\n   \
    \         i += 1;\n        } else {\n            let mut k = i;\n            while\
    \ k < j {\n                if s.chars().any(|c| c != ' ' && c != s.chars().nth(k))\
    \ {\n                    break;\n                }\n                k += 1\n \
    \           }\n            if k == i {\n                result.push(s.clone());\n\
    \                i += 1;\n            } else {\n                let mut k = i;\n\
    \                while k < j {\n                    if s.chars().any(|c| c !=\
    \ ' ' && c != s.chars().nth(k)) {\n                        break;\n          \
    \          }\n                    k += 1\n                }\n                result.push(s.clone());\n\
    \                i += 1;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpubofob2v.rs:33:55\n   |\n\
    33 |                 if s.chars().any(|c| c != ' ' && c != s.chars().nth(k)) {\n\
    \   |                                                       ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpubofob2v.rs:44:59\n\
    \   |\n44 |                     if s.chars().any(|c| c != ' ' && c != s.chars().nth(k))\
    \ {\n   |                                                           ^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == s[i] {\n            j += 1\n  \
    \      }\n        if j - i == n {\n            words.push(s.subslice(i, j));\n\
    \            i += j - i;\n        }\n    }\n    words\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcqedi052.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == s[i] {\n   |                \
    \              ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpcqedi052.rs:22:38\n   |\n22 |         while j < s.len() && s[j]\
    \ == s[i] {\n   |                                      ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcqedi052.rs:25:21\n\
    \   |\n25 |         if j - i == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0599]: no method\
    \ named `subslice` found for struct `String` in the current scope\n  --> /tmp/tmpcqedi052.rs:26:26\n\
    \   |\n26 |             words.push(s.subslice(i, j));\n   |                  \
    \        ^^^^^^^^ method not found in `String`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome "
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > n {\n        let mut\
    \ i = s.find('a', s.len());\n        if i == s.len() {\n            return result;\n\
    \        }\n        let mut j = i;\n        while j < s.len() {\n            if\
    \ s[j] != 'a' && s[j] != 'e' && s[j] != 'i' && s[j] != 'o' && s[j] != 'u' {\n\
    \                break;\n            }\n            j = j + 1;\n        }\n  \
    \      let mut k = i;\n        while k < s.len() {\n            if s[k] == 'a'\
    \ || s[k] == 'e' || s[k] == 'i' || s[k] == 'o' || s[k] == 'u' {\n            \
    \    break;\n            }\n            k = k + 1;\n        }\n        result.push(s.split_at(k).collect::<Vec<_>>());\n\
    \        s = &s[k..];\n    }\n    result.push(s.split_at(n).collect::<Vec<_>>());\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxg0d3929.rs:20:21\n   |\n\
    20 |     while s.len() > n {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     while s.len() > n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpxg0d3929.rs:21:23\n\
    \     |\n21   |         let mut i = s.find('a', s.len());\n     |            \
    \           ^^^^ ---  ------- supplied 2 arguments\n     |                   \
    \    |\n     |                       expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxg0d3929.rs:22:17\n\
    \   |\n22 |         if i == s.len() {\n   |                 ^^^^^^^ expected enum\
    \ `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n  \
    \            found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n22 |         if i == Some(s.len()) {\n   |                 +++++      \
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxg0d3929.rs:26:19\n   |\n\
    26 |         while j < s.len() {\n   |                   ^^^^^^^ expected enum\
    \ `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n  \
    \            found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n26 |         while j < Some(s.len()) {\n   |                   +++++  \
    \     +\n\nerror[E0277]: the type `String` cannot be indexed by `Option<usize>`\n\
    \  --> /tmp/tmpxg0d3929.rs:27:16\n   |\n27 |             if s[j] != 'a' && s[j]\
    \ != 'e' && s[j] != 'i' && s[j] != 'o' && s[j] != 'u' {\n   |                ^^^^\
    \ `String` cannot be indexed by `Option<usize>`\n   |\n   = help: the trait `Index<Option<usize>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Inde"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j - i == n {\n            words.push(s.split_whitespace()[i]);\n\
    \            i += j - i;\n        }\n        else {\n            i += 1;\n   \
    \     }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4vd8a6yu.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4vd8a6yu.rs:25:21\n\
    \   |\n25 |         if j - i == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0608]: cannot index\
    \ into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmp4vd8a6yu.rs:26:24\n\
    \   |\n26 |             words.push(s.split_whitespace()[i]);\n   |           \
    \             ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowel_consonants = Vec::new();\n    let mut vowel_consonant_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels = Vec::new();\n   \
    \ let mut vowel_consonant_vowels_vowels_vowels = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut \n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpi9ootj5y.rs:39:1\n\
    \   |\n39 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowel_consonants = Vec::new();\n    let mut vowel_consonant_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels = Vec::new();\n   \
    \ let mut vowel_consonant_vowels_consonants = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_vowels_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_consonants_vowels_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_consonants_vowels_consonants_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_consonants_vowels_consonants_consonants_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_conson\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8hhepiby.rs:35:104\n   |\n\
    35 |     let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_conson\n\
    \   |                                                                        \
    \                                ^ help: add `;` here\n36 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8hhepiby.rs:17:41\n \
    \  |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut current_word = String::from(\"\");\n    let\
    \ mut current_word_len = 0;\n    let mut current_word_index = 0;\n    let mut\
    \ current_word_is_consonant = false;\n    for c in s.chars() {\n        if c.is_whitespace()\
    \ {\n            if current_word_is_consonant {\n                result.push(current_word);\n\
    \                current_word = String::from(\"\");\n                current_word_len\
    \ = 0;\n                current_word_index = 0;\n                current_word_is_consonant\
    \ = false;\n            }\n        } else {\n            if current_word_is_consonant\
    \ {\n                current_word += c;\n                current_word_len += 1;\n\
    \            } else {\n                if current_word_len == n {\n          \
    \          result.push(current_word);\n                    current_word = String::from(\"\
    \");\n                    current_word_len = 0;\n                    current_word_index\
    \ = 0;\n                    current_word_is_consonant = false;\n             \
    \   } else {\n                    current_word += c;\n                    current_word_len\
    \ += 1;\n                }\n            }\n        }\n    }\n    if current_word_is_consonant\
    \ {\n        result.push(current_word);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpquzqvoag.rs:34:33\n   |\n\
    34 |                 current_word += c;\n   |                                \
    \ ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpquzqvoag.rs:44:37\n\
    \   |\n44 |                     current_word += c;\n   |                     \
    \                ^ expected `&str`, found `char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    while s.len() >\
    \ 0 {\n        let mut i = 0;\n        let mut j = s.len();\n        while i <\
    \ j {\n            if s[i] == ' ' {\n                i += 1;\n               \
    \ j -= 1;\n            } else {\n                i += 1;\n            }\n    \
    \    }\n        if i == n {\n            result.push(s.clone());\n        }\n\
    \        s = &s[..i];\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_16u5v3u.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_16u5v3u.rs:31:17\n\
    \   |\n31 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n31 |         if i == n.try_into().unwrap()\
    \ {\n   |                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_16u5v3u.rs:34:13\n   |\n19 |     let mut s = String::from(s);\n\
    \   |                 --------------- expected due to this value\n...\n34 |  \
    \       s = &s[..i];\n   |             ^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n34 |         s = (&s[..i]).to_string();\n\
    \   |             +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s.chars().all(|c| c == s.chars().nth(j))\
    \ {\n            j += 1\n        }\n        if j - i == n {\n            words.push(s.chars().take(i).collect::<String>());\n\
    \            i += n - 1;\n        }\n    }\n    words\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy13ycort.rs:22:53\n   |\n\
    22 |         while j < s.len() && s.chars().all(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy13ycort.rs:25:21\n\
    \   |\n25 |         if j - i == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpy13ycort.rs:27:18\n   |\n27 |             i += n - 1;\n\
    \   |                  ^^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add-assign `isize` to `usize`\n  --> /tmp/tmpy13ycort.rs:27:15\n   |\n\
    27 |             i += n - 1;\n   |               ^^ no implementation for `usize\
    \ += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n !=\
    \ 0 {\n        if s.chars().any(|c| c.is_consonant()) {\n            result.push(s);\n\
    \        }\n        n -= 1;\n        s = s.chars().take_while(|c| !c.is_consonant()).collect();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpk_tx3a05.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_consonant` found for\
    \ reference `&char` in the current scope\n  --> /tmp/tmpk_tx3a05.rs:26:41\n  \
    \ |\n26 |         s = s.chars().take_while(|c| !c.is_consonant()).collect();\n\
    \   |                                         ^^^^^^^^^^^^ method not found in\
    \ `&char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] != ' ' {\n            j = j + 1;\n\
    \        }\n        if j == i {\n            i += 1;\n            continue;\n\
    \        }\n        let mut k = i;\n        while k < j {\n            if s[k]\
    \ == ' ' {\n                k = k + 1;\n                continue;\n          \
    \  }\n            if s[k] == 'a' || s[k] == 'e' || s[k] == 'i' || s[k] == 'o'\
    \ || s[k] == 'u' {\n                k = k + 1;\n                continue;\n  \
    \          }\n            if s[k] == 'y' || s[k] == 's' || s[k] == 'h' || s[k]\
    \ == 'd' || s[k] == 'r' || s[k] == 'n' {\n                k = k + 1;\n       \
    \         continue;\n            }\n            if s[k] == 'c' || s[k] == 'k'\
    \ || s[k] == 'm' || s[k] == 'b' || s[k] == 'j' || s[k] == 'x' {\n            \
    \    k = k + 1;\n                continue;\n            }\n            if s[k]\
    \ == 'w' || s[k] == 'f' || s[k] == 'v' || s[k] == 'z' || s[k] == 'p' || s[k] ==\
    \ 'q' || s[k] == 'j' {\n                k = k + 1;\n                continue;\n\
    \            }\n            if s[k] == 'p' || s[k] == 'b' || s[k] == 'j' || s[k]\
    \ == 'x' || s[k] == 'z' || s[k] == 'f' || s[k] == 'w' {\n                k = k\
    \ + 1;\n                continue;\n            }\n            if s[k] == 'q' ||\
    \ s[k] == 'p' || s[k] == 'j' || s[k] == 'x' || s[k] == 'z' || s[k] == 'f' || s[k]\
    \ == 'w' {\n                k = k + 1;\n                continue;\n          \
    \  }\n            if s[k] == 'q' || s[k] == 'p' || s[k] == 'j' || s[k] == 'x'\
    \ || s[k] == 'z' || s[k] == 'f' || s[k] == 'w' {\n                k = k + 1;\n\
    \                continue;\n            }\n            if s[k] == 'q' || s[k]\
    \ == 'p' || s[k] == 'j' || s[k] == 'x' || s[k] == 'z' || s[k] == 'f' || s[k] ==\
    \ 'w' {\n                k = k + 1;\n                continue;\n            }\n\
    \            if s[k] == 'q' || s[k] == 'p' || s[k] == 'j' || s[k] == 'x' || s[k]\
    \ == 'z' || s[k] == 'f' || s[k] == 'w' {\n                k = k + 1;\n       \
    \         continue;\n            }\n            if s[k] == 'q' || s[k] == 'p'\
    \ || s[k] == 'j' || s[k] == 'x' || s[k] == 'z' || s[k] == 'f' || s[k] == 'w' {\n\
    \                k = k + 1;\n                continue;\n            }\n      \
    \      if s[k] == 'q' || s[k] == 'p' || s[k] == 'j' || s[k] == 'x' || s[k] ==\
    \ 'z' || s[k] == 'f' || s[k] == 'w' {\n                \n}\n\nfn main() {\n  \
    \  let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpc0gjrkgu.rs:88:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n20\
    \ |     while i < s.len() {\n   |                       - unclosed delimiter\n\
    ...\n30 |         while k < j {\n   |                     - unclosed delimiter\n\
    ...\n75 |             if s[k] == 'q' || s[k] == 'p' || s[k] == 'j' || s[k] ==\
    \ 'x' || s[k] == 'z' || s[k] == 'f' || s[k] == 'w' {\n   |                   \
    \                                                                            \
    \                       - this delimiter might not be properly closed...\n76 |\
    \                 \n77 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n88 | }\n   |   ^\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpc0gjrkgu.rs:22:30\n   |\n22 |         while\
    \ j < s.len() && s[j] != ' ' {\n   |                              ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpc0gjrkgu.rs:31:16\n   |\n31 |             if s[k] == ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<Ran"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut current_word = String::from(\"\");\n    let\
    \ mut current_word_len = 0;\n    let mut current_word_index = 0;\n    let mut\
    \ current_word_is_consonant = false;\n    let mut current_word_is_vowel = false;\n\
    \    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_space = false;\n    let mut current_word_is_space\
    \ = false;\n    let mut current_word_is_\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4k4wqom6.rs:74:29\n   |\n\
    74 |     let mut current_word_is_\n   |                             ^ help: add\
    \ `;` here\n75 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4k4wqom6.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowel_counter = 0;\n    let mut vowel_counter2 =\
    \ 0;\n    let mut vowel_counter3 = 0;\n    let mut vowel_counter4 = 0;\n    let\
    \ mut vowel_counter5 = 0;\n    let mut vowel_counter6 = 0;\n    let mut vowel_counter7\
    \ = 0;\n    let mut vowel_counter8 = 0;\n    let mut vowel_counter9 = 0;\n   \
    \ let mut vowel_counter10 = 0;\n    let mut vowel_counter11 = 0;\n    let mut\
    \ vowel_counter12 = 0;\n    let mut vowel_counter13 = 0;\n    let mut vowel_counter14\
    \ = 0;\n    let mut vowel_counter15 = 0;\n    let mut vowel_counter16 = 0;\n \
    \   let mut vowel_counter17 = 0;\n    let mut vowel_counter18 = 0;\n    let mut\
    \ vowel_counter19 = 0;\n    let mut vowel_counter20 = 0;\n    let mut vowel_counter21\
    \ = 0;\n    let mut vowel_counter22 = 0;\n    let mut vowel_counter23 = 0;\n \
    \   let mut vowel_counter24 = 0;\n    let mut vowel_counter25 = 0;\n    let mut\
    \ vowel_counter26 = 0;\n    let mut vowel_counter27 = 0;\n    let mut vowel_counter28\
    \ = 0;\n    let mut vowel_counter29 = 0;\n    let mut vowel_counter30 = 0;\n \
    \   let mut vowel_counter31 = 0;\n    let mut vowel_counter32 = 0;\n    let mut\
    \ vowel_counter33 = 0;\n    let mut vowel_counter34 = 0;\n    let mut vowel_counter35\
    \ = 0;\n    let mut vowel_counter36 = 0;\n    let mut vowel_counter37 = 0;\n \
    \   let mut vowel_counter38 = 0;\n    let mut vowel_counter39 = 0;\n    let mut\
    \ vowel_counter40 = 0;\n    let mut vowel_counter41 = 0;\n    let mut vowel_counter42\
    \ = 0;\n    let mut vowel_counter43 = 0;\n    let mut vowel_counter44 = 0;\n \
    \   let mut vowel_counter45 = 0;\n    let mut vowel_counter46 = 0;\n    let mut\
    \ vowel_counter47 = 0;\n    let mut vowel_counter48 = 0;\n    let mut vowel_counter49\
    \ = 0;\n    let mut vowel_counter50 = 0;\n    let mut vowel_counter51 = 0;\n \
    \   let mut vowel_counter52 = 0;\n    let mut vowel_counter53 = 0;\n    let mut\
    \ vowel_counter54 = 0;\n\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphooo0zh3.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    while n != 0 {\n        if s.contains(&consonants[n % consonants.len()])\
    \ {\n            result.push(s.clone());\n        }\n        n /= consonants.len();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `consonants` in this scope\n  --> /tmp/tmpnvyr62mg.rs:22:24\n\
    \   |\n22 |         if s.contains(&consonants[n % consonants.len()]) {\n   | \
    \                       ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `consonants` in this scope\n  --> /tmp/tmpnvyr62mg.rs:22:39\n   |\n\
    22 |         if s.contains(&consonants[n % consonants.len()]) {\n   |        \
    \                               ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `consonants` in this scope\n  --> /tmp/tmpnvyr62mg.rs:25:14\n\
    \   |\n25 |         n /= consonants.len();\n   |              ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n\
    \        while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n   \
    \         j += 1\n        }\n        if j == i {\n            result.push(s.clone());\n\
    \            i += 1;\n        } else {\n            result.push(s.clone());\n\
    \            i += j - i;\n        }\n        if i == n {\n            break;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpat_5rp_v.rs:24:53\n   |\n\
    24 |         while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n >\
    \ 0 {\n        if s.chars().any(|c| c.is_consonant()) {\n            result.push(s.clone());\n\
    \            n -= 1;\n        }\n        else {\n            s.next();\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpyr63kqeg.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `next` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpyr63kqeg.rs:27:15\n   |\n27 | \
    \            s.next();\n   |               ^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n !=\
    \ 0 {\n        if s.chars().any(|c| c.is_consonant()) {\n            result.push(s.clone());\n\
    \        }\n        n -= 1;\n        s = s.chars().filter(|c| !c.is_consonant()).collect();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpbpd4ed40.rs:22:32\n   |\n22 |         if s.chars().any(|c|\
    \ c.is_consonant()) {\n   |                                ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_consonant` found for\
    \ reference `&char` in the current scope\n  --> /tmp/tmpbpd4ed40.rs:26:37\n  \
    \ |\n26 |         s = s.chars().filter(|c| !c.is_consonant()).collect();\n   |\
    \                                     ^^^^^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] != ' ' {\n            j = j + 1;\n\
    \        }\n        if j == i {\n            break;\n        }\n        let mut\
    \ word = String::from(&s[i .. j]);\n        let mut count = 0;\n        while\
    \ j < s.len() && s[j] == ' ' {\n            j = j + 1;\n            count = count\
    \ + 1;\n        }\n        if count == n {\n            words.push(word);\n  \
    \      }\n        i = j;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmph8z9bcyf.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] != ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmph8z9bcyf.rs:30:30\n   |\n30 |         while j < s.len() && s[j]\
    \ == ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut spaces = vec![];\n    let mut punctuation = vec![];\n    let mut\
    \ letters = vec![];\n    let mut numbers = vec![];\n    let mut spaces_count =\
    \ vec![];\n    let mut punctuation_count = vec![];\n    let mut letters_count\
    \ = vec![];\n    let mut numbers_count = vec![];\n    let mut spaces_count_max\
    \ = vec![];\n    let mut punctuation_count_max = vec![];\n    let mut letters_count_max\
    \ = vec![];\n    let mut numbers_count_max = vec![];\n    let mut spaces_count_min\
    \ = vec![];\n    let mut punctuation_count_min = vec![];\n    let mut letters_count_min\
    \ = vec![];\n    let mut numbers_count_min = vec![];\n    let mut spaces_count_avg\
    \ = vec![];\n    let mut punctuation_count_avg = vec![];\n    let mut letters_count_avg\
    \ = vec![];\n    let mut numbers_count_avg = vec![];\n    let mut spaces_count_min\
    \ = vec![];\n    let mut punctuation_count_min = vec![];\n    let mut letters_count_min\
    \ = vec![];\n    let mut numbers_count_min = vec![];\n    let mut spaces_count_max\
    \ = vec![];\n    let mut punctuation_count_max = vec![];\n    let mut letters_count_max\
    \ = vec![];\n    let mut numbers_count_max = vec![];\n    let mut spaces_count_min\
    \ = vec![];\n    let mut punctuation_count_min = vec![];\n    let mut letters_count_min\
    \ = vec![];\n    let mut numbers_count_min = vec![];\n    let mut spaces_count_avg\
    \ = vec![];\n    let mut punctuation_count_avg = vec![];\n    let mut letters_count_avg\
    \ = vec![];\n    let mut numbers_count_avg = vec![];\n    let mut spaces_count_min\
    \ = vec![];\n    let mut punctuation_count_min = vec![];\n    let mut letters_count_min\
    \ = vec![];\n    let mut numbers_count_min = vec![];\n    let mut spaces_count_max\
    \ = vec![];\n    let mut punctuation_count_max = vec![];\n    let mut letters_count_max\
    \ = vec![];\n    let mut numbers_count_max = vec![];\n    let mut space\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuyagsymq.rs:65:18\n   |\n\
    65 |     let mut space\n   |                  ^ help: add `;` here\n66 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuyagsymq.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    while s.len() > 0 {\n        let\
    \ mut i = 0;\n        while i < s.len() && s.chars().any(|c| c.is_consonant())\
    \ {\n            i += 1;\n        }\n        if i == s.len() {\n            result.push(s);\n\
    \            break;\n        }\n        let mut j = i;\n        while j < s.len()\
    \ && s.chars().any(|c| !c.is_consonant()) {\n            j += 1;\n        }\n\
    \        if j == s.len() {\n            result.push(s.clone());\n            break;\n\
    \        }\n        let mut k = j;\n        while k < s.len() && s.chars().all(|c|\
    \ !c.is_consonant()) {\n            k += 1;\n        }\n        if k == s.len()\
    \ {\n            result.push(s.clone());\n            break;\n        }\n    \
    \    let mut l = k;\n        while l < s.len() && s.chars().all(|c| c.is_consonant())\
    \ {\n            l += 1;\n        }\n        if l == s.len() {\n            result.push(s.clone());\n\
    \            break;\n        }\n        let mut m = l;\n        while m < s.len()\
    \ && s.chars().any(|c| !c.is_consonant()) {\n            m += 1;\n        }\n\
    \        if m == s.len() {\n            result.push(s.clone());\n            break;\n\
    \        }\n        let mut n = m;\n        while n < s.len() && s.chars().all(|c|\
    \ c.is_consonant()) {\n            n += 1;\n        }\n        if n == s.len()\
    \ {\n            result.push(s.clone());\n            break;\n        }\n    \
    \    let mut o = n;\n        while o < s.len() && s.chars().any(|c| c.is_consonant())\
    \ {\n            o += 1;\n        }\n        if o == s.len() {\n            result.push(s.clone());\n\
    \            break;\n        }\n        let mut p = o;\n        while p < s.len()\
    \ && s.chars().all(|c| c.is_consonant()) {\n            p += 1;\n        }\n \
    \       if p == s.len() {\n            result.push(s.clone());\n            break;\n\
    \        }\n        let mut q = p;\n        while q < s.len() && s.chars().any(|c|\
    \ !c.is_consonant()) {\n            q += 1;\n        }\n        if q == s.len()\
    \ {\n            result.push(s.clone());\n            break;\n        }\n    \
    \    let mut r = q;\n        while r < s.len() && s.chars().all(|c| c.is_consonant())\
    \ {\n            r += 1;\n        }\n        if r == s.len() {\n            result.push(s.clone());\n\
    \            break;\n        }\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdui_f9no.rs:112:3\n\
    \    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while s.len() > 0 {\n    |                       - this delimiter might\
    \ not be properly closed...\n...\n101 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n112 | }\n    |   ^\n\nerror[E0599]: no method\
    \ named `is_consonant` found for type `char` in the current scope\n  --> /tmp/tmpdui_f9no.rs:22:50\n\
    \   |\n22 |         while i < s.len() && s.chars().any(|c| c.is_consonant()) {\n\
    \   |                                                  ^^^^^^^^^^^^ method not\
    \ found in `char`\n\nerror[E0599]: no method named `is_consonant` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpdui_f9no.rs:30:51\n   |\n30 |   \
    \      while j < s.len() && s.chars().any(|c| !c.is_consonant()) {\n   |     \
    \                                              ^^^^^^^^^^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `is_consonant` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpdui_f9no.rs:38:51\n   |\n38 |         while\
    \ k < s.len() && s.chars().all(|c| !c.is_consonant()) {\n   |                \
    \                                   ^^^^^^^^^^^^ method not found in `char`\n\n\
    error[E0599]: no method named `is_consonant` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpdui_f9no.rs:46:50\n   |\n46 |         while l < s.len()\
    \ && s.chars().all(|c| c.is_consonant()) {\n   |                             \
    \                     ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `is_consonant` found for type `char` in the current scope\n\
    \  --> /tmp/tmpdui_f9no.rs:54:51\n   |\n54 |         while m < s.len() && s.chars().any(|c|\
    \ !c.is_consonant()) {\n   |                                                 \
    \  ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method named `is_consonant`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpdui_f9no.rs:62:50\n\
    \   |\n62 |         while n <"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    while n > 0 {\n        let mut i = 0;\n        while i < s.len()\
    \ {\n            if s.chars().any(|c| c.is_uppercase() && c.is_ascii_letter())\
    \ {\n                i += 1;\n            } else {\n                break;\n \
    \           }\n        }\n        if i == s.len() {\n            break;\n    \
    \    }\n        let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c.is_lowercase() && c.is_ascii_letter()) {\n                j += 1;\n      \
    \      } else {\n                break;\n            }\n        }\n        if\
    \ j == s.len() {\n            break;\n        }\n        let mut k = j;\n    \
    \    while k < s.len() {\n            if s.chars().any(|c| c.is_ascii_letter())\
    \ {\n                k += 1;\n            } else {\n                break;\n \
    \           }\n        }\n        if k == s.len() {\n            break;\n    \
    \    }\n        let mut c = s.chars().nth(k).unwrap();\n        if c.is_uppercase()\
    \ && c.is_ascii_letter() {\n            result.push(s.chars().nth(i).unwrap());\n\
    \            n -= 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpff771g7q.rs:24:56\n   |\n24 |             if\
    \ s.chars().any(|c| c.is_uppercase() && c.is_ascii_letter()) {\n   |         \
    \                                               ^^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `is_ascii`\n\nerror[E0599]: no method\
    \ named `is_ascii_letter` found for type `char` in the current scope\n  --> /tmp/tmpff771g7q.rs:35:56\n\
    \   |\n35 |             if s.chars().any(|c| c.is_lowercase() && c.is_ascii_letter())\
    \ {\n   |                                                        ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for type `char` in the current scope\n\
    \  --> /tmp/tmpff771g7q.rs:46:36\n   |\n46 |             if s.chars().any(|c|\
    \ c.is_ascii_letter()) {\n   |                                    ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for type `char` in the current scope\n\
    \  --> /tmp/tmpff771g7q.rs:56:34\n   |\n56 |         if c.is_uppercase() && c.is_ascii_letter()\
    \ {\n   |                                  ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpff771g7q.rs:61:5\n   |\n17 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n61 |     result\n   |     ^^^^^^\
    \ expected struct `String`, found `char`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<char>`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s.chars().any(|c| c == s.chars().nth(j))\
    \ {\n            j += 1\n        }\n        if j == i {\n            break;\n\
    \        }\n        let mut word = s.to_string();\n        word.truncate(j);\n\
    \        word.push_str(&s.chars().nth(i).unwrap());\n        words.push(word);\n\
    \        i = j;\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjg_buwqy.rs:22:53\n   |\n\
    22 |         while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjg_buwqy.rs:30:23\n\
    \   |\n30 |         word.push_str(&s.chars().nth(i).unwrap());\n   |         \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowel_consonants = Vec::new();\n    let mut vowel_consonant_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels = Vec::new();\n   \
    \ let mut vowel_consonant_vowels_vowels_vowels = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut \n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpi9ootj5y.rs:39:1\n\
    \   |\n39 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ list = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = 0;\n        while j < s.len() {\n            if s.chars().nth(i).unwrap()\
    \ == s.chars().nth(j).unwrap() {\n                j += 1;\n            } else\
    \ {\n                break;\n            }\n        }\n        if j == n {\n \
    \           list.push(s.chars().nth(i).unwrap());\n            i += 1;\n     \
    \   }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6jbqqdfh.rs:29:17\n   |\n\
    29 |         if j == n {\n   |                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n29 |         if j == n.try_into().unwrap() {\n   |\
    \                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp6jbqqdfh.rs:34:5\n   |\n17 | fn select_words(s: String, n: isize) ->\
    \ Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n34 |     list\n   |     ^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<char>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n >\
    \ 0 {\n        let mut i = 0;\n        while i < s.len() {\n            if s[i]\
    \ == ' ' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i]\
    \ == 'u' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'y' || s[i] == 'o' || s[i] == 'u' {\n                i\
    \ += 1;\n                continue;\n            }\n            if s[i] == 'h'\
    \ || s[i] == 'l' || s[i] == 'o' || s[i] == 'r' || s[i] == 'u' {\n            \
    \    i += 1;\n                continue;\n            }\n            if s[i] ==\
    \ 'd' || s[i] == 'e' || s[i] == 'l' || s[i] == 'l' || s[i] == 'o' || s[i] == 'r'\
    \ || s[i] == 'u' {\n                i += 1;\n                continue;\n     \
    \       }\n            if s[i] == 'c' || s[i] == 'h' || s[i] == 'l' || s[i] ==\
    \ 'o' || s[i] == 'r' || s[i] == 'u' {\n                i += 1;\n             \
    \   continue;\n            }\n            if s[i] == 'b' || s[i] == 'e' || s[i]\
    \ == 'l' || s[i] == 'l' || s[i] == 'o' || s[i] == 'r' || s[i] == 'u' {\n     \
    \           i += 1;\n                continue;\n            }\n            if\
    \ s[i] == 'f' || s[i] == 'o' || s[i] == 'r' || s[i] == 'u' {\n               \
    \ i += 1;\n                continue;\n            }\n            if s[i] == 'p'\
    \ || s[i] == 'r' || s[i] == 'u' {\n                i += 1;\n                continue;\n\
    \            }\n            if s[i] == 'm' || s[i] == 'a' || s[i] == 'l' || s[i]\
    \ == 'l' || s[i] == 'o' || s[i] == 'r' || s[i] == 'u' {\n                i +=\
    \ 1;\n                continue;\n            }\n            if s[i] == 's' ||\
    \ s[i] == 'p' || s[i] == 'u' {\n                i += 1;\n                continue;\n\
    \            }\n            if s[i] == 't' || s[i] == 'h' || s[i] == 'e' || s[i]\
    \ == 'r' || s[i] == 'u' {\n                i += 1;\n                continue;\n\
    \            }\n            if s[i] == 'w' || s[i] == 'o' || s[i] == 'r' || s[i]\
    \ == 'u' {\n                i += 1;\n                continue;\n            }\n\
    \            if s[i] == 'v' || s[i] == 'e' || s[i] == 'r' || s[i] == 'u' {\n \
    \               i += 1;\n                continue;\n            }\n          \
    \  if s[i] == 'x' || s[i] == 'e' || s[i] == 'r' || s[i] == 'u' {\n           \
    \     i += 1;\n                continue;\n            }\n            if s[i] ==\
    \ 'z' || s[i] == 'e' || s[i] == 'r' || s[i] == 'u' {\n                i += 1;\n\
    \                continue\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpg09qbrqy.rs:98:3\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n21\
    \ |     while n > 0 {\n   |                 - unclosed delimiter\n22 |       \
    \  let mut i = 0;\n23 |         while i < s.len() {\n   |                    \
    \       - unclosed delimiter\n...\n84 |             if s[i] == 'z' || s[i] ==\
    \ 'e' || s[i] == 'r' || s[i] == 'u' {\n   |                                  \
    \                                       - this delimiter might not be properly\
    \ closed...\n...\n87 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n98 | }\n   |   ^\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpg09qbrqy.rs:24:16\n   |\n24 |             if s[i] ==\
    \ ' ' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpg09qbrqy.rs:28:16\n\
    \   |\n28 |             if s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] ==\
    \ 'o' || s[i] == 'u' {\n   |                ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    while s.len() >\
    \ 0 {\n        let mut i = 0;\n        let mut j = s.len();\n        while i <\
    \ j {\n            if s[i] == ' ' {\n                i += 1;\n               \
    \ j -= 1;\n            } else {\n                i += 1;\n            }\n    \
    \    }\n        if i == n {\n            result.push(s.clone());\n        }\n\
    \        s = &s[i..];\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpz_8_mgix.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz_8_mgix.rs:31:17\n\
    \   |\n31 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n31 |         if i == n.try_into().unwrap()\
    \ {\n   |                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpz_8_mgix.rs:34:13\n   |\n19 |     let mut s = String::from(s);\n\
    \   |                 --------------- expected due to this value\n...\n34 |  \
    \       s = &s[i..];\n   |             ^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n34 |         s = (&s[i..]).to_string();\n\
    \   |             +       +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut vowels = vec![\"a\", \"e\", \"i\", \"o\", \"u\"\
    ];\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"];\n    let mut spaces = vec![\" \"];\n    let mut punctuation\
    \ = vec![\".\", \"!\", \"?\"];\n    let mut letters = vec![\"a\", \"b\", \"c\"\
    , \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"\
    , \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\"];\n    let mut numbers = vec![\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"\
    , \"6\", \"7\", \"8\", \"9\"];\n    let mut symbols = vec![\"!\", \"@\", \"#\"\
    , \"$\", \"%\", \"^\", \"&\", \"*\", \"(\", \")\", \"_\", \"=\", \"+\", \"<\"\
    , \">\", \"{\", \"}\", \"[\", \"]\", \"|\", \";\", \":\", \"?\"];\n    let mut\
    \ punctuation_symbols = vec![\".\", \"!\", \"?\"];\n    let mut punctuation_symbols_count\
    \ = vec![0];\n    let mut punctuation_symbols_count_max = vec![0];\n    let mut\
    \ punctuation_symbols_count_min = vec![0];\n    let mut punctuation_symbols_count_max_index\
    \ = vec![0];\n    let mut punctuation_symbols_count_min_index = vec![0];\n   \
    \ let mut punctuation_symbols_count_max_value = vec![0];\n    let mut punctuation_symbols_count_min_value\
    \ = vec![0];\n    let mut punctuation_symbols_count_max_index = vec![0];\n   \
    \ let mut punctuation_symbols_count_min_index = vec![0];\n    let mut punctuation_symbols_count_max_value\
    \ = vec![0];\n    let mut punctuation_symbols_count_min_value = vec![0];\n   \
    \ let mut punctuation_symbols_count_max_index = vec![0];\n    let mut punctuation_symbols_count_min_index\
    \ = vec![0];\n    let mut punctuation_symbols_count_max_value = vec![0];\n   \
    \ let mut punctuation_symbols_count_min_value = vec![0];\n    let mut punctuation_symbols_count_max_index\
    \ = vec![0];\n    let mut punctuation_symbols_count_min_index = vec![0];\n   \
    \ let mut punctuation_symbols_count_max_value = vec![0];\n    let mut punctuation_symbols_count_min_value\
    \ = vec![0];\n    let mut punctuation_symbol\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1lctrknc.rs:46:31\n   |\n\
    46 |     let mut punctuation_symbol\n   |                               ^ help:\
    \ add `;` here\n47 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1lctrknc.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowels_count = Vec::new();\n    let mut vowels_count_max\
    \ = Vec::new();\n    let mut vowels_count_min = Vec::new();\n    let mut vowels_count_max_index\
    \ = Vec::new();\n    let mut vowels_count_min_index = Vec::new();\n    let mut\
    \ vowels_count_max_value = Vec::new();\n    let mut vowels_count_min_value = Vec::new();\n\
    \    let mut vowels_count_max_index = Vec::new();\n    let mut vowels_count_min_index\
    \ = Vec::new();\n    let mut vowels_count_max_value = Vec::new();\n    let mut\
    \ vowels_count_min_value = Vec::new();\n    let mut vowels_count_max_index = Vec::new();\n\
    \    let mut vowels_count_min_index = Vec::new();\n    let mut vowels_count_max_value\
    \ = Vec::new();\n    let mut vowels_count_min_value = Vec::new();\n    let mut\
    \ vowels_count_max_index = Vec::new();\n    let mut vowels_count_min_index = Vec::new();\n\
    \    let mut vowels_count_max_value = Vec::new();\n    let mut vowels_count_min_value\
    \ = Vec::new();\n    let mut vowels_count_max_index = Vec::new();\n    let mut\
    \ vowels_count_min_index = Vec::new();\n    let mut vowels_count_max_value = Vec::new();\n\
    \    let mut vowels_count_min_value = Vec::new();\n    let mut vowels_count_max_index\
    \ = Vec::new();\n    let mut vowels_count_min_index = Vec::new();\n    let mut\
    \ vowels_count_max_value = Vec::new();\n    let mut vowels_count_min_value = Vec::new();\n\
    \    let mut vowels_count_max_index = Vec::new();\n    let mut vowels_count_min_index\
    \ = Vec::new();\n    let mut vowels_count_max_value = Vec::new();\n    let mut\
    \ vowels_count_min_value = Vec::new();\n    let mut vowels_count_max_index = Vec::new();\n\
    \    let mut vowels_count_min_index = Vec::new();\n    let mut vowels_count_max_value\
    \ = Vec::new();\n    let mut vowels_count_min_value = Vec::new();\n    let mut\
    \ vowels_count_max_index = Vec::new();\n    let mut vowels_count_min_index = Vec::new();\n\
    \    let mut vowel\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphksdar7s.rs:58:18\n   |\n\
    58 |     let mut vowel\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphksdar7s.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    while n > 0 {\n        let mut pos = 0;\n        while pos < s.len()\
    \ {\n            if s[pos] == ' ' {\n                pos = pos + 1;\n        \
    \        continue;\n            }\n            let mut count = 0;\n          \
    \  while count < n && pos < s.len() {\n                if s[pos] != 'a' && s[pos]\
    \ != 'e' && s[pos] != 'i' && s[pos] != 'o' && s[pos] != 'u' && s[pos] != 'y' &&\
    \ s[pos] != 'A' && s[pos] != 'E' && s[pos] != 'I' && s[pos] != 'O' && s[pos] !=\
    \ 'U' && s[pos] != 'Y' {\n                    count = count + 1;\n           \
    \         pos = pos + 1;\n                } else {\n                    break;\n\
    \                }\n            }\n            if count == n {\n             \
    \   result.push(s.clone());\n                n = n - 1;\n                pos =\
    \ pos + 1;\n            } else {\n                break;\n            }\n    \
    \    }\n        s = s.clone();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppbpx8cuh.rs:24:16\n\
    \   |\n24 |             if s[pos] == ' ' {\n   |                ^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppbpx8cuh.rs:30:20\n   |\n30 | ...   if s[pos] != 'a' && s[pos]\
    \ != 'e' && s[pos] != 'i' && s[pos] != 'o' && s[pos] != 'u' && s[pos] != 'y' &&\
    \ s[pos] != 'A' && s[pos] !=...\n   |          ^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppbpx8cuh.rs:30:37\n   |\n30 | ...   if s[pos] != 'a' && s[pos]\
    \ != 'e' && s[pos] != 'i' && s[pos] != 'o' && s[pos] != 'u' && s[pos] != 'y' &&\
    \ s[pos] != 'A' && s[pos] !=...\n   |                           ^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowels_count = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp31p69ssz.rs:61:11\n   |\n\
    61 |     let mu\n   |           ^ help: add `;` here\n62 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp31p69ssz.rs:17:41\n \
    \  |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut s = String::from(s);\n    while s.len() > 0 {\n\
    \        let mut word = String::from(\"\");\n        let mut i = 0;\n        while\
    \ i < s.len() && s.chars().any(|c| c.is_ascii_lowercase()) {\n            i +=\
    \ 1;\n        }\n        if i == s.len() {\n            word = s;\n        } else\
    \ {\n            word = s.split_whitespace().nth(i).unwrap();\n        }\n   \
    \     if word.chars().count(|c| c.is_ascii_lowercase()) == n {\n            words.push(word);\n\
    \        }\n        s = String::from(word.chars().skip_while(|c| c.is_ascii_lowercase()).collect());\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp24kp9hy0.rs:29:20\n   |\n\
    21 |         let mut word = String::from(\"\");\n   |                        ----------------\
    \ expected due to this value\n...\n29 |             word = s.split_whitespace().nth(i).unwrap();\n\
    \   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                    |\n   |       \
    \             expected struct `String`, found `&str`\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24kp9hy0.rs:31:25\n\
    \    |\n31  |         if word.chars().count(|c| c.is_ascii_lowercase()) == n {\n\
    \    |                         ^^^^^ -------------------------- supplied 1 argument\n\
    \    |                         |\n    |                         expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp24kp9hy0.rs:31:62\n   |\n31 |         if word.chars().count(|c|\
    \ c.is_ascii_lowercase()) == n {\n   |                                       \
    \                       ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n31 |         if word.chars().count(|c| c.is_ascii_lowercase()) == n.try_into().unwrap()\
    \ {\n   |                                                               ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut vowel_counter = 0;\n    let mut vowel_counter2 = 0;\n    let mut\
    \ vowel_counter3 = 0;\n    let mut vowel_counter4 = 0;\n    let mut vowel_counter5\
    \ = 0;\n    let mut vowel_counter6 = 0;\n    let mut vowel_counter7 = 0;\n   \
    \ let mut vowel_counter8 = 0;\n    let mut vowel_counter9 = 0;\n    let mut vowel_counter10\
    \ = 0;\n    let mut vowel_counter11 = 0;\n    let mut vowel_counter12 = 0;\n \
    \   let mut vowel_counter13 = 0;\n    let mut vowel_counter14 = 0;\n    let mut\
    \ vowel_counter15 = 0;\n    let mut vowel_counter16 = 0;\n    let mut vowel_counter17\
    \ = 0;\n    let mut vowel_counter18 = 0;\n    let mut vowel_counter19 = 0;\n \
    \   let mut vowel_counter20 = 0;\n    let mut vowel_counter21 = 0;\n    let mut\
    \ vowel_counter22 = 0;\n    let mut vowel_counter23 = 0;\n    let mut vowel_counter24\
    \ = 0;\n    let mut vowel_counter25 = 0;\n    let mut vowel_counter26 = 0;\n \
    \   let mut vowel_counter27 = 0;\n    let mut vowel_counter28 = 0;\n    let mut\
    \ vowel_counter29 = 0;\n    let mut vowel_counter30 = 0;\n    let mut vowel_counter31\
    \ = 0;\n    let mut vowel_counter32 = 0;\n    let mut vowel_counter33 = 0;\n \
    \   let mut vowel_counter34 = 0;\n    let mut vowel_counter35 = 0;\n    let mut\
    \ vowel_counter36 = 0;\n    let mut vowel_counter37 = 0;\n    let mut vowel_counter38\
    \ = 0;\n    let mut vowel_counter39 = 0;\n    let mut vowel_counter40 = 0;\n \
    \   let mut vowel_counter41 = 0;\n    let mut vowel_counter42 = 0;\n    let mut\
    \ vowel_counter43 = 0;\n    let mut vowel_counter44 = 0;\n    let mut vowel_counter45\
    \ = 0;\n    let mut vowel_counter46 = 0;\n    let mut vowel_counter47 = 0;\n \
    \   let mut vowel_counter48 = 0;\n    let mut vowel_counter49 = 0;\n    let mut\
    \ vowel_counter50 = 0;\n    let mut vowel_counter51 = 0;\n    let mut vowel_counter52\
    \ = 0;\n    let mut vowel_counter53 = 0;\n    let mut vowel_counter54 = 0;\n \
    \   let mut \n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp7n3spxqb.rs:76:1\n\
    \   |\n76 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            i += 1;\n        } else {\n   \
    \         words.push(s.subslice(i, i + n));\n            i += n;\n        }\n\
    \    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp_miawcrr.rs:21:32\n   |\n21 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp_miawcrr.rs:24:26\n\
    \   |\n24 |             words.push(s.subslice(i, i + n));\n   |              \
    \            ^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_miawcrr.rs:24:42\n   |\n24 |             words.push(s.subslice(i,\
    \ i + n));\n   |                                          ^ expected `usize`,\
    \ found `isize`\n\nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmp_miawcrr.rs:24:40\n\
    \   |\n24 |             words.push(s.subslice(i, i + n));\n   |              \
    \                          ^ no implementation for `usize + isize`\n   |\n   =\
    \ help: the trait `Add<isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `Add<Rhs>`:\n             <&'a f32 as\
    \ Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n\
    \             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n    \
    \         <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n          \
    \   <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_miawcrr.rs:25:18\n   |\n25 |             i += n;\n   |\
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmp_miawcrr.rs:25:15\n   |\n25 |            \
    \ i += n;\n   |               ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `AddAssign<Rhs>`:\n        \
    \     <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n            \
    \ <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as A"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut spaces = vec![];\n    let mut non_spaces = vec![];\n    let mut non_letters\
    \ = vec![];\n    let mut non_letters_count = vec![];\n    let mut non_letters_count_max\
    \ = vec![];\n    let mut non_letters_count_max_index = vec![];\n    let mut non_letters_count_min\
    \ = vec![];\n    let mut non_letters_count_min_index = vec![];\n    let mut non_letters_count_max\
    \ = vec![];\n    let mut non_letters_count_max_index = vec![];\n    let mut non_letters_count_min\
    \ = vec![];\n    let mut non_letters_count_min_index = vec![];\n    let mut non_letters_count_max\
    \ = vec![];\n    let mut non_letters_count_max_index = vec![];\n    let mut non_letters_count_min\
    \ = vec![];\n    let mut non_letters_count_min_index = vec![];\n    let mut non_letters_count_max\
    \ = vec![];\n    let mut non_letters_count_max_index = vec![];\n    let mut non_letters_count_min\
    \ = vec![];\n    let mut non_letters_count_min_index = vec![];\n    let mut non_letters_count_max\
    \ = vec![];\n    let mut non_letters_count_max_index = vec![];\n    let mut non_letters_count_min\
    \ = vec![];\n    let mut non_letters_count_min_index = vec![];\n    let mut non_letters_count_max\
    \ = vec![];\n    let mut non_letters_count_max_index = vec![];\n    let mut non_letters_count_min\
    \ = vec![];\n    let mut non_letters_count_min_index = vec![];\n    let mut non_letters_count_max\
    \ = vec![];\n    let mut non_letters_count_max_index = vec![];\n    let mut non_letters_count_min\
    \ = vec![];\n    let mut non_letters_count_min_index = vec![];\n    let mut non_letters_count_max\
    \ = vec![];\n    let mut non_letters_count_max_index = vec![];\n    let mut non_letters_count_min\
    \ = vec![];\n    let mut non_letters_count_min_index = vec![];\n    let mut non_letters_count_max\
    \ = vec![];\n    let mut non_letters_count_max_index = vec![];\n    let mut non_letters_count_min\
    \ = vec![];\n    let mut non_letters_count_\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjg7e0n63.rs:60:31\n   |\n\
    60 |     let mut non_letters_count_\n   |                               ^ help:\
    \ add `;` here\n61 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjg7e0n63.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut vowel_consonants = vec![];\n    let mut vowel_consonant_vowels =\
    \ vec![];\n    let mut vowel_consonant_vowels_vowels = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels = vec![];\n\
    \    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels = vec![];\n  \
    \  let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels = vec![];\n\
    \    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = vec![];\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowel\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmewqmegm.rs:38:118\n   |\n\
    38 |     let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowel\n\
    \   |                                                                        \
    \                                              ^ help: add `;` here\n39 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmewqmegm.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    while s.len() > 0 {\n        let\
    \ mut i = 0;\n        while i < s.len() {\n            if s.chars().any(|c| c.is_consonant()\
    \ && c != ' ') {\n                i += 1;\n            } else {\n            \
    \    break;\n            }\n        }\n        if i == s.len() {\n           \
    \ result.push(s);\n            break;\n        }\n        let mut j = i;\n   \
    \     while j < s.len() {\n            if s.chars().any(|c| c.is_consonant() &&\
    \ c != ' ') {\n                j += 1;\n            } else {\n               \
    \ break;\n            }\n        }\n        if j == s.len() {\n            result.push(s.clone());\n\
    \            break;\n        }\n        let mut k = j;\n        while k < s.len()\
    \ {\n            if s.chars().any(|c| c.is_consonant() && c != ' ') {\n      \
    \          k += 1;\n            } else {\n                break;\n           \
    \ }\n        }\n        if k == s.len() {\n            result.push(s.clone());\n\
    \            break;\n        }\n        let mut l = k;\n        while l < s.len()\
    \ {\n            if s.chars().any(|c| c.is_consonant() && c != ' ') {\n      \
    \          l += 1;\n            } else {\n                break;\n           \
    \ }\n        }\n        if l == s.len() {\n            result.push(s.clone());\n\
    \            break;\n        }\n        let mut m = l;\n        while m < s.len()\
    \ {\n            if s.chars().any(|c| c.is_consonant() && c != ' ') {\n      \
    \          m += 1;\n            } else {\n                break;\n           \
    \ }\n        }\n        if m == s.len() {\n            result.push(s.clone());\n\
    \            break;\n        }\n        let mut n = m;\n        while n < s.len()\
    \ {\n            if s.chars().any(|c| c.is_consonant() && c != ' ') {\n      \
    \          n += 1;\n            } else {\n                break;\n           \
    \ }\n        }\n        if n == s.len() {\n            result.push(s.clone());\n\
    \            break;\n        }\n        let mut o = n;\n        while o < s.len()\
    \ {\n            if s.chars().any(|c| c.is_consonant() && c != ' ') {\n      \
    \          o += 1;\n            } else {\n                break;\n           \
    \ }\n        }\n        if o == s.len() {\n            result.push(s.clone());\n\
    \            break;\n        }\n        let mut p = o;\n        while p < s.len()\
    \ {\n            if s.chars().any(|c| c.is_consonant() && c != ' ') {\n      \
    \          p += 1;\n            } else {\n                break;\n           \
    \ }\n        }\n        if p == s.len() {\n            result.push(s.clone());\n\
    \            break;\n        }\n        let mut q = p;\n}\n\nfn main() {\n   \
    \ let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpho_8kcj3.rs:129:3\n\
    \    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while s.len() > 0 {\n    |                       - this delimiter might\
    \ not be properly closed...\n...\n118 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n129 | }\n    |   ^\n\nerror[E0599]: no method\
    \ named `is_consonant` found for type `char` in the current scope\n  --> /tmp/tmpho_8kcj3.rs:23:36\n\
    \   |\n23 |             if s.chars().any(|c| c.is_consonant() && c != ' ') {\n\
    \   |                                    ^^^^^^^^^^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `is_consonant` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpho_8kcj3.rs:35:36\n   |\n35 |             if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                    ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `is_consonant` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpho_8kcj3.rs:47:36\n   |\n\
    47 |             if s.chars().any(|c| c.is_consonant() && c != ' ') {\n   |  \
    \                                  ^^^^^^^^^^^^ method not found in `char`\n\n\
    error[E0599]: no method named `is_consonant` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpho_8kcj3.rs:59:36\n   |\n59 |             if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                    ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `is_consonant` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpho_8kcj3.rs:71:36\n   |\n\
    71 |             if s.chars().any(|c| c.is_consonant() && c != ' ') {\n   |  \
    \                                  ^^^^^^^^^^^^ method not found in `char`\n\n\
    error[E0599]: no method named `is_consonant` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpho_8kcj3.rs:83:36\n   |\n83 |             if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                  "
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ list = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n\
    \        }\n        if j - i == n {\n            list.push(s.split_whitespace()[i]);\n\
    \            i += n;\n        }\n        else {\n            i += j;\n       \
    \ }\n    }\n    list\n}\n\nfn main() {\n    let candidate = select_words;\n  \
    \  assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjhtjial4.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjhtjial4.rs:25:21\n\
    \   |\n25 |         if j - i == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0608]: cannot index\
    \ into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpjhtjial4.rs:26:23\n\
    \   |\n26 |             list.push(s.split_whitespace()[i]);\n   |            \
    \           ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjhtjial4.rs:27:18\n\
    \   |\n27 |             i += n;\n   |                  ^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot add-assign `isize` to `usize`\n  --> /tmp/tmpjhtjial4.rs:27:15\n\
    \   |\n27 |             i += n;\n   |               ^^ no implementation for `usize\
    \ += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerro"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    while s.len() > 0 {\n        let\
    \ mut i = 0;\n        while i < s.len() && s[i].is_ascii_letter() {\n        \
    \    i += 1;\n        }\n        if i == s.len() {\n            break;\n     \
    \   }\n        let mut j = i;\n        while j < s.len() && s[j].is_ascii_letter()\
    \ {\n            j += 1;\n        }\n        if j == s.len() {\n            break;\n\
    \        }\n        let mut k = j;\n        while k < s.len() && s[k].is_ascii_letter()\
    \ {\n            k += 1;\n        }\n        if k == s.len() {\n            break;\n\
    \        }\n        let mut l = k;\n        while l < s.len() && s[l].is_ascii_letter()\
    \ {\n            l += 1;\n        }\n        if l == s.len() {\n            break;\n\
    \        }\n        let mut m = l;\n        while m < s.len() && s[m].is_ascii_letter()\
    \ {\n            m += 1;\n        }\n        if m == s.len() {\n            break;\n\
    \        }\n        let mut n = m;\n        while n < s.len() && s[n].is_ascii_letter()\
    \ {\n            n += 1;\n        }\n        if n == s.len() {\n            break;\n\
    \        }\n        let mut o = n;\n        while o < s.len() && s[o].is_ascii_letter()\
    \ {\n            o += 1;\n        }\n        if o == s.len() {\n            break;\n\
    \        }\n        let mut p = o;\n        while p < s.len() && s[p].is_ascii_letter()\
    \ {\n            p += 1;\n        }\n        if p == s.len() {\n            break;\n\
    \        }\n        let mut q = p;\n        while q < s.len() && s[q].is_ascii_letter()\
    \ {\n            q += 1;\n        }\n        if q == s.len() {\n            break;\n\
    \        }\n        let mut r = q;\n        while r < s.len() && s[r].is_ascii_letter()\
    \ {\n            r += 1;\n        }\n        if r == s.len() {\n            break;\n\
    \        }\n        let mut s = r;\n        while s < s.len() && s[s].is_ascii_letter()\
    \ {\n            s += 1;\n        }\n        if s == s.len() {\n            break;\n\
    \        }\n        let mut t = s;\n        while t < s.len() && s[t].is_ascii_letter()\
    \ {\n            t += 1;\n        }\n        if t == s.len() {\n            break;\n\
    \        }\n        let mut u = t;\n        while u < s.len() && s[u].is_ascii_letter()\
    \ {\n            u += 1;\n        }\n        if u == s.len() {\n            break;\n\
    \        }\n        let mut v = u;\n        while v < s.len() && s[v].is_\n}\n\
    \nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpnouruznj.rs:125:3\n\
    \    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while s.len() > 0 {\n    |                       - this delimiter might\
    \ not be properly closed...\n...\n114 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n125 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpnouruznj.rs:114:1\n    |\n113 |         while v < s.len()\
    \ && s[v].is_\n    |         ----- ----------------------- this `while` condition\
    \ successfully parsed\n    |         |\n    |         while parsing the body of\
    \ this `while` expression\n114 | }\n    | ^ expected `{`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnouruznj.rs:22:30\n\
    \   |\n22 |         while i < s.len() && s[i].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnouruznj.rs:29:30\n\
    \   |\n29 |         while j < s.len() && s[j].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Ind"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j = j + 1;\n\
    \        }\n        if j == i {\n            break;\n        }\n        let mut\
    \ word = String::from(&s[i .. j]);\n        let mut count = 0;\n        while\
    \ j < s.len() && s[j] == ' ' {\n            j = j + 1;\n            count = count\
    \ + 1;\n        }\n        if count == n {\n            words.push(word);\n  \
    \      }\n        i = j;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5wdukya9.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5wdukya9.rs:30:30\n   |\n30 |         while j < s.len() && s[j]\
    \ == ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    \n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkv80rbe4.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n !=\
    \ 0 {\n        if s.chars().count() == n {\n            result.push(s);\n    \
    \    }\n        n -= 1;\n        s = s.chars().skip(n).collect();\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp19ybzc23.rs:22:33\n   |\n\
    22 |         if s.chars().count() == n {\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n22 |         if\
    \ s.chars().count() == n.try_into().unwrap() {\n   |                         \
    \         ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp19ybzc23.rs:26:28\n\
    \   |\n26 |         s = s.chars().skip(n).collect();\n   |                   \
    \         ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n26 |      \
    \   s = s.chars().skip(n.try_into().unwrap()).collect();\n   |               \
    \              ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut words = s.split_whitespace();\n    let mut\
    \ i = 0;\n    while i < words.len() {\n        let mut word = words[i];\n    \
    \    let mut count = 0;\n        for c in word.chars() {\n            if c.is_consonant()\
    \ {\n                count += 1;\n            }\n        }\n        if count ==\
    \ n {\n            result.push(word);\n            i += 1;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpjikwv5wf.rs:21:21\n   |\n21 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpjikwv5wf.rs:22:24\n   |\n22 |         let mut word = words[i];\n   |\
    \                        ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c.is_lowercase()) {\n            result.push(s.subslice(i,\
    \ i + n));\n            i += n;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpj8uc92tr.rs:23:32\n   |\n23 |         if s.chars().any(|c|\
    \ c.is_consonant() && c.is_lowercase()) {\n   |                              \
    \  ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method named `subslice`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpj8uc92tr.rs:24:27\n\
    \   |\n24 |             result.push(s.subslice(i, i + n));\n   |             \
    \              ^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    while s.len() > 0 {\n        let\
    \ mut i = 0;\n        let mut j = s.len();\n        while i < j {\n          \
    \  if s[i] == ' ' {\n                i += 1;\n                j = i;\n       \
    \     } else {\n                i += 1;\n            }\n        }\n        if\
    \ i == j {\n            result.push(s.clone());\n        }\n        s = &s[i..];\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_9t17dk_.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_9t17dk_.rs:34:13\n\
    \   |\n19 |     let mut s = s;\n   |                 - expected due to this value\n\
    ...\n34 |         s = &s[i..];\n   |             ^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n34 |        \
    \ s = (&s[i..]).to_string();\n   |             +       +++++++++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowel_consonants = Vec::new();\n    let mut vowel_consonant_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels = Vec::new();\n   \
    \ let mut vowel_consonant_vowels_consonants = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_vowels_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_consonants_vowels_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_consonants_consonants_vowels_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_consonants_consonants_vowels_consonants\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_consonants_conson\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpct80ojem.rs:35:115\n   |\n\
    35 |     let mut vowel_consonant_vowels_consonants_consonants_vowels_consonants_consonants_consonants_consonants_conson\n\
    \   |                                                                        \
    \                                           ^ help: add `;` here\n36 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpct80ojem.rs:17:41\n\
    \   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n\
    \        }\n        let mut word = String::from(&s[i .. j]);\n        let mut\
    \ count = 0;\n        while j < s.len() && s[j] == s[(j + n) % s.len()] {\n  \
    \          count += 1;\n            j += 1\n        }\n        if count == n {\n\
    \            words.push(word);\n            i += j - i;\n        }\n    }\n  \
    \  words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpyz__5w5p.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpyz__5w5p.rs:27:30\n   |\n27 |         while j < s.len() && s[j]\
    \ == s[(j + n) % s.len()] {\n   |                              ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyz__5w5p.rs:27:45\n\
    \   |\n27 |         while j < s.len() && s[j] == s[(j + n) % s.len()] {\n   |\
    \                                             ^ expected `usize`, found `isize`\n\
    \nerror[E0277]: cannot add `isize` to `usize`\n  --> /tmp/tmpyz__5w5p.rs:27:43\n\
    \   |\n27 |         while j < s.len() && s[j] == s[(j + n) % s.len()] {\n   |\
    \                                           ^ no implementation for `usize + isize`\n\
    \   |\n   = help: the trait `Add<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `Add<Rhs>`:\n             <&'a\
    \ f32 as Add<f32>>\n             <&"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ list = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n\
    \        }\n        let mut k = i;\n        while k < s.len() && s[k] == ' ' {\n\
    \            k += 1\n        }\n        if j == i {\n            list.push(s.to_string());\n\
    \            i += 1;\n            continue;\n        }\n        if k == i {\n\
    \            list.push(s.to_string());\n            i += 1;\n            continue;\n\
    \        }\n        if j > k {\n            list.push(s.to_string());\n      \
    \      i += 1;\n            continue;\n        }\n        if j == k {\n      \
    \      list.push(s.to_string());\n            i += 1;\n            continue;\n\
    \        }\n        if j > k {\n            list.push(s.to_string());\n      \
    \      i += 1;\n            continue;\n        }\n        if j == k {\n      \
    \      list.push(s.to_string());\n            i += 1;\n            continue;\n\
    \        }\n        if j > k {\n            list.push(s.to_string());\n      \
    \      i += 1;\n            continue;\n        }\n        if j == k {\n      \
    \      list.push(s.to_string());\n            i += 1;\n            continue;\n\
    \        }\n        if j > k {\n            list.push(s.to_string());\n      \
    \      i += 1;\n            continue;\n        }\n        if j == k {\n      \
    \      list.push(s.to_string());\n            i += 1;\n            continue;\n\
    \        }\n        if j > k {\n            list.push(s.to_string());\n      \
    \      i += 1;\n            continue;\n        }\n        if j == k {\n      \
    \      list.push(s.to_string());\n            i += 1;\n            continue;\n\
    \        }\n        if j > k {\n            list.push(s.to_string());\n      \
    \      i += 1;\n            continue;\n        }\n        if j == k {\n      \
    \      list.push(s.to_string());\n            i += 1;\n            continue;\n\
    \        }\n        if j > k {\n            list.push(s.to_string());\n      \
    \      i += 1;\n            continue;\n        }\n        if j == k {\n      \
    \      list.push(s.to_string());\n            i += 1;\n            continue;\n\
    \        }\n        if j > k {\n            list.push(s.to_string());\n      \
    \      i += 1;\n            continue;\n        }\n        if j == k {\n      \
    \      list.push(s.to_string());\n            i += 1;\n            continue;\n\
    \        }\n        if j > k {\n            list.push(s.to_string());\n      \
    \      i += 1;\n            continue;\n        }\n        if j == k {\n      \
    \      list.push(s.to_string());\n            i += 1;\n            continue;\n\
    \        }\n        if j > k {\n\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpjjpcsx29.rs:142:3\n\
    \    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while i < s.len() {\n    |                       - unclosed delimiter\n\
    ...\n129 |         if j > k {\n    |                  - this delimiter might not\
    \ be properly closed...\n130 | \n131 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n142 | }\n    |   ^\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpjjpcsx29.rs:22:30\n   |\n\
    22 |         while j < s.len() && s[j] == ' ' {\n   |                        \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjjpcsx29.rs:26:30\n   |\n26 |         while k < s.len() && s[k]\
    \ == ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpjjpcsx29.rs:20:5\n\
    \    |\n17  |   fn select_words(s: String, n: isize) -> Vec<String> {\n    | \
    \    "
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n >\
    \ 0 {\n        let mut i = 0;\n        while i < s.len() {\n            if s.chars().any(|c|\
    \ c != ' ') {\n                i += 1;\n            } else {\n               \
    \ break;\n            }\n        }\n        if i == s.len() {\n            result.push(s);\n\
    \            n -= 1;\n        } else {\n            s = s.to_string().split_whitespace().collect::<Vec<_>>();\n\
    \            result.push(s.first());\n            n -= 1;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsveoi480.rs:34:17\n   |\n\
    19 |     let mut s = s;\n   |                 - expected due to this value\n...\n\
    34 |             s = s.to_string().split_whitespace().collect::<Vec<_>>();\n \
    \  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found struct `Vec`\n   |\n   = note: expected struct `String`\n\
    \              found struct `Vec<&str>`\n\nerror[E0599]: no method named `first`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpsveoi480.rs:35:27\n\
    \   |\n35 |             result.push(s.first());\n   |                        \
    \   ^^^^^ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 101
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s.chars().all(|c| c != ' ') {\n   \
    \         j = j + 1;\n        }\n        if j == i {\n            break;\n   \
    \     }\n        let mut word = String::from(&s[i .. j]);\n        let mut count\
    \ = 0;\n        while count < n && j < s.len() {\n            if s.chars().any(|c|\
    \ c == ' ') {\n                break;\n            }\n            if s.chars().all(|c|\
    \ c != ' ') {\n                count += 1;\n            }\n            j = j +\
    \ 1;\n        }\n        if count == n {\n            words.push(word);\n    \
    \    }\n        i = j;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"little\"]`', /tmp/tmpiew3t21x.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n            result.push(s.subslice(i, i + n));\n\
    \            i += n;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpik2eoxnw.rs:23:32\n   |\n23 |         if s.chars().any(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `subslice` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpik2eoxnw.rs:24:27\n\
    \   |\n24 |             result.push(s.subslice(i, i + n));\n   |             \
    \              ^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ list = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s.chars().all(|c| c == s.chars().nth(j))\
    \ {\n            j += 1\n        }\n        if j - i == n {\n            list.push(s.chars().take(i).collect::<String>());\n\
    \            i += n;\n        }\n    }\n    list\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmh3wp1l7.rs:22:53\n   |\n\
    22 |         while j < s.len() && s.chars().all(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmh3wp1l7.rs:25:21\n\
    \   |\n25 |         if j - i == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmh3wp1l7.rs:27:18\n   |\n27 |             i += n;\n   |\
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmpmh3wp1l7.rs:27:15\n   |\n27 |            \
    \ i += n;\n   |               ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `AddAssign<Rhs>`:\n        \
    \     <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n            \
    \ <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16 as\
    \ AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut s = String::from(s);\n    while s.len() > 0\
    \ {\n        let mut i = 0;\n        while i < s.len() && s.chars().any(|c| c.is_consonant()\
    \ == true) {\n            i += 1;\n        }\n        if i == s.len() {\n    \
    \        break;\n        }\n        let mut j = i;\n        while j < s.len()\
    \ && s.chars().any(|c| c.is_consonant() == false) {\n            j += 1;\n   \
    \     }\n        if j == s.len() {\n            break;\n        }\n        let\
    \ mut k = j;\n        while k < s.len() && s.chars().any(|c| c.is_consonant()\
    \ == true) {\n            k += 1;\n        }\n        if k == s.len() {\n    \
    \        break;\n        }\n        let mut l = k;\n        while l < s.len()\
    \ && s.chars().any(|c| c.is_consonant() == false) {\n            l += 1;\n   \
    \     }\n        if l == s.len() {\n            break;\n        }\n        let\
    \ mut m = l;\n        while m < s.len() && s.chars().any(|c| c.is_consonant()\
    \ == true) {\n            m += 1;\n        }\n        if m == s.len() {\n    \
    \        break;\n        }\n        let mut n = m;\n        while n < s.len()\
    \ && s.chars().any(|c| c.is_consonant() == false) {\n            n += 1;\n   \
    \     }\n        if n == s.len() {\n            break;\n        }\n        let\
    \ mut o = n;\n        while o < s.len() && s.chars().any(|c| c.is_consonant()\
    \ == true) {\n            o += 1;\n        }\n        if o == s.len() {\n    \
    \        break;\n        }\n        let mut p = o;\n        while p < s.len()\
    \ && s.chars().any(|c| c.is_consonant() == false) {\n            p += 1;\n   \
    \     }\n        if p == s.len() {\n            break;\n        }\n        let\
    \ mut q = p;\n        while q < s.len() && s.chars().any(|c| c.is_consonant()\
    \ == true) {\n            q += 1;\n        }\n        if q == s.len() {\n    \
    \        break;\n        }\n        let mut r = q;\n        while r < s.len()\
    \ && s.chars().any(|c| c.is_consonant() == false) {\n            r += 1;\n   \
    \     }\n        if r == s.len() {\n            break;\n        }\n        let\
    \ mut s = r;\n        while s < s.len() && s.chars().any(|c| c.is_consonant()\
    \ == true) {\n            s += 1;\n        }\n        if s == s.len() {\n    \
    \        break;\n        }\n        let mut t = s;\n\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmptf88mhd3.rs:111:3\n\
    \    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while s.len() > 0 {\n    |                       - this delimiter might\
    \ not be properly closed...\n...\n100 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n111 | }\n    |   ^\n\nerror[E0599]: no method\
    \ named `is_consonant` found for type `char` in the current scope\n  --> /tmp/tmptf88mhd3.rs:22:50\n\
    \   |\n22 |         while i < s.len() && s.chars().any(|c| c.is_consonant() ==\
    \ true) {\n   |                                                  ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `is_consonant` found\
    \ for type `char` in the current scope\n  --> /tmp/tmptf88mhd3.rs:29:50\n   |\n\
    29 |         while j < s.len() && s.chars().any(|c| c.is_consonant() == false)\
    \ {\n   |                                                  ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `is_consonant` found for\
    \ type `char` in the current scope\n  --> /tmp/tmptf88mhd3.rs:36:50\n   |\n36\
    \ |         while k < s.len() && s.chars().any(|c| c.is_consonant() == true) {\n\
    \   |                                                  ^^^^^^^^^^^^ method not\
    \ found in `char`\n\nerror[E0599]: no method named `is_consonant` found for type\
    \ `char` in the current scope\n  --> /tmp/tmptf88mhd3.rs:43:50\n   |\n43 |   \
    \      while l < s.len() && s.chars().any(|c| c.is_consonant() == false) {\n \
    \  |                                                  ^^^^^^^^^^^^ method not\
    \ found in `char`\n\nerror[E0599]: no method named `is_consonant` found for type\
    \ `char` in the current scope\n  --> /tmp/tmptf88mhd3.rs:50:50\n   |\n50 |   \
    \      while m < s.len() && s.chars().any(|c| c.is_consonant() == true) {\n  \
    \ |                                                  ^^^^^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `is_consonant` found for type `char`\
    \ in the current scope\n  --> /tmp/tmptf88mhd3."
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n\
    \        }\n        if j == i {\n            break;\n        }\n        let mut\
    \ k = j;\n        while k < s.len() && s[k] != ' ' {\n            k += 1\n   \
    \     }\n        if k == j {\n            break;\n        }\n        if n == j\
    \ - i {\n            result.push(s.split_whitespace()[i]);\n            i += 1;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfheym74q.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpfheym74q.rs:29:30\n   |\n29 |         while k < s.len() && s[k]\
    \ != ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfheym74q.rs:35:17\n\
    \   |\n35 |         if n == j - i {\n   |                 ^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n35 |         if n == (j - i).try_into().unwrap()\
    \ {\n   |                 +     +++++++++++++++++++++\n\nerror[E0608]: cannot\
    \ index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpfheym74q.rs:36:25\n\
    \   |\n36 |             result.push(s.split_whitespace()[i]);\n   |          \
    \               ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanatio"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowels_count = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index2 = Vec::new();\n    let mut vowels_count_index3\
    \ = Vec::new();\n    let mut vowels_count_index4 = Vec::new();\n    let mut vowels_count_index5\
    \ = Vec::new();\n    let mut vowels_count_index6 = Vec::new();\n    let mut vowels_count_index7\
    \ = Vec::new();\n    let mut vowels_count_index8 = Vec::new();\n    let mut vowels_count_index9\
    \ = Vec::new();\n    let mut vowels_count_index10 = Vec::new();\n    let mut vowels_count_index11\
    \ = Vec::new();\n    let mut vowels_count_index12 = Vec::new();\n    let mut vowels_count_index13\
    \ = Vec::new();\n    let mut vowels_count_index14 = Vec::new();\n    let mut vowels_count_index15\
    \ = Vec::new();\n    let mut vowels_count_index16 = Vec::new();\n    let mut vowels_count_index17\
    \ = Vec::new();\n    let mut vowels_count_index18 = Vec::new();\n    let mut vowels_count_index19\
    \ = Vec::new();\n    let mut vowels_count_index20 = Vec::new();\n    let mut vowels_count_index21\
    \ = Vec::new();\n    let mut vowels_count_index22 = Vec::new();\n    let mut vowels_count_index23\
    \ = Vec::new();\n    let mut vowels_count_index24 = Vec::new();\n    let mut vowels_count_index25\
    \ = Vec::new();\n    let mut vowels_count_index26 = Vec::new();\n    let mut vowels_count_index27\
    \ = Vec::new();\n    let mut vowels_count_index28 = Vec::new();\n    let mut vowels_count_index29\
    \ = Vec::new();\n    let mut vowels_count_index30 = Vec::new();\n    let mut vowels_count_index31\
    \ = Vec::new();\n    let mut vowels_count_index32 = Vec::new();\n    let mut vowels_count_index33\
    \ = Vec::new();\n    let mut vowels_count_index34 = Vec::new();\n    let mut vowels_count_index\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpo0vniekp.rs:56:31\n   |\n\
    56 |     let mut vowels_count_index\n   |                               ^ help:\
    \ add `;` here\n57 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo0vniekp.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().any(|c|\
    \ c != ' ') {\n            result.push(s.subslice(i, i + n));\n            i +=\
    \ n;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `subslice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp8os54_qb.rs:24:27\n   |\n24 |             result.push(s.subslice(i,\
    \ i + n));\n   |                           ^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    while s.len() > 0 {\n        let\
    \ mut i = 0;\n        let mut j = s.len();\n        while i < j {\n          \
    \  if s[i] == ' ' {\n                i += 1;\n                j -= 1;\n      \
    \      } else {\n                i += 1;\n            }\n        }\n        if\
    \ i == j {\n            result.push(s.clone());\n            i += 1;\n       \
    \ }\n        while i < j {\n            if s[i] == ' ' {\n                i +=\
    \ 1;\n            } else {\n                result.push(s.clone());\n        \
    \        i += 1;\n            }\n        }\n        s = &s[i..];\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppc58pyh3.rs:24:16\n\
    \   |\n24 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppc58pyh3.rs:36:16\n   |\n36 |             if s[i] == ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppc58pyh3.rs:43:13\n\
    \   |\n19 |     let mut s = s;\n   |                 - expected due to this value\n\
    ...\n43 |         s = &s[i..];\n   |             ^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n43 |        \
    \ s = (&s[i..]).to_string();\n   |             +       +++++++++++++\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut index = 0;\n    while index < s.len() {\n     \
    \   let mut word = String::from(\"\");\n        let mut consonant = false;\n \
    \       for c in s.chars() {\n            if index == 0 {\n                consonant\
    \ = false;\n            }\n            if c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u' {\n                consonant = true;\n            }\n \
    \           if consonant {\n                word += c;\n            }\n      \
    \      index += 1;\n        }\n        if word.len() == n {\n            words.push(word);\n\
    \        }\n        index += 1;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2_454yg5.rs:31:25\n   |\n\
    31 |                 word += c;\n   |                         ^ expected `&str`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2_454yg5.rs:35:26\n\
    \   |\n35 |         if word.len() == n {\n   |                          ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n35 |         if word.len()\
    \ == n.try_into().unwrap() {\n   |                           ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    while s.len() >\
    \ 0 {\n        let mut i = 0;\n        let mut c = s.chars().nth(i);\n       \
    \ while c.is_some() && c.unwrap() == c.unwrap().to_ascii_lowercase().unwrap()\
    \ {\n            i += 1;\n            c = s.chars().nth(i);\n        }\n     \
    \   if i == n {\n            result.push(s.clone());\n            s.clear();\n\
    \        } else {\n            s.push(c.unwrap());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpk03r7els.rs:23:76\n   |\n23 |         while c.is_some()\
    \ && c.unwrap() == c.unwrap().to_ascii_lowercase().unwrap() {\n   |          \
    \                                                                  ^^^^^^ method\
    \ not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk03r7els.rs:27:17\n\
    \   |\n27 |         if i == n {\n   |                 ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n27 |         if i == n.try_into().unwrap()\
    \ {\n   |                  ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowel_counter = 0;\n    let mut vowel_counter2 =\
    \ 0;\n    let mut vowel_counter3 = 0;\n    let mut vowel_counter4 = 0;\n    let\
    \ mut vowel_counter5 = 0;\n    let mut vowel_counter6 = 0;\n    let mut vowel_counter7\
    \ = 0;\n    let mut vowel_counter8 = 0;\n    let mut vowel_counter9 = 0;\n   \
    \ let mut vowel_counter10 = 0;\n    let mut vowel_counter11 = 0;\n    let mut\
    \ vowel_counter12 = 0;\n    let mut vowel_counter13 = 0;\n    let mut vowel_counter14\
    \ = 0;\n    let mut vowel_counter15 = 0;\n    let mut vowel_counter16 = 0;\n \
    \   let mut vowel_counter17 = 0;\n    let mut vowel_counter18 = 0;\n    let mut\
    \ vowel_counter19 = 0;\n    let mut vowel_counter20 = 0;\n    let mut vowel_counter21\
    \ = 0;\n    let mut vowel_counter22 = 0;\n    let mut vowel_counter23 = 0;\n \
    \   let mut vowel_counter24 = 0;\n    let mut vowel_counter25 = 0;\n    let mut\
    \ vowel_counter26 = 0;\n    let mut vowel_counter27 = 0;\n    let mut vowel_counter28\
    \ = 0;\n    let mut vowel_counter29 = 0;\n    let mut vowel_counter30 = 0;\n \
    \   let mut vowel_counter31 = 0;\n    let mut vowel_counter32 = 0;\n    let mut\
    \ vowel_counter33 = 0;\n    let mut vowel_counter34 = 0;\n    let mut vowel_counter35\
    \ = 0;\n    let mut vowel_counter36 = 0;\n    let mut vowel_counter37 = 0;\n \
    \   let mut vowel_counter38 = 0;\n    let mut vowel_counter39 = 0;\n    let mut\
    \ vowel_counter40 = 0;\n    let mut vowel_counter41 = 0;\n    let mut vowel_counter42\
    \ = 0;\n    let mut vowel_counter43 = 0;\n    let mut vowel_counter44 = 0;\n \
    \   let mut vowel_counter45 = 0;\n    let mut vowel_counter46 = 0;\n    let mut\
    \ vowel_counter47 = 0;\n    let mut vowel_counter48 = 0;\n    let mut vowel_counter49\
    \ = 0;\n    let mut vowel_counter50 = 0;\n    let mut vowel_counter51 = 0;\n \
    \   let mut vowel_counter52 = 0;\n    let mut vowel_counter53 = 0;\n    let mut\
    \ vowel_counter54 = 0;\n\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphooo0zh3.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n\
    \        while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n   \
    \         j += 1\n        }\n        if j == i {\n            result.push(s.clone());\n\
    \            i += 1;\n        } else {\n            result.push(s.clone());\n\
    \            i += j - i;\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpamdxem1t.rs:24:53\n   |\n\
    24 |         while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == s[i] {\n            j = j + 1;\n\
    \        }\n        if j == s.len() {\n            words.push(s.to_string());\n\
    \            i = i + 1;\n        } else {\n            if j - i == n {\n     \
    \           words.push(s.to_string());\n                i = i + 1;\n         \
    \   } else {\n                j = j + 1;\n            }\n        }\n    }\n  \
    \  words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp3jleexs.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == s[i] {\n   |                \
    \              ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpp3jleexs.rs:22:38\n   |\n22 |         while j < s.len() && s[j]\
    \ == s[i] {\n   |                                      ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp3jleexs.rs:29:25\n\
    \   |\n29 |             if j - i == n {\n   |                         ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n29 |             if j -\
    \ i == n.try_into().unwrap() {\n   |                          ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowels_count = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp31p69ssz.rs:61:11\n   |\n\
    61 |     let mu\n   |           ^ help: add `;` here\n62 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp31p69ssz.rs:17:41\n \
    \  |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ list = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n\
    \        }\n        if j - i == n {\n            list.push(s.split_whitespace()[j..].to_owned());\n\
    \            i += n;\n        }\n        i += 1;\n    }\n    list\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm4wvi0ml.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm4wvi0ml.rs:25:21\n\
    \   |\n25 |         if j - i == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0608]: cannot index\
    \ into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpm4wvi0ml.rs:26:23\n\
    \   |\n26 |             list.push(s.split_whitespace()[j..].to_owned());\n   |\
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm4wvi0ml.rs:27:18\n   |\n27 |             i += n;\n   |\
    \                  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign\
    \ `isize` to `usize`\n  --> /tmp/tmpm4wvi0ml.rs:27:15\n   |\n27 |            \
    \ i += n;\n   |               ^^ no implementation for `usize += isize`\n   |\n\
    \   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `AddAssign<Rhs>`:\n        \
    \     <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n            \
    \ <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n             <i128\
    \ as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16 as\
    \ AddAssign<&i16>>\n             <i16 as AddAssign>\n           and "
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j].is_ascii_letter() {\n            j\
    \ = j + 1;\n        }\n        if j == s.len() {\n            break;\n       \
    \ }\n        let mut word = String::from(&s[i .. j]);\n        let mut count =\
    \ 0;\n        while j < s.len() && s[j].is_ascii_letter() {\n            count\
    \ = count + 1;\n            j = j + 1;\n        }\n        if count == n {\n \
    \           words.push(word);\n            i = j;\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqp_liug4.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqp_liug4.rs:30:30\n\
    \   |\n30 |         while j < s.len() && s[j].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s[j] == ' ' {\n            j = j +\
    \ 1;\n        }\n        if j == s.len() {\n            break;\n        }\n  \
    \      let mut k = j;\n        while k < s.len() && s[k] != ' ' {\n          \
    \  k = k + 1;\n        }\n        if k == s.len() {\n            break;\n    \
    \    }\n        if n == j - i {\n            words.push(s.split_whitespace()[i\
    \ .. k].collect::<Vec<_>>());\n            i = k;\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbr375rkb.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpbr375rkb.rs:29:30\n   |\n29 |         while k < s.len() && s[k]\
    \ != ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbr375rkb.rs:35:17\n\
    \   |\n35 |         if n == j - i {\n   |                 ^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n35 |         if n == (j - i).try_into().unwrap()\
    \ {\n   |                 +     +++++++++++++++++++++\n\nerror[E0608]: cannot\
    \ index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpbr375rkb.rs:36:24\n\
    \   |\n36 |             words.push(s.split_whitespace()[i .. k].collect::<Vec<_>>());\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome err"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n\
    \        while j < s.len() && s.chars().any(|c| c != s.chars().nth(j)) {\n   \
    \         j = j + 1;\n        }\n        if j == i {\n            result.push(s.to_string());\n\
    \            i += 1;\n        } else {\n            if j > i {\n             \
    \   let mut k = i;\n                while k < j {\n                    k = k +\
    \ 1;\n                }\n                let mut k = i;\n                while\
    \ k < j {\n                    if s.chars().any(|c| c != s.chars().nth(k)) {\n\
    \                        result.push(s.to_string());\n                       \
    \ break;\n                    }\n                    k = k + 1;\n            \
    \    }\n            }\n            i += j - i;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9r375m7u.rs:24:53\n   |\n\
    24 |         while j < s.len() && s.chars().any(|c| c != s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9r375m7u.rs:38:47\n\
    \   |\n38 |                     if s.chars().any(|c| c != s.chars().nth(k)) {\n\
    \   |                                               ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowels_count = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mut vowels_count_index = Vec::new();\n    let mut vowels_count_index\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp31p69ssz.rs:61:11\n   |\n\
    61 |     let mu\n   |           ^ help: add `;` here\n62 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp31p69ssz.rs:17:41\n \
    \  |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n   \
    \     }\n        if j == i {\n            break;\n        }\n        let mut k\
    \ = j;\n        while k < s.len() && s[k] != ' ' {\n            k += 1\n     \
    \   }\n        if k == j {\n            break;\n        }\n        if k == i {\n\
    \            result.push(s.split_whitespace()[k]);\n            i += k - j;\n\
    \        } else {\n            result.push(s.split_whitespace()[i]);\n       \
    \     i += k - j;\n        }\n    }\n    if result.is_empty() {\n        vec![]\n\
    \    } else {\n        result\n    }\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw10dxzu5.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpw10dxzu5.rs:29:30\n   |\n29 |         while k < s.len() && s[k]\
    \ != ' ' {\n   |                              ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpw10dxzu5.rs:36:25\n   |\n36 |             result.push(s.split_whitespace()[k]);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot\
    \ index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpw10dxzu5.rs:39:25\n\
    \   |\n39 |             result.push(s.split_whitespace()[i]);\n   |          \
    \               ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    select_words_helper(s,\
    \ n, 0)\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `select_words_helper` in this scope\n\
    \  --> /tmp/tmpytfvdp_1.rs:18:5\n   |\n18 |     select_words_helper(s, n, 0)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut index = 0;\n    while index < s.len() {\n \
    \       let mut word = String::new();\n        let mut consonants = String::new();\n\
    \        let mut vowels = String::new();\n        let mut spaces = String::new();\n\
    \        let mut letter = s.chars().nth(index).unwrap();\n        let mut vowel\
    \ = letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter\
    \ == 'u';\n        let mut space = letter == ' ';\n        while vowel && index\
    \ < s.len() {\n            vowel = s.chars().nth(index).unwrap() == 'a' || s.chars().nth(index).unwrap()\
    \ == 'e' || s.chars().nth(index).unwrap() == 'i' || s.chars().nth(index).unwrap()\
    \ == 'o' || s.chars().nth(index).unwrap() == 'u';\n            space = s.chars().nth(index).unwrap()\
    \ == ' ';\n            consonants = consonants.push_str(letter);\n           \
    \ vowels = vowels.push_str(letter);\n            word = word.push_str(letter);\n\
    \            index = index + 1;\n        }\n        if space {\n            spaces\
    \ = spaces.push_str(letter);\n        }\n        if consonants.len() == n {\n\
    \            words = words.push_str(word);\n        }\n        if vowels.len()\
    \ == n {\n            words = words.push_str(word);\n        }\n        if spaces.len()\
    \ == n {\n            words = words.push_str(word);\n        }\n    }\n    words\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkbsodubb.rs:31:46\n   |\n\
    31 |             consonants = consonants.push_str(letter);\n   |             \
    \                                 ^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkbsodubb.rs:31:26\n   |\n22 |         let mut\
    \ consonants = String::new();\n   |                              -------------\
    \ expected due to this value\n...\n31 |             consonants = consonants.push_str(letter);\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n \
    \ --> /tmp/tmpkbsodubb.rs:31:37\n   |\n31 |             consonants = consonants.push_str(letter);\n\
    \   |                          ---------- ^^^^^^^^ this call modifies `consonants`\
    \ in-place\n   |                          |\n   |                          you\
    \ probably want to use this value after calling the method...\n   = note: ...instead\
    \ of the `()` output of method `push_str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkbsodubb.rs:32:38\n   |\n32 |             vowels = vowels.push_str(letter);\n\
    \   |                                      ^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkbsodubb.rs:32:22\n   |\n23 |\
    \         let mut vowels = String::new();\n   |                          -------------\
    \ expected due to this value\n...\n32 |             vowels = vowels.push_str(letter);\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n  --> /tmp/tmpkbsodubb.rs:32:29\n\
    \   |\n32 |             vowels = vowels.push_str(letter);\n   |              \
    \        ------ ^^^^^^^^ this call modifies `vowels` in-place\n   |          \
    \            |\n   |                      you probably want to use this value\
    \ after calling the method...\n   = note: ...instead of the `()` output of method\
    \ `push_str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkbsodubb.rs:33:34\n\
    \   |\n33 |             word = word.push_str(letter);"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s[j] == ' ' {\n            j += 1\n\
    \        }\n        if j == s.len() {\n            break;\n        }\n       \
    \ let mut word = String::from(&s[i .. j]);\n        let mut count = 0;\n     \
    \   while j < s.len() && s[j] == s[j].to_lowercase() {\n            count += 1;\n\
    \            j += 1\n        }\n        if count == n {\n            words.push(word);\n\
    \        }\n        i = j;\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptjd81frl.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j] == ' ' {\n   |                 \
    \             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptjd81frl.rs:30:30\n   |\n30 |         while j < s.len() && s[j]\
    \ == s[j].to_lowercase() {\n   |                              ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptjd81frl.rs:30:38\n   |\n30 |         while j < s.len() && s[j]\
    \ == s[j].to_lowercase() {\n   |                                      ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \ "
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut i = 0;\n    while i < s.len() {\n        let mut\
    \ j = i;\n        while j < s.len() && s.chars().any(|c| c == s.chars().nth(j))\
    \ {\n            j += 1\n        }\n        if j - i == n {\n            words.push(s.chars().take(i).collect::<String>());\n\
    \            i += n - 1;\n        }\n    }\n    words\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4ie1szg2.rs:22:53\n   |\n\
    22 |         while j < s.len() && s.chars().any(|c| c == s.chars().nth(j)) {\n\
    \   |                                                     ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found enum `Option`\n   |\n   = note: expected type `char`\n       \
    \       found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4ie1szg2.rs:25:21\n\
    \   |\n25 |         if j - i == n {\n   |                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         if j - i == n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4ie1szg2.rs:27:18\n   |\n27 |             i += n - 1;\n\
    \   |                  ^^^^^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add-assign `isize` to `usize`\n  --> /tmp/tmp4ie1szg2.rs:27:15\n   |\n\
    27 |             i += n - 1;\n   |               ^^ no implementation for `usize\
    \ += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut consonants = vec![];\n    let mut vowels = vec![];\n\
    \    let mut spaces = vec![];\n    let mut non_spaces = vec![];\n    let mut non_spaces_count\
    \ = s.chars().filter(|c| !c.is_whitespace()).count();\n    let mut non_spaces_index\
    \ = 0;\n    let mut non_spaces_index2 = 0;\n    let mut non_spaces_index3 = 0;\n\
    \    let mut non_spaces_index4 = 0;\n    let mut non_spaces_index5 = 0;\n    let\
    \ mut non_spaces_index6 = 0;\n    let mut non_spaces_index7 = 0;\n    let mut\
    \ non_spaces_index8 = 0;\n    let mut non_spaces_index9 = 0;\n    let mut non_spaces_index10\
    \ = 0;\n    let mut non_spaces_index11 = 0;\n    let mut non_spaces_index12 =\
    \ 0;\n    let mut non_spaces_index13 = 0;\n    let mut non_spaces_index14 = 0;\n\
    \    let mut non_spaces_index15 = 0;\n    let mut non_spaces_index16 = 0;\n  \
    \  let mut non_spaces_index17 = 0;\n    let mut non_spaces_index18 = 0;\n    let\
    \ mut non_spaces_index19 = 0;\n    let mut non_spaces_index20 = 0;\n    let mut\
    \ non_spaces_index21 = 0;\n    let mut non_spaces_index22 = 0;\n    let mut non_spaces_index23\
    \ = 0;\n    let mut non_spaces_index24 = 0;\n    let mut non_spaces_index25 =\
    \ 0;\n    let mut non_spaces_index26 = 0;\n    let mut non_spaces_index27 = 0;\n\
    \    let mut non_spaces_index28 = 0;\n    let mut non_spaces_index29 = 0;\n  \
    \  let mut non_spaces_index30 = 0;\n    let mut non_spaces_index31 = 0;\n    let\
    \ mut non_spaces_index32 = 0;\n    let mut non_spaces_index33 = 0;\n    let mut\
    \ non_spaces_index34 = 0;\n    let mut non_spaces_index35 = 0;\n    let mut non_spaces_index36\
    \ = 0;\n    let mut non_spaces_index37 = 0;\n    let mut non_spaces_index38 =\
    \ 0;\n    let mut non_spaces_index39 = 0;\n    let mut non_spaces_index40 = 0;\n\
    \    let mut non_spaces_index41 = 0;\n    let mut non_spaces_index42 = 0;\n  \
    \  let mut non_spaces_index43 = 0;\n    let mut non_spaces_index44 = 0;\n    let\
    \ mut non_spaces_index45\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5rj_b01s.rs:68:31\n   |\n\
    68 |     let mut non_spaces_index45\n   |                               ^ help:\
    \ add `;` here\n69 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5rj_b01s.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize)\
    \ -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s[j].is_ascii_letter() {\n        \
    \    j += 1\n        }\n        if j - i > n {\n            words.push(s.split_whitespace()[j..]);\n\
    \            i = j;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk8mldcb4.rs:22:30\n\
    \   |\n22 |         while j < s.len() && s[j].is_ascii_letter() {\n   |      \
    \                        ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk8mldcb4.rs:25:20\n   |\n25 |         if j -\
    \ i > n {\n   |                    ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n25 |         if j - i > n.try_into().unwrap() {\n   |           \
    \          ++++++++++++++++++++\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmpk8mldcb4.rs:26:24\n   |\n26 |    \
    \         words.push(s.split_whitespace()[j..]);\n   |                       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() && s[j] == ' ' {\n            j = j +\
    \ 1;\n        }\n        if j == s.len() {\n            break;\n        }\n  \
    \      let mut k = j;\n        while k < s.len() && s[k] != ' ' {\n          \
    \  k = k + 1;\n        }\n        if k == s.len() {\n            break;\n    \
    \    }\n        let mut c = s[k];\n        while k < s.len() && s[k] == c {\n\
    \            k = k + 1;\n        }\n        if k == s.len() {\n            break;\n\
    \        }\n        if n == 0 {\n            break;\n        }\n        if n ==\
    \ 1 {\n            words.push(s.split_whitespace()[i]);\n            break;\n\
    \        }\n        if n == 2 {\n            words.push(s.split_whitespace()[i]);\n\
    \            words.push(s.split_whitespace()[j]);\n            break;\n      \
    \  }\n        if n == 3 {\n            words.push(s.split_whitespace()[i]);\n\
    \            words.push(s.split_whitespace()[j]);\n            words.push(s.split_whitespace()[k]);\n\
    \            break;\n        }\n        if n == 4 {\n            words.push(s.split_whitespace()[i]);\n\
    \            words.push(s.split_whitespace()[j]);\n            words.push(s.split_whitespace()[k]);\n\
    \            words.push(s.split_whitespace()[l]);\n            break;\n      \
    \  }\n        if n == 5 {\n            words.push(s.split_whitespace()[i]);\n\
    \            words.push(s.split_whitespace()[j]);\n            words.push(s.split_whitespace()[k]);\n\
    \            words.push(s.split_whitespace()[l]);\n            words.push(s.split_whitespace()[m]);\n\
    \            break;\n        }\n        if n == 6 {\n            words.push(s.split_whitespace()[i]);\n\
    \            words.push(s.split_whitespace()[j]);\n            words.push(s.split_whitespace()[k]);\n\
    \            words.push(s.split_whitespace()[l]);\n            words.push(s.split_whitespace()[m]);\n\
    \            words.push(s.split_whitespace()[n]);\n            break;\n      \
    \  }\n        if n == 7 {\n            words.push(s.split_whitespace()[i]);\n\
    \            words.push(s.split_whitespace()[j]);\n            words.push(s.split_whitespace()[k]);\n\
    \            words.push(s.split_whitespace()[l]);\n            words.push(s.split_whitespace()[m]);\n\
    \            words.push(s.split_whitespace()[n]);\n            words.push(s.split_whitespace()[o]);\n\
    \            break;\n        }\n        if n == 8 {\n            words.push(s.split_whitespace()[i]);\n\
    \            words.push(s.split_whitespace()[j]);\n            words.push(s.split_whitespace()[k]);\n\
    \            words.push(s.split_whitespace()[l]);\n            word\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpo2b650_s.rs:111:3\n\
    \    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while i < s.len() {\n    |                       - unclosed delimiter\n\
    ...\n94  |         if n == 8 {\n    |                   - this delimiter might\
    \ not be properly closed...\n...\n100 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n111 | }\n    |   ^\n\nerror[E0425]: cannot find\
    \ value `l` in this scope\n  --> /tmp/tmpo2b650_s.rs:64:45\n   |\n64 |       \
    \      words.push(s.split_whitespace()[l]);\n   |                            \
    \                 ^ help: a local variable with a similar name exists: `c`\n\n\
    error[E0425]: cannot find value `l` in this scope\n  --> /tmp/tmpo2b650_s.rs:71:45\n\
    \   |\n71 |             words.push(s.split_whitespace()[l]);\n   |           \
    \                                  ^ help: a local variable with a similar name\
    \ exists: `c`\n\nerror[E0425]: cannot find value `m` in this scope\n  --> /tmp/tmpo2b650_s.rs:72:45\n\
    \   |\n72 |             words.push(s.split_whitespace()[m]);\n   |           \
    \                                  ^ help: a local variable with a similar name\
    \ exists: `c`\n\nerror[E0425]: cannot find value `l` in this scope\n  --> /tmp/tmpo2b650_s.rs:79:45\n\
    \   |\n79 |             words.push(s.split_whitespace()[l]);\n   |           \
    \                                  ^ help: a local variable with a similar name\
    \ exists: `c`\n\nerror[E0425]: cannot find value `m` in this scope\n  --> /tmp/tmpo2b650_s.rs:80:45\n\
    \   |\n80 |             words.push(s.split_whitespace()[m]);\n   |           \
    \                                  ^ help: a local variable with a similar name\
    \ exists: `c`\n\nerror[E0425]: cannot find value `l` in this scope\n  --> /tmp/tmpo2b650_s.rs:88:45\n\
    \   |\n88 |             words.push(s.split_whitespace()[l]);\n   |           \
    \                                  ^ help: a local variable with a similar name\
    \ exists: `c`\n\nerror[E0425]: cannot find value `m` in this scope\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: -1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut s = String::from(s);\n    let mut i = 0;\n\
    \    while i < s.len() {\n        let mut j = i;\n        while j < s.len() &&\
    \ s.chars().all(|c| c != ' ') {\n            j = j + 1;\n        }\n        if\
    \ j == s.len() {\n            break;\n        }\n        let mut word = String::from(&s[i\
    \ .. j]);\n        let mut count = 0;\n        for c in word.chars() {\n     \
    \       if c == ' ' {\n                continue;\n            }\n            if\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n               \
    \ count = count + 1;\n            }\n        }\n        if count == n {\n    \
    \        words.push(word);\n        }\n        i = j;\n    }\n    words\n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660010747
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut index = 0;\n    while index < s.len() {\n \
    \       let mut found = false;\n        for c in s.chars() {\n            if c.is_consonant()\
    \ && index != s.len() {\n                found = true;\n                break;\n\
    \            }\n        }\n        if found {\n            words.push(s.split_to(index).unwrap());\n\
    \            index += 1;\n        }\n    }\n    words\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp6jca44j0.rs:23:18\n   |\n23 |             if c.is_consonant()\
    \ && index != s.len() {\n   |                  ^^^^^^^^^^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `split_to` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp6jca44j0.rs:29:26\n   |\n29 |          \
    \   words.push(s.split_to(index).unwrap());\n   |                          ^^^^^^^^\
    \ help: there is an associated function with a similar name: `split`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = s;\n    let mut n = n;\n    while n !=\
    \ 0 {\n        if s.chars().any(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o'\
    \ && c != 'u') {\n            result.push(s.clone());\n        }\n        n -=\
    \ 1;\n        s = s.chars().take(n).collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0fecxp34.rs:26:28\n   |\n\
    26 |         s = s.chars().take(n).collect();\n   |                          \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n26 |         s\
    \ = s.chars().take(n.try_into().unwrap()).collect();\n   |                   \
    \          ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut index = 0;\n    while index < s.len() {\n     \
    \   let mut word = String::from(\"\");\n        let mut count = 0;\n        while\
    \ count < n && index < s.len() {\n            let c = s[index];\n            if\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' {\n               \
    \ word.push(c);\n                count += 1;\n            }\n            index\
    \ += 1\n        }\n        if word.len() == n {\n            words.push(word);\n\
    \        }\n    }\n    words\n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpg_0hkz7j.rs:24:21\n\
    \   |\n24 |             let c = s[index];\n   |                     ^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg_0hkz7j.rs:31:26\n\
    \   |\n31 |         if word.len() == n {\n   |                          ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n31 |         if word.len()\
    \ == n.try_into().unwrap() {\n   |                           ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = vec![\"b\", \"c\", \"d\", \"f\"\
    , \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\"\
    , \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels = vec![\"a\"\
    , \"e\", \"i\", \"o\", \"u\"];\n    let mut vowel_consonants = vec![\"a\", \"\
    e\", \"i\", \"o\", \"u\", \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"\
    x\", \"y\", \"z\"];\n    let mut vowel_consonant_pairs = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\", \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"\
    l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"\
    y\", \"z\"];\n    let mut vowel_consonant_triples = vec![\"a\", \"e\", \"i\",\
    \ \"o\", \"u\", \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\"];\n    let mut vowel_consonant_quadruples = vec![\"a\", \"e\", \"i\",\
    \ \"o\", \"u\", \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\"];\n    let mut vowel_consonant_quintuples = vec![\"a\", \"e\", \"i\",\
    \ \"o\", \"u\", \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\"];\n    let mut vowel_consonant_sextuples = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\", \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"\
    m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"\
    z\"];\n    let mut vowel_consonant_sexpentuples = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\", \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"\
    m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"\
    z\"];\n    let mut vowel_consonant_sexpentyuples = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\", \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"\n\
    }\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpgowc1d8h.rs:39:136\n\
    \   |\n39 |       assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n   | \
    \ ________________________________________________________________________________________________________________________________________^\n\
    40 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut s = String::from(s);\n    while s.len() > 0\
    \ {\n        let mut i = 0;\n        while i < s.len() && s.chars().any(|c| c.is_consonant()\
    \ && c != ' ') {\n            i += 1;\n        }\n        if i == s.len() {\n\
    \            break;\n        }\n        let mut j = i;\n        while j < s.len()\
    \ && s.chars().any(|c| c.is_consonant() && c != ' ') {\n            j += 1;\n\
    \        }\n        if j == s.len() {\n            break;\n        }\n       \
    \ let mut k = j;\n        while k < s.len() && s.chars().any(|c| c.is_consonant()\
    \ && c != ' ') {\n            k += 1;\n        }\n        if k == s.len() {\n\
    \            break;\n        }\n        let mut l = k;\n        while l < s.len()\
    \ && s.chars().any(|c| c.is_consonant() && c != ' ') {\n            l += 1;\n\
    \        }\n        if l == s.len() {\n            break;\n        }\n       \
    \ let mut m = l;\n        while m < s.len() && s.chars().any(|c| c.is_consonant()\
    \ && c != ' ') {\n            m += 1;\n        }\n        if m == s.len() {\n\
    \            break;\n        }\n        let mut n = m;\n        while n < s.len()\
    \ && s.chars().any(|c| c.is_consonant() && c != ' ') {\n            n += 1;\n\
    \        }\n        if n == s.len() {\n            break;\n        }\n       \
    \ let mut o = n;\n        while o < s.len() && s.chars().any(|c| c.is_consonant()\
    \ && c != ' ') {\n            o += 1;\n        }\n        if o == s.len() {\n\
    \            break;\n        }\n        let mut p = o;\n        while p < s.len()\
    \ && s.chars().any(|c| c.is_consonant() && c != ' ') {\n            p += 1;\n\
    \        }\n        if p == s.len() {\n            break;\n        }\n       \
    \ let mut q = p;\n        while q < s.len() && s.chars().any(|c| c.is_consonant()\
    \ && c != ' ') {\n            q += 1;\n        }\n        if q == s.len() {\n\
    \            break;\n        }\n        let mut r = q;\n        while r < s.len()\
    \ && s.chars().any(|c| c.is_consonant() && c != ' ') {\n            r += 1;\n\
    \        }\n        if r == s.len() {\n            break;\n        }\n       \
    \ let mut s = r;\n        while s < s.len() && s.chars().any(|c| \n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpvfab2g_t.rs:104:3\n\
    \    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    20  |     while s.len() > 0 {\n    |                       - this delimiter might\
    \ not be properly closed...\n...\n93  | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n104 | }\n    |   ^\n\nerror: expected expression,\
    \ found `)`\n  --> /tmp/tmpvfab2g_t.rs:93:1\n   |\n92 |         while s < s.len()\
    \ && s.chars().any(|c| \n   |         ----- while parsing the condition of this\
    \ `while` expression\n93 | }\n   | ^ expected expression\n\nerror: mismatched\
    \ closing delimiter: `}`\n  --> /tmp/tmpvfab2g_t.rs:92:43\n   |\n17 | fn select_words(s:\
    \ String, n: isize) -> Vec<String> {\n   |                                   \
    \                  - closing delimiter possibly meant for this\n...\n92 |    \
    \     while s < s.len() && s.chars().any(|c| \n   |                          \
    \                 ^ unclosed delimiter\n93 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0599]: no method named `is_consonant` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpvfab2g_t.rs:22:50\n   |\n22 |         while i < s.len()\
    \ && s.chars().any(|c| c.is_consonant() && c != ' ') {\n   |                 \
    \                                 ^^^^^^^^^^^^ method not found in `char`\n\n\
    error[E0599]: no method named `is_consonant` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpvfab2g_t.rs:29:50\n   |\n29 |         while j < s.len()\
    \ && s.chars().any(|c| c.is_consonant() && c != ' ') {\n   |                 \
    \                                 ^^^^^^^^^^^^ method not found in `char`\n\n\
    error[E0599]: no method named `is_consonant` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpvfab2g_t.rs:36:50\n   |\n36 |         while k < s.len()\
    \ && s.chars().any(|c| c.is_consonant() && c != ' ') {\n   |                 \
    \                                 ^^^^^^^^^^^^ method not found in `char`\n\n\
    error[E0599]: no method named `is_consonant` found for typ"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    \n}\n\n\
    fn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkv80rbe4.rs:17:41\n   |\n\
    17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------\
    \                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010741
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = Vec::new();\n    let mut s = String::from(s);\n    let mut n = n as\
    \ usize;\n    let mut i = 0;\n    while i < s.len() {\n        if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n            result.push(s.split_whitespace()[i]);\n\
    \            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had\
    \ a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpddte345c.rs:23:32\n   |\n23 |         if s.chars().all(|c|\
    \ c.is_consonant() && c != ' ') {\n   |                                ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmpddte345c.rs:24:25\n   |\n24 |         \
    \    result.push(s.split_whitespace()[i]);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        if s.chars().any(|c| c != ' ') {\n            if s.chars().all(|c|\
    \ c != ' ' && c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n  \
    \              words.push(s.subslice(i, i + n));\n                i += n;\n  \
    \          }\n        }\n        i += 1;\n    }\n    words\n}\n\nfn main() {\n\
    \    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary\
    \ had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `subslice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmptqxwg6bx.rs:24:30\n   |\n24 |                 words.push(s.subslice(i,\
    \ i + n));\n   |                              ^^^^^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptqxwg6bx.rs:24:46\n   |\n24 |\
    \                 words.push(s.subslice(i, i + n));\n   |                    \
    \                          ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add `isize` to `usize`\n  --> /tmp/tmptqxwg6bx.rs:24:44\n   |\n24 | \
    \                words.push(s.subslice(i, i + n));\n   |                     \
    \                       ^ no implementation for `usize + isize`\n   |\n   = help:\
    \ the trait `Add<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptqxwg6bx.rs:25:22\n   |\n25 |                 i += n;\n\
    \   |                      ^ expected `usize`, found `isize`\n\nerror[E0277]:\
    \ cannot add-assign `isize` to `usize`\n  --> /tmp/tmptqxwg6bx.rs:25:19\n   |\n\
    25 |                 i += n;\n   |                   ^^ no implementation for\
    \ `usize += isize`\n   |\n   = help: the trait `AddAssign<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more informatio"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut index = 0;\n    while index < s.len() {\n     \
    \   let mut found = false;\n        let mut i = 0;\n        while i < n && !found\
    \ {\n            if s[index] == ' ' {\n                found = true;\n       \
    \     } else {\n                i += 1;\n            }\n        }\n        if\
    \ found {\n            words.push(s.split_whitespace()[index..]);\n          \
    \  index += 1;\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate\
    \ = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmeo791t0.rs:24:16\n\
    \   |\n24 |             if s[index] == ' ' {\n   |                ^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpmeo791t0.rs:31:24\n   |\n31 |             words.push(s.split_whitespace()[index..]);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0608.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ result = vec![];\n    let mut s = s;\n    while s.len() > n {\n        let mut\
    \ index = s.find(' ', n);\n        if index == s.len() {\n            result.push(s.clone());\n\
    \            break;\n        }\n        let mut word = s.split_at(index);\n  \
    \      if word.len() == 1 {\n            result.push(word.clone());\n        }\
    \ else {\n            result.push(word.clone());\n            result.push(word.clone());\n\
    \        }\n        s = &s[(index + 1)..];\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3puddnlm.rs:20:21\n   |\n\
    20 |     while s.len() > n {\n   |                     ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     while s.len() > n.try_into().unwrap()\
    \ {\n   |                      ++++++++++++++++++++\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp3puddnlm.rs:21:27\n\
    \     |\n21   |         let mut index = s.find(' ', n);\n     |              \
    \             ^^^^ ---  - supplied 2 arguments\n     |                       \
    \    |\n     |                           expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3puddnlm.rs:22:21\n\
    \   |\n22 |         if index == s.len() {\n   |                     ^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n22 |         if index == Some(s.len()) {\n   |                     +++++\
    \       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3puddnlm.rs:26:35\n\
    \   |\n26 |         let mut word = s.split_at(index);\n   |                  \
    \                 ^^^^^ expected `usize`, found enum `Option`\n   |\n   = note:\
    \ expected type `usize`\n              found enum `Option<usize>`\n\nerror[E0599]:\
    \ no method named `len` found for tuple `(&str, &str)` in the current scope\n\
    \  --> /tmp/tmp3puddnlm.rs:27:17\n   |\n27 |         if word.len() == 1 {\n  \
    \ |                 ^^^ method not found in `(&str, &str)`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3puddnlm.rs:28:25\n   |\n28 |             result.push(word.clone());\n\
    \   |                         ^^^^^^^^^^^^ expected struct `String`, found tuple\n\
    \   |\n   = note: expected struct `String`\n               found tuple `(&str,\
    \ &str)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3puddnlm.rs:30:25\n\
    \   |\n30 |             result.push(word.clone());\n   |                     \
    \    ^^^^^^^^^^^^ expected struct `St"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = vec![];\n    let mut count = 0;\n    for c in s.chars() {\n        if\
    \ c.is_consonant() {\n            count += 1;\n            if count == n {\n \
    \               words.push(c.to_string());\n                count = 0;\n     \
    \       }\n        }\n    }\n    words\n}\n\nfn main() {\n    let candidate =\
    \ select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"\
    Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"\
    world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"\
    Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n\
    \    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"\
    b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_consonant` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp6iv3apxb.rs:21:14\n   |\n21 |         if c.is_consonant()\
    \ {\n   |              ^^^^^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010742
- exit_code: 1
  program: "/// Given a string s and a natural number n, you have been tasked to implement\
    \ \n/// a function that returns a list of all words from string s that contain\
    \ exactly \n/// n consonants, in order these words appear in the string s.\n///\
    \ If the string s is empty then the function should return an empty list.\n///\
    \ Note: you may assume the input string contains only letters and spaces.\n///\
    \ Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n\
    /// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had\
    \ a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\"\
    )]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n\
    /// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"\
    world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"\
    Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut\
    \ words = Vec::new();\n    let mut consonants = Vec::new();\n    let mut vowels\
    \ = Vec::new();\n    let mut vowel_consonants = Vec::new();\n    let mut vowel_consonant_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels = Vec::new();\n   \
    \ let mut vowel_consonant_vowels_vowels_vowels = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut vowel_consonant_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels_vowels\
    \ = Vec::new();\n    let mut \n}\n\nfn main() {\n    let candidate = select_words;\n\
    \    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"\
    little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"\
    ), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"\
    simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"\
    Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"\
    Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\
    \"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c\
    \ d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"\
    d\"), String::from(\"f\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpi9ootj5y.rs:39:1\n\
    \   |\n39 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010741
