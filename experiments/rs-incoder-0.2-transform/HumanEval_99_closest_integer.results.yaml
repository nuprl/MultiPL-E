language: rs
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().filter(|&(_,\
    \ c)| c.is_numeric());\n    let mut result = value.chars().enumerate().filter(|&(_,\
    \ c)| c.is_numeric()).max().unwrap();\n    let mut i = 0;\n    while i < digits.len()\
    \ && digits[i].1.is_some() {\n        i += 1;\n    }\n    digits[i].1.unwrap().unwrap().parse().unwrap()\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp3_hn4_cd.rs:27:17\n\
    \   |\n27 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3_hn4_cd.rs:27:25\n   |\n27 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp3_hn4_cd.rs:28:17\n   |\n28 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp3_hn4_cd.rs:28:25\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp3_hn4_cd.rs:29:17\n   |\n29 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp3_hn4_cd.rs:29:25\n   |\n29 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp3_hn4_cd.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp3_hn4_cd.rs:30:25\n   |\n30 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp3_hn4_cd.rs:31:17\n  \
    \ |\n31 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3_hn4_cd.rs:31:25\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `len` found for struct `Filter` in the current scope\n  --> /tmp/tmp3_hn4_cd.rs:19:22\n\
    \   |\n19 |     while i < digits.len() && digits[i].1.is_some() {\n   |      \
    \                ^^^"
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().filter(|&(_,\
    \ c)| c != '0');\n    let mut result = value.chars().enumerate().filter(|&(_,\
    \ c)| c != '0');\n    let mut closest_value = result.next().unwrap();\n    let\
    \ mut closest_digits = digits.next().unwrap();\n    let mut closest_result = result.next().unwrap();\n\
    \    let mut closest_digit = closest_digits.next().unwrap();\n    let mut closest_result\
    \ = result.next().unwrap();\n    let mut closest_digit = closest_digits.next().unwrap();\n\
    \    let mut closest_result = result.next().unwrap();\n    let mut closest_digit\
    \ = closest_digits.next().unwrap();\n    let mut closest_result = result.next().unwrap();\n\
    \    let mut closest_digit = closest_digits.next().unwrap();\n    let mut closest_result\
    \ = result.next().unwrap();\n    let mut closest_digit = closest_digits.next().unwrap();\n\
    \    let mut closest_result = result.next().unwrap();\n    let mut closest_digit\
    \ = closest_digits.next().unwrap();\n    let mut closest_result = result.next().unwrap();\n\
    \    let mut closest_digit = closest_digits.next().unwrap();\n    let mut closest_result\
    \ = result.next().unwrap();\n    let mut closest_digit = closest_digits.next().unwrap();\n\
    \    let mut closest_result = result.next().unwrap();\n    let mut closest_digit\
    \ = closest_digits.next().unwrap();\n    let mut closest_result = result.next().unwrap();\n\
    \    let mut closest_digit = closest_digits.next().unwrap();\n    let mut closest_result\
    \ = result.next().unwrap();\n    let mut closest_digit = closest_digits.next().unwrap();\n\
    \    let mut closest_result = result.next().unwrap();\n    let mut closest_digit\
    \ = closest_digits.next().unwrap();\n    let mut closest_result = result.next().unwrap();\n\
    \    let mut closest_digit = closest_digits.next().unwrap();\n    let mut closest_result\
    \ = result.next().unwrap();\n    let mut closest_digit = closest_digits.next().unwrap();\n\
    \    let mut closest_result = result.next().unwrap();\n    let mut closest_digit\
    \ = closest_digits.next().unwrap();\n    let mut closest_result = result.next().unwrap();\n\
    \    let mut closest_digit = closest_digits.next().unwrap();\n    let mut closest_result\
    \ = result.next().unwrap();\n    let mut closest_digit = closest_digits.next().unwrap();\n\
    \    let mut closest_result = result.next().unwrap();\n    let mut closest_digit\
    \ = closest_digits.next().unwrap();\n    let mut closest_result = result.next().unwrap();\n\
    \    let mut closest_digit = closest_digits.next().unwrap();\n    let mut closest_result\
    \ = result.next().unwrap();\n    let mut closest_digit = closest_digits.next().unwrap();\n\
    \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpbb9rrg5u.rs:65:17\n\
    \   |\n65 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpbb9rrg5u.rs:65:25\n   |\n65 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpbb9rrg5u.rs:66:17\n   |\n66 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpbb9rrg5u.rs:66:25\n\
    \   |\n66 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpbb9rrg5u.rs:67:17\n   |\n67 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpbb9rrg5u.rs:67:25\n   |\n67 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpbb9rrg5u.rs:68:17\n   |\n68 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpbb9rrg5u.rs:68:25\n   |\n68 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpbb9rrg5u.rs:69:17\n  \
    \ |\n69 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpbb9rrg5u.rs:69:25\n   |\n69 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `next` found for tuple `(usize, char)` in the current scope\n  --> /tmp/tmpbb9rrg5u.rs:21:44\n\
    \   |\n21 |     let mut closest_digit = closest_digits.next().unwrap();\n   |\
    \            "
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if digits[i] != '.' {\n            digits =\
    \ &digits[i..];\n            break;\n        }\n        i += 1;\n    }\n    let\
    \ mut digits = digits.chars().nth(1).unwrap();\n    let mut result = value.chars().nth(1).unwrap();\n\
    \    let mut i = 0;\n    while i < value.len() {\n        if digits[i] != '.'\
    \ {\n            digits = &digits[i..];\n            break;\n        }\n     \
    \   i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n   \
    \ let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n    while\
    \ i < value.len() {\n        if digits[i] != '.' {\n            digits = &digits[i..];\n\
    \            break;\n        }\n        i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if digits[i] != '.' {\n            digits =\
    \ &digits[i..];\n            break;\n        }\n        i += 1;\n    }\n    let\
    \ mut digits = digits.chars().nth(1).unwrap();\n    let mut result = value.chars().nth(1).unwrap();\n\
    \    let mut i = 0;\n    while i < value.len() {\n        if digits[i] != '.'\
    \ {\n            digits = &digits[i..];\n            break;\n        }\n     \
    \   i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n   \
    \ let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n    while\
    \ i < value.len() {\n        if digits[i] != '.' {\n            digits = &digits[i..];\n\
    \            break;\n        }\n        i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if digits[i] != '.' {\n            digits =\
    \ &digits[i..];\n            break;\n        }\n        i += 1;\n    }\n    let\
    \ mut digits = digits.chars().nth(1).unwrap();\n    let mut result = value.chars().nth(1).unwrap();\n\
    \    let mut i = 0;\n    while i < value.len() {\n        if digits[i] != '.'\
    \ {\n            digits = \n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpfsc57qcd.rs:101:3\n\
    \    |\n14  | fn closest_integer(value: String) -> isize {\n    |            \
    \                                - unclosed delimiter\n...\n89  |     while i\
    \ < value.len() {\n    |                           - unclosed delimiter\n90  |\
    \         if digits[i] != '.' {\n    |                             - this delimiter\
    \ might not be properly closed...\n91  |             digits = \n92  | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n101 | }\n   \
    \ |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpfsc57qcd.rs:92:1\n\
    \   |\n92 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpfsc57qcd.rs:96:17\n   |\n96 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpfsc57qcd.rs:96:25\n \
    \  |\n96 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpfsc57qcd.rs:97:17\n   |\n97 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpfsc57qcd.rs:97:25\n   |\n97 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpfsc57qcd.rs:98:17\n   |\n98 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpfsc57qcd.rs:98:25\n   |\n98 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpfsc57qcd.rs:99:17\n  \
    \ |\n99 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfsc57qcd.rs:99:25\n   |\n99 |     assert_eq!({left"
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut v = value.to_string();\n    let mut digits = v.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_digit(16).unwrap()\n        }\n    });\n   \
    \ let mut digits = digits.collect::<Vec<_>>();\n    let mut min = digits[0];\n\
    \    let mut max = digits[0];\n    for &d in &digits[1..] {\n        if d < min\
    \ {\n            min = d;\n        }\n        if d > max {\n            max =\
    \ d;\n        }\n    }\n    let mut mid = min + (max - min) / 2;\n    if mid <\
    \ 0 {\n        mid += 1;\n    }\n    mid\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpva_l_4zc.rs:43:17\n\
    \   |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpva_l_4zc.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpva_l_4zc.rs:44:17\n   |\n44 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpva_l_4zc.rs:44:25\n\
    \   |\n44 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpva_l_4zc.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpva_l_4zc.rs:45:25\n   |\n45 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpva_l_4zc.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpva_l_4zc.rs:46:25\n   |\n46 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpva_l_4zc.rs:47:17\n  \
    \ |\n47 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpva_l_4zc.rs:47:25\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpva_l_4zc.rs:38:5\n   |\n14 | fn closest_integer(value:\
    \ String) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n..."
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut result = 0.0;\n    let mut\
    \ last_digit = 0.0;\n    let mut last_digit2 = 0.0;\n    let mut last_digit3 =\
    \ 0.0;\n    let mut last_digit4 = 0.0;\n    let mut last_digit5 = 0.0;\n    let\
    \ mut last_digit6 = 0.0;\n    let mut last_digit7 = 0.0;\n    let mut last_digit8\
    \ = 0.0;\n    let mut last_digit9 = 0.0;\n    let mut last_digit10 = 0.0;\n  \
    \  let mut last_digit11 = 0.0;\n    let mut last_digit12 = 0.0;\n    let mut last_digit13\
    \ = 0.0;\n    let mut last_digit14 = 0.0;\n    let mut last_digit15 = 0.0;\n \
    \   let mut last_digit16 = 0.0;\n    let mut last_digit17 = 0.0;\n    let mut\
    \ last_digit18 = 0.0;\n    let mut last_digit19 = 0.0;\n    let mut last_digit20\
    \ = 0.0;\n    let mut last_digit21 = 0.0;\n    let mut last_digit22 = 0.0;\n \
    \   let mut last_digit23 = 0.0;\n    let mut last_digit24 = 0.0;\n    let mut\
    \ last_digit25 = 0.0;\n    let mut last_digit26 = 0.0;\n    let mut last_digit27\
    \ = 0.0;\n    let mut last_digit28 = 0.0;\n    let mut last_digit29 = 0.0;\n \
    \   let mut last_digit30 = 0.0;\n    let mut last_digit31 = 0.0;\n    let mut\
    \ last_digit32 = 0.0;\n    let mut last_digit33 = 0.0;\n    let mut last_digit34\
    \ = 0.0;\n    let mut last_digit35 = 0.0;\n    let mut last_digit36 = 0.0;\n \
    \   let mut last_digit37 = 0.0;\n    let mut last_digit38 = 0.0;\n    let mut\
    \ last_digit39 = 0.0;\n    let mut last_digit40 = 0.0;\n    let mut last_digit41\
    \ = 0.0;\n    let mut last_digit42 = 0.0;\n    let mut last_digit43 = 0.0;\n \
    \   let mut last_digit44 = 0.0;\n    let mut last_digit45 = 0.0;\n    let mut\
    \ last_digit46 = 0.0;\n    let mut last_digit47 = 0.0;\n    let mut last_digit48\
    \ = 0.0;\n    let mut last_digit49 = 0.0;\n    let mut last_digit50 = 0.0;\n \
    \   let mut last_digit51 = 0.0;\n    let mut last_digit5\n}\n\nfn main() {\n \
    \   let candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv_zvhqw5.rs:69:24\n   |\n\
    69 |     let mut last_digit5\n   |                        ^ help: add `;` here\n\
    70 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n  --> /tmp/tmpv_zvhqw5.rs:74:17\n   |\n74 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpv_zvhqw5.rs:74:25\n   |\n74 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpv_zvhqw5.rs:75:17\n   |\n75 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpv_zvhqw5.rs:75:25\n   |\n75 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpv_zvhqw5.rs:76:17\n  \
    \ |\n76 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpv_zvhqw5.rs:76:25\n   |\n76 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpv_zvhqw5.rs:77:17\n   |\n77 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpv_zvhqw5.rs:77:25\n\
    \   |\n77 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpv_zvhqw5.rs:78:17\n   |\n78 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpv_zvhqw5.rs:78:25\n   |\n78 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types"
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if digits[i] != '.' {\n            digits =\
    \ &digits[..i];\n            break;\n        }\n        i += 1;\n    }\n    let\
    \ mut digits = digits.chars().nth(1).unwrap();\n    let mut i = 0;\n    while\
    \ i < value.len() {\n        if digits[i] != '.' {\n            digits = &digits[..i];\n\
    \            break;\n        }\n        i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut i = 0;\n    while i < value.len() {\n        if digits[i] != '.'\
    \ {\n            digits = &digits[..i];\n            break;\n        }\n     \
    \   i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n   \
    \ let mut i = 0;\n    while i < value.len() {\n        if digits[i] != '.' {\n\
    \            digits = &digits[..i];\n            break;\n        }\n        i\
    \ += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let\
    \ mut i = 0;\n    while i < value.len() {\n        if digits[i] != '.' {\n   \
    \         digits = &digits[..i];\n            break;\n        }\n        i +=\
    \ 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let mut\
    \ i = 0;\n    while i < value.len() {\n        if digits[i] != '.' {\n       \
    \     digits = &digits[..i];\n            break;\n        }\n        i += 1;\n\
    \    }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let mut i =\
    \ 0;\n    while i < value.len() {\n        if digits[i] != '.' {\n           \
    \ digits = &digits[..i];\n            break;\n        }\n        i += 1;\n   \
    \ }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let mut i = 0;\n\
    \    while i < value.len() {\n        if digits[i] != '.' {\n            digits\
    \ = &digits[..i];\n            break;\n        }\n        i += 1;\n    }\n   \
    \ let mut digits = digits.chars().nth(1).unwrap();\n    let mut i = 0;\n    while\
    \ i < value.len() {\n        if digits[i] != '.' {\n            digits = &digits[..i];\n\
    \            break;\n        }\n        i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n   --> /tmp/tmpyh4adedh.rs:104:17\n\
    \    |\n104 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpyh4adedh.rs:104:25\n    |\n104 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpyh4adedh.rs:105:17\n\
    \    |\n105 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpyh4adedh.rs:105:25\n    |\n105 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpyh4adedh.rs:106:17\n\
    \    |\n106 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpyh4adedh.rs:106:25\n    |\n106 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpyh4adedh.rs:107:17\n\
    \    |\n107 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpyh4adedh.rs:107:25\n    |\n107 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpyh4adedh.rs:108:17\n\
    \    |\n108 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpyh4adedh.rs:108:25\n    |\n108 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0608]:\
    \ cannot index into a value of type `char`\n  --> /tmp/tmpyh4adedh.rs:20:12\n\
    \   |\n20 |         if digits[i] != '.' {\n   |            ^^^^^^^^^\n\nerro"
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    if value.chars().count() > 1 {\n  \
    \      value = value.chars().nth(1).unwrap();\n    }\n    let mut value = value.parse::<isize>().unwrap();\n\
    \    if value % 2 == 0 {\n        value -= 1;\n    }\n    value\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpsm2hrwjk.rs:28:17\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpsm2hrwjk.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpsm2hrwjk.rs:29:17\n   |\n29 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpsm2hrwjk.rs:29:25\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpsm2hrwjk.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpsm2hrwjk.rs:30:25\n   |\n30 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpsm2hrwjk.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpsm2hrwjk.rs:31:25\n   |\n31 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpsm2hrwjk.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpsm2hrwjk.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsm2hrwjk.rs:17:17\n   |\n17 |         value = value.chars().nth(1).unwrap();\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method:"
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if digits[i] != '.' {\n            digits =\
    \ digits.chars().nth(1).unwrap();\n            result = result.chars().nth(1).unwrap();\n\
    \        }\n        if result.is_numeric() {\n            if result.len() < digits.len()\
    \ {\n                digits = digits.chars().nth(1).unwrap();\n              \
    \  result = result.chars().nth(1).unwrap();\n            } else {\n          \
    \      digits = digits.chars().nth(1).unwrap();\n                result = result.chars().nth(1).unwrap();\n\
    \            }\n        } else {\n            digits = digits.chars().nth(1).unwrap();\n\
    \            result = result.chars().nth(1).unwrap();\n        }\n        i +=\
    \ 1;\n    }\n    value.parse().unwrap()\n}\n\nfn main() {\n    let candidate =\
    \ closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpdjzcfask.rs:43:17\n\
    \   |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpdjzcfask.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpdjzcfask.rs:44:17\n   |\n44 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpdjzcfask.rs:44:25\n\
    \   |\n44 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpdjzcfask.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpdjzcfask.rs:45:25\n   |\n45 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpdjzcfask.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpdjzcfask.rs:46:25\n   |\n46 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpdjzcfask.rs:47:17\n  \
    \ |\n47 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpdjzcfask.rs:47:25\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0608]: cannot\
    \ index into a value of type `char`\n  --> /tmp/tmpdjzcfask.rs:20:12\n   |\n20\
    \ |         if digits[i] != '.' {\n   |            ^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `chars` found for type `"
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if digits[i] != '.' {\n            digits =\
    \ &digits[1..];\n        }\n        let mut digit = digits[i] - '0';\n       \
    \ if digit < 0 {\n            digit = digit * -1;\n        }\n        if digit\
    \ > result {\n            result = digit;\n        }\n        i += 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpscs03qto.rs:37:17\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpscs03qto.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpscs03qto.rs:38:17\n   |\n38 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpscs03qto.rs:38:25\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpscs03qto.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpscs03qto.rs:39:25\n   |\n39 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpscs03qto.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpscs03qto.rs:40:25\n   |\n40 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpscs03qto.rs:41:17\n  \
    \ |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpscs03qto.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0608]: cannot\
    \ index into a value of type `char`\n  --> /tmp/tmpscs03qto.rs:20:12\n   |\n20\
    \ |         if digits[i] != '.' {\n   |            ^^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `char`"
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_digit(16).unwrap()\n        }\n    });\n   \
    \ let mut result = value.chars().enumerate().map(|(i, c)| {\n        if c.is_numeric()\
    \ {\n            c.to_digit(10).unwrap()\n        } else {\n            c.to_digit(16).unwrap()\n\
    \        }\n    });\n    let mut min = result.len();\n    let mut max = result.len();\n\
    \    let mut mid = 0;\n    let mut i = 0;\n    while i < min {\n        mid =\
    \ i + (min - i);\n        if result[mid] < value {\n            min = mid;\n \
    \       } else {\n            max = mid;\n        }\n        i += 1;\n    }\n\
    \    while i < max {\n        mid = i + (max - i);\n        if result[mid] > value\
    \ {\n            max = mid;\n        } else {\n            min = mid;\n      \
    \  }\n        i += 1;\n    }\n    if min == max {\n        min\n    } else {\n\
    \        mid\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpco66fpaz.rs:61:17\n\
    \   |\n61 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpco66fpaz.rs:61:25\n   |\n61 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpco66fpaz.rs:62:17\n   |\n62 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpco66fpaz.rs:62:25\n\
    \   |\n62 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpco66fpaz.rs:63:17\n   |\n63 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpco66fpaz.rs:63:25\n   |\n63 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpco66fpaz.rs:64:17\n   |\n64 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpco66fpaz.rs:64:25\n   |\n64 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpco66fpaz.rs:65:17\n  \
    \ |\n65 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpco66fpaz.rs:65:25\n   |\n65 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: the method\
    \ `len` exists for struct `Map<Enumerate<Chars<'_>>, [closure@/tmp/tmpco66fpaz.rs:23:52:\
    \ 29:6]>`, but its trait bounds were not satisfied\n  --> /tmp/tmpco66fpaz.rs:30:26\n\
    \   |\n30 |      "
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_digit() {\n            c.to_digit(10).unwrap()\n    \
    \    } else {\n            i\n        }\n    });\n    let mut smallest = std::i32::MAX;\n\
    \    let mut largest = std::i32::MIN;\n    let mut midpoint: isize;\n    let mut\
    \ midpoint_digit: isize;\n    let mut midpoint_digits: Vec<isize>;\n    for digit\
    \ in digits {\n        let digit = digit.unwrap();\n        if digit < smallest\
    \ {\n            smallest = digit;\n        }\n        if digit > largest {\n\
    \            largest = digit;\n        }\n    }\n    midpoint = largest / 2;\n\
    \    midpoint_digit = largest % 2;\n    midpoint_digits = vec![midpoint, midpoint\
    \ + 1];\n    let mut midpoint_digit = midpoint_digit;\n    let mut midpoint_digits\
    \ = midpoint_digits;\n    let mut midpoint_digit = midpoint_digit;\n    let mut\
    \ midpoint_digits = midpoint_digits;\n    let mut midpoint_digit = midpoint_digit;\n\
    \    let mut midpoint_digits = midpoint_digits;\n    let mut midpoint_digit =\
    \ midpoint_digit;\n    let mut midpoint_digits = midpoint_digits;\n    let mut\
    \ midpoint_digit = midpoint_digit;\n    let mut midpoint_digits = midpoint_digits;\n\
    \    let mut midpoint_digit = midpoint_digit;\n    let mut midpoint_digits = midpoint_digits;\n\
    \    let mut midpoint_digit = midpoint_digit;\n    let mut midpoint_digits = midpoint_digits;\n\
    \    let mut midpoint_digit = midpoint_digit;\n    let mut midpoint_digits = midpoint_digits;\n\
    \    let mut midpoint_digit = midpoint_digit;\n    let mut midpoint_digits = midpoint_digits;\n\
    \    let mut midpoint_digit = midpoint_digit;\n    let mut midpoint_digits = midpoint_digits;\n\
    \    let mut midpoint_digit = midpoint_digit;\n    let mut midpoint_digits = midpoint_digits;\n\
    \    let mut midpoint_digit = midpoint_digit;\n    let mut midpoint_digits = midpoint_digits;\n\
    \    let mut midpoint_digit = midpoint_digit;\n    let mut midpoint_digits = midpoint_digits;\n\
    \    let mut midpoint_digit = midpoint_digit;\n    let mut midpoint_digits = midpoint_\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1z7xjg13.rs:67:40\n   |\n\
    67 |     let mut midpoint_digits = midpoint_\n   |                           \
    \             ^ help: add `;` here\n68 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `midpoint_` in this scope\n  --> /tmp/tmp1z7xjg13.rs:67:31\n\
    \   |\n67 |     let mut midpoint_digits = midpoint_\n   |                    \
    \           ^^^^^^^^^ help: a local variable with a similar name exists: `midpoint`\n\
    \nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp1z7xjg13.rs:72:17\n\
    \   |\n72 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp1z7xjg13.rs:72:25\n   |\n72 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp1z7xjg13.rs:73:17\n   |\n73 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp1z7xjg13.rs:73:25\n\
    \   |\n73 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp1z7xjg13.rs:74:17\n   |\n74 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp1z7xjg13.rs:74:25\n   |\n74 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp1z7xjg13.rs:75:17\n   |\n75 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp1z7xjg13.rs:75:25\n   |\n75 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp1z7xjg13.rs:76:17\n  \
    \ |\n76 |     assert_eq!({left}, "
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut digit =\
    \ digits.iter().next().unwrap();\n    let mut i = 0;\n    let mut j = 0;\n   \
    \ let mut k = 0;\n    while i < result.len() {\n        if digits[k] == digit\
    \ {\n            i += 1;\n            j += 1;\n        } else {\n            i\
    \ += 1;\n        }\n        k += 1;\n        if k == digits.len() {\n        \
    \    k = 0;\n        }\n    }\n    result.truncate(i);\n    result.parse().unwrap()\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpmobam8fz.rs:40:17\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmobam8fz.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpmobam8fz.rs:41:17\n   |\n41 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpmobam8fz.rs:41:25\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpmobam8fz.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpmobam8fz.rs:42:25\n   |\n42 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpmobam8fz.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpmobam8fz.rs:43:25\n   |\n43 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpmobam8fz.rs:44:17\n  \
    \ |\n44 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmobam8fz.rs:44:25\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmobam8fz.rs:23:25\n   |\n23 |         if digits[k] == digit\
    \ {\n   |                         ^^^^^ expected `char`, found `&char`\n   |\n\
    help: consider dereferencing the"
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut exponent = 0;\n\
    \    while let Some(digit) = digits.next() {\n        let mut next_digit = digits.next().unwrap();\n\
    \        if next_digit == digit {\n            exponent += 1;\n        } else\
    \ {\n            break;\n        }\n    }\n    if exponent == 0 {\n        return\
    \ value.parse().unwrap();\n    }\n    let mut result = value.chars().nth(1).unwrap();\n\
    \    let mut exponent = 0;\n    while let Some(digit) = digits.next() {\n    \
    \    let mut next_digit = digits.next().unwrap();\n        if next_digit == digit\
    \ {\n            exponent += 1;\n        } else {\n            break;\n      \
    \  }\n    }\n    if exponent == 0 {\n        return value.parse().unwrap();\n\
    \    }\n    let mut result = value.chars().nth(1).unwrap();\n    let mut exponent\
    \ = 0;\n    while let Some(digit) = digits.next() {\n        let mut next_digit\
    \ = digits.next().unwrap();\n        if next_digit == digit {\n            exponent\
    \ += 1;\n        } else {\n            break;\n        }\n    }\n    if exponent\
    \ == 0 {\n        return value.parse().unwrap();\n    }\n    let mut result =\
    \ value.chars().nth(1).unwrap();\n    let mut exponent = 0;\n    while let Some(digit)\
    \ = digits.next() {\n        let mut next_digit = digits.next().unwrap();\n  \
    \      if next_digit == digit {\n            exponent += 1;\n        } else {\n\
    \            break;\n        }\n    }\n    if exponent == 0 {\n        return\
    \ value.parse().unwrap();\n    }\n    let mut result = value.chars().nth(1).unwrap();\n\
    \    let mut exponent = 0;\n    while let Some(digit) = digits.next() {\n    \
    \    let mut next_digit = digits.next().unwrap();\n        if next_digit == digit\
    \ {\n            exponent += 1;\n        } else {\n            break;\n      \
    \  }\n    }\n    if exponent == 0 {\n        return value.parse().unwrap();\n\
    \    }\n    let mut result = value.chars().nth(1).unwrap();\n    let mut exponent\
    \ = 0;\n    while let Some(digit) = digits.next() {\n        let mut next_digit\
    \ = digits.next().unwrap();\n        if next_digit == digit {\n            exponent\
    \ += 1;\n        } else {\n            break;\n        }\n    }\n    if exponent\
    \ == 0 {\n        return value.parse().unwrap();\n    }\n    let mut result =\
    \ value.chars().nth(1).unwrap();\n    let mut exponent = 0;\n    while let Some(digit)\
    \ = digits.next() {\n        let mut next_digit = digits.next().unwrap();\n  \
    \      if next_digit == digit {\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmphk310z8g.rs:109:3\n\
    \    |\n14  | fn closest_integer(value: String) -> isize {\n    |            \
    \                                - unclosed delimiter\n...\n97  |     while let\
    \ Some(digit) = digits.next() {\n    |                                       \
    \    - unclosed delimiter\n98  |         let mut next_digit = digits.next().unwrap();\n\
    99  |         if next_digit == digit {\n    |                                -\
    \ this delimiter might not be properly closed...\n100 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n109 | }\n    |   ^\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmphk310z8g.rs:104:17\n\
    \    |\n104 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmphk310z8g.rs:104:25\n    |\n104 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmphk310z8g.rs:105:17\n\
    \    |\n105 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmphk310z8g.rs:105:25\n    |\n105 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmphk310z8g.rs:106:17\n\
    \    |\n106 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmphk310z8g.rs:106:25\n    |\n106 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmphk310z8g.rs:107:17\n\
    \    |\n107 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmphk310z8g.rs:107:25\n    |\n107 |     assert_eq!({left}"
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_digit(16).unwrap()\n        }\n    });\n   \
    \ let mut result = digits[0];\n    let mut min_diff = std::i32::MAX;\n    for\
    \ i in 1..digits.len() {\n        let diff = digits[i] - digits[i - 1];\n    \
    \    if diff < min_diff {\n            min_diff = diff;\n            result =\
    \ digits[i];\n        }\n    }\n    result.parse::<isize>().unwrap()\n}\n\nfn\
    \ main() {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpoovranqf.rs:37:17\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpoovranqf.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpoovranqf.rs:38:17\n   |\n38 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpoovranqf.rs:38:25\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpoovranqf.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpoovranqf.rs:39:25\n   |\n39 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpoovranqf.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpoovranqf.rs:40:25\n   |\n40 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpoovranqf.rs:41:17\n  \
    \ |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpoovranqf.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0608]: cannot\
    \ index into a value of type `Map<Enumerate<Chars<'_>>, [closure@/tmp/tmpoovranqf.rs:16:52:\
    \ 22:6]>`\n  --> /tmp/tmpoovranqf.rs:23:22\n   |\n23 |     let mut result = digits[0];\n\
    \   |           "
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut closest_digit = digits[0];\n\
    \    let mut closest_distance = std::cmp::max(1, digits[0]);\n    for digit in\
    \ &digits[1..] {\n        let distance = std::cmp::max(\n            std::cmp::min(closest_distance,\
    \ digit),\n            digit,\n        );\n        if distance < closest_distance\
    \ {\n            closest_distance = distance;\n            closest_digit = digit;\n\
    \        }\n    }\n    closest_digit\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpfcg5xgnf.rs:34:17\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfcg5xgnf.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpfcg5xgnf.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpfcg5xgnf.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpfcg5xgnf.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpfcg5xgnf.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpfcg5xgnf.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpfcg5xgnf.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpfcg5xgnf.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfcg5xgnf.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfcg5xgnf.rs:18:49\n   |\n18 |     let mut closest_distance\
    \ = std::cmp::max(1, digits[0]);\n   |                                       \
    \          ^^^^^^^^^ expected int"
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut closest_digit = digits[0];\n\
    \    let mut closest_digits = &digits[1..];\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n    let mut closest_integer = isize::MAX;\n\
    \    let mut closest_integer = isize::MAX;\n\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpd56kwapo.rs:62:17\n\
    \   |\n62 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpd56kwapo.rs:62:25\n   |\n62 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpd56kwapo.rs:63:17\n   |\n63 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpd56kwapo.rs:63:25\n\
    \   |\n63 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpd56kwapo.rs:64:17\n   |\n64 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpd56kwapo.rs:64:25\n   |\n64 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpd56kwapo.rs:65:17\n   |\n65 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpd56kwapo.rs:65:25\n   |\n65 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpd56kwapo.rs:66:17\n  \
    \ |\n66 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpd56kwapo.rs:66:25\n   |\n66 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd56kwapo.rs:14:38\n   |\n14 | fn closest_integer(value:\
    \ String) -> isize {\n   |    ---------------                   ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   "
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    if value.chars().count() > 0 {\n  \
    \      value = value.chars().nth(1).unwrap();\n    }\n    let mut value = value.parse::<isize>().unwrap();\n\
    \    if value < 0 {\n        value += 1;\n    }\n    value\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpcaqymtlh.rs:28:17\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpcaqymtlh.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpcaqymtlh.rs:29:17\n   |\n29 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpcaqymtlh.rs:29:25\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpcaqymtlh.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpcaqymtlh.rs:30:25\n   |\n30 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpcaqymtlh.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpcaqymtlh.rs:31:25\n   |\n31 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpcaqymtlh.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpcaqymtlh.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcaqymtlh.rs:17:17\n   |\n17 |         value = value.chars().nth(1).unwrap();\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method:"
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut result = 0.0;\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        let mut j = i;\n        while\
    \ j < digits.len() && digits[j] == digits[i] {\n            j += 1\n        }\n\
    \        let mut dist = j - i;\n        if dist > 0 {\n            dist = dist\
    \ + 1;\n        }\n        result = result + dist * (j - i);\n        i = j;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpqdkib6ac.rs:36:17\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpqdkib6ac.rs:36:25\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpqdkib6ac.rs:37:17\n   |\n37 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpqdkib6ac.rs:37:25\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpqdkib6ac.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpqdkib6ac.rs:38:25\n   |\n38 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpqdkib6ac.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpqdkib6ac.rs:39:25\n   |\n39 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpqdkib6ac.rs:40:17\n  \
    \ |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpqdkib6ac.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: cannot\
    \ add `usize` to `{float}`\n  --> /tmp/tmpqdkib6ac.rs:28:25\n   |\n28 |      \
    \   result = result + dist * (j - i);\n   |                         ^ no implementation\
    \ for `{float} + usize`\n   |\n  "
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    let mut closest_integer = isize::MAX;\n    while i <\
    \ digits.len() && digits[i] != '.' {\n        if digits[i] < '0' {\n         \
    \   i += 1;\n            continue;\n        }\n        let mut j = i;\n      \
    \  while j < digits.len() && digits[j] >= '0' {\n            j += 1;\n       \
    \ }\n        let mut diff = digits[i] - digits[j];\n        if diff < closest_integer\
    \ {\n            closest_integer = diff;\n        }\n        i = j;\n    }\n \
    \   closest_integer\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp5rtj4g_9.rs:39:17\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5rtj4g_9.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp5rtj4g_9.rs:40:17\n   |\n40 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp5rtj4g_9.rs:40:25\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp5rtj4g_9.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp5rtj4g_9.rs:41:25\n   |\n41 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp5rtj4g_9.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp5rtj4g_9.rs:42:25\n   |\n42 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp5rtj4g_9.rs:43:17\n  \
    \ |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5rtj4g_9.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0369]: cannot\
    \ subtract `char` from `char`\n  --> /tmp/tmp5rtj4g_9.rs:28:34\n   |\n28 |   \
    \      let mut diff = digits[i] - digits[j];\n   |                        ---------\
    \ ^ --------- char\n   |            "
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.parse::<isize>().unwrap();\n    let mut min_value\
    \ = std::i32::MAX;\n    let mut max_value = std::i32::MIN;\n    let mut min_digits\
    \ = std::i32::MAX;\n    let mut max_digits = std::i32::MIN;\n    let mut min_value\
    \ = std::i32::MAX;\n    let mut max_value = std::i32::MIN;\n    let mut min_digits\
    \ = std::i32::MAX;\n    let mut max_digits = std::i32::MIN;\n    let mut min_value\
    \ = std::i32::MAX;\n    let mut max_value = std::i32::MIN;\n    let mut min_digits\
    \ = std::i32::MAX;\n    let mut max_digits = std::i32::MIN;\n    let mut min_value\
    \ = std::i32::MAX;\n    let mut max_value = std::i32::MIN;\n    let mut min_digits\
    \ = std::i32::MAX;\n    let mut max_digits = std::i32::MIN;\n    let mut min_value\
    \ = std::i32::MAX;\n    let mut max_value = std::i32::MIN;\n    let mut min_digits\
    \ = std::i32::MAX;\n    let mut max_digits = std::i32::MIN;\n    let mut min_value\
    \ = std::i32::MAX;\n    let mut max_value = std::i32::MIN;\n    let mut min_digits\
    \ = std::i32::MAX;\n    let mut max_digits = std::i32::MIN;\n    let mut min_value\
    \ = std::i32::MAX;\n    let mut max_value = std::i32::MIN;\n    let mut min_digits\
    \ = std::i32::MAX;\n    let mut max_digits = std::i32::MIN;\n    let mut min_value\
    \ = std::i32::MAX;\n    let mut max_value = std::i32::MIN;\n    let mut min_digits\
    \ = std::i32::MAX;\n    let mut max_digits = std::i32::MIN;\n    let mut min_value\
    \ = std::i32::MAX;\n    let mut max_value = std::i32::MIN;\n    let mut min_digits\
    \ = std::i32::MAX;\n    let mut max_digits = std::i32::MIN;\n    let mut min_value\
    \ = std::i32::MAX;\n    let mut max_value = std::i32::MIN;\n    let mut min_digits\
    \ = std::i32::MAX;\n    let mut max_digits = std::i32::MIN;\n    let mut min_value\
    \ = std::i32::MAX;\n    let mu\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt1o458or.rs:59:11\n   |\n\
    59 |     let mu\n   |           ^ help: add `;` here\n60 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpt1o458or.rs:64:17\n\
    \   |\n64 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpt1o458or.rs:64:25\n   |\n64 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpt1o458or.rs:65:17\n   |\n65 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpt1o458or.rs:65:25\n\
    \   |\n65 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpt1o458or.rs:66:17\n   |\n66 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpt1o458or.rs:66:25\n   |\n66 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpt1o458or.rs:67:17\n   |\n67 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpt1o458or.rs:67:25\n   |\n67 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpt1o458or.rs:68:17\n  \
    \ |\n68 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpt1o458or.rs:68:25\n   |\n68 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt1o458or.rs"
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut exponent = 0;\n    let mut exponents = Vec::new();\n    let mut i\
    \ = 0;\n    let mut last_digit = digits.pop().unwrap();\n    while i < digits.len()\
    \ {\n        let mut digit = digits[i];\n        if digit == '.' {\n         \
    \   exponent = exponents.last().unwrap();\n            exponents.push(0);\n  \
    \          i += 1;\n            continue;\n        }\n        let mut exponent\
    \ = exponents.last().unwrap();\n        if digit == 'e' || digit == 'E' {\n  \
    \          exponent += 1;\n            i += 1;\n            continue;\n      \
    \  }\n        let mut exponent = exponents.last().unwrap();\n        if exponent\
    \ == 0 {\n            exponents.push(0);\n            exponent += 1;\n       \
    \     i += 1;\n            continue;\n        }\n        if exponent > 0 {\n \
    \           exponent += 1;\n        }\n        if exponent < 0 {\n           \
    \ exponent += 1;\n        }\n        if exponent == 0 {\n            exponents.push(0);\n\
    \            exponent += 1;\n            i += 1;\n            continue;\n    \
    \    }\n        if exponent > 0 {\n            exponent += 1;\n        }\n   \
    \     if exponent < 0 {\n            exponent += 1;\n        }\n        if exponent\
    \ == 0 {\n            exponents.push(0);\n            exponent += 1;\n       \
    \     i += 1;\n            continue;\n        }\n        if exponent > 0 {\n \
    \           exponent += 1;\n        }\n        if exponent < 0 {\n           \
    \ exponent += 1;\n        }\n        if exponent == 0 {\n            exponents.push(0);\n\
    \            exponent += 1;\n            i += 1;\n            continue;\n    \
    \    }\n        if exponent > 0 {\n            exponent += 1;\n        }\n   \
    \     if exponent < 0 {\n            exponent += 1;\n        }\n        if exponent\
    \ == 0 {\n            exponents.push(0);\n            exponent += 1;\n       \
    \     i += 1;\n            continue;\n        }\n        if exponent > 0 {\n \
    \           exponent += 1;\n        }\n        if exponent < 0 {\n           \
    \ exponent += 1;\n        }\n        if exponent == 0 {\n            exponents.push(0);\n\
    \            exponent += 1;\n            i += 1;\n            continue;\n    \
    \    }\n        if exponent > 0 {\n            exponent += 1;\n        }\n   \
    \     if exponent < 0 {\n            exponent += 1;\n        }\n        if exponent\
    \ == 0 {\n            exponents.push(0);\n            exponent += 1;\n       \
    \     i += 1;\n            continue;\n        }\n        if exponent > 0 {\n \
    \           exponent += 1;\n        }\n        if exponent < 0 {\n           \
    \ exponent += 1;\n        }\n        if exponent == 0 {\n            exponents.push(0);\n\
    \            exponent += 1;\n            i += 1;\n            continue;\n    \
    \    }\n        if exponent > 0 {\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp4ftmtg0r.rs:136:3\n\
    \    |\n14  | fn closest_integer(value: String) -> isize {\n    |            \
    \                                - unclosed delimiter\n...\n21  |     while i\
    \ < digits.len() {\n    |                            - unclosed delimiter\n...\n\
    126 |         if exponent > 0 {\n    |                         - this delimiter\
    \ might not be properly closed...\n127 | }\n    | - ...as it matches this but\
    \ it has different indentation\n...\n136 | }\n    |   ^\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n   --> /tmp/tmp4ftmtg0r.rs:131:17\n    |\n\
    131 |     assert_eq!({left}, {right});\n    |                 ^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `right` in this scope\n   -->\
    \ /tmp/tmp4ftmtg0r.rs:131:25\n    |\n131 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp4ftmtg0r.rs:132:17\n\
    \    |\n132 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp4ftmtg0r.rs:132:25\n    |\n132 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp4ftmtg0r.rs:133:17\n\
    \    |\n133 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp4ftmtg0r.rs:133:25\n    |\n133 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp4ftmtg0r.rs:134:17\n\
    \    |\n134 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp4ftmtg0r.rs:134:25\n    |\n134 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_digit(16).unwrap()\n        }\n    });\n   \
    \ let mut result = digits[0];\n    let mut last_digit = digits[0];\n    for &(i,\
    \ digit) in &digits[1..] {\n        if digit > last_digit {\n            last_digit\
    \ = digit;\n            result = i;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpyv2rhi9e.rs:36:17\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpyv2rhi9e.rs:36:25\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpyv2rhi9e.rs:37:17\n   |\n37 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpyv2rhi9e.rs:37:25\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpyv2rhi9e.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpyv2rhi9e.rs:38:25\n   |\n38 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpyv2rhi9e.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpyv2rhi9e.rs:39:25\n   |\n39 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpyv2rhi9e.rs:40:17\n  \
    \ |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpyv2rhi9e.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0608]: cannot\
    \ index into a value of type `Map<Enumerate<Chars<'_>>, [closure@/tmp/tmpyv2rhi9e.rs:16:52:\
    \ 22:6]>`\n  --> /tmp/tmpyv2rhi9e.rs:23:22\n   |\n23 |     let mut result = digits[0];\n\
    \   |           "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut v = value.parse::<isize>().unwrap();\n    if v < 0 {\n        v = -v;\n\
    \    }\n    if v == 0 {\n        return 0;\n    }\n    let mut low = v;\n    let\
    \ mut high = v;\n    let mut mid = 0;\n    while low < high {\n        mid = low\
    \ + ((high - low) / 2);\n        if mid * mid > v {\n            high = mid -\
    \ 1;\n        } else {\n            low = mid;\n        }\n    }\n    low\n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpq565gpo3.rs:38:17\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpq565gpo3.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpq565gpo3.rs:39:17\n   |\n39 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpq565gpo3.rs:39:25\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpq565gpo3.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpq565gpo3.rs:40:25\n   |\n40 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpq565gpo3.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpq565gpo3.rs:41:25\n   |\n41 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpq565gpo3.rs:42:17\n  \
    \ |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpq565gpo3.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 10 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut exponent = 0;\n    let mut remainder = 0;\n    while let Some(digit)\
    \ = digits.next() {\n        let mut next = digit;\n        if let Some(next)\
    \ = digits.next() {\n            exponent += 1;\n            remainder = next\
    \ - digit;\n        } else {\n            break;\n        }\n    }\n    if exponent\
    \ == 0 {\n        return value.parse().unwrap();\n    }\n    let mut result =\
    \ value.parse().unwrap();\n    if remainder > 0 {\n        result = result + 1;\n\
    \    }\n    if exponent > 0 {\n        result = result * 10 ** (exponent - 1);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpkmdiimb5.rs:43:17\n\
    \   |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpkmdiimb5.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpkmdiimb5.rs:44:17\n   |\n44 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpkmdiimb5.rs:44:25\n\
    \   |\n44 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpkmdiimb5.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpkmdiimb5.rs:45:25\n   |\n45 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpkmdiimb5.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpkmdiimb5.rs:46:25\n   |\n46 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpkmdiimb5.rs:47:17\n  \
    \ |\n47 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpkmdiimb5.rs:47:25\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `next` found for type `char` in the current scope\n  --> /tmp/tmpkmdiimb5.rs:19:36\n\
    \   |\n19 |     while let Some(digit) = digits.next() {\n   |                \
    \                    ^^"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n    let mut result = value.chars().take_while(|c| c\
    \ >= '0' && c <= '9').next();\n    let mut i = 0;\n    while i < digits.len()\
    \ && result != Some(i) {\n        if digits[i] > result {\n            result\
    \ = Some(i);\n        }\n        i += 1;\n    }\n    result.unwrap_or(0)\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp1lbrhvj_.rs:30:17\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp1lbrhvj_.rs:30:25\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp1lbrhvj_.rs:31:17\n   |\n31 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp1lbrhvj_.rs:31:25\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp1lbrhvj_.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp1lbrhvj_.rs:32:25\n   |\n32 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp1lbrhvj_.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp1lbrhvj_.rs:33:25\n   |\n33 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp1lbrhvj_.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp1lbrhvj_.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1lbrhvj_.rs:16:56\n   |\n16 |     let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n   |                                               \
    \         ^^"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_digit(16).unwrap()\n        }\n    });\n   \
    \ let mut result = digits[0];\n    let mut min_diff = std::i32::MAX;\n    let\
    \ mut min_diff_index = 0;\n    for &(i, &d) in &digits[1..] {\n        let diff\
    \ = d - result;\n        if diff < min_diff {\n            min_diff = diff;\n\
    \            min_diff_index = i;\n        }\n    }\n    result.to_digit(10).unwrap()\
    \ + min_diff_index\n}\n\nfn main() {\n    let candidate = closest_integer;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp6cdycyrm.rs:38:17\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6cdycyrm.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp6cdycyrm.rs:39:17\n   |\n39 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp6cdycyrm.rs:39:25\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp6cdycyrm.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp6cdycyrm.rs:40:25\n   |\n40 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp6cdycyrm.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp6cdycyrm.rs:41:25\n   |\n41 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp6cdycyrm.rs:42:17\n  \
    \ |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6cdycyrm.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0608]: cannot\
    \ index into a value of type `Map<Enumerate<Chars<'_>>, [closure@/tmp/tmp6cdycyrm.rs:16:52:\
    \ 22:6]>`\n  --> /tmp/tmp6cdycyrm.rs:23:22\n   |\n23 |     let mut result = digits[0];\n\
    \   |           "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.to_string();\n    let mut value = value.parse::<isize>().unwrap();\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = closest_integer.abs();\n\
    \    let mut closest_integer = closest_integer.abs();\n    while closest_integer\
    \ > 0 {\n        if closest_integer % 2 == 0 {\n            closest_integer =\
    \ closest_integer / 2;\n        } else {\n            closest_integer = closest_integer\
    \ / 2;\n        }\n    }\n    closest_integer\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpjt8wbrnz.rs:32:17\n\
    \   |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpjt8wbrnz.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpjt8wbrnz.rs:33:17\n   |\n33 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpjt8wbrnz.rs:33:25\n\
    \   |\n33 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpjt8wbrnz.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpjt8wbrnz.rs:34:25\n   |\n34 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpjt8wbrnz.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpjt8wbrnz.rs:35:25\n   |\n35 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpjt8wbrnz.rs:36:17\n  \
    \ |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpjt8wbrnz.rs:36:25\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 10 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            0\n        }\n    });\n    let mut smallest_digit\
    \ = digits[0];\n    let mut closest_digit = digits[0];\n    let mut closest_integer\
    \ = value.chars().enumerate().map(|(i, c)| {\n        if c.is_numeric() {\n  \
    \          c.to_digit(10).unwrap()\n        } else {\n            0\n        }\n\
    \    }).collect::<Vec<_>>();\n    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0yslrt_x.rs:50:70\n   |\n\
    50 |     let mut closest_integer = closest_integer.iter().cloned().collect\n \
    \  |                                                                      ^ help:\
    \ add `;` here\n51 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `left` in this scope\n  --> /tmp/tmp0yslrt_x.rs:55:17\n   |\n55 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp0yslrt_x.rs:55:25\n \
    \  |\n55 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp0yslrt_x.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp0yslrt_x.rs:56:25\n   |\n56 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp0yslrt_x.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp0yslrt_x.rs:57:25\n   |\n57 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp0yslrt_x.rs:58:17\n  \
    \ |\n58 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp0yslrt_x.rs:58:25\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp0yslrt_x.rs:59:17\n   |\n59 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp0yslrt_x.rs:59:25\n\
    \   |\n59 |     assert_eq!({left}, {right})"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_ascii_lowercase().unwrap()\n        }\n    });\n\
    \    let mut result = digits[0];\n    let mut max_diff = 0;\n    for &(i, &d)\
    \ in &digits[1..] {\n        let diff = i - d;\n        if diff > max_diff {\n\
    \            max_diff = diff;\n            result = i;\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpwxx74n6j.rs:37:17\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpwxx74n6j.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpwxx74n6j.rs:38:17\n   |\n38 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpwxx74n6j.rs:38:25\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpwxx74n6j.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpwxx74n6j.rs:39:25\n   |\n39 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpwxx74n6j.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpwxx74n6j.rs:40:25\n   |\n40 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpwxx74n6j.rs:41:17\n  \
    \ |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpwxx74n6j.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmpwxx74n6j.rs:20:36\n\
    \   |\n20 |             c.to_ascii_lowercase().unwrap()\n   |                \
    \                    "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut digit = digits;\n\
    \    while digit != 0 {\n        let mut next_digit = digit;\n        let mut\
    \ next_result = result;\n        while next_digit != 0 {\n            let mut\
    \ next_digit = next_digit / 10;\n            let mut next_result = next_result\
    \ / 10;\n            if next_digit == 0 {\n                break;\n          \
    \  }\n        }\n        if next_digit == 0 {\n            break;\n        }\n\
    \        result = next_result;\n        digit = next_digit;\n    }\n    result.parse().unwrap()\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpvdkbgz5s.rs:40:17\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpvdkbgz5s.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpvdkbgz5s.rs:41:17\n   |\n41 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpvdkbgz5s.rs:41:25\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpvdkbgz5s.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpvdkbgz5s.rs:42:25\n   |\n42 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpvdkbgz5s.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpvdkbgz5s.rs:43:25\n   |\n43 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpvdkbgz5s.rs:44:17\n  \
    \ |\n44 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpvdkbgz5s.rs:44:25\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvdkbgz5s.rs:19:20\n   |\n19 |     while digit != 0 {\n\
    \   |                    ^ expected `char`, found `u8`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvdkbgz5s.rs:"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut exponent = 0;\n    let mut result = isize::MAX;\n    while exponent\
    \ < value.len() {\n        let mut digit = digits.chars().nth(1).unwrap();\n \
    \       if digit == '.' {\n            exponent += 1;\n            digits = digits.chars().nth(1).unwrap();\n\
    \            continue;\n        }\n        let mut digit = digit;\n        let\
    \ mut multiplier = 1;\n        while digit != '0' {\n            digit /= 10;\n\
    \            multiplier *= 10;\n        }\n        let mut new_digit = digit *\
    \ multiplier;\n        if new_digit > result {\n            result = new_digit;\n\
    \        }\n        digits += digit;\n        exponent += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmppk3mjzfs.rs:44:17\n\
    \   |\n44 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmppk3mjzfs.rs:44:25\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmppk3mjzfs.rs:45:17\n   |\n45 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmppk3mjzfs.rs:45:25\n\
    \   |\n45 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmppk3mjzfs.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmppk3mjzfs.rs:46:25\n   |\n46 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmppk3mjzfs.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmppk3mjzfs.rs:47:25\n   |\n47 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmppk3mjzfs.rs:48:17\n  \
    \ |\n48 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmppk3mjzfs.rs:48:25\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmppk3mjzfs.rs:20:32\n\
    \   |\n20 |         let mut digit = digits.chars().nth(1).unwrap();\n   |    \
    \                     "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if digits[i] != '.' {\n            digits =\
    \ &digits[1..];\n            break;\n        }\n        i += 1;\n    }\n    let\
    \ mut digits = digits.chars().nth(1).unwrap();\n    let mut i = 0;\n    while\
    \ i < digits.len() {\n        if digits[i] != '.' {\n            digits = &digits[1..];\n\
    \            break;\n        }\n        i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut i = 0;\n    while i < digits.len() {\n        if digits[i] != '.'\
    \ {\n            digits = &digits[1..];\n            break;\n        }\n     \
    \   i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n   \
    \ let mut i = 0;\n    while i < digits.len() {\n        if digits[i] != '.' {\n\
    \            digits = &digits[1..];\n            break;\n        }\n        i\
    \ += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let\
    \ mut i = 0;\n    while i < digits.len() {\n        if digits[i] != '.' {\n  \
    \          digits = &digits[1..];\n            break;\n        }\n        i +=\
    \ 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        if digits[i] != '.' {\n      \
    \      digits = &digits[1..];\n            break;\n        }\n        i += 1;\n\
    \    }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let mut i =\
    \ 0;\n    while i < digits.len() {\n        if digits[i] != '.' {\n          \
    \  digits = &digits[1..];\n            break;\n        }\n        i += 1;\n  \
    \  }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let mut i = 0;\n\
    \    while i < digits.len() {\n        if digits[i] != '.' {\n            digits\
    \ = &digits[1..];\n            break;\n        }\n        i += 1;\n    }\n   \
    \ let mut digits = digits.chars().nth(1).unwrap();\n    let mut i = 0;\n    while\
    \ i < digits.len() {\n        if digits[i] != '.' {\n            digits = &digits[1..];\n\
    \            break;\n        }\n        i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n   --> /tmp/tmp5rjru_dc.rs:104:17\n\
    \    |\n104 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp5rjru_dc.rs:104:25\n    |\n104 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp5rjru_dc.rs:105:17\n\
    \    |\n105 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp5rjru_dc.rs:105:25\n    |\n105 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp5rjru_dc.rs:106:17\n\
    \    |\n106 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp5rjru_dc.rs:106:25\n    |\n106 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp5rjru_dc.rs:107:17\n\
    \    |\n107 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp5rjru_dc.rs:107:25\n    |\n107 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp5rjru_dc.rs:108:17\n\
    \    |\n108 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp5rjru_dc.rs:108:25\n    |\n108 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0608]:\
    \ cannot index into a value of type `char`\n  --> /tmp/tmp5rjru_dc.rs:20:12\n\
    \   |\n20 |         if digits[i] != '.' {\n   |            ^^^^^^^^^\n\nerro"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().filter(|&(_,\
    \ c)| c.is_numeric()).map(|(_, c)| c.to_digit(10)).collect::<Vec<_>>();\n    let\
    \ mut result = value.chars().enumerate().filter(|&(_, c)| c.is_numeric()).map(|(_,\
    \ c)| c.to_digit(10)).collect::<Vec<_>>();\n    let mut min: isize = 0;\n    let\
    \ mut max: isize = 0;\n    let mut mid: isize = 0;\n    let mut diff: isize =\
    \ 0;\n    let mut min_diff: isize = 0;\n    let mut max_diff: isize = 0;\n   \
    \ let mut min_mid: isize = 0;\n    let mut max_mid: isize = 0;\n    let mut min_diff2:\
    \ isize = 0;\n    let mut max_diff2: isize = 0;\n    let mut min_mid2: isize =\
    \ 0;\n    let mut max_mid2: isize = 0;\n    let mut min_diff3: isize = 0;\n  \
    \  let mut max_diff3: isize = 0;\n    let mut min_mid3: isize = 0;\n    let mut\
    \ max_mid3: isize = 0;\n    let mut min_diff4: isize = 0;\n    let mut max_diff4:\
    \ isize = 0;\n    let mut min_mid4: isize = 0;\n    let mut max_mid4: isize =\
    \ 0;\n    let mut min_diff5: isize = 0;\n    let mut max_diff5: isize = 0;\n \
    \   let mut min_mid5: isize = 0;\n    let mut max_mid5: isize = 0;\n    let mut\
    \ min_diff6: isize = 0;\n    let mut max_diff6: isize = 0;\n    let mut min_mid6:\
    \ isize = 0;\n    let mut max_mid6: isize = 0;\n    let mut min_diff7: isize =\
    \ 0;\n    let mut max_diff7: isize = 0;\n    let mut min_mid7: isize = 0;\n  \
    \  let mut max_mid7: isize = 0;\n    let mut min_diff8: isize = 0;\n    let mut\
    \ max_diff8: isize = 0;\n    let mut min_mid8: isize = 0;\n    let mut max_mid8:\
    \ isize = 0;\n    let mut min_diff9: isize = 0;\n    let mut max_diff9: isize\
    \ = 0;\n    let mut min_mid9: isize = 0;\n    let mut max_mid9: isize = 0;\n \
    \   let mut min_diff10: isize = 0;\n\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpwnl_ajw_.rs:64:17\n\
    \   |\n64 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpwnl_ajw_.rs:64:25\n   |\n64 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpwnl_ajw_.rs:65:17\n   |\n65 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpwnl_ajw_.rs:65:25\n\
    \   |\n65 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpwnl_ajw_.rs:66:17\n   |\n66 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpwnl_ajw_.rs:66:25\n   |\n66 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpwnl_ajw_.rs:67:17\n   |\n67 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpwnl_ajw_.rs:67:25\n   |\n67 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpwnl_ajw_.rs:68:17\n  \
    \ |\n68 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpwnl_ajw_.rs:68:25\n   |\n68 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwnl_ajw_.rs:14:38\n   |\n14 | fn closest_integer(value:\
    \ String) -> isize {\n   |    ---------------                   ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut v = value.parse::<isize>().unwrap();\n    if v < 0 {\n        v = -v;\n\
    \    }\n    if v == 0 {\n        return v;\n    }\n    let mut closest_v = v;\n\
    \    let mut closest_i = 1;\n    while closest_v == v {\n        closest_i +=\
    \ 1;\n        v = closest_v * closest_i;\n    }\n    closest_i\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp_0j2xwc_.rs:33:17\n\
    \   |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_0j2xwc_.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_0j2xwc_.rs:34:17\n   |\n34 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_0j2xwc_.rs:34:25\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_0j2xwc_.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_0j2xwc_.rs:35:25\n   |\n35 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_0j2xwc_.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_0j2xwc_.rs:36:25\n   |\n36 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_0j2xwc_.rs:37:17\n  \
    \ |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_0j2xwc_.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 10 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(0).unwrap();\n    let mut i = 0;\n   \
    \ while i < digits.len() {\n        if digits.is_ascii_digit() {\n           \
    \ let digit = digits.to_ascii_digit();\n            if digit < result.to_ascii_digit()\
    \ {\n                result = digit;\n            }\n        } else {\n      \
    \      let digit = digits.to_digit();\n            if digit < result.to_digit()\
    \ {\n                result = digit;\n            }\n        }\n        i += 1;\n\
    \    }\n    result.parse().unwrap()\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp997p53_m.rs:38:17\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp997p53_m.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp997p53_m.rs:39:17\n   |\n39 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp997p53_m.rs:39:25\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp997p53_m.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp997p53_m.rs:40:25\n   |\n40 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp997p53_m.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp997p53_m.rs:41:25\n   |\n41 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp997p53_m.rs:42:17\n  \
    \ |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp997p53_m.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `len` found for type `char` in the current scope\n  --> /tmp/tmp997p53_m.rs:19:22\n\
    \   |\n19 |     while i < digits.len() {\n   |                      ^^^ method\
    \ not found in `char`\n\n"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_digit() {\n            c.to_digit(10).unwrap()\n    \
    \    } else {\n            i\n        }\n    });\n    let mut result = isize::MAX;\n\
    \    let mut current_digit = 0;\n    let mut current_digits = &mut digits;\n \
    \   while current_digit < digits.len() {\n        let mut current_digit = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n        let mut current_value = isize::MAX;\n\
    \        let mut current_value = &mut value;\n        while current_value > 0\
    \ {\n            let mut current_digit = current_digits.iter().position(|&x| x\
    \ == current_digit).unwrap();\n            let mut current_value = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n            current_digit = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n            current_digit = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n            current_digit = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n            current_digit = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n            current_digit = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n            current_digit = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n            current_digit = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n            current_digit = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n            current_digit = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n            current_digit = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n            current_digit = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n            current_digit = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n            current_digit = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n            current_digit = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n            current_digit = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n            current_digit = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n            current_digit = current_digits.iter().position(|&x|\
    \ x == current_digit).unwrap();\n            current_digit = current_digits.iter().position(|&x|\
    \ \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpka0exq9w.rs:60:3\n\
    \   |\n14 | fn closest_integer(value: String) -> isize {\n   |               \
    \                             - unclosed delimiter\n...\n26 |     while current_digit\
    \ < digits.len() {\n   |                                        - unclosed delimiter\n\
    ...\n30 |         while current_value > 0 {\n   |                            \
    \     - this delimiter might not be properly closed...\n...\n51 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n60 | }\n   |   ^\n\n\
    error: expected expression, found `)`\n  --> /tmp/tmpka0exq9w.rs:51:1\n   |\n\
    51 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n\
    \  --> /tmp/tmpka0exq9w.rs:50:59\n   |\n14 | fn closest_integer(value: String)\
    \ -> isize {\n   |                                            - closing delimiter\
    \ possibly meant for this\n...\n50 |             current_digit = current_digits.iter().position(|&x|\
    \ \n   |                                                           ^ unclosed\
    \ delimiter\n51 | }\n   | ^ mismatched closing delimiter\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpka0exq9w.rs:55:17\n   |\n55 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpka0exq9w.rs:55:25\n\
    \   |\n55 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpka0exq9w.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpka0exq9w.rs:56:25\n   |\n56 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpka0exq9w.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().take_while(|c|\
    \ c != '0');\n    let mut result = value.chars().take_while(|c| c != '0').count();\n\
    \    let mut closest_value = value.chars().take_while(|c| c != '0').count();\n\
    \    let mut closest_integer = value.chars().take_while(|c| c != '0').count();\n\
    \    while closest_integer > result {\n        closest_value -= 1;\n        closest_integer\
    \ -= 1;\n    }\n    while closest_integer < result {\n        closest_value +=\
    \ 1;\n        closest_integer += 1;\n    }\n    closest_value\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp_067k8t3.rs:33:17\n\
    \   |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_067k8t3.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_067k8t3.rs:34:17\n   |\n34 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_067k8t3.rs:34:25\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_067k8t3.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_067k8t3.rs:35:25\n   |\n35 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_067k8t3.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_067k8t3.rs:36:25\n   |\n36 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_067k8t3.rs:37:17\n  \
    \ |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_067k8t3.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_067k8t3.rs:16:53\n   |\n16 |   \
    \  let mut digits = value.chars().take_while(|c| c != '0');\n   |            \
    \                                         "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(0).unwrap();\n    let mut digit = digits.chars().nth(1).unwrap();\n\
    \    let mut result = result.chars().nth(0).unwrap();\n    while digit != '.'\
    \ {\n        let mut new_digit = digit;\n        let mut new_result = result;\n\
    \        while new_digit != '.' {\n            let mut new_digit = digits.chars().nth(1).unwrap();\n\
    \            let mut new_result = result.chars().nth(0).unwrap();\n          \
    \  if new_digit == '.' {\n                break;\n            }\n            if\
    \ new_digit == '0' {\n                new_digit = digits.chars().nth(1).unwrap();\n\
    \                new_result = result.chars().nth(0).unwrap();\n            }\n\
    \        }\n        if new_digit == '.' {\n            break;\n        }\n   \
    \     if new_digit == '0' {\n            new_digit = digits.chars().nth(1).unwrap();\n\
    \            new_result = result.chars().nth(0).unwrap();\n        }\n       \
    \ result = new_result;\n        digit = new_digit;\n    }\n    if result == '.'\
    \ {\n        return 0;\n    }\n    let mut result = result.chars().nth(0).unwrap();\n\
    \    while result == '0' {\n        result = result.chars().nth(1).unwrap();\n\
    \    }\n    result.parse().unwrap()\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpzak74ipb.rs:56:17\n\
    \   |\n56 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpzak74ipb.rs:56:25\n   |\n56 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpzak74ipb.rs:57:17\n   |\n57 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpzak74ipb.rs:57:25\n\
    \   |\n57 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpzak74ipb.rs:58:17\n   |\n58 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpzak74ipb.rs:58:25\n   |\n58 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpzak74ipb.rs:59:17\n   |\n59 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpzak74ipb.rs:59:25\n   |\n59 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpzak74ipb.rs:60:17\n  \
    \ |\n60 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpzak74ipb.rs:60:25\n   |\n60 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmpzak74ipb.rs:18:28\n\
    \   |\n18 |     let mut digit = digits.chars().nth(1).unwrap();\n   |        \
    \                    ^"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if digits[i] != '.' {\n            digits =\
    \ &digits[i..];\n            break;\n        }\n        i += 1;\n    }\n    let\
    \ mut digits = digits.chars().nth(1).unwrap();\n    let mut i = 0;\n    while\
    \ i < digits.len() {\n        if digits[i] != '.' {\n            digits = &digits[i..];\n\
    \            break;\n        }\n        i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut i = 0;\n    while i < digits.len() {\n        if digits[i] != '.'\
    \ {\n            digits = &digits[i..];\n            break;\n        }\n     \
    \   i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n   \
    \ let mut i = 0;\n    while i < digits.len() {\n        if digits[i] != '.' {\n\
    \            digits = &digits[i..];\n            break;\n        }\n        i\
    \ += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let\
    \ mut i = 0;\n    while i < digits.len() {\n        if digits[i] != '.' {\n  \
    \          digits = &digits[i..];\n            break;\n        }\n        i +=\
    \ 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        if digits[i] != '.' {\n      \
    \      digits = &digits[i..];\n            break;\n        }\n        i += 1;\n\
    \    }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let mut i =\
    \ 0;\n    while i < digits.len() {\n        if digits[i] != '.' {\n          \
    \  digits = &digits[i..];\n            break;\n        }\n        i += 1;\n  \
    \  }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let mut i = 0;\n\
    \    while i < digits.len() {\n        if digits[i] != '.' {\n            digits\
    \ = &digits[i..];\n            break;\n        }\n        i += 1;\n    }\n   \
    \ let mut digits = digits.chars().nth(1).unwrap();\n    let mut i = 0;\n    while\
    \ i < digits.len() {\n        if digits[i] != '.' {\n            digits = &digits[i..];\n\
    \            break;\n        }\n        i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut i = 0;\n    while i < digits.len(\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpoo_pqjav.rs:101:1\n    |\n\
    101 | }\n    | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  \
    \ --> /tmp/tmpoo_pqjav.rs:100:25\n    |\n14  | fn closest_integer(value: String)\
    \ -> isize {\n    |                                            - closing delimiter\
    \ possibly meant for this\n...\n100 |     while i < digits.len(\n    |       \
    \                  ^ unclosed delimiter\n101 | }\n    | ^ mismatched closing delimiter\n\
    \nerror[E0425]: cannot find value `left` in this scope\n   --> /tmp/tmpoo_pqjav.rs:105:17\n\
    \    |\n105 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpoo_pqjav.rs:105:25\n    |\n105 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpoo_pqjav.rs:106:17\n\
    \    |\n106 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpoo_pqjav.rs:106:25\n    |\n106 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpoo_pqjav.rs:107:17\n\
    \    |\n107 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpoo_pqjav.rs:107:25\n    |\n107 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpoo_pqjav.rs:108:17\n\
    \    |\n108 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpoo_pqjav.rs:108:25\n    |\n108 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpoo_pqjav.r"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut remainder =\
    \ 0;\n\n    while !digits.is_empty() {\n        let mut digit = digits.chars().nth(1).unwrap();\n\
    \        let mut remainder = digit % 10;\n        digit = digit / 10;\n      \
    \  if digit == 0 {\n            break;\n        }\n        result = remainder\
    \ + result;\n        remainder = remainder % 10;\n        digits = digits[1..].to_string();\n\
    \    }\n    result - remainder\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmparwur_q2.rs:36:17\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmparwur_q2.rs:36:25\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmparwur_q2.rs:37:17\n   |\n37 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmparwur_q2.rs:37:25\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmparwur_q2.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmparwur_q2.rs:38:25\n   |\n38 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmparwur_q2.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmparwur_q2.rs:39:25\n   |\n39 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmparwur_q2.rs:40:17\n  \
    \ |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmparwur_q2.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `is_empty` found for type `char` in the current scope\n  --> /tmp/tmparwur_q2.rs:20:19\n\
    \   |\n20 |     while !digits.is_empty() {\n   |                   ^^^^^^^^ method\
    \ not found in"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n    let mut result = value.chars().take_while(|c| c\
    \ >= '0' && c <= '9').next().unwrap();\n    let mut exponent = 0;\n    let mut\
    \ remainder = 0;\n    while result != Some('0') {\n        let mut value = result.to_digit(10);\n\
    \        remainder = value % 10;\n        value /= 10;\n        exponent += 1;\n\
    \        if exponent > 3 {\n            exponent = 0;\n        }\n        if value\
    \ == 0 {\n            break;\n        }\n        if remainder == 0 {\n       \
    \     break;\n        }\n        result = Some(value + remainder);\n    }\n  \
    \  match exponent {\n        0 => result.unwrap(),\n        _ => result.unwrap()\
    \ - 1,\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpqn0bzfbp.rs:44:17\n\
    \   |\n44 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpqn0bzfbp.rs:44:25\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpqn0bzfbp.rs:45:17\n   |\n45 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpqn0bzfbp.rs:45:25\n\
    \   |\n45 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpqn0bzfbp.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpqn0bzfbp.rs:46:25\n   |\n46 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpqn0bzfbp.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpqn0bzfbp.rs:47:25\n   |\n47 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpqn0bzfbp.rs:48:17\n  \
    \ |\n48 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpqn0bzfbp.rs:48:25\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqn0bzfbp.rs:16:56\n   |\n16 |     let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n   |                                               \
    \         ^^"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    if value.chars().count() > 2 {\n  \
    \      value = value.chars().nth(2).unwrap();\n    }\n    let mut value = value.parse::<isize>().unwrap();\n\
    \    if value < 0 {\n        value = -value;\n    }\n    value\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmplc4znct7.rs:28:17\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmplc4znct7.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmplc4znct7.rs:29:17\n   |\n29 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmplc4znct7.rs:29:25\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmplc4znct7.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmplc4znct7.rs:30:25\n   |\n30 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmplc4znct7.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmplc4znct7.rs:31:25\n   |\n31 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmplc4znct7.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmplc4znct7.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplc4znct7.rs:17:17\n   |\n17 |         value = value.chars().nth(2).unwrap();\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method:"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = 0.0;\n    let mut exponent = value.len() - 1;\n    let mut\
    \ last_digit = digits[exponent];\n    while exponent > 0 {\n        if last_digit\
    \ == '0' {\n            break;\n        }\n        result *= 10;\n        result\
    \ += (last_digit as f64).floor() as isize;\n        exponent--;\n        last_digit\
    \ = digits[exponent];\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp3hvxe23_.rs:26:19\n\
    \   |\n26 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp3hvxe23_.rs:34:17\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3hvxe23_.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp3hvxe23_.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp3hvxe23_.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp3hvxe23_.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp3hvxe23_.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp3hvxe23_.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp3hvxe23_.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp3hvxe23_.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3hvxe23_.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: cannot\
    \ multiply-assign `{float}` by `{integer}`\n"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut exponent = 0;\n    let mut remainder = 0;\n    while let Some(digit)\
    \ = digits.next() {\n        let mut new_exponent = exponent + 1;\n        let\
    \ mut new_remainder = remainder * 10;\n        if digit == '.' {\n           \
    \ new_exponent += 1;\n            new_remainder /= 10;\n        }\n        if\
    \ new_exponent > 9 {\n            return 0;\n        }\n        if new_exponent\
    \ == 0 {\n            return new_remainder;\n        }\n        if new_exponent\
    \ < exponent {\n            exponent = new_exponent;\n            remainder =\
    \ new_remainder;\n        }\n    }\n    0\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpag6fr9h5.rs:42:17\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpag6fr9h5.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpag6fr9h5.rs:43:17\n   |\n43 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpag6fr9h5.rs:43:25\n\
    \   |\n43 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpag6fr9h5.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpag6fr9h5.rs:44:25\n   |\n44 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpag6fr9h5.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpag6fr9h5.rs:45:25\n   |\n45 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpag6fr9h5.rs:46:17\n  \
    \ |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpag6fr9h5.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `next` found for type `char` in the current scope\n  --> /tmp/tmpag6fr9h5.rs:19:36\n\
    \   |\n19 |     while let Some(digit) = digits.next() {\n   |                \
    \                    ^^"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut exponent = 0;\n    let mut result = value.chars().nth(0).unwrap();\n\
    \    while result.is_some() {\n        let mut next_digit = result.unwrap().to_string();\n\
    \        if next_digit.len() > 0 {\n            exponent += next_digit.chars().nth(1).unwrap().to_i();\n\
    \        }\n        result = next_digit.chars().nth(0).unwrap();\n    }\n    let\
    \ mut exponent = exponent - 1;\n    let mut result = value.chars().nth(0).unwrap();\n\
    \    while result.is_some() {\n        let mut next_digit = result.unwrap().to_string();\n\
    \        if next_digit.len() > 0 {\n            exponent += next_digit.chars().nth(1).unwrap().to_i();\n\
    \        }\n        result = next_digit.chars().nth(0).unwrap();\n    }\n    let\
    \ mut exponent = exponent + 1;\n    let mut result = value.chars().nth(0).unwrap();\n\
    \    while result.is_some() {\n        let mut next_digit = result.unwrap().to_string();\n\
    \        if next_digit.len() > 0 {\n            exponent += next_digit.chars().nth(1).unwrap().to_i();\n\
    \        }\n        result = next_digit.chars().nth(0).unwrap();\n    }\n    let\
    \ mut exponent = exponent - 1;\n    let mut result = value.chars().nth(0).unwrap();\n\
    \    while result.is_some() {\n        let mut next_digit = result.unwrap().to_string();\n\
    \        if next_digit.len() > 0 {\n            exponent += next_digit.chars().nth(1).unwrap().to_i();\n\
    \        }\n        result = next_digit.chars().nth(0).unwrap();\n    }\n    let\
    \ mut exponent = exponent + 1;\n    let mut result = value.chars().nth(0).unwrap();\n\
    \    while result.is_some() {\n        let mut next_digit = result.unwrap().to_string();\n\
    \        if next_digit.len() > 0 {\n            exponent += next_digit.chars().nth(1).unwrap().to_i();\n\
    \        }\n        result = next_digit.chars().nth(0).unwrap();\n    }\n    let\
    \ mut exponent = exponent - 1;\n    let mut result = value.chars().nth(0).unwrap();\n\
    \    while result.is_some() {\n        let mut next_digit = result.unwrap().to_string();\n\
    \        if next_digit.len() > 0 {\n            exponent += next_digit.chars().nth(1).unwrap().to_i();\n\
    \        }\n        result = next_digit.chars().nth(0).unwrap();\n    }\n    let\
    \ mut exponent = exponent + 1;\n    let mut result = value.chars().nth(0).unwrap\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9li36gu2.rs:72:49\n   |\n\
    72 |     let mut result = value.chars().nth(0).unwrap\n   |                  \
    \                               ^ help: add `;` here\n73 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp9li36gu2.rs:77:17\n\
    \   |\n77 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp9li36gu2.rs:77:25\n   |\n77 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp9li36gu2.rs:78:17\n   |\n78 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp9li36gu2.rs:78:25\n\
    \   |\n78 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp9li36gu2.rs:79:17\n   |\n79 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp9li36gu2.rs:79:25\n   |\n79 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp9li36gu2.rs:80:17\n   |\n80 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp9li36gu2.rs:80:25\n   |\n80 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp9li36gu2.rs:81:17\n  \
    \ |\n81 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp9li36gu2.rs:81:25\n   |\n81 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not f"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut v = value.to_string().parse::<isize>().unwrap();\n    if v < 0 {\n\
    \        v = -v;\n    }\n    v\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpc_01mv16.rs:24:17\n\
    \   |\n24 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpc_01mv16.rs:24:25\n   |\n24 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpc_01mv16.rs:25:17\n   |\n25 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpc_01mv16.rs:25:25\n\
    \   |\n25 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpc_01mv16.rs:26:17\n   |\n26 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpc_01mv16.rs:26:25\n   |\n26 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpc_01mv16.rs:27:17\n   |\n27 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpc_01mv16.rs:27:25\n   |\n27 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpc_01mv16.rs:28:17\n  \
    \ |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpc_01mv16.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 10 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        let mut j = i;\n        while j < value.len()\
    \ {\n            if digits[j] < digits[i] {\n                digits[j] += 10;\n\
    \                j += 1;\n            } else {\n                break;\n     \
    \       }\n        }\n        if j == i {\n            break;\n        }\n   \
    \     digits[i] = digits[j];\n        i += 1;\n    }\n    digits.parse().unwrap()\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpaxco7d3i.rs:40:17\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpaxco7d3i.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpaxco7d3i.rs:41:17\n   |\n41 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpaxco7d3i.rs:41:25\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpaxco7d3i.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpaxco7d3i.rs:42:25\n   |\n42 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpaxco7d3i.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpaxco7d3i.rs:43:25\n   |\n43 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpaxco7d3i.rs:44:17\n  \
    \ |\n44 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpaxco7d3i.rs:44:25\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0608]: cannot\
    \ index into a value of type `char`\n  --> /tmp/tmpaxco7d3i.rs:22:16\n   |\n22\
    \ |             if digits[j] < digits[i] {\n   |                ^^^^^^^^^\n\n\
    error[E0608]: cannot index into a value o"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        let mut digit = digits.chars().nth(1).unwrap();\n\
    \        if digit == '.' {\n            digit = digits.chars().nth(1).unwrap();\n\
    \        }\n        let mut digit = digit.chars().nth(1).unwrap();\n        if\
    \ digit == '.' {\n            digit = digits.chars().nth(1).unwrap();\n      \
    \  }\n        if digit == 'e' || digit == 'E' {\n            digit = digits.chars().nth(1).unwrap();\n\
    \        }\n        if digit == '+' || digit == '-' {\n            digit = digits.chars().nth(1).unwrap();\n\
    \        }\n        if digit == '0' {\n            digit = digits.chars().nth(1).unwrap();\n\
    \        }\n        if digit == '9' {\n            digit = digits.chars().nth(1).unwrap();\n\
    \        }\n        if digit == '.' {\n            digit = digits.chars().nth(1).unwrap();\n\
    \        }\n        if digit == 'e' || digit == 'E' {\n            digit = digits.chars().nth(1).unwrap();\n\
    \        }\n        if digit == '+' || digit == '-' {\n            digit = digits.chars().nth(1).unwrap();\n\
    \        }\n        if digit == '0' {\n            digit = digits.chars().nth(1).unwrap();\n\
    \        }\n        if digit == '9' {\n            digit = digits.chars().nth(1).unwrap();\n\
    \        }\n        if digit == '.' {\n            digit = digits.chars().nth(1).unwrap();\n\
    \        }\n        if digit == 'e' || digit == 'E' {\n            digit = digits.chars().nth(1).unwrap();\n\
    \        }\n        if digit == '+' || digit == '-' {\n            digit = digits.chars().nth(1).unwrap();\n\
    \        }\n        if digit == '0' {\n            digit = digits.chars().nth(1).unwrap();\n\
    \        }\n        if digit == '9' {\n            digit = digits.chars().nth(1).unwrap();\n\
    \        }\n        if digit == '.' {\n            digit = digits.chars().nth(1).unwrap();\n\
    \        }\n        if digit == 'e' || digit == 'E' {\n            digit = digits.chars().nth(1).unwrap();\n\
    \        }\n        if digit == '+' || digit == '-' {\n            digit = digits.chars().nth(1).unwrap();\n\
    \        }\n        if digit == '0' {\n            digit = \n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpa_e8wr4i.rs:90:3\n\
    \   |\n14 | fn closest_integer(value: String) -> isize {\n   |               \
    \                             - unclosed delimiter\n...\n19 |     while i < value.len()\
    \ {\n   |                           - unclosed delimiter\n...\n79 |         if\
    \ digit == '0' {\n   |                         - this delimiter might not be properly\
    \ closed...\n80 |             digit = \n81 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n90 | }\n   |   ^\n\nerror: expected expression,\
    \ found `}`\n  --> /tmp/tmpa_e8wr4i.rs:81:1\n   |\n81 | }\n   | ^ expected expression\n\
    \nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpa_e8wr4i.rs:85:17\n\
    \   |\n85 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpa_e8wr4i.rs:85:25\n   |\n85 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpa_e8wr4i.rs:86:17\n   |\n86 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpa_e8wr4i.rs:86:25\n\
    \   |\n86 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpa_e8wr4i.rs:87:17\n   |\n87 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpa_e8wr4i.rs:87:25\n   |\n87 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpa_e8wr4i.rs:88:17\n   |\n88 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpa_e8wr4i.rs:88:25\n   |\n88 |     assert_eq!({left},\
    \ {right});\n   |  "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut result = 0.0;\n    let mut\
    \ exponent = value.len() - 1;\n    while exponent >= 0 {\n        let mut digit\
    \ = digits[exponent];\n        if digit < 0 {\n            digit = -digit;\n \
    \           exponent = exponent - 1;\n        }\n        let mut next_digit =\
    \ digits[exponent];\n        if next_digit < 0 {\n            next_digit = -next_digit;\n\
    \            exponent = exponent - 1;\n        }\n        let mut dist = digit\
    \ + next_digit;\n        if dist > result {\n            result = dist;\n    \
    \    }\n        exponent = exponent - 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp6cx5y8s2.rs:41:17\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6cx5y8s2.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp6cx5y8s2.rs:42:17\n   |\n42 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp6cx5y8s2.rs:42:25\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp6cx5y8s2.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp6cx5y8s2.rs:43:25\n   |\n43 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp6cx5y8s2.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp6cx5y8s2.rs:44:25\n   |\n44 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp6cx5y8s2.rs:45:17\n  \
    \ |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6cx5y8s2.rs:45:25\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6cx5y8s2.rs:21:20\n   |\n21 |         if digit < 0 {\n\
    \   |                    ^\n   |                    |\n   |                  \
    \  expected enum `Option`, found intege"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut closest_digit = digits[0];\n\
    \    let mut closest_distance = value.len() as isize;\n    let mut closest_integer\
    \ = value.len() as isize;\n    let mut current_distance = 0;\n    let mut current_integer\
    \ = value.len() as isize;\n    while current_integer > 0 {\n        if current_distance\
    \ > closest_distance {\n            closest_distance = current_distance;\n   \
    \         closest_digit = digits[current_integer];\n        }\n        current_distance\
    \ += closest_digit;\n        current_integer -= 1;\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpcxvfyd1j.rs:35:17\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpcxvfyd1j.rs:35:25\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpcxvfyd1j.rs:36:17\n   |\n36 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpcxvfyd1j.rs:36:25\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpcxvfyd1j.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpcxvfyd1j.rs:37:25\n   |\n37 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpcxvfyd1j.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpcxvfyd1j.rs:38:25\n   |\n38 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpcxvfyd1j.rs:39:17\n  \
    \ |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpcxvfyd1j.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `[Option<u32>]` cannot be indexed by `isize`\n  --> /tmp/tmpcxvfyd1j.rs:25:29\n\
    \   |\n25 |             closest_digit = digits[current_integer];\n   |       \
    \                      ^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_digit() {\n            c.to_digit(10).unwrap()\n    \
    \    } else {\n            c.to_digit(16).unwrap()\n        }\n    });\n    let\
    \ mut result = value.chars().enumerate().map(|(i, c)| {\n        if c.is_digit()\
    \ {\n            c.to_digit(10).unwrap()\n        } else {\n            c.to_digit(16).unwrap()\n\
    \        }\n    });\n    let mut min = result.len();\n    let mut max = result.len();\n\
    \    let mut min_digits = digits.len();\n    let mut max_digits = digits.len();\n\
    \    let mut min_value = result.len();\n    let mut max_value = result.len();\n\
    \    let mut min_digit = result.len();\n    let mut max_digit = result.len();\n\
    \    let mut min_value = result.len();\n    let mut max_value = result.len();\n\
    \    let mut min_digit = result.len();\n    let mut max_digit = result.len();\n\
    \    let mut min_value = result.len();\n    let mut max_value = result.len();\n\
    \    let mut min_digit = result.len();\n    let mut max_digit = result.len();\n\
    \    let mut min_value = result.len();\n    let mut max_value = result.len();\n\
    \    let mut min_digit = result.len();\n    let mut max_digit = result.len();\n\
    \    let mut min_value = result.len();\n    let mut max_value = result.len();\n\
    \    let mut min_digit = result.len();\n    let mut max_digit = result.len();\n\
    \    let mut min_value = result.len();\n    let mut max_value = result.len();\n\
    \    let mut min_digit = result.len();\n    let mut max_digit = result.len();\n\
    \    let mut min_value = result.len();\n    let mut max_value = result.len();\n\
    \    let mut min_digit = result.len();\n    let mut max_digit = result.len();\n\
    \    let mut min_value = result.len();\n    let mut max_value = result.len();\n\
    \    let mut min_digit = result.len();\n    let mut max_digit = result.len();\n\
    \    let mut min_value = result.len();\n    let mut max_value = result.len();\n\
    \    let mut min_digit = result.len();\n    let mut max_digit = result.len();\n\
    \    let mut min_value = result.len();\n    let mut max_value = result.len();\n\
    \    let mut min_digit = result.len();\n    let \n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpndka6squ.rs:74:1\n  \
    \ |\n74 | }\n   | ^ expected pattern\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpndka6squ.rs:78:17\n   |\n78 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpndka6squ.rs:78:25\n \
    \  |\n78 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpndka6squ.rs:79:17\n   |\n79 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpndka6squ.rs:79:25\n   |\n79 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpndka6squ.rs:80:17\n   |\n80 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpndka6squ.rs:80:25\n   |\n80 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpndka6squ.rs:81:17\n  \
    \ |\n81 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpndka6squ.rs:81:25\n   |\n81 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpndka6squ.rs:82:17\n   |\n82 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpndka6squ.rs:82:25\n\
    \   |\n82 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0061]: this function takes 1 argument but\
    \ 0 arguments were supplied\n   --> /tmp/tmpndka6squ.rs:17:"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_digit() {\n            c.to_digit(10).unwrap()\n    \
    \    } else {\n            c.to_digit(16).unwrap()\n        }\n    });\n    let\
    \ mut result = value.chars().enumerate().map(|(i, c)| {\n        if c.is_digit()\
    \ {\n            c.to_digit(10).unwrap()\n        } else {\n            c.to_digit(16).unwrap()\n\
    \        }\n    });\n    let mut smallest = result.iter().min().unwrap();\n  \
    \  let mut largest = result.iter().max().unwrap();\n    let mut mid = result.len()\
    \ / 2;\n    while let Some(mid) = result.iter().position(|&x| x == mid) {\n  \
    \      if mid < smallest {\n            smallest = mid;\n        }\n        if\
    \ mid > largest {\n            largest = mid;\n        }\n        mid = result.len()\
    \ / 2;\n    }\n    smallest.to_digit(10).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpg1qyvhv1.rs:47:17\n\
    \   |\n47 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpg1qyvhv1.rs:47:25\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpg1qyvhv1.rs:48:17\n   |\n48 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpg1qyvhv1.rs:48:25\n\
    \   |\n48 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpg1qyvhv1.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpg1qyvhv1.rs:49:25\n   |\n49 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpg1qyvhv1.rs:50:17\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpg1qyvhv1.rs:50:25\n   |\n50 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpg1qyvhv1.rs:51:17\n  \
    \ |\n51 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpg1qyvhv1.rs:51:25\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpg1qyvhv1.rs:17:14\n\
    \    |\n17  |         if c.is_digit() {\n    |              ^^^^^^^^- supplied\
    \ 0 arguments\n    |       "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            0\n        }\n    });\n    let mut result = digits[0];\n\
    \    let mut max_diff = 0;\n    for &(i, &d) in &digits[1..] {\n        let diff\
    \ = d - result;\n        if diff > max_diff {\n            max_diff = diff;\n\
    \            result = i;\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpq5omq_zg.rs:37:17\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpq5omq_zg.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpq5omq_zg.rs:38:17\n   |\n38 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpq5omq_zg.rs:38:25\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpq5omq_zg.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpq5omq_zg.rs:39:25\n   |\n39 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpq5omq_zg.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpq5omq_zg.rs:40:25\n   |\n40 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpq5omq_zg.rs:41:17\n  \
    \ |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpq5omq_zg.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0608]: cannot\
    \ index into a value of type `Map<Enumerate<Chars<'_>>, [closure@/tmp/tmpq5omq_zg.rs:16:52:\
    \ 22:6]>`\n  --> /tmp/tmpq5omq_zg.rs:23:22\n   |\n23 |     let mut result = digits[0];\n\
    \   |           "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut result = 0.0;\n    let mut\
    \ last_digit = digits.get(0);\n    let mut last_result = 0.0;\n    let mut last_last_digit\
    \ = 0.0;\n    let mut last_last_result = 0.0;\n    let mut last_last_last_digit\
    \ = 0.0;\n    let mut last_last_last_result = 0.0;\n    let mut last_last_last_last_digit\
    \ = 0.0;\n    let mut last_last_last_last_result = 0.0;\n    let mut last_last_last_last_last_digit\
    \ = 0.0;\n    let mut last_last_last_last_last_result = 0.0;\n    let mut last_last_last_last_last_last_digit\
    \ = 0.0;\n    let mut last_last_last_last_last_last_result = 0.0;\n    let mut\
    \ last_last_last_last_last_last_last_digit = 0.0;\n    let mut last_last_last_last_last_last_last_result\
    \ = 0.0;\n    let mut last_last_last_last_last_last_last_last_digit = 0.0;\n \
    \   let mut last_last_last_last_last_last_last_result = 0.0;\n    let mut last_last_last_last_last_last_last_last_digit\
    \ = 0.0;\n    let mut last_last_last_last_last_last_last_last_result = 0.0;\n\
    \    let mut last_last_last_last_last_last_last_last_last_digit = 0.0;\n    let\
    \ mut last_last_last_last_last_last_last_last_last_result = 0.0;\n    let mut\
    \ last_last_last_last_last_last_last_last_last_last_digit = 0.0;\n    let mut\
    \ last_last_last_last_last_last_last_last_last_last_result = 0.0;\n    let mut\
    \ last_last_last_last_last_last_last_last_last_last_digit = 0.0;\n    let mut\
    \ last_last_last_last_last_last_last_last_last_last_result = 0.0;\n    let mut\
    \ last_last_last_last_last_last_last_last_last_last_last_digit = 0.0;\n    let\
    \ mut last_last_last_last_last_last_last_last_last_last_last_result = 0.0;\n \
    \   let mut last_last_last_last_last_last_last_last_last_last_last_last_digit\
    \ = 0.0;\n    let mut last_last_last_last_last_last_last_last_last_last_last_last_result\
    \ = 0.0;\n    let mut last_last_last_last_last_last_last_last_last_last_last_last_last_digit\
    \ = 0.0;\n    let mut last_last_last_last_last_last_last_last_last_last_last_last_last_result\
    \ = 0.0;\n    let mut last_last_last_last_last_last_last_last_last_last_last_last_last_last_digit\
    \ = 0.0;\n    let mut last_last_last_last_last_last_last_last_last_last_last_last_last_last_result\
    \ = 0.0;\n\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpfzylo0k1.rs:55:17\n\
    \   |\n55 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfzylo0k1.rs:55:25\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpfzylo0k1.rs:56:17\n   |\n56 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpfzylo0k1.rs:56:25\n\
    \   |\n56 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpfzylo0k1.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpfzylo0k1.rs:57:25\n   |\n57 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpfzylo0k1.rs:58:17\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpfzylo0k1.rs:58:25\n   |\n58 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpfzylo0k1.rs:59:17\n  \
    \ |\n59 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfzylo0k1.rs:59:25\n   |\n59 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfzylo0k1.rs:14:38\n   |\n14 | fn closest_integer(value:\
    \ String) -> isize {\n   |    ---------------                   ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut len = 0;\n    while i < digits.len() && j < digits.len()\
    \ {\n        if digits[i] > digits[j] {\n            len = j;\n        } else\
    \ {\n            len = i;\n        }\n        i += 1;\n        j += 1;\n    }\n\
    \    if len == 0 {\n        return 0;\n    }\n    if len == digits.len() {\n \
    \       return digits.len() - 1;\n    }\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut len = 0;\n    while i < digits.len() && j < digits.len() {\n    \
    \    if digits[i] > digits[j] {\n            len = j;\n        } else {\n    \
    \        len = i;\n        }\n        i += 1;\n        j += 1;\n    }\n    if\
    \ len == 0 {\n        return digits.len() - 1;\n    }\n    if len == digits.len()\
    \ {\n        return 0;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    let\
    \ mut len = 0;\n    while i < digits.len() && j < digits.len() {\n        if digits[i]\
    \ > digits[j] {\n            len = j;\n        } else {\n            len = i;\n\
    \        }\n        i += 1;\n        j += 1;\n    }\n    if len == 0 {\n     \
    \   return digits.len() - 1;\n    }\n    if len == digits.len() {\n        return\
    \ 0;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    let mut len = 0;\n  \
    \  while i < digits.len() && j < digits.len() {\n        if digits[i] > digits[j]\
    \ {\n            len = j;\n        } else {\n            len = i;\n        }\n\
    \        i += 1;\n        j += 1;\n    }\n    if len == 0 {\n        return digits.len()\
    \ - 1;\n    }\n    if len == digits.len() {\n        return 0;\n    }\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    let mut len = 0;\n    while i < digits.len()\
    \ && j < digits.len() {\n        if digits[i] > digits[j] {\n            len =\
    \ j;\n        } else {\n            len = i;\n        }\n        i += 1;\n   \
    \     j += 1;\n    }\n    if len == 0 {\n        return digits.len() - 1;\n  \
    \  }\n    if len == digits.len() {\n        return 0;\n    }\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    let mut len = 0;\n    while i < digits.len() &&\
    \ j < digits.len() {\n        if digits[i] > digits[j] {\n            len = j;\n\
    \        } else {\n            len = i;\n        }\n        i += 1;\n        j\
    \ += 1;\n    }\n\n}\n\nfn main() {\n    let candidate = closest_integer;\n   \
    \ assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n   --> /tmp/tmptdyh2ov4.rs:125:17\n\
    \    |\n125 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmptdyh2ov4.rs:125:25\n    |\n125 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmptdyh2ov4.rs:126:17\n\
    \    |\n126 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmptdyh2ov4.rs:126:25\n    |\n126 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmptdyh2ov4.rs:127:17\n\
    \    |\n127 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmptdyh2ov4.rs:127:25\n    |\n127 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmptdyh2ov4.rs:128:17\n\
    \    |\n128 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmptdyh2ov4.rs:128:25\n    |\n128 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmptdyh2ov4.rs:129:17\n\
    \    |\n129 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmptdyh2ov4.rs:129:25\n    |\n129 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptdyh2ov4.rs:34:16\n   |\n14 | fn closest_integer(value:\
    \ String) -> isize {\n   |                                    "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n    let mut result = value.chars().take_while(|c| c\
    \ >= '0' && c <= '9').nth(1);\n    let mut exponent = 0;\n    let mut remainder\
    \ = 0;\n    while let Some(digit) = digits.next() {\n        remainder *= 10;\n\
    \        remainder += digit;\n        exponent = exponent + 1;\n    }\n    if\
    \ remainder < 0 {\n        result = result.chain(digits.take(exponent));\n   \
    \ }\n    if exponent == 0 {\n        result.next()\n    } else {\n        result.chain(digits.take(exponent\
    \ - 1))\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpog3ju97c.rs:37:17\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpog3ju97c.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpog3ju97c.rs:38:17\n   |\n38 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpog3ju97c.rs:38:25\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpog3ju97c.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpog3ju97c.rs:39:25\n   |\n39 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpog3ju97c.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpog3ju97c.rs:40:25\n   |\n40 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpog3ju97c.rs:41:17\n  \
    \ |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpog3ju97c.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpog3ju97c.rs:16:56\n   |\n16 |     let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n   |                                               \
    \         ^^"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut k = 0;\n    while i < digits.len() && j < digits.len()\
    \ {\n        if digits[i] > digits[j] {\n            k = i;\n        } else {\n\
    \            k = j;\n        }\n        i += 1;\n        j += 1;\n        if k\
    \ == 0 {\n            break;\n        }\n    }\n    if k == 0 {\n        return\
    \ value.chars().last().unwrap();\n    }\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    while i < digits.len() && j < digits.len() {\n      \
    \  if digits[i] > digits[j] {\n            k = i;\n        } else {\n        \
    \    k = j;\n        }\n        i += 1;\n        j += 1;\n        if k == digits.len()\
    \ - 1 {\n            break;\n        }\n    }\n    if k == digits.len() - 1 {\n\
    \        return value.chars().last().unwrap();\n    }\n    let mut i = 0;\n  \
    \  let mut j = 0;\n    let mut k = 0;\n    while i < digits.len() && j < digits.len()\
    \ {\n        if digits[i] > digits[j] {\n            k = i;\n        } else {\n\
    \            k = j;\n        }\n        i += 1;\n        j += 1;\n        if k\
    \ == 0 {\n            break;\n        }\n    }\n    if k == 0 {\n        return\
    \ value.chars().last().unwrap();\n    }\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    while i < digits.len() && j < digits.len() {\n      \
    \  if digits[i] > digits[j] {\n            k = i;\n        } else {\n        \
    \    k = j;\n        }\n        i += 1;\n        j += 1;\n        if k == digits.len()\
    \ - 1 {\n            break;\n        }\n    }\n    if k == digits.len() - 1 {\n\
    \        return value.chars().last().unwrap();\n    }\n    let mut i = 0;\n  \
    \  let mut j = 0;\n    let mut k = 0;\n    while i < digits.len() && j < digits.len()\
    \ {\n        if digits[i] > digits[j] {\n            k = i;\n        } else {\n\
    \            k = j;\n        }\n        i += 1;\n        j += 1;\n        if k\
    \ == digits.len() - 1 {\n            break;\n        }\n    }\n    if k == digits.len()\
    \ - 1 {\n        return value.chars().last().unwrap();\n    }\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    let mut k = 0;\n    while i < digits.len() && j\
    \ < digits.len() {\n        if digits[i] > digits[j] {\n            k = i;\n \
    \       } else {\n            k = j;\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpvjx0olbf.rs:125:3\n\
    \    |\n14  | fn closest_integer(value: String) -> isize {\n    |            \
    \                                - unclosed delimiter\n...\n111 |     while i\
    \ < digits.len() && j < digits.len() {\n    |                                \
    \                - unclosed delimiter\n...\n114 |         } else {\n    |    \
    \            - this delimiter might not be properly closed...\n115 |         \
    \    k = j;\n116 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n125 | }\n    |   ^\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \   --> /tmp/tmpvjx0olbf.rs:120:17\n    |\n120 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpvjx0olbf.rs:120:25\n    |\n120 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpvjx0olbf.rs:121:17\n    |\n121 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpvjx0olbf.rs:121:25\n    |\n121 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpvjx0olbf.rs:122:17\n    |\n122 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpvjx0olbf.rs:122:25\n    |\n122 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpvjx0olbf.rs:123:17\n    |\n123 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpvjx0olbf.rs:123:25\n    |\n123 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut exponent = 0;\n    let mut fraction = 0;\n    while digits.is_some()\
    \ {\n        fraction += 1;\n        digits = digits.next_back().unwrap();\n \
    \       exponent += 1;\n    }\n    let mut result = value.chars().nth(0).unwrap();\n\
    \    let mut exponent = exponent;\n    while exponent > 0 {\n        if exponent\
    \ % 2 == 0 {\n            result += '0';\n        } else {\n            result\
    \ += '1';\n        }\n        exponent /= 2;\n    }\n    result.parse().unwrap()\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp_8qsqoi_.rs:39:17\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_8qsqoi_.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_8qsqoi_.rs:40:17\n   |\n40 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_8qsqoi_.rs:40:25\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_8qsqoi_.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_8qsqoi_.rs:41:25\n   |\n41 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_8qsqoi_.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_8qsqoi_.rs:42:25\n   |\n42 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_8qsqoi_.rs:43:17\n  \
    \ |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_8qsqoi_.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `is_some` found for type `char` in the current scope\n  --> /tmp/tmp_8qsqoi_.rs:19:18\n\
    \   |\n19 |     while digits.is_some() {\n   |                  ^^^^^^^ method\
    \ not found in `cha"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut smallest = std::cmp::min(*digits.iter().cloned().collect::<isize>());\n\
    \    let mut largest = std::cmp::max(*digits.iter().cloned().collect::<isize>());\n\
    \    let mut i = 0;\n    while i < digits.len() && smallest > largest {\n    \
    \    if *digits[i] < smallest {\n            smallest = *digits[i];\n        }\n\
    \        if *digits[i] > largest {\n            largest = *digits[i];\n      \
    \  }\n        i += 1;\n    }\n    smallest\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp_jopxc36.rs:34:17\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_jopxc36.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_jopxc36.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_jopxc36.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_jopxc36.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_jopxc36.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_jopxc36.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_jopxc36.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_jopxc36.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_jopxc36.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0061]: this\
    \ function takes 2 arguments but 1 argument was supplied\n    --> /tmp/tmp_jopxc36.rs:17:24\n\
    \     |\n17   |     let mut smallest = std::cmp::min(*digits.iter().cloned().collect::<isize>());\n\
    \    "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().take(10).collect::<Vec<_>>();\n\
    \    let mut result = value.chars().take(10).collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < 10 {\n        if digits[i] != '.' {\n            digits[i]\
    \ = '0';\n        }\n        i += 1;\n    }\n    let mut digits = digits.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut result = result.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < 10 {\n        if digits[i] != '.' {\n            digits[i]\
    \ = '0';\n        }\n        i += 1;\n    }\n    let mut digits = digits.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut result = result.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < 10 {\n        if digits[i] != '.' {\n            digits[i]\
    \ = '0';\n        }\n        i += 1;\n    }\n    let mut digits = digits.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut result = result.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < 10 {\n        if digits[i] != '.' {\n            digits[i]\
    \ = '0';\n        }\n        i += 1;\n    }\n    let mut digits = digits.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut result = result.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < 10 {\n        if digits[i] != '.' {\n            digits[i]\
    \ = '0';\n        }\n        i += 1;\n    }\n    let mut digits = digits.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut result = result.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < 10 {\n        if digits[i] != '.' {\n            digits[i]\
    \ = '0';\n        }\n        i += 1;\n    }\n    let mut digits = digits.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut result = result.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ i = 0;\n    while i < 10 {\n        if digits[i] != '.' {\n            digits[i]\
    \ = '0';\n        }\n        i += 1;\n    }\n    let mut digits = digits.iter().cloned().collect\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcxdk13pt.rs:79:52\n   |\n\
    79 |     let mut digits = digits.iter().cloned().collect\n   |               \
    \                                     ^ help: add `;` here\n80 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpcxdk13pt.rs:84:17\n\
    \   |\n84 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpcxdk13pt.rs:84:25\n   |\n84 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpcxdk13pt.rs:85:17\n   |\n85 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpcxdk13pt.rs:85:25\n\
    \   |\n85 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpcxdk13pt.rs:86:17\n   |\n86 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpcxdk13pt.rs:86:25\n   |\n86 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpcxdk13pt.rs:87:17\n   |\n87 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpcxdk13pt.rs:87:25\n   |\n87 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpcxdk13pt.rs:88:17\n  \
    \ |\n88 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpcxdk13pt.rs:88:25\n   |\n88 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_digit(16).unwrap()\n        }\n    }).collect::<Vec<_>>();\n\
    \    let mut result = 0.0;\n    let mut max_diff = 0.0;\n    let mut max_diff_index\
    \ = 0;\n    for (i, &digit) in &digits {\n        let diff = digit - result;\n\
    \        if diff > max_diff {\n            max_diff = diff;\n            max_diff_index\
    \ = i;\n        }\n        result = result + digit;\n    }\n    max_diff_index\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpbwsgr_5b.rs:39:17\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpbwsgr_5b.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpbwsgr_5b.rs:40:17\n   |\n40 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpbwsgr_5b.rs:40:25\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpbwsgr_5b.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpbwsgr_5b.rs:41:25\n   |\n41 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpbwsgr_5b.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpbwsgr_5b.rs:42:25\n   |\n42 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpbwsgr_5b.rs:43:17\n  \
    \ |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpbwsgr_5b.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwsgr_5b.rs:26:9\n   |\n26 |     for (i, &digit) in &digits\
    \ {\n   |         ^^^^^^^^^^^    ------- this expression has type `&u32`\n   |\
    \         |\n   |         expecte"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if digits[i] != '.' {\n            digits =\
    \ digits.chars().nth(1).unwrap();\n            result = result.chars().nth(1).unwrap();\n\
    \        }\n        let digit = digits[i] - '0';\n        let mut new_digit =\
    \ digit;\n        let mut new_result = result;\n        if digit < 0 {\n     \
    \       new_digit *= -1;\n            new_result *= -1;\n        }\n        if\
    \ new_digit == 0 {\n            i += 1;\n            continue;\n        }\n  \
    \      if new_digit < 0 {\n            new_digit *= -1;\n        }\n        if\
    \ new_digit < new_result {\n            result = new_result;\n        }\n    \
    \    i += 1;\n    }\n    result.parse().unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpbb1dkc47.rs:48:17\n\
    \   |\n48 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpbb1dkc47.rs:48:25\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpbb1dkc47.rs:49:17\n   |\n49 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpbb1dkc47.rs:49:25\n\
    \   |\n49 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpbb1dkc47.rs:50:17\n   |\n50 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpbb1dkc47.rs:50:25\n   |\n50 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpbb1dkc47.rs:51:17\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpbb1dkc47.rs:51:25\n   |\n51 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpbb1dkc47.rs:52:17\n  \
    \ |\n52 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpbb1dkc47.rs:52:25\n   |\n52 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0608]: cannot\
    \ index into a value of type `char`\n  --> /tmp/tmpbb1dkc47.rs:20:12\n   |\n20\
    \ |         if digits[i] != '.' {\n   |            ^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `chars` found for type `"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut result = 0.0;\n    let mut\
    \ last_digit = digits[0];\n    let mut last_result = 0.0;\n    let mut last_last_digit\
    \ = digits[0];\n    for digit in digits.iter_mut() {\n        if digit < last_digit\
    \ {\n            last_result = last_last_digit;\n            last_digit = digit;\n\
    \        }\n        if digit > last_digit {\n            last_last_digit = digit;\n\
    \        }\n        result += digit as isize;\n    }\n    if result < 0 {\n  \
    \      result -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpxzw0o7zb.rs:39:17\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpxzw0o7zb.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpxzw0o7zb.rs:40:17\n   |\n40 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpxzw0o7zb.rs:40:25\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpxzw0o7zb.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpxzw0o7zb.rs:41:25\n   |\n41 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpxzw0o7zb.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpxzw0o7zb.rs:42:25\n   |\n42 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpxzw0o7zb.rs:43:17\n  \
    \ |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpxzw0o7zb.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxzw0o7zb.rs:22:20\n   |\n22 |         if digit < last_digit\
    \ {\n   |                    ^^^^^^^^^^\n   |                    |\n   |     \
    \               expected `&mut Opt"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_digit(10) {\n            c.to_digit(10)\n        } else\
    \ {\n            c.to_digit(10)\n        }\n    });\n    let mut result = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_digit(10) {\n            c.to_digit(10)\n        } else\
    \ {\n            c.to_digit(10)\n        }\n    });\n    let mut min_value = result.iter().min().unwrap();\n\
    \    let mut max_value = result.iter().max().unwrap();\n    let mut min_digits\
    \ = digits.iter().min().unwrap();\n    let mut max_digits = digits.iter().max().unwrap();\n\
    \    let mut min_value = min_value.to_digit(10);\n    let mut max_value = max_value.to_digit(10);\n\
    \    let mut min_digits = min_digits.to_digit(10);\n    let mut max_digits = max_digits.to_digit(10);\n\
    \    let mut min_value = min_value.to_digit(10);\n    let mut max_value = max_value.to_digit(10);\n\
    \    let mut min_digits = min_digits.to_digit(10);\n    let mut max_digits = max_digits.to_digit(10);\n\
    \    let mut min_value = min_value.to_digit(10);\n    let mut max_value = max_value.to_digit(10);\n\
    \    let mut min_digits = min_digits.to_digit(10);\n    let mut max_digits = max_digits.to_digit(10);\n\
    \    let mut min_value = min_value.to_digit(10);\n    let mut max_value = max_value.to_digit(10);\n\
    \    let mut min_digits = min_digits.to_digit(10);\n    let mut max_digits = max_digits.to_digit(10);\n\
    \    let mut min_value = min_value.to_digit(10);\n    let mut max_value = max_value.to_digit(10);\n\
    \    let mut min_digits = min_digits.to_digit(10);\n    let mut max_digits = max_digits.to_digit(10);\n\
    \    let mut min_value = min_value.to_digit(10);\n    let mut max_value = max_value.to_digit(10);\n\
    \    let mut min_digits = min_digits.to_digit(10);\n    let mut max_digits = max_digits.to_digit(10);\n\
    \    let mut min_value = min_value.to_digit(10);\n    let mut max_value = max_value.to_digit(10);\n\
    \    let mut min_digits = min_digits.to_digit(10);\n    let mut max_digits = max_digits.to_digit(10);\n\
    \    let mut min_value = min_value.to_digit(10);\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpv0p9dbjc.rs:67:17\n\
    \   |\n67 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpv0p9dbjc.rs:67:25\n   |\n67 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpv0p9dbjc.rs:68:17\n   |\n68 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpv0p9dbjc.rs:68:25\n\
    \   |\n68 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpv0p9dbjc.rs:69:17\n   |\n69 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpv0p9dbjc.rs:69:25\n   |\n69 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpv0p9dbjc.rs:70:17\n   |\n70 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpv0p9dbjc.rs:70:25\n   |\n70 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpv0p9dbjc.rs:71:17\n  \
    \ |\n71 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpv0p9dbjc.rs:71:25\n   |\n71 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `iter` found for struct `Map` in the current scope\n  --> /tmp/tmpv0p9dbjc.rs:30:32\n\
    \   |\n30 |     let mut min_value = result.iter().min().unwrap();\n   |      \
    \                     "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if digits.is_none() {\n            digits =\
    \ value.chars().nth(i).unwrap();\n            i += 1;\n            continue;\n\
    \        }\n        if digits.unwrap() == 0 {\n            digits = value.chars().nth(i).unwrap();\n\
    \            i += 1;\n            continue;\n        }\n        if digits.unwrap()\
    \ < result.unwrap() {\n            result = digits.unwrap();\n        }\n    \
    \    digits = value.chars().nth(i).unwrap();\n        i += 1;\n    }\n    result.parse().unwrap()\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp72hzdeac.rs:41:17\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp72hzdeac.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp72hzdeac.rs:42:17\n   |\n42 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp72hzdeac.rs:42:25\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp72hzdeac.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp72hzdeac.rs:43:25\n   |\n43 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp72hzdeac.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp72hzdeac.rs:44:25\n   |\n44 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp72hzdeac.rs:45:17\n  \
    \ |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp72hzdeac.rs:45:25\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `is_none` found for type `char` in the current scope\n  --> /tmp/tmp72hzdeac.rs:20:19\n\
    \   |\n20 |         if digits.is_none() {\n   |                   ^^^^^^^ method\
    \ not found in `c"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    if value.chars().count() > 1 {\n  \
    \      value = value.chars().fold(String::new(), |mut acc, c| {\n            acc.push_str(&c.to_string());\n\
    \            acc\n        });\n    }\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut smallest = digits[0];\n  \
    \  let mut largest = digits[0];\n    for i in 1..digits.len() {\n        if digits[i]\
    \ > largest {\n            largest = digits[i];\n        }\n        if digits[i]\
    \ < smallest {\n            smallest = digits[i];\n        }\n    }\n    let mut\
    \ result = smallest;\n    if largest - smallest > 1 {\n        result = largest\
    \ + 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpmgbr2mka.rs:42:17\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmgbr2mka.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpmgbr2mka.rs:43:17\n   |\n43 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpmgbr2mka.rs:43:25\n\
    \   |\n43 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpmgbr2mka.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpmgbr2mka.rs:44:25\n   |\n44 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpmgbr2mka.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpmgbr2mka.rs:45:25\n   |\n45 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpmgbr2mka.rs:46:17\n  \
    \ |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmgbr2mka.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0369]: cannot\
    \ subtract `Option<u32>` from `Option<u32>`\n  --> /tmp/tmpmgbr2mka.rs:34:16\n\
    \   |\n34 |     if largest - smallest > 1 {\n   |        ------- ^ -------- Option<u32>\n\
    \   |        |\n   |        Op"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut result = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut min_value = result.iter().min().unwrap();\n\
    \    let mut max_value = result.iter().max().unwrap();\n    let mut min_digits\
    \ = digits.iter().min().unwrap();\n    let mut max_digits = digits.iter().max().unwrap();\n\
    \    while min_value != max_value {\n        let mut min_digit = min_digits.iter().min().unwrap();\n\
    \        let mut max_digit = max_digits.iter().max().unwrap();\n        if min_digit\
    \ == max_digit {\n            if min_value == 0 {\n                min_value =\
    \ 0;\n            }\n            if max_value == 0 {\n                max_value\
    \ = 0;\n            }\n            return min_value;\n        }\n        if min_digit\
    \ > max_digit {\n            min_value = min_value - 1;\n            min_digit\
    \ = min_digits.iter().min().unwrap();\n            max_digit = max_digits.iter().max().unwrap();\n\
    \        } else {\n            max_value = max_value + 1;\n            max_digit\
    \ = max_digits.iter().min().unwrap();\n            min_digit = min_digits.iter().max().unwrap();\n\
    \        }\n    }\n    min_value\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmposj4uuuq.rs:49:17\n\
    \   |\n49 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmposj4uuuq.rs:49:25\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmposj4uuuq.rs:50:17\n   |\n50 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmposj4uuuq.rs:50:25\n\
    \   |\n50 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmposj4uuuq.rs:51:17\n   |\n51 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmposj4uuuq.rs:51:25\n   |\n51 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmposj4uuuq.rs:52:17\n   |\n52 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmposj4uuuq.rs:52:25\n   |\n52 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmposj4uuuq.rs:53:17\n  \
    \ |\n53 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmposj4uuuq.rs:53:25\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: can't\
    \ compare `&Option<u32>` with `{integer}`\n  --> /tmp/tmposj4uuuq.rs:26:26\n \
    \  |\n26 |             if min_value == 0 {\n   |                          ^^ no\
    \ implementation for `&Option<u32> == {i"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut last_digit = digits.get(0);\n    let mut last_result\
    \ = result.get(0);\n    while i < digits.len() && j < result.len() {\n       \
    \ if digits.get(i) < result.get(j) {\n            i += 1;\n            last_digit\
    \ = digits.get(i);\n            last_result = result.get(j);\n        } else {\n\
    \            j += 1;\n            last_digit = digits.get(j);\n            last_result\
    \ = result.get(j);\n        }\n    }\n    if i == digits.len() {\n        return\
    \ last_digit as isize;\n    }\n    if j == result.len() {\n        return last_result\
    \ as isize;\n    }\n    if digits.get(i) == result.get(j) {\n        return last_digit\
    \ as isize;\n    }\n    if digits.get(i) > result.get(j) {\n        return last_result\
    \ as isize;\n    }\n    return last_digit as isize;\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpwx6txh7e.rs:50:17\n\
    \   |\n50 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpwx6txh7e.rs:50:25\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpwx6txh7e.rs:51:17\n   |\n51 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpwx6txh7e.rs:51:25\n\
    \   |\n51 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpwx6txh7e.rs:52:17\n   |\n52 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpwx6txh7e.rs:52:25\n   |\n52 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpwx6txh7e.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpwx6txh7e.rs:53:25\n   |\n53 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpwx6txh7e.rs:54:17\n  \
    \ |\n54 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpwx6txh7e.rs:54:25\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0605]: non-primitive\
    \ cast: `Option<&char>` as `isize`\n  --> /tmp/tmpwx6txh7e.rs:34:16\n   |\n34\
    \ |         return last_digit as isize;\n   |                ^^^^^^^^^^^^^^^^^^^\
    \ an `as` expression can only b"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut v = value.to_string().parse().unwrap();\n    let mut i = 1;\n    while\
    \ i <= v {\n        if v % i == 0 {\n            return i;\n        }\n      \
    \  i += 1;\n    }\n    return i;\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpgcc44h51.rs:28:17\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpgcc44h51.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpgcc44h51.rs:29:17\n   |\n29 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpgcc44h51.rs:29:25\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpgcc44h51.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpgcc44h51.rs:30:25\n   |\n30 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpgcc44h51.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpgcc44h51.rs:31:25\n   |\n31 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpgcc44h51.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpgcc44h51.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 10 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_digit(16).unwrap()\n        }\n    });\n   \
    \ let mut min_value = digits[0].unwrap();\n    let mut max_value = digits[0].unwrap();\n\
    \    for &(i, &d) in &digits[1..] {\n        if d < min_value {\n            min_value\
    \ = d;\n        }\n        if d > max_value {\n            max_value = d;\n  \
    \      }\n    }\n    let mut min_value = min_value.to_digit(10).unwrap();\n  \
    \  let mut max_value = max_value.to_digit(10).unwrap();\n    let mut min_value\
    \ = min_value.saturating_add((max_value - min_value).abs());\n    let mut max_value\
    \ = max_value.saturating_add((max_value - min_value).abs());\n    let mut min_value\
    \ = min_value.saturating_sub((max_value - min_value).abs());\n    let mut max_value\
    \ = max_value.saturating_sub((max_value - min_value).abs());\n    min_value.saturating_sub(1)\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp8axc1u7u.rs:44:17\n\
    \   |\n44 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8axc1u7u.rs:44:25\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp8axc1u7u.rs:45:17\n   |\n45 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp8axc1u7u.rs:45:25\n\
    \   |\n45 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8axc1u7u.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8axc1u7u.rs:46:25\n   |\n46 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp8axc1u7u.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp8axc1u7u.rs:47:25\n   |\n47 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp8axc1u7u.rs:48:17\n  \
    \ |\n48 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8axc1u7u.rs:48:25\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0608]: cannot\
    \ index into a value of type `Map<Enumerate<Chars<'_>>, [closure@/tmp/tmp8axc1u7u.rs:16:52:\
    \ 22:6]>`\n  --> /tmp/tmp8axc1u7u.rs:23:25\n   |\n23 |     let mut min_value =\
    \ digits[0].unwrap();\n   "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_digit(16).unwrap()\n        }\n    });\n   \
    \ let mut result = value.chars().enumerate().map(|(i, c)| {\n        if c.is_numeric()\
    \ {\n            c.to_digit(10).unwrap()\n        } else {\n            c.to_digit(16).unwrap()\n\
    \        }\n    });\n    let mut smallest = result.iter().min().unwrap();\n  \
    \  let mut largest = result.iter().max().unwrap();\n    let mut mid = result.len()\
    \ / 2;\n    let mut i = 0;\n    while i < mid {\n        if smallest.0 > result.len()\
    \ {\n            break;\n        }\n        if largest.0 > result.len() {\n  \
    \          break;\n        }\n        if result[i] < smallest {\n            smallest\
    \ = result[i];\n        }\n        if result[i] > largest {\n            largest\
    \ = result[i];\n        }\n        i += 1;\n    }\n    smallest\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp35h9pzav.rs:54:17\n\
    \   |\n54 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp35h9pzav.rs:54:25\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp35h9pzav.rs:55:17\n   |\n55 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp35h9pzav.rs:55:25\n\
    \   |\n55 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp35h9pzav.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp35h9pzav.rs:56:25\n   |\n56 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp35h9pzav.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp35h9pzav.rs:57:25\n   |\n57 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp35h9pzav.rs:58:17\n  \
    \ |\n58 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp35h9pzav.rs:58:25\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `iter` found for struct `Map` in the current scope\n  --> /tmp/tmp35h9pzav.rs:30:31\n\
    \   |\n30 |     let mut smallest = result.iter().min().unwrap();\n   |       \
    \                     "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(0).unwrap();\n    let mut remainder =\
    \ value.chars().nth(1).unwrap();\n    while remainder.is_some() {\n        let\
    \ mut new_remainder = 0;\n        for digit in &mut remainder {\n            if\
    \ digit == '.' {\n                new_remainder += 1;\n                continue;\n\
    \            }\n            let mut new_digit = digit;\n            if new_remainder\
    \ == 0 {\n                new_digit -= 1;\n            }\n            new_remainder\
    \ += new_digit;\n        }\n        remainder = new_remainder;\n    }\n    while\
    \ digits.is_some() {\n        let mut new_digits = 0;\n        for digit in &mut\
    \ digits {\n            if digit == '.' {\n                new_digits += 1;\n\
    \                continue;\n            }\n            let mut new_digit = digit;\n\
    \            if new_digits == 0 {\n                new_digit -= 1;\n         \
    \   }\n            new_digits += new_digit;\n        }\n        digits = new_digits;\n\
    \    }\n    if digits.is_some() {\n        result -= digits;\n    }\n    if result\
    \ < 0 {\n        result += isize::MAX;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmplgcll3c2.rs:60:17\n\
    \   |\n60 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmplgcll3c2.rs:60:25\n   |\n60 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmplgcll3c2.rs:61:17\n   |\n61 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmplgcll3c2.rs:61:25\n\
    \   |\n61 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmplgcll3c2.rs:62:17\n   |\n62 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmplgcll3c2.rs:62:25\n   |\n62 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmplgcll3c2.rs:63:17\n   |\n63 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmplgcll3c2.rs:63:25\n   |\n63 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmplgcll3c2.rs:64:17\n  \
    \ |\n64 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmplgcll3c2.rs:64:25\n   |\n64 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `is_some` found for type `char` in the current scope\n  --> /tmp/tmplgcll3c2.rs:19:21\n\
    \   |\n19 |     while remainder.is_some() {\n   |                     ^^^^^^^\
    \ method not found i"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_digit(16).unwrap()\n        }\n    }).collect::<Vec<_>>();\n\
    \    let mut result = 0.0;\n    let mut last_digit = 0.0;\n    let mut last_digit2\
    \ = 0.0;\n    let mut last_digit3 = 0.0;\n    let mut last_digit4 = 0.0;\n   \
    \ let mut last_digit5 = 0.0;\n    let mut last_digit6 = 0.0;\n    let mut last_digit7\
    \ = 0.0;\n    let mut last_digit8 = 0.0;\n    let mut last_digit9 = 0.0;\n   \
    \ let mut last_digit10 = 0.0;\n    let mut last_digit11 = 0.0;\n    let mut last_digit12\
    \ = 0.0;\n    let mut last_digit13 = 0.0;\n    let mut last_digit14 = 0.0;\n \
    \   let mut last_digit15 = 0.0;\n    let mut last_digit16 = 0.0;\n    let mut\
    \ last_digit17 = 0.0;\n    let mut last_digit18 = 0.0;\n    let mut last_digit19\
    \ = 0.0;\n    let mut last_digit20 = 0.0;\n    let mut last_digit21 = 0.0;\n \
    \   let mut last_digit22 = 0.0;\n    let mut last_digit23 = 0.0;\n    let mut\
    \ last_digit24 = 0.0;\n    let mut last_digit25 = 0.0;\n    let mut last_digit26\
    \ = 0.0;\n    let mut last_digit27 = 0.0;\n    let mut last_digit28 = 0.0;\n \
    \   let mut last_digit29 = 0.0;\n    let mut last_digit30 = 0.0;\n    let mut\
    \ last_digit31 = 0.0;\n    let mut last_digit32 = 0.0;\n    let mut last_digit33\
    \ = 0.0;\n    let mut last_digit34 = 0.0;\n    let mut last_digit35 = 0.0;\n \
    \   let mut last_digit36 = 0.0;\n    let mut last_digit37 = 0.0;\n    let mut\
    \ last_digit38 = 0.0;\n    let mut last_digit39 = 0.0;\n    let mut last_digit40\
    \ = 0.0;\n    let mut last_digit41 = 0.0;\n    let mut last_digit42 = 0.0;\n \
    \   let mut last_digit43 = 0.0;\n    let mut last_digit44 = 0.0;\n    let mut\
    \ last_digit45 = 0.0;\n    let mut last_digit46 = 0.0;\n    let mut last_digit47\
    \ = 0.0;\n    let mut last_digit48 = 0.0;\n    let mut \n}\n\nfn main() {\n  \
    \  let candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpj3l_kgma.rs:73:1\n\
    \   |\n73 | }\n   | ^ expected identifier\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpj3l_kgma.rs:77:17\n   |\n77 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpj3l_kgma.rs:77:25\n \
    \  |\n77 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpj3l_kgma.rs:78:17\n   |\n78 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpj3l_kgma.rs:78:25\n   |\n78 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpj3l_kgma.rs:79:17\n   |\n79 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpj3l_kgma.rs:79:25\n   |\n79 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpj3l_kgma.rs:80:17\n  \
    \ |\n80 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpj3l_kgma.rs:80:25\n   |\n80 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpj3l_kgma.rs:81:17\n   |\n81 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpj3l_kgma.rs:81:25\n\
    \   |\n81 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --expl"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut exponent = 0;\n    let mut result = isize::MAX;\n    while exponent\
    \ < value.len() && result < isize::MAX {\n        let mut digit = digits.chars().nth(1).unwrap();\n\
    \        if digit == '.' {\n            exponent = value.len() - 1;\n        }\
    \ else {\n            exponent += 1;\n        }\n        if exponent < value.len()\
    \ {\n            digits = digits.chars().nth(exponent + 1).unwrap();\n       \
    \ }\n        result = result * 10 + digit.parse().unwrap();\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpvsqfqhlp.rs:36:17\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpvsqfqhlp.rs:36:25\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpvsqfqhlp.rs:37:17\n   |\n37 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpvsqfqhlp.rs:37:25\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpvsqfqhlp.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpvsqfqhlp.rs:38:25\n   |\n38 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpvsqfqhlp.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpvsqfqhlp.rs:39:25\n   |\n39 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpvsqfqhlp.rs:40:17\n  \
    \ |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpvsqfqhlp.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmpvsqfqhlp.rs:20:32\n\
    \   |\n20 |         let mut digit = digits.chars().nth(1).unwrap();\n   |    \
    \                     "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().filter(|&(_,\
    \ c)| c.is_numeric());\n    let mut digit = digits[0];\n    let mut result = digit.1.to_digit(10);\n\
    \    let mut i = 0;\n    while i < digits.len() {\n        let digit = digits[i];\n\
    \        let mut next = digit.1.to_digit(10);\n        if next < result {\n  \
    \          result = next;\n            digit = digits[i];\n        }\n       \
    \ i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp1alkxbbh.rs:34:17\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp1alkxbbh.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp1alkxbbh.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp1alkxbbh.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp1alkxbbh.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp1alkxbbh.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp1alkxbbh.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp1alkxbbh.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp1alkxbbh.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp1alkxbbh.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0608]: cannot\
    \ index into a value of type `Filter<Enumerate<Chars<'_>>, [closure@/tmp/tmp1alkxbbh.rs:16:55:\
    \ 16:79]>`\n  --> /tmp/tmp1alkxbbh.rs:17:21\n   |\n17 |     let mut digit = digits[0];\n\
    \   |        "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_digit(16).unwrap()\n        }\n    });\n   \
    \ let mut result = value.chars().enumerate().map(|(i, c)| {\n        if c.is_numeric()\
    \ {\n            c.to_digit(10).unwrap()\n        } else {\n            c.to_digit(16).unwrap()\n\
    \        }\n    });\n    let mut min_value = result.iter().min().unwrap();\n \
    \   let mut max_value = result.iter().max().unwrap();\n    let mut min_digits\
    \ = digits.iter().min().unwrap();\n    let mut max_digits = digits.iter().max().unwrap();\n\
    \    let mut min_value = min_value.to_digit(16).unwrap();\n    let mut max_value\
    \ = max_value.to_digit(16).unwrap();\n    let mut min_digits = min_digits.to_digit(16).unwrap();\n\
    \    let mut max_digits = max_digits.to_digit(16).unwrap();\n    while min_value\
    \ != max_value {\n        if min_digits == max_digits {\n            min_value\
    \ = min_value.to_digit(10).unwrap();\n            max_value = max_value.to_digit(10).unwrap();\n\
    \            min_digits = min_digits.to_digit(10).unwrap();\n            max_digits\
    \ = max_digits.to_digit(10).unwrap();\n        } else {\n            min_value\
    \ = min_value.to_digit(16).unwrap();\n            max_value = max_value.to_digit(16).unwrap();\n\
    \            min_digits = min_digits.to_digit(16).unwrap();\n            max_digits\
    \ = max_digits.to_digit(16).unwrap();\n        }\n    }\n    min_value\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp2ekvfagp.rs:56:17\n\
    \   |\n56 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp2ekvfagp.rs:56:25\n   |\n56 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp2ekvfagp.rs:57:17\n   |\n57 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp2ekvfagp.rs:57:25\n\
    \   |\n57 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp2ekvfagp.rs:58:17\n   |\n58 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp2ekvfagp.rs:58:25\n   |\n58 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp2ekvfagp.rs:59:17\n   |\n59 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp2ekvfagp.rs:59:25\n   |\n59 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp2ekvfagp.rs:60:17\n  \
    \ |\n60 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp2ekvfagp.rs:60:25\n   |\n60 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `iter` found for struct `Map` in the current scope\n  --> /tmp/tmp2ekvfagp.rs:30:32\n\
    \   |\n30 |     let mut min_value = result.iter().min().unwrap();\n   |      \
    \                     "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut exponent = 0;\n    let mut result = isize::MAX;\n    while exponent\
    \ < value.len() && result < isize::MAX {\n        let mut new_digits = digits.clone();\n\
    \        new_digits = new_digits.chars().nth(exponent).unwrap();\n        let\
    \ mut new_exponent = exponent;\n        while new_exponent < new_digits.len()\
    \ && new_exponent < exponent {\n            new_exponent += 1;\n        }\n  \
    \      let mut new_result = result;\n        while new_exponent < new_digits.len()\
    \ && new_result < isize::MAX {\n            new_result *= 10;\n            new_result\
    \ += new_digits.chars().nth(new_exponent).unwrap();\n            new_exponent\
    \ += 1;\n        }\n        if new_result < result {\n            result = new_result;\n\
    \        }\n        exponent = new_exponent;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpy03gk65o.rs:42:17\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpy03gk65o.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpy03gk65o.rs:43:17\n   |\n43 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpy03gk65o.rs:43:25\n\
    \   |\n43 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpy03gk65o.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpy03gk65o.rs:44:25\n   |\n44 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpy03gk65o.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpy03gk65o.rs:45:25\n   |\n45 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpy03gk65o.rs:46:17\n  \
    \ |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpy03gk65o.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmpy03gk65o.rs:21:33\n\
    \   |\n21 |         new_digits = new_digits.chars().nth(exponent).unwrap();\n\
    \   |                 "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut digit = digits.chars().nth(1).unwrap();\n\
    \    let mut i = 0;\n    while i < value.len() {\n        let mut digit = digits.chars().nth(1).unwrap();\n\
    \        let mut digit = digit.chars().nth(1).unwrap();\n        let mut digit\
    \ = digit.chars().nth(1).unwrap();\n        let mut digit = digit.chars().nth(1).unwrap();\n\
    \        let mut digit = digit.chars().nth(1).unwrap();\n        let mut digit\
    \ = digit.chars().nth(1).unwrap();\n        let mut digit = digit.chars().nth(1).unwrap();\n\
    \        let mut digit = digit.chars().nth(1).unwrap();\n        let mut digit\
    \ = digit.chars().nth(1).unwrap();\n        let mut digit = digit.chars().nth(1).unwrap();\n\
    \        let mut digit = digit.chars().nth(1).unwrap();\n        let mut digit\
    \ = digit.chars().nth(1).unwrap();\n        let mut digit = digit.chars().nth(1).unwrap();\n\
    \        let mut digit = digit.chars().nth(1).unwrap();\n        let mut digit\
    \ = digit.chars().nth(1).unwrap();\n        let mut digit = digit.chars().nth(1).unwrap();\n\
    \        let mut digit = digit.chars().nth(1).unwrap();\n        let mut digit\
    \ = digit.chars().nth(1).unwrap();\n        let mut digit = digit.chars().nth(1).unwrap();\n\
    \        let mut digit = digit.chars().nth(1).unwrap();\n        let mut digit\
    \ = digit.chars().nth(1).unwrap();\n        let mut digit = digit.chars().nth(1).unwrap();\n\
    \        let mut digit = digit.chars().nth(1).unwrap();\n        let mut digit\
    \ = digit.chars().nth(1).unwrap();\n        let mut digit = digit.chars().nth(1).unwrap();\n\
    \        let mut digit = digit.chars().nth(1).unwrap();\n        let mut digit\
    \ = digit.chars().nth(1).unwrap();\n        let mut digit = digit.chars().nth(1).unwrap();\n\
    \        let mut digit = digit.chars().nth(1).unwrap();\n        let mut digit\
    \ = digit.chars().nth(1).unwrap();\n        let mut \n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp326bo0gk.rs:61:3\n\
    \   |\n14 | fn closest_integer(value: String) -> isize {\n   |               \
    \                             - unclosed delimiter\n...\n20 |     while i < value.len()\
    \ {\n   |                           - this delimiter might not be properly closed...\n\
    ...\n52 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    61 | }\n   |   ^\n\nerror: expected identifier, found `}`\n  --> /tmp/tmp326bo0gk.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected identifier\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmp326bo0gk.rs:56:17\n   |\n56 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp326bo0gk.rs:56:25\n \
    \  |\n56 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp326bo0gk.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp326bo0gk.rs:57:25\n   |\n57 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp326bo0gk.rs:58:17\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp326bo0gk.rs:58:25\n   |\n58 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp326bo0gk.rs:59:17\n  \
    \ |\n59 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp326bo0gk.rs:59:25\n   |\n59 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut k = 0;\n    while i < digits.len() && j < digits.len()\
    \ {\n        if digits[i] < digits[j] {\n            i += 1;\n        } else {\n\
    \            j += 1;\n        }\n    }\n    while i < digits.len() {\n       \
    \ result.push(i);\n        i += 1;\n    }\n    while j < digits.len() {\n    \
    \    result.push(j);\n        j += 1;\n    }\n    let mut max = result.len();\n\
    \    let mut min = result.len();\n    for i in 0..result.len() {\n        if result[i]\
    \ > max {\n            max = result[i];\n        }\n        if result[i] < min\
    \ {\n            min = result[i];\n        }\n    }\n    if min == max {\n   \
    \     0\n    } else {\n        max - min\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpr7z6bwfe.rs:55:17\n\
    \   |\n55 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpr7z6bwfe.rs:55:25\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpr7z6bwfe.rs:56:17\n   |\n56 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpr7z6bwfe.rs:56:25\n\
    \   |\n56 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpr7z6bwfe.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpr7z6bwfe.rs:57:25\n   |\n57 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpr7z6bwfe.rs:58:17\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpr7z6bwfe.rs:58:25\n   |\n58 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpr7z6bwfe.rs:59:17\n  \
    \ |\n59 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpr7z6bwfe.rs:59:25\n   |\n59 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr7z6bwfe.rs:29:21\n   |\n29 |         result.push(i);\n\
    \   |                     ^ expected `char`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr7z6bwf"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_digit() {\n            c.to_digit(10).unwrap()\n    \
    \    } else {\n            i\n        }\n    });\n    let mut smallest = std::i32::MAX;\n\
    \    let mut largest = std::i32::MIN;\n    let mut i = 0;\n    while i < digits.len()\
    \ {\n        let digit = digits[i];\n        if digit < smallest {\n         \
    \   smallest = digit;\n        }\n        if digit > largest {\n            largest\
    \ = digit;\n        }\n        i += 1;\n    }\n    smallest.checked_add(largest).unwrap()\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpgdbq0lcx.rs:41:17\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpgdbq0lcx.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpgdbq0lcx.rs:42:17\n   |\n42 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpgdbq0lcx.rs:42:25\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpgdbq0lcx.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpgdbq0lcx.rs:43:25\n   |\n43 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpgdbq0lcx.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpgdbq0lcx.rs:44:25\n   |\n44 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpgdbq0lcx.rs:45:17\n  \
    \ |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpgdbq0lcx.rs:45:25\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpgdbq0lcx.rs:17:14\n\
    \    |\n17  |         if c.is_digit() {\n    |              ^^^^^^^^- supplied\
    \ 0 arguments\n    |       "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    if value.chars().count() > 1 {\n  \
    \      value = value.chars().take(2).collect::<String>().to_string();\n    }\n\
    \    let mut value = value.parse::<isize>().unwrap();\n    if value < 0 {\n  \
    \      value = -value;\n    }\n    value\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp3z0i673b.rs:28:17\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3z0i673b.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp3z0i673b.rs:29:17\n   |\n29 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp3z0i673b.rs:29:25\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp3z0i673b.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp3z0i673b.rs:30:25\n   |\n30 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp3z0i673b.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp3z0i673b.rs:31:25\n   |\n31 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp3z0i673b.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3z0i673b.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 10 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    if value.chars().count() > 1 {\n  \
    \      value = value.chars().next().unwrap();\n    }\n    let mut value = value.parse::<isize>().unwrap();\n\
    \    if value < 0 {\n        value = -value;\n    }\n    value\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpsa7hr9m5.rs:28:17\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpsa7hr9m5.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpsa7hr9m5.rs:29:17\n   |\n29 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpsa7hr9m5.rs:29:25\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpsa7hr9m5.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpsa7hr9m5.rs:30:25\n   |\n30 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpsa7hr9m5.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpsa7hr9m5.rs:31:25\n   |\n31 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpsa7hr9m5.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpsa7hr9m5.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsa7hr9m5.rs:17:17\n   |\n17 |         value = value.chars().next().unwrap();\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method:"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut closest_integer = digits[digits.len()\
    \ - 1];\n    let mut closest_distance = std::cmp::max(1, closest_integer);\n \
    \   let mut closest_digit = digits[digits.len() - 2];\n    for digit in digits.iter_mut()\
    \ {\n        if *digit > closest_distance {\n            *digit = closest_distance;\n\
    \            closest_distance = *digit;\n            closest_digit = digit;\n\
    \        }\n    }\n    closest_integer\n}\n\nfn main() {\n    let candidate =\
    \ closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpwu_vvtjq.rs:32:17\n\
    \   |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpwu_vvtjq.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpwu_vvtjq.rs:33:17\n   |\n33 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpwu_vvtjq.rs:33:25\n\
    \   |\n33 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpwu_vvtjq.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpwu_vvtjq.rs:34:25\n   |\n34 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpwu_vvtjq.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpwu_vvtjq.rs:35:25\n   |\n35 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpwu_vvtjq.rs:36:17\n  \
    \ |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpwu_vvtjq.rs:36:25\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwu_vvtjq.rs:18:49\n   |\n18 |     let mut closest_distance\
    \ = std::cmp::max(1, closest_integer);\n   |                                 \
    \                ^^^^^^^^^^^^^^^ "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut len = 0;\n    let mut max_len = value.len();\n\
    \    while i < digits.len() && j < digits.len() {\n        if digits[i] < digits[j]\
    \ {\n            len = i;\n        } else {\n            len = j;\n        }\n\
    \        if len > max_len {\n            max_len = len;\n        }\n        i\
    \ += 1;\n        j += 1;\n    }\n    if digits.len() == 0 {\n        return 0;\n\
    \    }\n    let mut i = 0;\n    while i < digits.len() {\n        if digits[i]\
    \ == 0 {\n            return i;\n        }\n        i += 1;\n    }\n    return\
    \ digits.len();\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp8cxajzk1.rs:49:17\n\
    \   |\n49 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8cxajzk1.rs:49:25\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp8cxajzk1.rs:50:17\n   |\n50 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp8cxajzk1.rs:50:25\n\
    \   |\n50 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8cxajzk1.rs:51:17\n   |\n51 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8cxajzk1.rs:51:25\n   |\n51 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp8cxajzk1.rs:52:17\n   |\n52 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp8cxajzk1.rs:52:25\n   |\n52 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp8cxajzk1.rs:53:17\n  \
    \ |\n53 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8cxajzk1.rs:53:25\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8cxajzk1.rs:39:25\n   |\n39 |         if digits[i] == 0\
    \ {\n   |                         ^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8c"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_digit(16).unwrap()\n        }\n    }).collect::<Vec<_>>();\n\
    \    let mut result = 0.0;\n    let mut i = 0;\n    while i < digits.len() {\n\
    \        let mut digit = digits[i];\n        if digit < 0 {\n            digit\
    \ = -digit;\n        }\n        let mut next = digit;\n        let mut j = i;\n\
    \        while j > 0 {\n            let mut digit = digits[j];\n            if\
    \ digit < 0 {\n                digit = -digit;\n            }\n            if\
    \ digit == next {\n                next = digit;\n                break;\n   \
    \         }\n            j -= 1;\n        }\n        result = result + next;\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpzvzf45zh.rs:51:17\n\
    \   |\n51 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpzvzf45zh.rs:51:25\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpzvzf45zh.rs:52:17\n   |\n52 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpzvzf45zh.rs:52:25\n\
    \   |\n52 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpzvzf45zh.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpzvzf45zh.rs:53:25\n   |\n53 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpzvzf45zh.rs:54:17\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpzvzf45zh.rs:54:25\n   |\n54 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpzvzf45zh.rs:55:17\n  \
    \ |\n55 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpzvzf45zh.rs:55:25\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0600]: cannot\
    \ apply unary operator `-` to type `u32`\n  --> /tmp/tmpzvzf45zh.rs:28:21\n  \
    \ |\n28 |             digit = -digit;\n   |                     ^^^^^^ cannot\
    \ apply unary operator `-`\n   |\n   = note"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n    let mut result = value.chars().take_while(|c| c\
    \ >= '0' && c <= '9').next();\n    let mut exponent = 0;\n    let mut remainder\
    \ = 0;\n    while let Some(digit) = digits.next() {\n        remainder *= 10;\n\
    \        remainder += digit;\n        exponent = exponent + 1;\n    }\n    if\
    \ exponent == 0 {\n        return remainder;\n    }\n    let mut result = remainder;\n\
    \    let mut exponent = exponent - 1;\n    while exponent > 0 {\n        remainder\
    \ *= 10;\n        remainder += 1;\n        exponent = exponent - 1;\n    }\n \
    \   if remainder == 0 {\n        return result;\n    }\n    let mut result = remainder;\n\
    \    let mut exponent = exponent - 1;\n    while exponent > 0 {\n        remainder\
    \ *= 10;\n        remainder += 1;\n        exponent = exponent - 1;\n    }\n \
    \   if remainder == 0 {\n        return result;\n    }\n    let mut result = remainder;\n\
    \    let mut exponent = exponent - 1;\n    while exponent > 0 {\n        remainder\
    \ *= 10;\n        remainder += 1;\n        exponent = exponent - 1;\n    }\n \
    \   if remainder == 0 {\n        return result;\n    }\n    result.unwrap()\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmph46597xa.rs:63:17\n\
    \   |\n63 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmph46597xa.rs:63:25\n   |\n63 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmph46597xa.rs:64:17\n   |\n64 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmph46597xa.rs:64:25\n\
    \   |\n64 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmph46597xa.rs:65:17\n   |\n65 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmph46597xa.rs:65:25\n   |\n65 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmph46597xa.rs:66:17\n   |\n66 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmph46597xa.rs:66:25\n   |\n66 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmph46597xa.rs:67:17\n  \
    \ |\n67 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmph46597xa.rs:67:25\n   |\n67 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph46597xa.rs:16:56\n   |\n16 |     let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n   |                                               \
    \         ^^"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut result = value.parse::<isize>().unwrap();\n    if result < 0 {\n  \
    \      result = -result;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp3xzjqaoh.rs:24:17\n\
    \   |\n24 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3xzjqaoh.rs:24:25\n   |\n24 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp3xzjqaoh.rs:25:17\n   |\n25 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp3xzjqaoh.rs:25:25\n\
    \   |\n25 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp3xzjqaoh.rs:26:17\n   |\n26 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp3xzjqaoh.rs:26:25\n   |\n26 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp3xzjqaoh.rs:27:17\n   |\n27 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp3xzjqaoh.rs:27:25\n   |\n27 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp3xzjqaoh.rs:28:17\n  \
    \ |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3xzjqaoh.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 10 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut exponent = 0;\n    let mut mantissa = value.chars().nth(2).unwrap();\n\
    \n    while exponent < 3 {\n        mantissa = mantissa.chars().nth(1).unwrap();\n\
    \        exponent = exponent + 1;\n    }\n\n    let mut mantissa = mantissa.to_string();\n\
    \    let mut exponent = exponent.to_string();\n\n    while exponent < 3 {\n  \
    \      mantissa = mantissa.chars().nth(1).unwrap();\n        exponent = exponent\
    \ + 1;\n    }\n\n    let mut mantissa = mantissa.to_string();\n    let mut exponent\
    \ = exponent.to_string();\n\n    while exponent < 3 {\n        mantissa = mantissa.chars().nth(1).unwrap();\n\
    \        exponent = exponent + 1;\n    }\n\n    let mut mantissa = mantissa.to_string();\n\
    \    let mut exponent = exponent.to_string();\n\n    while exponent < 3 {\n  \
    \      mantissa = mantissa.chars().nth(1).unwrap();\n        exponent = exponent\
    \ + 1;\n    }\n\n    let mut mantissa = mantissa.to_string();\n    let mut exponent\
    \ = exponent.to_string();\n\n    while exponent < 3 {\n        mantissa = mantissa.chars().nth(1).unwrap();\n\
    \        exponent = exponent + 1;\n    }\n\n    let mut mantissa = mantissa.to_string();\n\
    \    let mut exponent = exponent.to_string();\n\n    while exponent < 3 {\n  \
    \      mantissa = mantissa.chars().nth(1).unwrap();\n        exponent = exponent\
    \ + 1;\n    }\n\n    let mut mantissa = mantissa.to_string();\n    let mut exponent\
    \ = exponent.to_string();\n\n    while exponent < 3 {\n        mantissa = mantissa.chars().nth(1).unwrap();\n\
    \        exponent = exponent + 1;\n    }\n\n    let mut mantissa = mantissa.to_string();\n\
    \    let mut exponent = exponent.to_string();\n\n    while exponent < 3 {\n  \
    \      mantissa = mantissa.chars().nth(1).unwrap();\n        exponent = exponent\
    \ + 1;\n    }\n\n    let mut mantissa = mantissa.to_string();\n    let mut exponent\
    \ = exponent.to_string();\n\n    while exponent < 3 {\n        mantissa = mantissa.chars().nth(1).unwrap();\n\
    \        exponent = exponent + 1;\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpfngf89p3.rs:96:3\n\
    \   |\n14 | fn closest_integer(value: String) -> isize {\n   |               \
    \                             - unclosed delimiter\n...\n84 |     while exponent\
    \ < 3 {\n   |                        - this delimiter might not be properly closed...\n\
    ...\n87 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    96 | }\n   |   ^\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpfngf89p3.rs:91:17\n   |\n91 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpfngf89p3.rs:91:25\n   |\n91 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpfngf89p3.rs:92:17\n  \
    \ |\n92 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfngf89p3.rs:92:25\n   |\n92 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpfngf89p3.rs:93:17\n   |\n93 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpfngf89p3.rs:93:25\n\
    \   |\n93 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpfngf89p3.rs:94:17\n   |\n94 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpfngf89p3.rs:94:25\n   |\n94 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpfngf89p3.rs:95:17\n   |\n95 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in t"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(0).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        let mut j = i;\n        while j < value.len()\
    \ {\n            if digits[j] < digits[i] {\n                j = j + 1;\n    \
    \        } else {\n                break;\n            }\n        }\n        if\
    \ j == i {\n            break;\n        }\n        result = digits[i];\n     \
    \   i = j;\n    }\n    result.parse().unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp9gzrhkj2.rs:39:17\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp9gzrhkj2.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp9gzrhkj2.rs:40:17\n   |\n40 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp9gzrhkj2.rs:40:25\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp9gzrhkj2.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp9gzrhkj2.rs:41:25\n   |\n41 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp9gzrhkj2.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp9gzrhkj2.rs:42:25\n   |\n42 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp9gzrhkj2.rs:43:17\n  \
    \ |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp9gzrhkj2.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0608]: cannot\
    \ index into a value of type `char`\n  --> /tmp/tmp9gzrhkj2.rs:22:16\n   |\n22\
    \ |             if digits[j] < digits[i] {\n   |                ^^^^^^^^^\n\n\
    error[E0608]: cannot index into a value o"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut exponent = 0;\n\
    \    let mut remainder = 0;\n    while let Some(digit) = digits.next() {\n   \
    \     remainder += digit;\n        if remainder >= 10 {\n            exponent\
    \ += 1;\n            remainder -= 10;\n        }\n    }\n    if exponent == 0\
    \ {\n        value.parse().unwrap()\n    } else {\n        value.parse::<isize>().unwrap()\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpvay771c7.rs:36:17\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpvay771c7.rs:36:25\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpvay771c7.rs:37:17\n   |\n37 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpvay771c7.rs:37:25\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpvay771c7.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpvay771c7.rs:38:25\n   |\n38 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpvay771c7.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpvay771c7.rs:39:25\n   |\n39 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpvay771c7.rs:40:17\n  \
    \ |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpvay771c7.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `next` found for type `char` in the current scope\n  --> /tmp/tmpvay771c7.rs:20:36\n\
    \   |\n20 |     while let Some(digit) = digits.next() {\n   |                \
    \                    ^^"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    if value.chars().count() > 1 {\n  \
    \      value = value.chars().next().unwrap();\n    }\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    while i < digits.len() {\n        let mut j = i;\n        while j < digits.len()\
    \ && digits[j] == digits[i] {\n            j += 1\n        }\n        let mut\
    \ min_dist = std::cmp::max(i + 1, j + 1);\n        for &d in &digits[i..j] {\n\
    \            let dist = std::cmp::min(std::cmp::min(d, digits[i]), digits[j]);\n\
    \            if dist < min_dist {\n                min_dist = dist;\n        \
    \    }\n        }\n        if min_dist == j + 1 {\n            result[i] = digits[i];\n\
    \            i += 1;\n        } else {\n            result[i] = digits[j];\n \
    \           i += 1;\n        }\n    }\n    result.len()\n}\n\nfn main() {\n  \
    \  let candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpqzhonw8m.rs:47:17\n\
    \   |\n47 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpqzhonw8m.rs:47:25\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpqzhonw8m.rs:48:17\n   |\n48 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpqzhonw8m.rs:48:25\n\
    \   |\n48 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpqzhonw8m.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpqzhonw8m.rs:49:25\n   |\n49 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpqzhonw8m.rs:50:17\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpqzhonw8m.rs:50:25\n   |\n50 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpqzhonw8m.rs:51:17\n  \
    \ |\n51 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpqzhonw8m.rs:51:25\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqzhonw8m.rs:17:17\n   |\n17 |         value = value.chars().next().unwrap();\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method:"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut exponent = 0;\n    let mut result = isize::MAX;\n    let mut i =\
    \ 0;\n    while i < digits.len() {\n        let digit = digits[i];\n        if\
    \ digit == '.' {\n            exponent = digits.len() - i;\n            break;\n\
    \        }\n        i += 1;\n    }\n    if exponent == 0 {\n        result = value.parse().unwrap();\n\
    \    } else {\n        let mut fraction = value.split_at(exponent);\n        let\
    \ mut numerator = fraction.next().unwrap();\n        let mut denominator = fraction.next().unwrap();\n\
    \        if numerator.is_empty() {\n            numerator = \"0\".to_string();\n\
    \        }\n        if denominator.is_empty() {\n            denominator = \"\
    1\".to_string();\n        }\n        let mut exponent = exponent;\n        let\
    \ mut result = isize::MAX;\n        while exponent > 0 {\n            let mut\
    \ numerator = numerator.to_string();\n            let mut denominator = denominator.to_string();\n\
    \            let mut remainder: isize = numerator.chars().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while i < remainder.len() {\n       \
    \         let digit = remainder[i];\n                if digit == '.' {\n     \
    \               remainder = remainder.split_at(i).collect::<Vec<_>>();\n     \
    \               i += 1;\n                    break;\n                }\n     \
    \           i += 1;\n            }\n            let mut numerator = numerator.to_string();\n\
    \            let mut denominator = denominator.to_string();\n            let mut\
    \ remainder: isize = numerator.chars().collect::<Vec<_>>();\n            let mut\
    \ i = 0;\n            while i < remainder.len() {\n                let digit =\
    \ remainder[i];\n                if digit == '.' {\n                    remainder\
    \ = remainder.split_at(i).collect::<Vec<_>>();\n                    i += 1;\n\
    \                    break;\n                }\n                i += 1;\n    \
    \        }\n            let mut numerator = numerator.to_string();\n         \
    \   let mut denominator = denominator.to_string();\n            let mut remainder:\
    \ isize = numerator.chars().collect::<Vec<_>>();\n            let mut i = 0;\n\
    \            while i < remainder.len() {\n                let digit = remainder[i];\n\
    \                if digit == '.' {\n                    remainder = remainder.split_at(i).collect::<Vec<_>>();\n\
    \                    i += 1;\n                    break;\n                }\n\
    \                i += 1;\n            }\n            let mut numerator = numerator.to_string();\n\
    \            let mut denominator = denominator.to_string();\n            let mut\
    \ remainder: isize = numerator.char\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp70fnd07o.rs:94:3\n\
    \   |\n14 | fn closest_integer(value: String) -> isize {\n   |               \
    \                             - unclosed delimiter\n...\n30 |     } else {\n \
    \  |            - unclosed delimiter\n...\n42 |         while exponent > 0 {\n\
    \   |                            - this delimiter might not be properly closed...\n\
    ...\n85 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    94 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp70fnd07o.rs:84:54\n\
    \   |\n84 |             let mut remainder: isize = numerator.char\n   |      \
    \                                                ^ help: add `;` here\n85 | }\n\
    \   | - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp70fnd07o.rs:89:17\n   |\n89 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp70fnd07o.rs:89:25\n   |\n89 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp70fnd07o.rs:90:17\n   |\n90 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp70fnd07o.rs:90:25\n   |\n90 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp70fnd07o.rs:91:17\n  \
    \ |\n91 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp70fnd07o.rs:91:25\n   |\n91 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp70fnd07o.rs:92:17\n   |\n92 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scop"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut len = 0;\n    while i < digits.len() && j < digits.len()\
    \ {\n        if digits[i] > digits[j] {\n            len = j;\n        } else\
    \ {\n            len = i;\n        }\n        i += 1;\n        j += 1;\n    }\n\
    \    if len == 0 {\n        return value.chars().last().unwrap() as isize;\n \
    \   }\n    let mut i = 0;\n    let mut j = 0;\n    let mut len = 0;\n    while\
    \ i < digits.len() && j < digits.len() {\n        if digits[i] > digits[j] {\n\
    \            len = j;\n        } else {\n            len = i;\n        }\n   \
    \     i += 1;\n        j += 1;\n    }\n    if len == 0 {\n        return value.chars().last().unwrap()\
    \ as isize;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    let mut len =\
    \ 0;\n    while i < digits.len() && j < digits.len() {\n        if digits[i] >\
    \ digits[j] {\n            len = j;\n        } else {\n            len = i;\n\
    \        }\n        i += 1;\n        j += 1;\n    }\n    if len == 0 {\n     \
    \   return value.chars().last().unwrap() as isize;\n    }\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut len = 0;\n    while i < digits.len() && j < digits.len()\
    \ {\n        if digits[i] > digits[j] {\n            len = j;\n        } else\
    \ {\n            len = i;\n        }\n        i += 1;\n        j += 1;\n    }\n\
    \    if len == 0 {\n        return value.chars().last().unwrap() as isize;\n \
    \   }\n    let mut i = 0;\n    let mut j = 0;\n    let mut len = 0;\n    while\
    \ i < digits.len() && j < digits.len() {\n        if digits[i] > digits[j] {\n\
    \            len = j;\n        } else {\n            len = i;\n        }\n   \
    \     i += 1;\n        j += 1;\n    }\n    if len == 0 {\n        return value.chars().last().unwrap()\
    \ as isize;\n    }\n    let mut i = 0;\n    let mut j = 0;\n    let mut len =\
    \ 0;\n    while i < digits.len() && j < digits.len() {\n        if digits[i] >\
    \ digits[j] {\n            len = j;\n        } else {\n            len = i;\n\
    \        }\n        i += 1;\n        j += 1;\n    }\n    if len == 0 {\n     \
    \   return value.chars().last().unwrap() as isize;\n    }\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut len = 0;\n    while i < digits.len() && j < \n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmpvbhzj162.rs:112:1\n\
    \    |\n112 | }\n    | ^ expected expression\n\nerror[E0425]: cannot find value\
    \ `left` in this scope\n   --> /tmp/tmpvbhzj162.rs:116:17\n    |\n116 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpvbhzj162.rs:116:25\n\
    \    |\n116 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpvbhzj162.rs:117:17\n    |\n117 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpvbhzj162.rs:117:25\n\
    \    |\n117 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpvbhzj162.rs:118:17\n    |\n118 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpvbhzj162.rs:118:25\n\
    \    |\n118 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpvbhzj162.rs:119:17\n    |\n119 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpvbhzj162.rs:119:25\n\
    \    |\n119 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpvbhzj162.rs:120:17\n    |\n120 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpvbhzj162.rs:120:25\n\
    \    |\n120 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror: aborting due to 11 previous errors\n\
    \nF"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut exponent = 0;\n\
    \    while digits.is_some() {\n        exponent = exponent + 1;\n        if exponent\
    \ > 3 {\n            break;\n        }\n        digits = digits.next().unwrap();\n\
    \    }\n    if exponent < 3 {\n        return value.chars().nth(1).unwrap().parse().unwrap();\n\
    \    }\n    let mut exponent = exponent - 3;\n    let mut result = value.chars().nth(1).unwrap();\n\
    \    while exponent > 0 {\n        exponent = exponent - 1;\n        result =\
    \ result.next().unwrap().parse().unwrap();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpqe4q15vd.rs:40:17\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpqe4q15vd.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpqe4q15vd.rs:41:17\n   |\n41 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpqe4q15vd.rs:41:25\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpqe4q15vd.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpqe4q15vd.rs:42:25\n   |\n42 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpqe4q15vd.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpqe4q15vd.rs:43:25\n   |\n43 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpqe4q15vd.rs:44:17\n  \
    \ |\n44 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpqe4q15vd.rs:44:25\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `is_some` found for type `char` in the current scope\n  --> /tmp/tmpqe4q15vd.rs:19:18\n\
    \   |\n19 |     while digits.is_some() {\n   |                  ^^^^^^^ method\
    \ not found in `cha"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    if value.chars().count() > 1 {\n  \
    \      value = &value.chars().last().unwrap();\n    }\n    let mut value = value.parse::<isize>().unwrap();\n\
    \    if value < 0 {\n        value += 1;\n    }\n    value\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp_r2zl5d0.rs:28:17\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_r2zl5d0.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_r2zl5d0.rs:29:17\n   |\n29 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_r2zl5d0.rs:29:25\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_r2zl5d0.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_r2zl5d0.rs:30:25\n   |\n30 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_r2zl5d0.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_r2zl5d0.rs:31:25\n   |\n31 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_r2zl5d0.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_r2zl5d0.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_r2zl5d0.rs:17:17\n   |\n17 |         value = &value.chars().last().unwrap();\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&c"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            0\n        }\n    });\n    let mut min: isize = 0;\n\
    \    let mut max: isize = 0;\n    let mut min_index: usize = 0;\n    let mut max_index:\
    \ usize = 0;\n    let mut min_diff: isize = 0;\n    let mut max_diff: isize =\
    \ 0;\n    for &(i, &d) in digits {\n        if d < min {\n            min = d;\n\
    \            min_index = i;\n        }\n        if d > max {\n            max\
    \ = d;\n            max_index = i;\n        }\n        if d == min {\n       \
    \     min_diff = 0;\n        } else {\n            min_diff = d - min;\n     \
    \   }\n        if d == max {\n            max_diff = 0;\n        } else {\n  \
    \          max_diff = d - max;\n        }\n    }\n    if min_diff == max_diff\
    \ {\n        return min_index;\n    }\n    if min_diff < max_diff {\n        return\
    \ min_index;\n    }\n    return max_index;\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp6qxzt2tp.rs:60:17\n\
    \   |\n60 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6qxzt2tp.rs:60:25\n   |\n60 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp6qxzt2tp.rs:61:17\n   |\n61 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp6qxzt2tp.rs:61:25\n\
    \   |\n61 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp6qxzt2tp.rs:62:17\n   |\n62 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp6qxzt2tp.rs:62:25\n   |\n62 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp6qxzt2tp.rs:63:17\n   |\n63 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp6qxzt2tp.rs:63:25\n   |\n63 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp6qxzt2tp.rs:64:17\n  \
    \ |\n64 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6qxzt2tp.rs:64:25\n   |\n64 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6qxzt2tp.rs:29:9\n   |\n29 |     for &(i, &d) in digits\
    \ {\n   |         ^^^^^^^^    ------ this expression has type `u32`\n   |    \
    \     |\n   |         expected `u32`, "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    if value.chars().count() > 1 {\n  \
    \      value = &value.chars().last().unwrap();\n    }\n    let mut value = value.parse::<isize>().unwrap();\n\
    \    if value < 0 {\n        value += 1;\n    }\n    value\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp_r2zl5d0.rs:28:17\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_r2zl5d0.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_r2zl5d0.rs:29:17\n   |\n29 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_r2zl5d0.rs:29:25\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_r2zl5d0.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_r2zl5d0.rs:30:25\n   |\n30 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_r2zl5d0.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_r2zl5d0.rs:31:25\n   |\n31 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_r2zl5d0.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_r2zl5d0.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_r2zl5d0.rs:17:17\n   |\n17 |         value = &value.chars().last().unwrap();\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&c"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_digit() {\n            c.to_digit(10).unwrap()\n    \
    \    } else {\n            i\n        }\n    });\n    let mut result = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_digit() {\n            c.to_digit(10).unwrap()\n    \
    \    } else {\n            i\n        }\n    });\n    let mut min: isize = 0;\n\
    \    let mut max: isize = 0;\n    let mut min_index: usize = 0;\n    let mut max_index:\
    \ usize = 0;\n    let mut min_diff: isize = 0;\n    let mut max_diff: isize =\
    \ 0;\n    let mut min_diff_index: usize = 0;\n    let mut max_diff_index: usize\
    \ = 0;\n    let mut min_diff_index2: usize = 0;\n    let mut max_diff_index2:\
    \ usize = 0;\n    let mut min_diff_index3: usize = 0;\n    let mut max_diff_index3:\
    \ usize = 0;\n    let mut min_diff_index4: usize = 0;\n    let mut max_diff_index4:\
    \ usize = 0;\n    let mut min_diff_index5: usize = 0;\n    let mut max_diff_index5:\
    \ usize = 0;\n    let mut min_diff_index6: usize = 0;\n    let mut max_diff_index6:\
    \ usize = 0;\n    let mut min_diff_index7: usize = 0;\n    let mut max_diff_index7:\
    \ usize = 0;\n    let mut min_diff_index8: usize = 0;\n    let mut max_diff_index8:\
    \ usize = 0;\n    let mut min_diff_index9: usize = 0;\n    let mut max_diff_index9:\
    \ usize = 0;\n    let mut min_diff_index10: usize = 0;\n    let mut max_diff_index10:\
    \ usize = 0;\n    let mut min_diff_index11: usize = 0;\n    let mut max_diff_index11:\
    \ usize = 0;\n    let mut min_diff_index12: usize = 0;\n    let mut max_diff_index12:\
    \ usize = 0;\n    let mut min_diff_index13: usize = 0;\n    let mut max_diff_index13:\
    \ usize = 0;\n    let mut min_diff_index14: usize = 0;\n    let mut max_diff_index14:\
    \ usize = 0;\n    let mut min_diff_index15: usize = 0;\n    let mut max_diff_index15:\
    \ usize = 0;\n    let mut min_diff_index16: usize = 0;\n    let mut max_\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr3eu72tg.rs:67:17\n   |\n\
    67 |     let mut max_\n   |                 ^ help: add `;` here\n68 | }\n   |\
    \ - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpr3eu72tg.rs:72:17\n   |\n72 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpr3eu72tg.rs:72:25\n   |\n72 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpr3eu72tg.rs:73:17\n   |\n73 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpr3eu72tg.rs:73:25\n   |\n73 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpr3eu72tg.rs:74:17\n  \
    \ |\n74 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpr3eu72tg.rs:74:25\n   |\n74 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpr3eu72tg.rs:75:17\n   |\n75 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpr3eu72tg.rs:75:25\n\
    \   |\n75 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpr3eu72tg.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpr3eu72tg.rs:76:25\n   |\n76 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0061]: this function takes 1 argument"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.to_string();\n    let mut value = value.parse::<isize>().unwrap();\n\
    \    let mut closest_integer = value;\n    let mut closest_integer = closest_integer.abs();\n\
    \    let mut closest_integer = closest_integer.abs();\n    let mut closest_integer\
    \ = closest_integer.abs();\n    let mut closest_integer = closest_integer.abs();\n\
    \    let mut closest_integer = closest_integer.abs();\n    let mut closest_integer\
    \ = closest_integer.abs();\n    let mut closest_integer = closest_integer.abs();\n\
    \    let mut closest_integer = closest_integer.abs();\n    let mut closest_integer\
    \ = closest_integer.abs();\n    let mut closest_integer = closest_integer.abs();\n\
    \    let mut closest_integer = closest_integer.abs();\n    let mut closest_integer\
    \ = closest_integer.abs();\n    let mut closest_integer = closest_integer.abs();\n\
    \    let mut closest_integer = closest_integer.abs();\n    let mut closest_integer\
    \ = closest_integer.abs();\n    let mut closest_integer = closest_integer.abs();\n\
    \    let mut closest_integer = closest_integer.abs();\n    let mut closest_integer\
    \ = closest_integer.abs();\n    let mut closest_integer = closest_integer.abs();\n\
    \    let mut closest_integer = closest_integer.abs();\n    let mut closest_integer\
    \ = closest_integer.abs();\n    let mut closest_integer = closest_integer.abs();\n\
    \    let mut closest_integer = closest_integer.abs();\n    let mut closest_integer\
    \ = closest_integer.abs();\n    let mut closest_integer = closest_integer.abs();\n\
    \    let mut closest_integer = closest_integer.abs();\n    let mut closest_integer\
    \ = closest_integer.abs();\n    let mut closest_integer = closest_integer.abs();\n\
    \    let mut closest_integer = closest_integer.abs();\n    let mut closest_integer\
    \ = closest_integer.abs();\n    let mut closest_integer = closest_integer.abs();\n\
    \    let mut closest_integer = closest_integer.abs();\n    let mut closest_integer\
    \ = closest_integer.abs();\n    let mut closest_integer = closest_integer.abs();\n\
    \    let mut closest_integer = closest_integer.abs();\n    let mut closest_integer\
    \ = closest_integer.abs();\n    let mut closest_integer = closest_integer.abs();\n\
    \    let mut closest_integer = closest_integer.abs();\n    let mut closest_integer\
    \ = closest_integer.abs();\n    let mut closest_integer = closest_integer.abs();\n\
    \    let mut closest_integer = closest_integer.abs();\n    let mut closest_integer\
    \ = closest_integer.abs();\n    let mut closest_integer = closest_integer.abs();\n\
    \    let mut closest_integer = closest_integer.abs();\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpi7l3tf50.rs:66:17\n\
    \   |\n66 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpi7l3tf50.rs:66:25\n   |\n66 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpi7l3tf50.rs:67:17\n   |\n67 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpi7l3tf50.rs:67:25\n\
    \   |\n67 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpi7l3tf50.rs:68:17\n   |\n68 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpi7l3tf50.rs:68:25\n   |\n68 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpi7l3tf50.rs:69:17\n   |\n69 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpi7l3tf50.rs:69:25\n   |\n69 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpi7l3tf50.rs:70:17\n  \
    \ |\n70 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpi7l3tf50.rs:70:25\n   |\n70 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi7l3tf50.rs:14:38\n   |\n14 | fn closest_integer(value:\
    \ String) -> isize {\n   |    ---------------                   ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   "
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().take(10).collect::<Vec<_>>();\n\
    \    let mut result = 0.0;\n    let mut exponent = value.chars().count() - 1;\n\
    \    let mut last_digit = digits[exponent];\n    while exponent > 0 {\n      \
    \  let mut next_digit = digits[exponent - 1];\n        if last_digit == next_digit\
    \ {\n            break;\n        }\n        last_digit = next_digit;\n       \
    \ exponent--;\n    }\n    if exponent == 0 {\n        result = value.parse().unwrap();\n\
    \    } else {\n        result = result / 10.0 ** exponent;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpnv2kw5jp.rs:26:19\n\
    \   |\n26 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpnv2kw5jp.rs:38:17\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpnv2kw5jp.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpnv2kw5jp.rs:39:17\n   |\n39 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpnv2kw5jp.rs:39:25\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpnv2kw5jp.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpnv2kw5jp.rs:40:25\n   |\n40 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpnv2kw5jp.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpnv2kw5jp.rs:41:25\n   |\n41 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpnv2kw5jp.rs:42:17\n  \
    \ |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpnv2kw5jp.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0614]: type\
    \ `usize` cannot be dereferenced\n  --> /tmp/t"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_digit() {\n            c.to_digit(10).unwrap()\n    \
    \    } else {\n            c.to_digit(16).unwrap()\n        }\n    });\n    let\
    \ mut result = digits.iter().cloned().collect::<Vec<_>>();\n    let mut min_value\
    \ = result.iter().min().unwrap();\n    let mut max_value = result.iter().max().unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let \n}\n\nfn main() {\n   \
    \ let candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp6s5m_38f.rs:68:1\n  \
    \ |\n68 | }\n   | ^ expected pattern\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmp6s5m_38f.rs:72:17\n   |\n72 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp6s5m_38f.rs:72:25\n \
    \  |\n72 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp6s5m_38f.rs:73:17\n   |\n73 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp6s5m_38f.rs:73:25\n   |\n73 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp6s5m_38f.rs:74:17\n   |\n74 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp6s5m_38f.rs:74:25\n   |\n74 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp6s5m_38f.rs:75:17\n  \
    \ |\n75 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6s5m_38f.rs:75:25\n   |\n75 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp6s5m_38f.rs:76:17\n   |\n76 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp6s5m_38f.rs:76:25\n\
    \   |\n76 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0061]: this function takes 1 argument but\
    \ 0 arguments were supplied\n   --> /tmp/tmp6s5m_38f.rs:17:"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().filter(|&(_,\
    \ c)| c.is_digit()).collect::<Vec<_>>();\n    let mut result = value.chars().enumerate().filter(|&(_,\
    \ c)| c.is_digit()).collect::<Vec<_>>();\n    let mut min: isize = 0;\n    let\
    \ mut max: isize = 0;\n    let mut min_digits = result.len();\n    let mut max_digits\
    \ = result.len();\n    let mut min_digits_index = 0;\n    let mut max_digits_index\
    \ = 0;\n    let mut min_digits_index2 = 0;\n    let mut max_digits_index2 = 0;\n\
    \    let mut min_digits_index3 = 0;\n    let mut max_digits_index3 = 0;\n    let\
    \ mut min_digits_index4 = 0;\n    let mut max_digits_index4 = 0;\n    let mut\
    \ min_digits_index5 = 0;\n    let mut max_digits_index5 = 0;\n    let mut min_digits_index6\
    \ = 0;\n    let mut max_digits_index6 = 0;\n    let mut min_digits_index7 = 0;\n\
    \    let mut max_digits_index7 = 0;\n    let mut min_digits_index8 = 0;\n    let\
    \ mut max_digits_index8 = 0;\n    let mut min_digits_index9 = 0;\n    let mut\
    \ max_digits_index9 = 0;\n    let mut min_digits_index10 = 0;\n    let mut max_digits_index10\
    \ = 0;\n    let mut min_digits_index11 = 0;\n    let mut max_digits_index11 =\
    \ 0;\n    let mut min_digits_index12 = 0;\n    let mut max_digits_index12 = 0;\n\
    \    let mut min_digits_index13 = 0;\n    let mut max_digits_index13 = 0;\n  \
    \  let mut min_digits_index14 = 0;\n    let mut max_digits_index14 = 0;\n    let\
    \ mut min_digits_index15 = 0;\n    let mut max_digits_index15 = 0;\n    let mut\
    \ min_digits_index16 = 0;\n    let mut max_digits_index16 = 0;\n    let mut min_digits_index17\
    \ = 0;\n    let mut max_digits_index17 = 0;\n    let mut min_digits_index18 =\
    \ 0;\n    let mut max_digits_index18 = 0;\n    let mut min_digits_index19 = 0;\n\
    \    let mut max_digits_index19 = 0;\n    let mut min_digits_index20 = 0;\n  \
    \  let mut max_digits_index20 = 0;\n    let mut min_digits_index21 = 0;\n    let\
    \ mut max_digits_index21 = 0;\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpzr95uez3.rs:68:17\n\
    \   |\n68 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpzr95uez3.rs:68:25\n   |\n68 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpzr95uez3.rs:69:17\n   |\n69 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpzr95uez3.rs:69:25\n\
    \   |\n69 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpzr95uez3.rs:70:17\n   |\n70 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpzr95uez3.rs:70:25\n   |\n70 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpzr95uez3.rs:71:17\n   |\n71 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpzr95uez3.rs:71:25\n   |\n71 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpzr95uez3.rs:72:17\n  \
    \ |\n72 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpzr95uez3.rs:72:25\n   |\n72 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpzr95uez3.rs:16:67\n\
    \    |\n16  |     let mut digits = value.chars().enumerate().filter(|&(_, c)|\
    \ c.is_digit()).collect::<"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut max_diff = 0;\n    let mut max_diff_index = 0;\n\
    \    while i < digits.len() && j < digits.len() {\n        let mut d = digits[i]\
    \ - digits[j];\n        if d > 0 {\n            i += 1;\n            d -= 1;\n\
    \        } else {\n            j += 1;\n            d += 1;\n        }\n     \
    \   if d > max_diff {\n            max_diff = d;\n            max_diff_index =\
    \ j;\n        }\n    }\n    if max_diff == 0 {\n        digits.iter().cloned().collect()\n\
    \    } else {\n        digits[max_diff_index]\n    }\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpvqshflk2.rs:45:17\n\
    \   |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpvqshflk2.rs:45:25\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpvqshflk2.rs:46:17\n   |\n46 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpvqshflk2.rs:46:25\n\
    \   |\n46 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpvqshflk2.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpvqshflk2.rs:47:25\n   |\n47 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpvqshflk2.rs:48:17\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpvqshflk2.rs:48:25\n   |\n48 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpvqshflk2.rs:49:17\n  \
    \ |\n49 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpvqshflk2.rs:49:25\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0369]: cannot\
    \ subtract `char` from `char`\n  --> /tmp/tmpvqshflk2.rs:23:31\n   |\n23 |   \
    \      let mut d = digits[i] - digits[j];\n   |                     ---------\
    \ ^ --------- char\n   |                  "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n    let mut result = value.chars().take_while(|c| c\
    \ >= '0' && c <= '9').nth(1).unwrap();\n    let mut i = 0;\n    while i < digits.len()\
    \ && digits.len() > i {\n        if digits.nth(i) < result {\n            result\
    \ = digits.nth(i);\n        }\n        i += 1;\n    }\n    result.parse().unwrap()\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp3avfhcj9.rs:30:17\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3avfhcj9.rs:30:25\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp3avfhcj9.rs:31:17\n   |\n31 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp3avfhcj9.rs:31:25\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp3avfhcj9.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp3avfhcj9.rs:32:25\n   |\n32 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp3avfhcj9.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp3avfhcj9.rs:33:25\n   |\n33 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp3avfhcj9.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3avfhcj9.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3avfhcj9.rs:16:56\n   |\n16 |     let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n   |                                               \
    \         ^^"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().filter(|&(_,\
    \ c)| c != '-').collect::<Vec<_>>();\n    let mut result = value.chars().enumerate().filter(|&(_,\
    \ c)| c != '-').collect::<Vec<_>>();\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    while i < result.len() && j < digits.len() {\n      \
    \  if result[i] < digits[j] {\n            i += 1;\n        } else if result[i]\
    \ > digits[j] {\n            j += 1;\n        } else {\n            i += 1;\n\
    \            j += 1;\n        }\n    }\n    if i == result.len() {\n        i\n\
    \    } else if j == digits.len() {\n        j\n    } else {\n        let mut min\
    \ = i;\n        let mut max = j;\n        if result[i] < digits[j] {\n       \
    \     min = j;\n        } else {\n            max = i;\n        }\n        if\
    \ min == max {\n            min\n        } else {\n            min\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp4xem4aq_.rs:53:17\n\
    \   |\n53 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp4xem4aq_.rs:53:25\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp4xem4aq_.rs:54:17\n   |\n54 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp4xem4aq_.rs:54:25\n\
    \   |\n54 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp4xem4aq_.rs:55:17\n   |\n55 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp4xem4aq_.rs:55:25\n   |\n55 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp4xem4aq_.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp4xem4aq_.rs:56:25\n   |\n56 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp4xem4aq_.rs:57:17\n  \
    \ |\n57 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp4xem4aq_.rs:57:25\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4xem4aq_.rs:32:9\n   |\n14 | fn closest_integer(value:\
    \ String) -> isize {\n   |                                      ----- expected\
    \ `isize` because of return type\n..."
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut v = value.parse::<isize>().unwrap();\n    if v < 0 {\n        v = -v;\n\
    \    }\n    if v == 0 {\n        return 0;\n    }\n    let mut closest_integer\
    \ = v;\n    let mut prev_v = v;\n    while prev_v > 0 {\n        prev_v = v %\
    \ 10;\n        v = v / 10;\n        if v == 0 {\n            break;\n        }\n\
    \        closest_integer = closest_integer * 10 + v;\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpkr12ifvh.rs:37:17\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpkr12ifvh.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpkr12ifvh.rs:38:17\n   |\n38 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpkr12ifvh.rs:38:25\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpkr12ifvh.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpkr12ifvh.rs:39:25\n   |\n39 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpkr12ifvh.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpkr12ifvh.rs:40:25\n   |\n40 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpkr12ifvh.rs:41:17\n  \
    \ |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpkr12ifvh.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 10 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.parse::<isize>().unwrap();\n    let mut min: isize\
    \ = 0;\n    let mut max: isize = 0;\n    let mut min_digits = digits.len();\n\
    \    let mut max_digits = digits.len();\n    let mut min_result = result;\n  \
    \  let mut max_result = result;\n    while min_digits > max_digits {\n       \
    \ min_digits -= 1;\n        min_result = min_result / 10;\n    }\n    while max_digits\
    \ > min_digits {\n        max_digits -= 1;\n        max_result = max_result /\
    \ 10;\n    }\n    if min_digits == max_digits {\n        // The number is equidistant\
    \ from two integers\n        if min_result < max_result {\n            // The\
    \ number is closer to zero than the other integer\n            return result;\n\
    \        }\n        // The number is closer to one than the other integer\n  \
    \      return result - 1;\n    }\n    if min_digits < max_digits {\n        //\
    \ The number is closer to one than the other integer\n        return result -\
    \ 1;\n    }\n    // The number is closer to zero than the other integer\n    return\
    \ result;\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpp1jdz446.rs:51:17\n\
    \   |\n51 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpp1jdz446.rs:51:25\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpp1jdz446.rs:52:17\n   |\n52 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpp1jdz446.rs:52:25\n\
    \   |\n52 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpp1jdz446.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpp1jdz446.rs:53:25\n   |\n53 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpp1jdz446.rs:54:17\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpp1jdz446.rs:54:25\n   |\n54 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpp1jdz446.rs:55:17\n  \
    \ |\n55 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpp1jdz446.rs:55:25\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 10 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n    let mut result = value.chars().take_while(|c| c\
    \ >= '0' && c <= '9').count();\n    let mut i = 0;\n    while i < digits {\n \
    \       if digits[i] > result {\n            result = digits[i];\n        }\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpy6fwinno.rs:30:17\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpy6fwinno.rs:30:25\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpy6fwinno.rs:31:17\n   |\n31 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpy6fwinno.rs:31:25\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpy6fwinno.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpy6fwinno.rs:32:25\n   |\n32 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpy6fwinno.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpy6fwinno.rs:33:25\n   |\n33 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpy6fwinno.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpy6fwinno.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpy6fwinno.rs:16:56\n   |\n16 |     let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n   |                                               \
    \         ^^"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(0).unwrap();\n    let mut digit = digits.chars().nth(1).unwrap();\n\
    \    let mut exponent = 0;\n    let mut exponents = value.chars().nth(1).unwrap().chars().nth(1).unwrap().chars().nth(1).unwrap().chars().nth(1).unwrap();\n\
    \    let mut exponent = exponents.chars().nth(1).unwrap();\n    let mut exponent\
    \ = exponent.chars().nth(1).unwrap();\n    let mut exponent = exponent.chars().nth(1).unwrap();\n\
    \    let mut exponent = exponent.chars().nth(1).unwrap();\n    let mut exponent\
    \ = exponent.chars().nth(1).unwrap();\n    let mut exponent = exponent.chars().nth(1).unwrap();\n\
    \    let mut exponent = exponent.chars().nth(1).unwrap();\n    let mut exponent\
    \ = exponent.chars().nth(1).unwrap();\n    let mut exponent = exponent.chars().nth(1).unwrap();\n\
    \    let mut exponent = exponent.chars().nth(1).unwrap();\n    let mut exponent\
    \ = exponent.chars().nth(1).unwrap();\n    let mut exponent = exponent.chars().nth(1).unwrap();\n\
    \    let mut exponent = exponent.chars().nth(1).unwrap();\n    let mut exponent\
    \ = exponent.chars().nth(1).unwrap();\n    let mut exponent = exponent.chars().nth(1).unwrap();\n\
    \    let mut exponent = exponent.chars().nth(1).unwrap();\n    let mut exponent\
    \ = exponent.chars().nth(1).unwrap();\n    let mut exponent = exponent.chars().nth(1).unwrap();\n\
    \    let mut exponent = exponent.chars().nth(1).unwrap();\n    let mut exponent\
    \ = exponent.chars().nth(1).unwrap();\n    let mut exponent = exponent.chars().nth(1).unwrap();\n\
    \    let mut exponent = exponent.chars().nth(1).unwrap();\n    let mut exponent\
    \ = exponent.chars().nth(1).unwrap();\n    let mut exponent = exponent.chars().nth(1).unwrap();\n\
    \    let mut exponent = exponent.chars().nth(1).unwrap();\n    let mut exponent\
    \ = exponent.chars().nth(1).unwrap();\n    let mut exponent = exponent.chars().nth(1).unwrap();\n\
    \    let mut exponent = exponent.chars().nth(1).unwrap();\n    let mut \n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpdslk99t9.rs:50:1\n\
    \   |\n50 | }\n   | ^ expected identifier\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpdslk99t9.rs:54:17\n   |\n54 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpdslk99t9.rs:54:25\n \
    \  |\n54 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpdslk99t9.rs:55:17\n   |\n55 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpdslk99t9.rs:55:25\n   |\n55 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpdslk99t9.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpdslk99t9.rs:56:25\n   |\n56 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpdslk99t9.rs:57:17\n  \
    \ |\n57 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpdslk99t9.rs:57:25\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpdslk99t9.rs:58:17\n   |\n58 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpdslk99t9.rs:58:25\n\
    \   |\n58 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `chars` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpdslk"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_digit() {\n            c.to_digit(10).unwrap()\n    \
    \    } else {\n            c.to_digit(16).unwrap()\n        }\n    });\n    let\
    \ mut min_digits = std::cmp::min(digits.len(), 2);\n    let mut min_value = std::cmp::min(digits[min_digits],\
    \ digits[min_digits + 1]);\n    let mut max_value = std::cmp::max(digits[min_digits],\
    \ digits[min_digits + 1]);\n    let mut min_value = min_value.unwrap();\n    let\
    \ mut max_value = max_value.unwrap();\n    let mut min_digits = min_digits.unwrap();\n\
    \    let mut max_digits = max_digits.unwrap();\n    let mut min_value = min_value.unwrap();\n\
    \    let mut max_value = max_value.unwrap();\n    let mut min_digits = min_digits.unwrap();\n\
    \    let mut max_digits = max_digits.unwrap();\n    let mut min_value = min_value.unwrap();\n\
    \    let mut max_value = max_value.unwrap();\n    let mut min_digits = min_digits.unwrap();\n\
    \    let mut max_digits = max_digits.unwrap();\n    let mut min_value = min_value.unwrap();\n\
    \    let mut max_value = max_value.unwrap();\n    let mut min_digits = min_digits.unwrap();\n\
    \    let mut max_digits = max_digits.unwrap();\n    let mut min_value = min_value.unwrap();\n\
    \    let mut max_value = max_value.unwrap();\n    let mut min_digits = min_digits.unwrap();\n\
    \    let mut max_digits = max_digits.unwrap();\n    let mut min_value = min_value.unwrap();\n\
    \    let mut max_value = max_value.unwrap();\n    let mut min_digits = min_digits.unwrap();\n\
    \    let mut max_digits = max_digits.unwrap();\n    let mut min_value = min_value.unwrap();\n\
    \    let mut max_value = max_value.unwrap();\n    let mut min_digits = min_digits.unwrap();\n\
    \    let mut max_digits = max_digits.unwrap();\n    let mut min_value = min_value.unwrap();\n\
    \    let mut max_value = max_value.unwrap();\n    let mut min_digits = min_digits.unwrap();\n\
    \    let mut max_digits = max_digits.unwrap();\n    let mut min_value = min_value.unwrap();\n\
    \    let mut max_value = max_value.unwrap();\n    let mut min_digits = min_digits.unwrap();\n\
    \    let mut max_digits = max_digits.unwrap();\n    let mut min_value = min_value.unwrap();\n\
    \    let mut max_value = max_value.unwrap\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp073_y9ar.rs:63:41\n   |\n\
    63 |     let mut max_value = max_value.unwrap\n   |                          \
    \               ^ help: add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `max_digits` in this scope\n  --> /tmp/tmp073_y9ar.rs:29:26\n\
    \   |\n29 |     let mut max_digits = max_digits.unwrap();\n   |              \
    \            ^^^^^^^^^^ help: a local variable with a similar name exists: `min_digits`\n\
    \nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp073_y9ar.rs:68:17\n\
    \   |\n68 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp073_y9ar.rs:68:25\n   |\n68 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp073_y9ar.rs:69:17\n   |\n69 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp073_y9ar.rs:69:25\n\
    \   |\n69 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp073_y9ar.rs:70:17\n   |\n70 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp073_y9ar.rs:70:25\n   |\n70 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp073_y9ar.rs:71:17\n   |\n71 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp073_y9ar.rs:71:25\n   |\n71 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp073_y9ar.rs:72:17\n  \
    \ |\n72 |     assert_eq!({"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut closest_digit = 0;\n    let\
    \ mut closest_digits = Vec::new();\n    let mut closest_digits_len = closest_digits.len();\n\
    \    let mut closest_digits_sum = closest_digits_len as isize;\n    let mut closest_digits_sums\
    \ = Vec::new();\n    let mut closest_digits_sums_len = closest_digits_sums.len();\n\
    \    let mut closest_digits_sums_sum = closest_digits_sums_len as isize;\n   \
    \ let mut closest_digits_sums_sums = Vec::new();\n    let mut closest_digits_sums_sums_len\
    \ = closest_digits_sums_sums.len();\n    let mut closest_digits_sums_sums_sum\
    \ = closest_digits_sums_sums_len as isize;\n    let mut closest_digits_sums_sums_sums\
    \ = Vec::new();\n    let mut closest_digits_sums_sums_sums_len = closest_digits_sums_sums_sums.len();\n\
    \    let mut closest_digits_sums_sums_sums_sum = closest_digits_sums_sums_sums_len\
    \ as isize;\n    let mut closest_digits_sums_sums_sums_sums = Vec::new();\n  \
    \  let mut closest_digits_sums_sums_sums_sums_len = closest_digits_sums_sums_sums_sums.len();\n\
    \    let mut closest_digits_sums_sums_sums_sums_sum = closest_digits_sums_sums_sums_sums_len\
    \ as isize;\n    let mut closest_digits_sums_sums_sums_sums_sums = Vec::new();\n\
    \    let mut closest_digits_sums_sums_sums_sums_sums_len = closest_digits_sums_sums_sums_sums_sums.len();\n\
    \    let mut closest_digits_sums_sums_sums_sums_sums_sum = closest_digits_sums_sums_sums_sums_sums_len\
    \ as isize;\n    let mut closest_digits_sums_sums_sums_sums_sums_sums = Vec::new();\n\
    \    let mut closest_digits_sums_sums_sums_sums_sums_sums_len = closest_digits_sums_sums_sums_sums_sums_sums.len();\n\
    \    let mut closest_digits_sums_sums_sums_sums_sums_sums_sums_len = closest_digits_sums_sums_\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphi2hfiqt.rs:39:94\n   |\n\
    39 |     let mut closest_digits_sums_sums_sums_sums_sums_sums_sums_len = closest_digits_sums_sums_\n\
    \   |                                                                        \
    \                      ^ help: add `;` here\n40 | }\n   | - unexpected token\n\
    \nerror[E0425]: cannot find value `closest_digits_sums_sums_` in this scope\n\
    \  --> /tmp/tmphi2hfiqt.rs:39:69\n   |\n39 |     let mut closest_digits_sums_sums_sums_sums_sums_sums_sums_len\
    \ = closest_digits_sums_sums_\n   |                                          \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with\
    \ a similar name exists: `closest_digits_sums_sums`\n\nerror[E0425]: cannot find\
    \ value `left` in this scope\n  --> /tmp/tmphi2hfiqt.rs:44:17\n   |\n44 |    \
    \ assert_eq!({left}, {right});\n   |                 ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmphi2hfiqt.rs:44:25\n\
    \   |\n44 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmphi2hfiqt.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmphi2hfiqt.rs:45:25\n   |\n45 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmphi2hfiqt.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmphi2hfiqt.rs:46:25\n   |\n46 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmphi2hfiqt.rs:47:17\n  \
    \ |\n47 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<isize>().unwrap();\n    let mut closest: isize =\
    \ 0;\n    let mut closest_dist = std::cmp::max(isize::MIN, isize::MAX);\n    let\
    \ mut closest_dist2 = std::cmp::max(isize::MIN, isize::MAX);\n    let mut closest_dist3\
    \ = std::cmp::max(isize::MIN, isize::MAX);\n    let mut closest_dist4 = std::cmp::max(isize::MIN,\
    \ isize::MAX);\n    let mut closest_dist5 = std::cmp::max(isize::MIN, isize::MAX);\n\
    \    let mut closest_dist6 = std::cmp::max(isize::MIN, isize::MAX);\n    let mut\
    \ closest_dist7 = std::cmp::max(isize::MIN, isize::MAX);\n    let mut closest_dist8\
    \ = std::cmp::max(isize::MIN, isize::MAX);\n    let mut closest_dist9 = std::cmp::max(isize::MIN,\
    \ isize::MAX);\n    let mut closest_dist10 = std::cmp::max(isize::MIN, isize::MAX);\n\
    \    let mut closest_dist11 = std::cmp::max(isize::MIN, isize::MAX);\n    let\
    \ mut closest_dist12 = std::cmp::max(isize::MIN, isize::MAX);\n    let mut closest_dist13\
    \ = std::cmp::max(isize::MIN, isize::MAX);\n    let mut closest_dist14 = std::cmp::max(isize::MIN,\
    \ isize::MAX);\n    let mut closest_dist15 = std::cmp::max(isize::MIN, isize::MAX);\n\
    \    let mut closest_dist16 = std::cmp::max(isize::MIN, isize::MAX);\n    let\
    \ mut closest_dist17 = std::cmp::max(isize::MIN, isize::MAX);\n    let mut closest_dist18\
    \ = std::cmp::max(isize::MIN, isize::MAX);\n    let mut closest_dist19 = std::cmp::max(isize::MIN,\
    \ isize::MAX);\n    let mut closest_dist20 = std::cmp::max(isize::MIN, isize::MAX);\n\
    \    let mut closest_dist21 = std::cmp::max(isize::MIN, isize::MAX);\n    let\
    \ mut closest_dist22 = std::cmp::max(isize::MIN, isize::MAX);\n    let mut closest_dist23\
    \ = std::cmp::max(isize::MIN, isize::MAX);\n    let mut closest_dist24 = std::cmp::max(isize::MIN,\
    \ isize::MAX);\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpb2cdg8ry.rs:45:17\n\
    \   |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpb2cdg8ry.rs:45:25\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpb2cdg8ry.rs:46:17\n   |\n46 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpb2cdg8ry.rs:46:25\n\
    \   |\n46 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpb2cdg8ry.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpb2cdg8ry.rs:47:25\n   |\n47 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpb2cdg8ry.rs:48:17\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpb2cdg8ry.rs:48:25\n   |\n48 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpb2cdg8ry.rs:49:17\n  \
    \ |\n49 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpb2cdg8ry.rs:49:25\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb2cdg8ry.rs:14:38\n   |\n14 | fn closest_integer(value:\
    \ String) -> isize {\n   |    ---------------                   ^^^^^ expected\
    \ `isize`, found `()`\n   |    |\n   "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut result = 0.0;\n    let mut\
    \ i = 0;\n    while i < digits.len() {\n        let mut digit = digits[i];\n \
    \       if digit < 0 {\n            digit = -digit;\n        }\n        let mut\
    \ new_digit = digit + 1;\n        if new_digit > 9 {\n            new_digit -=\
    \ 10;\n        }\n        result = result * 10.0 + new_digit;\n        i += 1;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpt8soza2r.rs:36:17\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpt8soza2r.rs:36:25\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpt8soza2r.rs:37:17\n   |\n37 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpt8soza2r.rs:37:25\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpt8soza2r.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpt8soza2r.rs:38:25\n   |\n38 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpt8soza2r.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpt8soza2r.rs:39:25\n   |\n39 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpt8soza2r.rs:40:17\n  \
    \ |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpt8soza2r.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt8soza2r.rs:21:20\n   |\n21 |         if digit < 0 {\n\
    \   |                    ^\n   |                    |\n   |                  \
    \  expected enum `Option`, found intege"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n    let mut result = value.chars().take_while(|c| c\
    \ >= '0' && c <= '9').nth(1).unwrap();\n    let mut i = 0;\n    while i < digits.len()\
    \ && digits.len() > i {\n        if digits.nth(i) < result {\n            result\
    \ = digits.nth(i);\n        }\n        i += 1;\n    }\n    result.parse().unwrap()\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp3avfhcj9.rs:30:17\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3avfhcj9.rs:30:25\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp3avfhcj9.rs:31:17\n   |\n31 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp3avfhcj9.rs:31:25\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp3avfhcj9.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp3avfhcj9.rs:32:25\n   |\n32 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp3avfhcj9.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp3avfhcj9.rs:33:25\n   |\n33 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp3avfhcj9.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3avfhcj9.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3avfhcj9.rs:16:56\n   |\n16 |     let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n   |                                               \
    \         ^^"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut closest_digit = digits[0];\n    let mut closest_distance = std::cmp::max(1,\
    \ digits.len());\n    let mut closest_integer = isize::MAX;\n    let mut digit\
    \ = isize::MAX;\n    for digit in digits {\n        let distance = value.chars().enumerate().filter(|(_,\
    \ c)| c == digit).count();\n        if distance < closest_distance {\n       \
    \     closest_distance = distance;\n            closest_digit = digit;\n     \
    \   }\n    }\n    closest_integer\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpwzhli9af.rs:33:17\n\
    \   |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpwzhli9af.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpwzhli9af.rs:34:17\n   |\n34 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpwzhli9af.rs:34:25\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpwzhli9af.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpwzhli9af.rs:35:25\n   |\n35 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpwzhli9af.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpwzhli9af.rs:36:25\n   |\n36 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpwzhli9af.rs:37:17\n  \
    \ |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpwzhli9af.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpwzhli9af.rs:22:68\n   |\n22 |   \
    \      let distance = value.chars().enumerate().filter(|(_, c)| c == digit).count();\n\
    \   |                            "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(0).unwrap();\n    let mut digit = digits.chars().nth(0).unwrap();\n\
    \    let mut i = 0;\n    while digit != 0 {\n        let mut digit = digits.chars().nth(i).unwrap();\n\
    \        let mut digit = digit.chars().nth(0).unwrap();\n        i += 1;\n   \
    \     if digit == 0 {\n            break;\n        }\n    }\n    let mut i = 0;\n\
    \    while digit != 0 {\n        let mut digit = digits.chars().nth(i).unwrap();\n\
    \        let mut digit = digit.chars().nth(0).unwrap();\n        i += 1;\n   \
    \     if digit == 0 {\n            break;\n        }\n    }\n    i = i / 2;\n\
    \    i as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpjgtb10f1.rs:43:17\n\
    \   |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpjgtb10f1.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpjgtb10f1.rs:44:17\n   |\n44 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpjgtb10f1.rs:44:25\n\
    \   |\n44 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpjgtb10f1.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpjgtb10f1.rs:45:25\n   |\n45 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpjgtb10f1.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpjgtb10f1.rs:46:25\n   |\n46 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpjgtb10f1.rs:47:17\n  \
    \ |\n47 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpjgtb10f1.rs:47:25\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmpjgtb10f1.rs:18:28\n\
    \   |\n18 |     let mut digit = digits.chars().nth(0).unwrap();\n   |        \
    \                    ^"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n    let mut result = value.chars().take_while(|c| c\
    \ >= '0' && c <= '9').nth(1).unwrap();\n    let mut i = 0;\n    while i < digits.len()\
    \ && result < value {\n        result = digits.nth(i).unwrap();\n        i +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp35cm91wi.rs:28:17\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp35cm91wi.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp35cm91wi.rs:29:17\n   |\n29 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp35cm91wi.rs:29:25\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp35cm91wi.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp35cm91wi.rs:30:25\n   |\n30 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp35cm91wi.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp35cm91wi.rs:31:25\n   |\n31 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp35cm91wi.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp35cm91wi.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp35cm91wi.rs:16:56\n   |\n16 |     let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n   |                                               \
    \         ^^"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut result = value.parse::<isize>().unwrap();\n    if result < 0 {\n  \
    \      result = -result;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp3xzjqaoh.rs:24:17\n\
    \   |\n24 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3xzjqaoh.rs:24:25\n   |\n24 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp3xzjqaoh.rs:25:17\n   |\n25 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp3xzjqaoh.rs:25:25\n\
    \   |\n25 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp3xzjqaoh.rs:26:17\n   |\n26 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp3xzjqaoh.rs:26:25\n   |\n26 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp3xzjqaoh.rs:27:17\n   |\n27 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp3xzjqaoh.rs:27:25\n   |\n27 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp3xzjqaoh.rs:28:17\n  \
    \ |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3xzjqaoh.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 10 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823260
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut exponent = 0;\n    let mut result = isize::MAX;\n    while exponent\
    \ < value.len() {\n        let mut value = value.chars().nth(exponent + 1).unwrap();\n\
    \        let mut exponent = value.len();\n        while exponent > 0 {\n     \
    \       let mut value = value.chars().nth(exponent - 1).unwrap();\n          \
    \  exponent -= 1;\n            if value >= '0' && value <= '9' {\n           \
    \     let digit = value - '0';\n                let mut result = result * 10 +\
    \ digit;\n                if result < result {\n                    result = isize::MAX;\n\
    \                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp67ee_3fl.rs:39:17\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp67ee_3fl.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp67ee_3fl.rs:40:17\n   |\n40 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp67ee_3fl.rs:40:25\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp67ee_3fl.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp67ee_3fl.rs:41:25\n   |\n41 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp67ee_3fl.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp67ee_3fl.rs:42:25\n   |\n42 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp67ee_3fl.rs:43:17\n  \
    \ |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp67ee_3fl.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `len` found for type `char` in the current scope\n  --> /tmp/tmp67ee_3fl.rs:21:34\n\
    \   |\n21 |         let mut exponent = value.len();\n   |                    \
    \              ^^^ metho"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_digit() {\n            c.to_digit(10).unwrap()\n    \
    \    } else {\n            i\n        }\n    });\n    let mut min_digits = std::cmp::min(digits.len(),\
    \ 2);\n    let mut max_digits = std::cmp::max(digits.len(), 2);\n    let mut min_value\
    \ = std::cmp::min(&digits[min_digits], &digits[max_digits]);\n    let mut max_value\
    \ = std::cmp::max(&digits[min_digits], &digits[max_digits]);\n    let mut min_value\
    \ = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n    let\
    \ mut min_value = min_value.to_digit(10).unwrap();\n    let mut max_value = max_value.to_digit(10).unwrap();\n\
    \    let mut min_value = min_value.to_digit(10).unwrap();\n    let mut max_value\
    \ = max_value.to_digit(10).unwrap();\n    let mut min_value = min_value.to_digit(10).unwrap();\n\
    \    let mut max_value = max_value.to_digit(10).unwrap();\n    let mut min_value\
    \ = min_value.to_digit(10).unwrap();\n    let mut max_value = max_value.to_digit(10).unwrap();\n\
    \    let mut min_value = min_value.to_digit(10).unwrap();\n    let mut max_value\
    \ = max_value.to_digit(10).unwrap();\n    let mut min_value = min_value.to_digit(10).unwrap();\n\
    \    let mut max_value = max_value.to_digit(10).unwrap();\n    let mut min_value\
    \ = min_value.to_digit(10).unwrap();\n    let mut max_value = max_value.to_digit(10).unwrap();\n\
    \    let mut min_value = min_value.to_digit(10).unwrap();\n    let mut max_value\
    \ = max_value.to_digit(10).unwrap();\n    let mut min_value = min_value.to_digit(10).unwrap();\n\
    \    let mut max_value = max_value.to_digit(10).unwrap();\n    let mut min_value\
    \ = min_value.to_digit(10).unwrap();\n    let mut max_value = max_value.to_digit(10).unwrap();\n\
    \    let mut min_value = min_value.to_digit(10).unwrap();\n    let mut max_value\
    \ = max_value.to_digit(10).unwrap();\n    let mut min_value = min_value.to_digit(10).unwrap();\n\
    \    let mut max_value = max_value.to_digit(10).unwrap();\n    let mut min_value\
    \ = min_value.\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpseef2nkx.rs:54:1\n   |\n54\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpseef2nkx.rs:53:35\n\
    \   |\n53 |     let mut min_value = min_value.\n   |                         \
    \          ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpseef2nkx.rs:58:17\n  \
    \ |\n58 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpseef2nkx.rs:58:25\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpseef2nkx.rs:59:17\n   |\n59 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpseef2nkx.rs:59:25\n\
    \   |\n59 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpseef2nkx.rs:60:17\n   |\n60 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpseef2nkx.rs:60:25\n   |\n60 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpseef2nkx.rs:61:17\n   |\n61 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpseef2nkx.rs:61:25\n   |\n61 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpseef2nkx.rs:62:17\n  \
    \ |\n62 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpseef2nkx.rs:62:25\n   |\n62 |     assert_eq!({left}"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut digit =\
    \ digits[0];\n    let mut exponent = 0;\n    let mut last_digit = digit;\n   \
    \ let mut last_exponent = 0;\n    let mut last_last_digit = digit;\n    let mut\
    \ last_last_exponent = 0;\n    let mut last_last_last_digit = digit;\n    let\
    \ mut last_last_last_exponent = 0;\n    let mut last_last_last_last_digit = digit;\n\
    \    let mut last_last_last_last_exponent = 0;\n    let mut last_last_last_last_last_digit\
    \ = digit;\n    let mut last_last_last_last_last_exponent = 0;\n    let mut last_last_last_last_last_last_digit\
    \ = digit;\n    let mut last_last_last_last_last_last_exponent = 0;\n    let mut\
    \ last_last_last_last_last_last_last_digit = digit;\n    let mut last_last_last_last_last_last_last_exponent\
    \ = 0;\n    let mut last_last_last_last_last_last_last_last_digit = digit;\n \
    \   let mut last_last_last_last_last_last_last_last_exponent = 0;\n    let mut\
    \ last_last_last_last_last_last_last_last_last_digit = digit;\n    let mut last_last_last_last_last_last_last_last_last_exponent\
    \ = 0;\n    let mut last_last_last_last_last_last_last_last_last_digit = digit;\n\
    \    let mut last_last_last_last_last_last_last_last_last_exponent = 0;\n    let\
    \ mut last_last_last_last_last_last_last_last_last_last_digit = digit;\n    let\
    \ mut last_last_last_last_last_last_last_last_last_last_exponent = 0;\n    let\
    \ mut last_last_last_last_last_last_last_last_last_last_digit = digit;\n    let\
    \ mut last_last_last_last_last_last_last_last_last_last_exponent = 0;\n    let\
    \ mut last_last_last_last_last_last_last_last_last_last_last_digit = digit;\n\
    \    let mut last_last_last_last_last_last_last_last_last_last_last_exponent =\
    \ 0;\n    let mut last_last_last_last_last_last_last_last_last_last_last_digit\
    \ = digit;\n    let mut last_last_last_last_last_last_last_last_last_last_last_last_exponent\
    \ = 0;\n    let mut last_last_last_last_last_last_last_last_last_last_last_last_digit\
    \ = digit;\n    let mut last_last_last_last_last_last_last_last_last_last_last_last_exponent\
    \ = 0;\n    let mut last_last_last_last_last_last_last_last_last_last_last_last_digit\
    \ = digit;\n    let mut last_last_last_last_last_last_last_last_last_\n}\n\nfn\
    \ main() {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3lufl4af.rs:51:58\n   |\n\
    51 |     let mut last_last_last_last_last_last_last_last_last_\n   |         \
    \                                                 ^ help: add `;` here\n52 | }\n\
    \   | - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp3lufl4af.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp3lufl4af.rs:56:25\n   |\n56 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp3lufl4af.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp3lufl4af.rs:57:25\n   |\n57 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp3lufl4af.rs:58:17\n  \
    \ |\n58 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3lufl4af.rs:58:25\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp3lufl4af.rs:59:17\n   |\n59 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp3lufl4af.rs:59:25\n\
    \   |\n59 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp3lufl4af.rs:60:17\n   |\n60 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp3lufl4af.rs:60:25\n   |\n60 |   \
    \  assert_eq!({left}, {right});\n   |                  "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().filter(|&(_,\
    \ c)| c.is_numeric());\n    let mut result = value.chars().enumerate().filter(|&(_,\
    \ c)| c.is_numeric()).max().unwrap();\n    let mut digit = result.1;\n    let\
    \ mut remainder = result.0;\n    while let Some(digit) = digits.next() {\n   \
    \     let mut remainder_digit = remainder.chars().enumerate().filter(|&(_, c)|\
    \ c.is_numeric()).max().unwrap();\n        let mut remainder_digit = remainder_digit.1;\n\
    \        let mut remainder_remainder = remainder.chars().enumerate().filter(|&(_,\
    \ c)| c.is_numeric()).max().unwrap();\n        let mut remainder_remainder = remainder_remainder.1;\n\
    \        if remainder_digit == digit {\n            if remainder_remainder ==\
    \ digit {\n                remainder = remainder.chars().enumerate().filter(|&(_,\
    \ c)| c.is_numeric()).max().unwrap();\n            } else {\n                remainder\
    \ = remainder.chars().enumerate().filter(|&(_, c)| c.is_numeric()).max().unwrap();\n\
    \                remainder_remainder = remainder.chars().enumerate().filter(|&(_,\
    \ c)| c.is_numeric()).max().unwrap();\n            }\n        } else {\n     \
    \       digit = digit;\n            digits = digits.skip(1);\n            result\
    \ = result.skip(1);\n            remainder = remainder.skip(1);\n            remainder_remainder\
    \ = remainder_remainder.skip(1);\n        }\n    }\n    result.unwrap()\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpae471k_a.rs:45:17\n\
    \   |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpae471k_a.rs:45:25\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpae471k_a.rs:46:17\n   |\n46 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpae471k_a.rs:46:25\n\
    \   |\n46 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpae471k_a.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpae471k_a.rs:47:25\n   |\n47 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpae471k_a.rs:48:17\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpae471k_a.rs:48:25\n   |\n48 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpae471k_a.rs:49:17\n  \
    \ |\n49 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpae471k_a.rs:49:25\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `chars` found for type `usize` in the current scope\n  --> /tmp/tmpae471k_a.rs:21:45\n\
    \   |\n21 |         let mut remainder_digit = remainder.chars().enumerate().filter(|&(_,\
    \ c)| c.i"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut max_diff = 0;\n    while i < digits.len() &&\
    \ j < digits.len() {\n        let diff = (digits[i] - digits[j]).abs();\n    \
    \    if diff > max_diff {\n            max_diff = diff;\n        }\n        i\
    \ += 1;\n        j += 1;\n    }\n    if i == digits.len() {\n        return digits.len()\
    \ - 1;\n    }\n    if j == digits.len() {\n        return 0;\n    }\n    if max_diff\
    \ < 0 {\n        return digits.len() - 1;\n    }\n    if max_diff == 0 {\n   \
    \     return i;\n    }\n    if max_diff < result.len() {\n        return i;\n\
    \    }\n    if max_diff == result.len() {\n        return j;\n    }\n    if max_diff\
    \ > result.len() {\n        return j;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmph_wvpczi.rs:54:17\n\
    \   |\n54 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmph_wvpczi.rs:54:25\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmph_wvpczi.rs:55:17\n   |\n55 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmph_wvpczi.rs:55:25\n\
    \   |\n55 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmph_wvpczi.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmph_wvpczi.rs:56:25\n   |\n56 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmph_wvpczi.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmph_wvpczi.rs:57:25\n   |\n57 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmph_wvpczi.rs:58:17\n  \
    \ |\n58 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmph_wvpczi.rs:58:25\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0369]: cannot\
    \ subtract `char` from `char`\n  --> /tmp/tmph_wvpczi.rs:22:31\n   |\n22 |   \
    \      let diff = (digits[i] - digits[j]).abs();\n   |                     ---------\
    \ ^ --------- char\n   |           "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.parse::<isize>().unwrap();\n    let mut max_diff:\
    \ isize = 0;\n    let mut max_digits: usize = 0;\n    let mut max_digits_len =\
    \ 0;\n    let mut min_diff: isize = 0;\n    let mut min_digits: usize = 0;\n \
    \   let mut min_digits_len = 0;\n    while digits != vec![] {\n        let mut\
    \ digit = digits.iter().next().unwrap();\n        let mut digits_len = digits.len();\n\
    \        let mut digits_len2 = digits_len;\n        while digits_len2 > 0 {\n\
    \            let mut digit2 = digits.iter().next().unwrap();\n            digits_len2\
    \ -= 1;\n            if digit == digit2 {\n                break;\n          \
    \  }\n            if digits_len2 == 0 {\n                digits_len2 = digits_len;\n\
    \            }\n        }\n        let mut diff: isize = 0;\n        let mut digits_len3\
    \ = digits_len2;\n        while digits_len3 > 0 {\n            let mut digit3\
    \ = digits.iter().next().unwrap();\n            digits_len3 -= 1;\n          \
    \  if digit == digit3 {\n                break;\n            }\n            if\
    \ digits_len3 == 0 {\n                digits_len3 = digits_len;\n            }\n\
    \        }\n        if digits_len > 0 {\n            diff += digit - digit2;\n\
    \        }\n        if digits_len2 > 0 {\n            diff += digit - digit3;\n\
    \        }\n        if diff > max_diff {\n            max_diff = diff;\n     \
    \       max_digits = digit;\n            max_digits_len = digits_len;\n      \
    \  }\n        if diff < min_diff {\n            min_diff = diff;\n           \
    \ min_digits = digit;\n            min_digits_len = digits_len;\n        }\n \
    \       digits = digits.iter().skip(digits_len).collect::<Vec<_>>();\n    }\n\
    \    if max_diff == 0 {\n        max_diff = 1;\n    }\n    if min_diff == 0 {\n\
    \        min_diff = 1;\n    }\n    if max_diff == min_diff {\n        if max_digits\
    \ == min_digits {\n            return value.parse::<isize>().unwrap();\n     \
    \   }\n    }\n    if max_digits == min_digits {\n        return value.parse::<isize>().unwrap();\n\
    \    }\n    if max_digits > min_digits {\n        return value.parse::<isize>().unwrap();\n\
    \    }\n    if max_digits < min_digits {\n        return value.parse::<isize>().unwrap();\n\
    \    }\n    if max_\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmp0xafqv_u.rs:89:1\n   |\n\
    88 |     if max_\n   |     -- this `if` expression has a condition, but no block\n\
    89 | }\n   | ^ expected `{`\n\nerror[E0425]: cannot find value `digit2` in this\
    \ scope\n  --> /tmp/tmp0xafqv_u.rs:51:29\n   |\n51 |             diff += digit\
    \ - digit2;\n   |                             ^^^^^^ help: a local variable with\
    \ a similar name exists: `digit`\n\nerror[E0425]: cannot find value `digit3` in\
    \ this scope\n  --> /tmp/tmp0xafqv_u.rs:54:29\n   |\n54 |             diff +=\
    \ digit - digit3;\n   |                             ^^^^^^ help: a local variable\
    \ with a similar name exists: `digit`\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmp0xafqv_u.rs:93:17\n   |\n93 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp0xafqv_u.rs:93:25\n \
    \  |\n93 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp0xafqv_u.rs:94:17\n   |\n94 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp0xafqv_u.rs:94:25\n   |\n94 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp0xafqv_u.rs:95:17\n   |\n95 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp0xafqv_u.rs:95:25\n   |\n95 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp0xafqv_u.rs:96:17\n  \
    \ |\n96 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp0xafqv_u.rs:96:25\n   |\n96 |     assert_eq!({left}, {righ"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.parse::<isize>().unwrap();\n    let mut closest_value\
    \ = result;\n    let mut closest_digits = digits.clone();\n    let mut closest_digit\
    \ = closest_digits[closest_digits.len() - 1];\n    let mut closest_digits = &mut\
    \ closest_digits[..];\n    let mut closest_digit = closest_digit;\n    let mut\
    \ closest_digits = &mut closest_digits[..];\n    let mut closest_digit = closest_digit;\n\
    \    let mut closest_digits = &mut closest_digits[..];\n    let mut closest_digit\
    \ = closest_digit;\n    let mut closest_digits = &mut closest_digits[..];\n  \
    \  let mut closest_digit = closest_digit;\n    let mut closest_digits = &mut closest_digits[..];\n\
    \    let mut closest_digit = closest_digit;\n    let mut closest_digits = &mut\
    \ closest_digits[..];\n    let mut closest_digit = closest_digit;\n    let mut\
    \ closest_digits = &mut closest_digits[..];\n    let mut closest_digit = closest_digit;\n\
    \    let mut closest_digits = &mut closest_digits[..];\n    let mut closest_digit\
    \ = closest_digit;\n    let mut closest_digits = &mut closest_digits[..];\n  \
    \  let mut closest_digit = closest_digit;\n    let mut closest_digits = &mut closest_digits[..];\n\
    \    let mut closest_digit = closest_digit;\n    let mut closest_digits = &mut\
    \ closest_digits[..];\n    let mut closest_digit = closest_digit;\n    let mut\
    \ closest_digits = &mut closest_digits[..];\n    let mut closest_digit = closest_digit;\n\
    \    let mut closest_digits = &mut closest_digits[..];\n    let mut closest_digit\
    \ = closest_digit;\n    let mut closest_digits = &mut closest_digits[..];\n  \
    \  let mut closest_digit = closest_digit;\n    let mut closest_digits = &mut closest_digits[..];\n\
    \    let mut closest_digit = closest_digit;\n    let mut closest_digits = &mut\
    \ closest_digits[..];\n    let mut closest_digit = closest_digit;\n    let mut\
    \ closest_digits = &mut closest_digits[..];\n    let mut closest_digit = closest_digit;\n\
    \    let mut closest_digits = &mut closest_digits[..];\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpahprkr6s.rs:56:11\n   |\n\
    56 |     let mu\n   |           ^ help: add `;` here\n57 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpahprkr6s.rs:61:17\n\
    \   |\n61 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpahprkr6s.rs:61:25\n   |\n61 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpahprkr6s.rs:62:17\n   |\n62 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpahprkr6s.rs:62:25\n\
    \   |\n62 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpahprkr6s.rs:63:17\n   |\n63 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpahprkr6s.rs:63:25\n   |\n63 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpahprkr6s.rs:64:17\n   |\n64 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpahprkr6s.rs:64:25\n   |\n64 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpahprkr6s.rs:65:17\n  \
    \ |\n65 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpahprkr6s.rs:65:25\n   |\n65 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpahprkr6s.rs"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut result = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut min_value = result.iter().min().unwrap();\n\
    \    let mut max_value = result.iter().max().unwrap();\n    let mut min_digits\
    \ = digits.iter().min().unwrap();\n    let mut max_digits = digits.iter().max().unwrap();\n\
    \    let mut min_value = min_value.to_digit(10);\n    let mut max_value = max_value.to_digit(10);\n\
    \    let mut min_digits = min_digits.to_digit(10);\n    let mut max_digits = max_digits.to_digit(10);\n\
    \    let mut min_value = min_value.to_digit(10);\n    let mut max_value = max_value.to_digit(10);\n\
    \    let mut min_digits = min_digits.to_digit(10);\n    let mut max_digits = max_digits.to_digit(10);\n\
    \    while min_value + 1 < max_value {\n        let mut min_digit = min_digits.clone();\n\
    \        let mut max_digit = max_digits.clone();\n        if min_digit + 1 < max_digit\
    \ {\n            min_digit += 1;\n            max_digit += 1;\n        }\n   \
    \     if min_digit + 1 == max_digit {\n            min_value += 1;\n         \
    \   max_value += 1;\n        }\n        if min_digit + 1 == max_digit {\n    \
    \        min_value += 1;\n            max_value += 1;\n        }\n        if min_digit\
    \ + 1 == max_digit {\n            min_value += 1;\n            max_value += 1;\n\
    \        }\n        if min_digit + 1 == max_digit {\n            min_value +=\
    \ 1;\n            max_value += 1;\n        }\n        if min_digit + 1 == max_digit\
    \ {\n            min_value += 1;\n            max_value += 1;\n        }\n   \
    \     if min_digit + 1 == max_digit {\n            min_value += 1;\n         \
    \   max_value += 1;\n        }\n        if min_digit + 1 == max_digit {\n    \
    \        min_value += 1;\n            max_value += 1;\n        }\n        if min_digit\
    \ + 1 == max_digit {\n            min_value += 1;\n            max_value += 1;\n\
    \        }\n        if min_digit + 1 == max_digit {\n            min_value +=\
    \ 1;\n            max_value += 1;\n        }\n        if min_digit + 1 == max_digit\
    \ {\n            min_value += 1;\n            max_value += 1;\n        }\n   \
    \     if min_digit + 1 == max_digit {\n            min_value += 1;\n         \
    \   max_value += 1;\n        }\n        if min_digit + 1 == max_digit {\n    \
    \        min_value += 1;\n            max_value += 1;\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmppdxtzs_4.rs:93:3\n\
    \   |\n14 | fn closest_integer(value: String) -> isize {\n   |               \
    \                             - unclosed delimiter\n...\n30 |     while min_value\
    \ + 1 < max_value {\n   |                                     - unclosed delimiter\n\
    ...\n81 |         if min_digit + 1 == max_digit {\n   |                      \
    \                 - this delimiter might not be properly closed...\n...\n84 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n93 |\
    \ }\n   |   ^\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmppdxtzs_4.rs:88:17\n\
    \   |\n88 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmppdxtzs_4.rs:88:25\n   |\n88 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmppdxtzs_4.rs:89:17\n   |\n89 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmppdxtzs_4.rs:89:25\n\
    \   |\n89 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmppdxtzs_4.rs:90:17\n   |\n90 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmppdxtzs_4.rs:90:25\n   |\n90 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmppdxtzs_4.rs:91:17\n   |\n91 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmppdxtzs_4.rs:91:25\n   |\n91 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find val"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    while i < digits.len() && j < digits.len() {\n      \
    \  if digits[i] < digits[j] {\n            result[j] = digits[i];\n          \
    \  i += 1;\n        } else {\n            result[j] = digits[j];\n           \
    \ j += 1;\n        }\n    }\n    result\n        .iter()\n        .enumerate()\n\
    \        .filter(|(_, x)| x == 0)\n        .map(|(_, x)| x)\n        .max()\n\
    \        .unwrap()\n}\n\nfn main() {\n    let candidate = closest_integer;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpp_sszl_i.rs:40:17\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpp_sszl_i.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpp_sszl_i.rs:41:17\n   |\n41 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpp_sszl_i.rs:41:25\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpp_sszl_i.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpp_sszl_i.rs:42:25\n   |\n42 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpp_sszl_i.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpp_sszl_i.rs:43:25\n   |\n43 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpp_sszl_i.rs:44:17\n  \
    \ |\n44 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpp_sszl_i.rs:44:25\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: can't\
    \ compare `&&char` with `{integer}`\n  --> /tmp/tmpp_sszl_i.rs:32:28\n   |\n32\
    \ |         .filter(|(_, x)| x == 0)\n   |                            ^^ no implementation\
    \ for `&&char == {integer}`\n"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut k = 0;\n    while i < digits.len() && j < digits.len()\
    \ {\n        if digits[i] < digits[j] {\n            i += 1;\n        } else {\n\
    \            j += 1;\n        }\n    }\n    while i < digits.len() {\n       \
    \ result.push(digits[i]);\n        i += 1;\n    }\n    while j < digits.len()\
    \ {\n        result.push(digits[j]);\n        j += 1;\n    }\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    let mut k = 0;\n    while i < result.len() && j\
    \ < result.len() {\n        if result[i] < result[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    while i < result.len()\
    \ {\n        result.push(result[i]);\n        i += 1;\n    }\n    while j < result.len()\
    \ {\n        result.push(result[j]);\n        j += 1;\n    }\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    let mut k = 0;\n    while i < result.len() && j\
    \ < result.len() {\n        if result[i] < result[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    while i < result.len()\
    \ {\n        result.push(result[i]);\n        i += 1;\n    }\n    while j < result.len()\
    \ {\n        result.push(result[j]);\n        j += 1;\n    }\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    let mut k = 0;\n    while i < result.len() && j\
    \ < result.len() {\n        if result[i] < result[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    while i < result.len()\
    \ {\n        result.push(result[i]);\n        i += 1;\n    }\n    while j < result.len()\
    \ {\n        result.push(result[j]);\n        j += 1;\n    }\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    let mut k = 0;\n    while i < result.len() && j\
    \ < result.len() {\n        if result[i] < result[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    while i < result.len()\
    \ {\n        result.push(result[i]);\n        i += 1;\n    }\n    while j < result.len()\
    \ {\n        result.push(result[j]);\n        j += 1;\n    }\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    let mut k = 0;\n    while i < result.len() && j\
    \ < result.len() {\n        if result[i] < result[j] {\n            i += 1;\n\
    \        } else {\n            j += 1;\n        }\n    }\n    while i < result.len(\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n   --> /tmp/tmpc7dzmffy.rs:118:25\n\
    \    |\n14  | fn closest_integer(value: String) -> isize {\n    |            \
    \                                - closing delimiter possibly meant for this\n\
    ...\n118 |     while i < result.len(\n    |                         ^ unclosed\
    \ delimiter\n119 | }\n    | ^ mismatched closing delimiter\n\nerror: expected\
    \ `{`, found `}`\n   --> /tmp/tmpc7dzmffy.rs:119:1\n    |\n119 | }\n    | ^ expected\
    \ `{`\n\nerror[E0425]: cannot find value `left` in this scope\n   --> /tmp/tmpc7dzmffy.rs:123:17\n\
    \    |\n123 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpc7dzmffy.rs:123:25\n    |\n123 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpc7dzmffy.rs:124:17\n\
    \    |\n124 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpc7dzmffy.rs:124:25\n    |\n124 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpc7dzmffy.rs:125:17\n\
    \    |\n125 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpc7dzmffy.rs:125:25\n    |\n125 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpc7dzmffy.rs:126:17\n\
    \    |\n126 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpc7dzmffy.rs:126:25\n    |\n126 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpc7dzmffy.r"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    if value.chars().count() > 2 {\n  \
    \      value = &value[0..value.len() - 2];\n    }\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut k = 0;\n    while i < digits.len() && j < digits.len()\
    \ {\n        if digits[i] < digits[j] {\n            i += 1;\n        } else {\n\
    \            j += 1;\n        }\n    }\n    if i == digits.len() {\n        return\
    \ digits.len() - 1;\n    }\n    if j == digits.len() {\n        return digits.len()\
    \ - 2;\n    }\n    if digits[i] == digits[j] {\n        if digits[i] > digits[j]\
    \ {\n            return digits.len() - 2;\n        } else {\n            return\
    \ digits.len() - 1;\n        }\n    }\n    if digits[i] > digits[j] {\n      \
    \  return i;\n    } else {\n        return j;\n    }\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpaxlj51d5.rs:53:17\n\
    \   |\n53 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpaxlj51d5.rs:53:25\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpaxlj51d5.rs:54:17\n   |\n54 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpaxlj51d5.rs:54:25\n\
    \   |\n54 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpaxlj51d5.rs:55:17\n   |\n55 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpaxlj51d5.rs:55:25\n   |\n55 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpaxlj51d5.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpaxlj51d5.rs:56:25\n   |\n56 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpaxlj51d5.rs:57:17\n  \
    \ |\n57 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpaxlj51d5.rs:57:25\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpaxlj51d5.rs:17:17\n   |\n17 |         value = &value[0..value.len()\
    \ - 2];\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut smallest = digits[0];\n  \
    \  let mut largest = digits[0];\n    for i in 1..digits.size() {\n        if digits[i]\
    \ < smallest {\n            smallest = digits[i];\n        }\n        if digits[i]\
    \ > largest {\n            largest = digits[i];\n        }\n    }\n    let mut\
    \ i = 0;\n    while i < digits.size() && digits[i] > largest {\n        i += 1;\n\
    \    }\n    i + (largest - smallest).abs()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp_pto6c41.rs:36:17\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_pto6c41.rs:36:25\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_pto6c41.rs:37:17\n   |\n37 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_pto6c41.rs:37:25\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_pto6c41.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_pto6c41.rs:38:25\n   |\n38 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_pto6c41.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_pto6c41.rs:39:25\n   |\n39 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_pto6c41.rs:40:17\n  \
    \ |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_pto6c41.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `size` found for struct `Vec<Option<u32>>` in the current scope\n  -->\
    \ /tmp/tmp_pto6c41.rs:19:24\n   |\n19 |     for i in 1..digits.size() {\n   |\
    \                        ^^^^ method "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            0\n        }\n    });\n    let mut min = 0;\n   \
    \ let mut max = digits.len();\n    while min < max {\n        let mid = (min +\
    \ max) / 2;\n        let midval = digits.iter().position(|&i| i == mid).unwrap();\n\
    \        let midval = midval as isize;\n        if midval < value {\n        \
    \    max = mid;\n        } else {\n            min = mid;\n        }\n    }\n\
    \    min\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpjw_leskq.rs:40:17\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpjw_leskq.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpjw_leskq.rs:41:17\n   |\n41 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpjw_leskq.rs:41:25\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpjw_leskq.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpjw_leskq.rs:42:25\n   |\n42 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpjw_leskq.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpjw_leskq.rs:43:25\n   |\n43 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpjw_leskq.rs:44:17\n  \
    \ |\n44 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpjw_leskq.rs:44:25\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: the method\
    \ `len` exists for struct `Map<Enumerate<Chars<'_>>, [closure@/tmp/tmpjw_leskq.rs:16:52:\
    \ 22:6]>`, but its trait bounds were not satisfied\n  --> /tmp/tmpjw_leskq.rs:24:26\n\
    \   |\n24 |      "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut min_diff = std::cmp::max(1,\
    \ digits[0]);\n    let mut closest_integer = digits[0];\n    for d in &digits[1..]\
    \ {\n        let diff = (d - min_diff).abs();\n        if diff < min_diff {\n\
    \            min_diff = diff;\n            closest_integer = d;\n        }\n \
    \   }\n    closest_integer.parse().unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpmjjnun_4.rs:31:17\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmjjnun_4.rs:31:25\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpmjjnun_4.rs:32:17\n   |\n32 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpmjjnun_4.rs:32:25\n\
    \   |\n32 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpmjjnun_4.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpmjjnun_4.rs:33:25\n   |\n33 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpmjjnun_4.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpmjjnun_4.rs:34:25\n   |\n34 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpmjjnun_4.rs:35:17\n  \
    \ |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmjjnun_4.rs:35:25\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmjjnun_4.rs:17:41\n   |\n17 |     let mut min_diff = std::cmp::max(1,\
    \ digits[0]);\n   |                                         ^^^^^^^^^ expected\
    \ integer, found enum"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut exponent = 0;\n\
    \    let mut i = 0;\n    while i < value.len() {\n        let mut digit = digits.chars().nth(1).unwrap();\n\
    \        if digit == '.' {\n            exponent = digits.chars().nth(1).unwrap().parse().unwrap();\n\
    \            digits = digits.chars().nth(2).unwrap();\n        } else {\n    \
    \        digit = digit.parse().unwrap();\n        }\n        if exponent == 0\
    \ {\n            if digit < result {\n                result = digit;\n      \
    \      }\n        } else {\n            if digit < result {\n                result\
    \ = digit;\n            }\n            if digit == result {\n                exponent\
    \ = exponent - 1;\n            }\n        }\n        i += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp1fyt9q_c.rs:47:17\n\
    \   |\n47 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp1fyt9q_c.rs:47:25\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp1fyt9q_c.rs:48:17\n   |\n48 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp1fyt9q_c.rs:48:25\n\
    \   |\n48 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp1fyt9q_c.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp1fyt9q_c.rs:49:25\n   |\n49 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp1fyt9q_c.rs:50:17\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp1fyt9q_c.rs:50:25\n   |\n50 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp1fyt9q_c.rs:51:17\n  \
    \ |\n51 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp1fyt9q_c.rs:51:25\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmp1fyt9q_c.rs:21:32\n\
    \   |\n21 |         let mut digit = digits.chars().nth(1).unwrap();\n   |    \
    \                     "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(0).unwrap();\n    let mut i = 0;\n   \
    \ while i < digits.len() {\n        if digits[i] != '.' {\n            i += 1;\n\
    \            continue;\n        }\n        let mut j = i;\n        while j < digits.len()\
    \ && digits[j] == '.' {\n            i += 1;\n            j = i;\n        }\n\
    \        let mut k = i;\n        while k < digits.len() && digits[k] == '.' {\n\
    \            i += 1;\n            k = i;\n        }\n        let mut digit = digits[i..k].collect::<String>();\n\
    \        if digit == \"0\" {\n            i += 1;\n            continue;\n   \
    \     }\n        if digit == \"1\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"2\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"3\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"4\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"5\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"6\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"7\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"8\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"9\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \".\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"-\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"+\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"+\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"+\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"+\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"+\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"+\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"+\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"+\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"+\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"+\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"+\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"+\" {\n            i += 1;\n            continue;\n\
    \        }\n        if digit == \"+\" {\n            i += 1;\n}\n\nfn main() {\n\
    \    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp_lggti7h.rs:142:3\n\
    \    |\n14  | fn closest_integer(value: String) -> isize {\n    |            \
    \                                - unclosed delimiter\n...\n19  |     while i\
    \ < digits.len() {\n    |                            - unclosed delimiter\n...\n\
    131 |         if digit == \"+\" {\n    |                         - this delimiter\
    \ might not be properly closed...\n132 |             i += 1;\n133 | }\n    | -\
    \ ...as it matches this but it has different indentation\n...\n142 | }\n    |\
    \   ^\n\nerror[E0425]: cannot find value `left` in this scope\n   --> /tmp/tmp_lggti7h.rs:137:17\n\
    \    |\n137 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp_lggti7h.rs:137:25\n    |\n137 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp_lggti7h.rs:138:17\n\
    \    |\n138 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp_lggti7h.rs:138:25\n    |\n138 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp_lggti7h.rs:139:17\n\
    \    |\n139 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp_lggti7h.rs:139:25\n    |\n139 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp_lggti7h.rs:140:17\n\
    \    |\n140 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp_lggti7h.rs:140:25\n    |\n140 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\n"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut remainder =\
    \ 0;\n    let mut i = 0;\n    while i < value.len() {\n        let mut digit =\
    \ digits.chars().nth(i).unwrap();\n        let mut remainder = remainder.chars().nth(i).unwrap();\n\
    \        if digit == remainder {\n            i += 1;\n            continue;\n\
    \        }\n        if digit < remainder {\n            digit = digit + 10;\n\
    \            remainder = remainder - digit;\n        } else {\n            digit\
    \ = digit - 10;\n            remainder = remainder + digit;\n        }\n     \
    \   result = digit + remainder;\n        i += 1;\n    }\n    result.parse().unwrap()\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpyme_cmb_.rs:42:17\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpyme_cmb_.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpyme_cmb_.rs:43:17\n   |\n43 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpyme_cmb_.rs:43:25\n\
    \   |\n43 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpyme_cmb_.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpyme_cmb_.rs:44:25\n   |\n44 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpyme_cmb_.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpyme_cmb_.rs:45:25\n   |\n45 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpyme_cmb_.rs:46:17\n  \
    \ |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpyme_cmb_.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmpyme_cmb_.rs:21:32\n\
    \   |\n21 |         let mut digit = digits.chars().nth(i).unwrap();\n   |    \
    \                     "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut exponent = 0;\n    let mut result = isize::MAX;\n    while exponent\
    \ < value.len() {\n        let mut digit = digits.chars().nth(1).unwrap();\n \
    \       let mut digit = digit.parse::<usize>().unwrap();\n        if digit < result\
    \ {\n            result = digit;\n        }\n        digits = digits.chars().nth(1).unwrap();\n\
    \        exponent = exponent + 1;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp2h4zznpf.rs:33:17\n\
    \   |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp2h4zznpf.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp2h4zznpf.rs:34:17\n   |\n34 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp2h4zznpf.rs:34:25\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp2h4zznpf.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp2h4zznpf.rs:35:25\n   |\n35 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp2h4zznpf.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp2h4zznpf.rs:36:25\n   |\n36 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp2h4zznpf.rs:37:17\n  \
    \ |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp2h4zznpf.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmp2h4zznpf.rs:20:32\n\
    \   |\n20 |         let mut digit = digits.chars().nth(1).unwrap();\n   |    \
    \                     "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_digit(16).unwrap()\n        }\n    }).collect::<Vec<_>>();\n\
    \    let mut result = value.chars().enumerate().map(|(i, c)| {\n        if c.is_numeric()\
    \ {\n            c.to_digit(10).unwrap()\n        } else {\n            c.to_digit(16).unwrap()\n\
    \        }\n    }).collect::<Vec<_>>();\n    let mut min: isize = 0;\n    let\
    \ mut max: isize = 0;\n    let mut mid: isize = 0;\n    let mut mid2: isize =\
    \ 0;\n    let mut mid3: isize = 0;\n    let mut mid4: isize = 0;\n    let mut\
    \ mid5: isize = 0;\n    let mut mid6: isize = 0;\n    let mut mid7: isize = 0;\n\
    \    let mut mid8: isize = 0;\n    let mut mid9: isize = 0;\n    let mut mid10:\
    \ isize = 0;\n    let mut mid11: isize = 0;\n    let mut mid12: isize = 0;\n \
    \   let mut mid13: isize = 0;\n    let mut mid14: isize = 0;\n    let mut mid15:\
    \ isize = 0;\n    let mut mid16: isize = 0;\n    let mut mid17: isize = 0;\n \
    \   let mut mid18: isize = 0;\n    let mut mid19: isize = 0;\n    let mut mid20:\
    \ isize = 0;\n    let mut mid21: isize = 0;\n    let mut mid22: isize = 0;\n \
    \   let mut mid23: isize = 0;\n    let mut mid24: isize = 0;\n    let mut mid25:\
    \ isize = 0;\n    let mut mid26: isize = 0;\n    let mut mid27: isize = 0;\n \
    \   let mut mid28: isize = 0;\n    let mut mid29: isize = 0;\n    let mut mid30:\
    \ isize = 0;\n    let mut mid31: isize = 0;\n    let mut mid32: isize = 0;\n \
    \   let mut mid33: isize = 0;\n    let mut mid34: isize = 0;\n    let mut mid35:\
    \ isize = 0;\n    let mut mid36: isize = 0;\n    let mut mid37: isize = 0;\n \
    \   let mut mid38: isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5nzh92k3.rs:69:25\n   |\n\
    69 |     let mut mid38: isize\n   |                         ^ help: add `;` here\n\
    70 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n  --> /tmp/tmp5nzh92k3.rs:74:17\n   |\n74 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp5nzh92k3.rs:74:25\n   |\n74 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp5nzh92k3.rs:75:17\n   |\n75 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp5nzh92k3.rs:75:25\n   |\n75 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp5nzh92k3.rs:76:17\n  \
    \ |\n76 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5nzh92k3.rs:76:25\n   |\n76 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp5nzh92k3.rs:77:17\n   |\n77 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp5nzh92k3.rs:77:25\n\
    \   |\n77 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp5nzh92k3.rs:78:17\n   |\n78 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp5nzh92k3.rs:78:25\n   |\n78 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched typ"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n    let mut result = value.parse::<isize>().unwrap();\n\
    \    let mut i = 0;\n    while i < digits.len() && result < 0 {\n        result\
    \ = result * 10 + digits.get(i);\n        i += 1;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp2hmnyzc6.rs:28:17\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp2hmnyzc6.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp2hmnyzc6.rs:29:17\n   |\n29 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp2hmnyzc6.rs:29:25\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp2hmnyzc6.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp2hmnyzc6.rs:30:25\n   |\n30 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp2hmnyzc6.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp2hmnyzc6.rs:31:25\n   |\n31 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp2hmnyzc6.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp2hmnyzc6.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2hmnyzc6.rs:16:56\n   |\n16 |     let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n   |                                               \
    \         ^^"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut min_digits = digits.iter().min();\n\
    \    let mut max_digits = digits.iter().max();\n    let mut min_value = min_digits.to_digit(10);\n\
    \    let mut max_value = max_digits.to_digit(10);\n    let mut min_diff = 0;\n\
    \    let mut max_diff = 0;\n    let mut min_diff_index = 0;\n    let mut max_diff_index\
    \ = 0;\n    let mut min_diff_value = max_value;\n    let mut max_diff_value =\
    \ min_value;\n    let mut min_diff_index = max_diff_index;\n    let mut max_diff_index\
    \ = min_diff_index;\n    let mut min_diff_value = max_diff_value;\n    let mut\
    \ max_diff_value = min_diff_value;\n    let mut min_diff_index = max_diff_index;\n\
    \    let mut max_diff_index = min_diff_index;\n    let mut min_diff_value = max_diff_value;\n\
    \    let mut max_diff_value = min_diff_value;\n    let mut min_diff_index = max_diff_index;\n\
    \    let mut max_diff_index = min_diff_index;\n    let mut min_diff_value = max_diff_value;\n\
    \    let mut max_diff_value = min_diff_value;\n    let mut min_diff_index = max_diff_index;\n\
    \    let mut max_diff_index = min_diff_index;\n    let mut min_diff_value = max_diff_value;\n\
    \    let mut max_diff_value = min_diff_value;\n    let mut min_diff_index = max_diff_index;\n\
    \    let mut max_diff_index = min_diff_index;\n    let mut min_diff_value = max_diff_value;\n\
    \    let mut max_diff_value = min_diff_value;\n    let mut min_diff_index = max_diff_index;\n\
    \    let mut max_diff_index = min_diff_index;\n    let mut min_diff_value = max_diff_value;\n\
    \    let mut max_diff_value = min_diff_value;\n    let mut min_diff_index = max_diff_index;\n\
    \    let mut max_diff_index = min_diff_index;\n    let mut min_diff_value = max_diff_value;\n\
    \    let mut max_diff_value = min_diff_value;\n    let mut min_diff_index = max_diff_index;\n\
    \    let mut max_diff_index = min_diff_index;\n    let mut min_diff_value = max_diff_value;\n\
    \    let mut max_diff_value = min_diff_value;\n    let mut min_diff_index = max_diff_index;\n\
    \    let mut max_diff_index = min_diff_index;\n    let mut min_diff_value = max_diff\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoq47a9s2.rs:61:38\n   |\n\
    61 |     let mut min_diff_value = max_diff\n   |                             \
    \         ^ help: add `;` here\n62 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpoq47a9s2.rs:66:17\n  \
    \ |\n66 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpoq47a9s2.rs:66:25\n   |\n66 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpoq47a9s2.rs:67:17\n   |\n67 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpoq47a9s2.rs:67:25\n\
    \   |\n67 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpoq47a9s2.rs:68:17\n   |\n68 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpoq47a9s2.rs:68:25\n   |\n68 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpoq47a9s2.rs:69:17\n   |\n69 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpoq47a9s2.rs:69:25\n   |\n69 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpoq47a9s2.rs:70:17\n  \
    \ |\n70 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpoq47a9s2.rs:70:25\n   |\n70 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\ner"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().filter(|&(_,\
    \ c)| c != '0');\n    let mut result = value.chars().enumerate().filter(|&(_,\
    \ c)| c != '0').max().unwrap();\n    let mut i = 0;\n    while i < digits.len()\
    \ {\n        if digits[i] - digits[digits.len() - i] > 1 {\n            digits[digits.len()\
    \ - i] -= 1;\n        } else {\n            i += 1;\n        }\n    }\n    digits.iter().cloned().map(|c|\
    \ c.unwrap()).sum::<isize>()\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpzxp3ltos.rs:31:17\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpzxp3ltos.rs:31:25\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpzxp3ltos.rs:32:17\n   |\n32 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpzxp3ltos.rs:32:25\n\
    \   |\n32 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpzxp3ltos.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpzxp3ltos.rs:33:25\n   |\n33 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpzxp3ltos.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpzxp3ltos.rs:34:25\n   |\n34 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpzxp3ltos.rs:35:17\n  \
    \ |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpzxp3ltos.rs:35:25\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `len` found for struct `Filter` in the current scope\n  --> /tmp/tmpzxp3ltos.rs:19:22\n\
    \   |\n19 |     while i < digits.len() {\n   |                      ^^^ method\
    \ not found in `Fil"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_digit() {\n            c.to_digit(10).unwrap()\n    \
    \    } else {\n            i\n        }\n    });\n    let mut closest_digit =\
    \ digits[0];\n    let mut closest_distance = std::cmp::max(digits[0]);\n    let\
    \ mut closest_integer = value.chars().enumerate().map(|(i, c)| {\n        if c.is_digit()\
    \ {\n            let distance = std::cmp::max(\n                closest_digit,\n\
    \                closest_distance,\n                std::cmp::min(\n         \
    \           closest_digit,\n                    closest_distance,\n          \
    \          c.to_digit(10).unwrap(),\n                ),\n            );\n    \
    \        closest_digit = c;\n            closest_distance = distance;\n      \
    \      distance\n        } else {\n            i\n        }\n    });\n    closest_integer.next()\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpzc7cwx3j.rs:48:17\n\
    \   |\n48 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpzc7cwx3j.rs:48:25\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpzc7cwx3j.rs:49:17\n   |\n49 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpzc7cwx3j.rs:49:25\n\
    \   |\n49 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpzc7cwx3j.rs:50:17\n   |\n50 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpzc7cwx3j.rs:50:25\n   |\n50 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpzc7cwx3j.rs:51:17\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpzc7cwx3j.rs:51:25\n   |\n51 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpzc7cwx3j.rs:52:17\n  \
    \ |\n52 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpzc7cwx3j.rs:52:25\n   |\n52 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpzc7cwx3j.rs:17:14\n\
    \    |\n17  |         if c.is_digit() {\n    |              ^^^^^^^^- supplied\
    \ 0 arguments\n    |       "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if i == 0 {\n            digits = value.chars().nth(1).unwrap();\n\
    \            result = value.chars().nth(1).unwrap();\n        }\n        if digits.is_digit()\
    \ {\n            if result.is_digit() {\n                let mut digit = digits.to_digit(10);\n\
    \                let mut result = result.to_digit(10);\n                if digit\
    \ > result {\n                    digit = digit - 10;\n                    result\
    \ = result + 10;\n                }\n                i = i + 1;\n            }\
    \ else {\n                digits = digits.to_digit(10);\n                result\
    \ = result + 10;\n            }\n        } else {\n            digits = digits.to_digit(10);\n\
    \            result = result + 10;\n        }\n    }\n    digits.parse::<isize>().unwrap()\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpdyldl_r5.rs:47:17\n\
    \   |\n47 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpdyldl_r5.rs:47:25\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpdyldl_r5.rs:48:17\n   |\n48 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpdyldl_r5.rs:48:25\n\
    \   |\n48 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpdyldl_r5.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpdyldl_r5.rs:49:25\n   |\n49 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpdyldl_r5.rs:50:17\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpdyldl_r5.rs:50:25\n   |\n50 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpdyldl_r5.rs:51:17\n  \
    \ |\n51 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpdyldl_r5.rs:51:25\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpdyldl_r5.rs:24:19\n\
    \    |\n24  |         if digits.is_digit() {\n    |                   ^^^^^^^^-\
    \ supplied 0 arguments\n  "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if digits[i] != '.' {\n            digits =\
    \ &digits[i..];\n            break;\n        }\n        i += 1;\n    }\n    let\
    \ mut digits = digits.chars().nth(1).unwrap();\n    let mut i = 0;\n    while\
    \ i < value.len() {\n        if digits[i] != '.' {\n            digits = &digits[i..];\n\
    \            break;\n        }\n        i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut i = 0;\n    while i < value.len() {\n        if digits[i] != '.'\
    \ {\n            digits = &digits[i..];\n            break;\n        }\n     \
    \   i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n   \
    \ let mut i = 0;\n    while i < value.len() {\n        if digits[i] != '.' {\n\
    \            digits = &digits[i..];\n            break;\n        }\n        i\
    \ += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let\
    \ mut i = 0;\n    while i < value.len() {\n        if digits[i] != '.' {\n   \
    \         digits = &digits[i..];\n            break;\n        }\n        i +=\
    \ 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let mut\
    \ i = 0;\n    while i < value.len() {\n        if digits[i] != '.' {\n       \
    \     digits = &digits[i..];\n            break;\n        }\n        i += 1;\n\
    \    }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let mut i =\
    \ 0;\n    while i < value.len() {\n        if digits[i] != '.' {\n           \
    \ digits = &digits[i..];\n            break;\n        }\n        i += 1;\n   \
    \ }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let mut i = 0;\n\
    \    while i < value.len() {\n        if digits[i] != '.' {\n            digits\
    \ = &digits[i..];\n            break;\n        }\n        i += 1;\n    }\n   \
    \ let mut digits = digits.chars().nth(1).unwrap();\n    let mut i = 0;\n    while\
    \ i < value.len() {\n        if digits[i] != '.' {\n            digits = &digits[i..];\n\
    \            break;\n        }\n        i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut i = 0;\n    while i < value.len(\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpuvk1o5qx.rs:101:1\n    |\n\
    101 | }\n    | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  \
    \ --> /tmp/tmpuvk1o5qx.rs:100:24\n    |\n14  | fn closest_integer(value: String)\
    \ -> isize {\n    |                                            - closing delimiter\
    \ possibly meant for this\n...\n100 |     while i < value.len(\n    |        \
    \                ^ unclosed delimiter\n101 | }\n    | ^ mismatched closing delimiter\n\
    \nerror[E0425]: cannot find value `left` in this scope\n   --> /tmp/tmpuvk1o5qx.rs:105:17\n\
    \    |\n105 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpuvk1o5qx.rs:105:25\n    |\n105 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpuvk1o5qx.rs:106:17\n\
    \    |\n106 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpuvk1o5qx.rs:106:25\n    |\n106 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpuvk1o5qx.rs:107:17\n\
    \    |\n107 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpuvk1o5qx.rs:107:25\n    |\n107 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpuvk1o5qx.rs:108:17\n\
    \    |\n108 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpuvk1o5qx.rs:108:25\n    |\n108 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpuvk1o5qx.rs:"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if digits[i] != '.' {\n            digits =\
    \ &digits[i..];\n            break;\n        }\n        i += 1;\n    }\n    let\
    \ mut digits = digits.chars().nth(1).unwrap();\n    let mut i = 0;\n    while\
    \ i < value.len() {\n        if digits[i] != '.' {\n            digits = &digits[i..];\n\
    \            break;\n        }\n        i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut i = 0;\n    while i < value.len() {\n        if digits[i] != '.'\
    \ {\n            digits = &digits[i..];\n            break;\n        }\n     \
    \   i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n   \
    \ let mut i = 0;\n    while i < value.len() {\n        if digits[i] != '.' {\n\
    \            digits = &digits[i..];\n            break;\n        }\n        i\
    \ += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let\
    \ mut i = 0;\n    while i < value.len() {\n        if digits[i] != '.' {\n   \
    \         digits = &digits[i..];\n            break;\n        }\n        i +=\
    \ 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let mut\
    \ i = 0;\n    while i < value.len() {\n        if digits[i] != '.' {\n       \
    \     digits = &digits[i..];\n            break;\n        }\n        i += 1;\n\
    \    }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let mut i =\
    \ 0;\n    while i < value.len() {\n        if digits[i] != '.' {\n           \
    \ digits = &digits[i..];\n            break;\n        }\n        i += 1;\n   \
    \ }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let mut i = 0;\n\
    \    while i < value.len() {\n        if digits[i] != '.' {\n            digits\
    \ = &digits[i..];\n            break;\n        }\n        i += 1;\n    }\n   \
    \ let mut digits = digits.chars().nth(1).unwrap();\n    let mut i = 0;\n    while\
    \ i < value.len() {\n        if digits[i] != '.' {\n            digits = &digits[i..];\n\
    \            break;\n        }\n        i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut i = 0;\n    while i < value.len(\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpuvk1o5qx.rs:101:1\n    |\n\
    101 | }\n    | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  \
    \ --> /tmp/tmpuvk1o5qx.rs:100:24\n    |\n14  | fn closest_integer(value: String)\
    \ -> isize {\n    |                                            - closing delimiter\
    \ possibly meant for this\n...\n100 |     while i < value.len(\n    |        \
    \                ^ unclosed delimiter\n101 | }\n    | ^ mismatched closing delimiter\n\
    \nerror[E0425]: cannot find value `left` in this scope\n   --> /tmp/tmpuvk1o5qx.rs:105:17\n\
    \    |\n105 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpuvk1o5qx.rs:105:25\n    |\n105 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpuvk1o5qx.rs:106:17\n\
    \    |\n106 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpuvk1o5qx.rs:106:25\n    |\n106 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpuvk1o5qx.rs:107:17\n\
    \    |\n107 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpuvk1o5qx.rs:107:25\n    |\n107 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpuvk1o5qx.rs:108:17\n\
    \    |\n108 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpuvk1o5qx.rs:108:25\n    |\n108 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpuvk1o5qx.rs:"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n    let mut exponent = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut result = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut exponent = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut exponent = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut exponent = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut exponent = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut exponent = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut exponent = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut exponent = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut exponent = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut exponent = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut exponent = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut exponent = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut exponent = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut exponent = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut exponent = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut exponent = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9').count();\n    let mut exponent = value.chars().take_while(|c|\
    \ c >= '0' && c <= \n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `)`\n  --> /tmp/tmp1qg8oww5.rs:35:1\n\
    \   |\n35 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmp1qg8oww5.rs:34:48\n   |\n14 | fn closest_integer(value: String)\
    \ -> isize {\n   |                                            - closing delimiter\
    \ possibly meant for this\n...\n34 |     let mut exponent = value.chars().take_while(|c|\
    \ c >= '0' && c <= \n   |                                                ^ unclosed\
    \ delimiter\n35 | }\n   | ^ mismatched closing delimiter\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp1qg8oww5.rs:39:17\n   |\n39 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp1qg8oww5.rs:39:25\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp1qg8oww5.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp1qg8oww5.rs:40:25\n   |\n40 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp1qg8oww5.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp1qg8oww5.rs:41:25\n   |\n41 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp1qg8oww5.rs:42:17\n  \
    \ |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp1qg8oww5.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scop"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut min_diff = 0;\n    while i < digits.len() &&\
    \ j < digits.len() {\n        let mut diff = digits[j] - digits[i];\n        if\
    \ diff < min_diff {\n            min_diff = diff;\n        }\n        i += 1;\n\
    \        j += 1;\n    }\n    if min_diff == 0 {\n        0\n    } else {\n   \
    \     let mut i = 0;\n        let mut j = 0;\n        while i < digits.len() &&\
    \ j < digits.len() {\n            let mut diff = digits[j] - digits[i];\n    \
    \        if diff == 0 {\n                i += 1;\n                j += 1;\n  \
    \          } else {\n                let mut min_diff = diff;\n              \
    \  let mut min_i = i;\n                let mut min_j = j;\n                while\
    \ i < digits.len() && j < digits.len() {\n                    let mut diff = digits[j]\
    \ - digits[i];\n                    if diff < min_diff {\n                   \
    \     min_diff = diff;\n                        min_i = i;\n                 \
    \       min_j = j;\n                    }\n                    i += 1;\n     \
    \               j += 1;\n                }\n                if min_diff == 0 {\n\
    \                    min_i\n                } else {\n                    min_i\
    \ - min_j\n                }\n            }\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpn8u8sbqp.rs:65:17\n\
    \   |\n65 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpn8u8sbqp.rs:65:25\n   |\n65 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpn8u8sbqp.rs:66:17\n   |\n66 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpn8u8sbqp.rs:66:25\n\
    \   |\n66 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpn8u8sbqp.rs:67:17\n   |\n67 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpn8u8sbqp.rs:67:25\n   |\n67 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpn8u8sbqp.rs:68:17\n   |\n68 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpn8u8sbqp.rs:68:25\n   |\n68 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpn8u8sbqp.rs:69:17\n  \
    \ |\n69 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpn8u8sbqp.rs:69:25\n   |\n69 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0369]: cannot\
    \ subtract `char` from `char`\n  --> /tmp/tmpn8u8sbqp.rs:22:34\n   |\n22 |   \
    \      let mut diff = digits[j] - digits[i];\n   |                        ---------\
    \ ^ --------- char\n   |            "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut v = value.to_string();\n    let mut digits = v.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_digit() {\n            c.to_digit(10).unwrap()\n    \
    \    } else {\n            c.to_digit(16).unwrap()\n        }\n    }).collect::<Vec<_>>();\n\
    \    let mut result = digits[0];\n    let mut last_digit = digits[0];\n    for\
    \ &d in &digits[1..] {\n        if d != last_digit {\n            last_digit =\
    \ d;\n            result += d;\n        }\n    }\n    result.parse().unwrap()\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpf95p4ahq.rs:36:17\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpf95p4ahq.rs:36:25\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpf95p4ahq.rs:37:17\n   |\n37 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpf95p4ahq.rs:37:25\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpf95p4ahq.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpf95p4ahq.rs:38:25\n   |\n38 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpf95p4ahq.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpf95p4ahq.rs:39:25\n   |\n39 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpf95p4ahq.rs:40:17\n  \
    \ |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpf95p4ahq.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpf95p4ahq.rs:17:14\n\
    \    |\n17  |         if c.is_digit() {\n    |              ^^^^^^^^- supplied\
    \ 0 arguments\n    |       "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut exponent\
    \ = 0;\n    let mut i = 0;\n    while i < digits.len() {\n        if digits[i]\
    \ < '0' {\n            digits[i] = '0';\n        }\n        i += 1;\n    }\n \
    \   let mut exponent = 0;\n    let mut i = 0;\n    while i < digits.len() {\n\
    \        if digits[i] < '0' {\n            digits[i] = '0';\n        }\n     \
    \   i += 1;\n    }\n    let mut exponent = 0;\n    let mut i = 0;\n    while i\
    \ < digits.len() {\n        if digits[i] < '0' {\n            digits[i] = '0';\n\
    \        }\n        i += 1;\n    }\n    let mut exponent = 0;\n    let mut i =\
    \ 0;\n    while i < digits.len() {\n        if digits[i] < '0' {\n           \
    \ digits[i] = '0';\n        }\n        i += 1;\n    }\n    let mut exponent =\
    \ 0;\n    let mut i = 0;\n    while i < digits.len() {\n        if digits[i] <\
    \ '0' {\n            digits[i] = '0';\n        }\n        i += 1;\n    }\n   \
    \ let mut exponent = 0;\n    let mut i = 0;\n    while i < digits.len() {\n  \
    \      if digits[i] < '0' {\n            digits[i] = '0';\n        }\n       \
    \ i += 1;\n    }\n    let mut exponent = 0;\n    let mut i = 0;\n    while i <\
    \ digits.len() {\n        if digits[i] < '0' {\n            digits[i] = '0';\n\
    \        }\n        i += 1;\n    }\n    let mut exponent = 0;\n    let mut i =\
    \ 0;\n    while i < digits.len() {\n        if digits[i] < '0' {\n           \
    \ digits[i] = '0';\n        }\n        i += 1;\n    }\n    let mut exponent =\
    \ 0;\n    let mut i = 0;\n    while i < digits.len() {\n        if digits[i] <\
    \ '0' {\n            digits[i] = '0';\n        }\n        i += 1;\n    }\n   \
    \ let mut exponent = 0;\n    let mut i = 0;\n    while i < digits.len() {\n  \
    \      if digits[i] < '0' {\n            digits[i] = '0';\n        }\n       \
    \ i += 1;\n    }\n    let mut exponent = 0;\n    let mut i = 0;\n    while i <\
    \ digits.len() {\n        if digits[i] < '0' {\n            digits[i] = '0';\n\
    \        }\n        i += 1;\n    }\n    let mut exponent = 0;\n    let mut i =\
    \ 0;\n    while i < digits.len() {\n        if digits[i] < '0' {\n           \
    \ digits[i] = '0';\n        }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp9ge2t4xs.rs:121:3\n\
    \    |\n14  | fn closest_integer(value: String) -> isize {\n    |            \
    \                                - unclosed delimiter\n...\n108 |     while i\
    \ < digits.len() {\n    |                            - this delimiter might not\
    \ be properly closed...\n...\n112 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n121 | }\n    |   ^\n\nerror[E0425]: cannot find\
    \ value `left` in this scope\n   --> /tmp/tmp9ge2t4xs.rs:116:17\n    |\n116 |\
    \     assert_eq!({left}, {right});\n    |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n   --> /tmp/tmp9ge2t4xs.rs:116:25\n\
    \    |\n116 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmp9ge2t4xs.rs:117:17\n    |\n117 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmp9ge2t4xs.rs:117:25\n\
    \    |\n117 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmp9ge2t4xs.rs:118:17\n    |\n118 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmp9ge2t4xs.rs:118:25\n\
    \    |\n118 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmp9ge2t4xs.rs:119:17\n    |\n119 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmp9ge2t4xs.rs:119:25\n\
    \    |\n119 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmp9ge2t4xs.rs:120:17\n    |\n120 |     assert"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut v = value.parse::<isize>().unwrap();\n    if v < 0 {\n        v = -v;\n\
    \    }\n    if v == 0 {\n        return 0;\n    }\n    let mut closest_integer\
    \ = v;\n    let mut prev_closest_integer = v;\n    while prev_closest_integer\
    \ != 0 {\n        prev_closest_integer = closest_integer;\n        closest_integer\
    \ = closest_integer / 10;\n    }\n    closest_integer\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp5ac6zwc3.rs:33:17\n\
    \   |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5ac6zwc3.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp5ac6zwc3.rs:34:17\n   |\n34 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp5ac6zwc3.rs:34:25\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp5ac6zwc3.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp5ac6zwc3.rs:35:25\n   |\n35 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp5ac6zwc3.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp5ac6zwc3.rs:36:25\n   |\n36 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp5ac6zwc3.rs:37:17\n  \
    \ |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5ac6zwc3.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 10 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(0).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if digits[i] != '.' {\n            digits =\
    \ &digits[1..];\n            result = &result[1..];\n        }\n        let mut\
    \ digit = digits[i] - '0';\n        if digit < 0 {\n            digit *= -1;\n\
    \        }\n        let mut result = digit;\n        if result > 0 {\n       \
    \     i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpby3ter5i.rs:38:17\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpby3ter5i.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpby3ter5i.rs:39:17\n   |\n39 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpby3ter5i.rs:39:25\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpby3ter5i.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpby3ter5i.rs:40:25\n   |\n40 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpby3ter5i.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpby3ter5i.rs:41:25\n   |\n41 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpby3ter5i.rs:42:17\n  \
    \ |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpby3ter5i.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0608]: cannot\
    \ index into a value of type `char`\n  --> /tmp/tmpby3ter5i.rs:20:12\n   |\n20\
    \ |         if digits[i] != '.' {\n   |            ^^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `char`"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(0).unwrap();\n    let mut i = 0;\n   \
    \ while i < digits.len() && digits.chars().nth(i).unwrap() == result {\n     \
    \   i += 1;\n    }\n    if i == digits.len() {\n        return value.chars().nth(0).unwrap();\n\
    \    }\n    if i == 0 {\n        return value.chars().nth(1).unwrap();\n    }\n\
    \    let mut j = i;\n    while j > 0 && digits.chars().nth(j).unwrap() == result\
    \ {\n        j -= 1;\n    }\n    if j == 0 {\n        return value.chars().nth(1).unwrap();\n\
    \    }\n    let mut k = j;\n    while k > 0 && digits.chars().nth(k).unwrap()\
    \ == result {\n        k -= 1;\n    }\n    if k == 0 {\n        return value.chars().nth(1).unwrap();\n\
    \    }\n    let mut m = k;\n    while m > 0 && digits.chars().nth(m).unwrap()\
    \ == result {\n        m -= 1;\n    }\n    if m == 0 {\n        return value.chars().nth(1).unwrap();\n\
    \    }\n    let mut n = m;\n    while n > 0 && digits.chars().nth(n).unwrap()\
    \ == result {\n        n -= 1;\n    }\n    if n == 0 {\n        return value.chars().nth(1).unwrap();\n\
    \    }\n    let mut d = n;\n    while d > 0 && digits.chars().nth(d).unwrap()\
    \ == result {\n        d -= 1;\n    }\n    if d == 0 {\n        return value.chars().nth(1).unwrap();\n\
    \    }\n    let mut f = d;\n    while f > 0 && digits.chars().nth(f).unwrap()\
    \ == result {\n        f -= 1;\n    }\n    if f == 0 {\n        return value.chars().nth(1).unwrap();\n\
    \    }\n    let mut g = f;\n    while g > 0 && digits.chars().nth(g).unwrap()\
    \ == result {\n        g -= 1;\n    }\n    if g == 0 {\n        return value.chars().nth(1).unwrap();\n\
    \    }\n    let mut h = g;\n    while h > 0 && digits.chars().nth(h).unwrap()\
    \ == result {\n        h -= 1;\n    }\n    if h == 0 {\n        return value.chars().nth(1).unwrap();\n\
    \    }\n    let mut i = h;\n    while i > 0 && digits.chars().nth(i).unwrap()\
    \ == result {\n        i -= 1;\n    }\n    if i == 0 {\n        return value.chars().nth(1).unwrap();\n\
    \    }\n    let mut j = i;\n    while j > 0 && digits.chars().nth(j).unwrap\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmp6rev_kik.rs:93:1\n   |\n\
    93 | }\n   | ^ expected `{`\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n  --> /tmp/tmp6rev_kik.rs:97:17\n   |\n97 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp6rev_kik.rs:97:25\n   |\n97 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp6rev_kik.rs:98:17\n   |\n98 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp6rev_kik.rs:98:25\n   |\n98 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp6rev_kik.rs:99:17\n  \
    \ |\n99 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6rev_kik.rs:99:25\n   |\n99 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n   --> /tmp/tmp6rev_kik.rs:100:17\n    |\n\
    100 |     assert_eq!({left}, {right});\n    |                 ^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `right` in this scope\n   -->\
    \ /tmp/tmp6rev_kik.rs:100:25\n    |\n100 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp6rev_kik.rs:101:17\n\
    \    |\n101 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp6rev_kik.rs:101:25\n    |\n101 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `len` found for type `char` in the current scope\n  --> /tmp/tmp"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut exponent = 0;\n\
    \    let mut exponents = vec![];\n    while exponent < 10 {\n        exponents.push(exponent);\n\
    \        exponent = exponent + 1;\n    }\n    let mut exponents = exponents.into_iter().map(|&x|\
    \ x.to_string()).collect();\n    let mut exponent = exponents.iter().max().unwrap();\n\
    \    let mut exponent = exponents.iter().max().unwrap();\n    let mut exponent\
    \ = exponents.iter().max().unwrap();\n    while exponent < 10 {\n        exponent\
    \ = exponent + 1;\n    }\n    let mut exponent = exponents.iter().max().unwrap();\n\
    \    let mut exponent = exponents.iter().max().unwrap();\n    let mut exponent\
    \ = exponents.iter().max().unwrap();\n    while exponent < 10 {\n        exponent\
    \ = exponent + 1;\n    }\n    let mut exponent = exponents.iter().max().unwrap();\n\
    \    let mut exponent = exponents.iter().max().unwrap();\n    let mut exponent\
    \ = exponents.iter().max().unwrap();\n    while exponent < 10 {\n        exponent\
    \ = exponent + 1;\n    }\n    let mut exponent = exponents.iter().max().unwrap();\n\
    \    let mut exponent = exponents.iter().max().unwrap();\n    let mut exponent\
    \ = exponents.iter().max().unwrap();\n    while exponent < 10 {\n        exponent\
    \ = exponent + 1;\n    }\n    let mut exponent = exponents.iter().max().unwrap();\n\
    \    let mut exponent = exponents.iter().max().unwrap();\n    let mut exponent\
    \ = exponents.iter().max().unwrap();\n    while exponent < 10 {\n        exponent\
    \ = exponent + 1;\n    }\n    let mut exponent = exponents.iter().max().unwrap();\n\
    \    let mut exponent = exponents.iter().max().unwrap();\n    let mut exponent\
    \ = exponents.iter().max().unwrap();\n    while exponent < 10 {\n        exponent\
    \ = exponent + 1;\n    }\n    let mut exponent = exponents.iter().max().unwrap();\n\
    \    let mut exponent = exponents.iter().max().unwrap();\n    let mut exponent\
    \ = exponents.iter().max().unwrap();\n    while exponent < 10 {\n        exponent\
    \ = exponent + 1;\n    }\n    let mut exponent = exponents.iter().max().unwrap();\n\
    \    let mut exponent = exponent\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpc2uhzoz5.rs:68:32\n   |\n\
    68 |     let mut exponent = exponent\n   |                                ^ help:\
    \ add `;` here\n69 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `left` in this scope\n  --> /tmp/tmpc2uhzoz5.rs:73:17\n   |\n73 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpc2uhzoz5.rs:73:25\n \
    \  |\n73 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpc2uhzoz5.rs:74:17\n   |\n74 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpc2uhzoz5.rs:74:25\n   |\n74 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpc2uhzoz5.rs:75:17\n   |\n75 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpc2uhzoz5.rs:75:25\n   |\n75 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpc2uhzoz5.rs:76:17\n  \
    \ |\n76 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpc2uhzoz5.rs:76:25\n   |\n76 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpc2uhzoz5.rs:77:17\n   |\n77 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpc2uhzoz5.rs:77:25\n\
    \   |\n77 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0308]: "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_digit(16).unwrap()\n        }\n    });\n   \
    \ let mut digits = digits.collect::<Vec<_>>();\n    let mut result = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_digit(16).unwrap()\n        }\n    });\n   \
    \ let mut result = result.collect::<Vec<_>>();\n    let mut min: isize = 0;\n\
    \    let mut max: isize = 0;\n    let mut min_digit = result.iter().min().unwrap();\n\
    \    let mut max_digit = result.iter().max().unwrap();\n    let mut min_digit\
    \ = min_digit.to_digit(10);\n    let mut max_digit = max_digit.to_digit(10);\n\
    \    while min_digit != max_digit {\n        if min_digit < max_digit {\n    \
    \        if min_digit < digits[min] {\n                min = min;\n          \
    \  } else {\n                max = max;\n            }\n        } else {\n   \
    \         if max_digit < digits[max] {\n                max = max;\n         \
    \   } else {\n                min = min;\n            }\n        }\n        min_digit\
    \ = result.iter().min().unwrap();\n        max_digit = result.iter().max().unwrap();\n\
    \        min_digit = min_digit.to_digit(10);\n        max_digit = max_digit.to_digit(10);\n\
    \    }\n    min + min\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpn8dt8ix4.rs:62:17\n\
    \   |\n62 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpn8dt8ix4.rs:62:25\n   |\n62 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpn8dt8ix4.rs:63:17\n   |\n63 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpn8dt8ix4.rs:63:25\n\
    \   |\n63 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpn8dt8ix4.rs:64:17\n   |\n64 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpn8dt8ix4.rs:64:25\n   |\n64 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpn8dt8ix4.rs:65:17\n   |\n65 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpn8dt8ix4.rs:65:25\n   |\n65 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpn8dt8ix4.rs:66:17\n  \
    \ |\n66 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpn8dt8ix4.rs:66:25\n   |\n66 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `to_digit` found for reference `&u32` in the current scope\n  --> /tmp/tmpn8dt8ix4.rs:36:35\n\
    \   |\n36 |     let mut min_digit = min_digit.to_digit(10);\n   |            \
    \             "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut exponent = 0;\n\
    \    let mut digit = digits.chars().nth(1).unwrap();\n    while exponent < 10\
    \ {\n        if digit == 0 {\n            break;\n        }\n        result *=\
    \ 10;\n        result += digit;\n        exponent++;\n        digit = digits.chars().nth(1).unwrap();\n\
    \    }\n    result as isize\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmp0eplh3hb.rs:26:18\n\
    \   |\n26 |         exponent++;\n   |                  ^ expected expression\n\
    \nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp0eplh3hb.rs:34:17\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp0eplh3hb.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp0eplh3hb.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp0eplh3hb.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp0eplh3hb.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp0eplh3hb.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp0eplh3hb.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp0eplh3hb.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp0eplh3hb.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp0eplh3hb.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(0).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if i == 0 {\n            digits = value.chars().nth(1).unwrap();\n\
    \            result = value.chars().nth(0).unwrap();\n        }\n        let mut\
    \ digit = digits.chars().nth(1).unwrap();\n        if digit == result {\n    \
    \        i += 1;\n            continue;\n        }\n        if digit < result\
    \ {\n            digits = value.chars().nth(1).unwrap();\n            result =\
    \ value.chars().nth(0).unwrap();\n        } else {\n            digits = value.chars().nth(2).unwrap();\n\
    \            result = value.chars().nth(0).unwrap();\n        }\n        i +=\
    \ 1;\n    }\n    result.parse().unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp4pfb0yuw.rs:43:17\n\
    \   |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp4pfb0yuw.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp4pfb0yuw.rs:44:17\n   |\n44 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp4pfb0yuw.rs:44:25\n\
    \   |\n44 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp4pfb0yuw.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp4pfb0yuw.rs:45:25\n   |\n45 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp4pfb0yuw.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp4pfb0yuw.rs:46:25\n   |\n46 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp4pfb0yuw.rs:47:17\n  \
    \ |\n47 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp4pfb0yuw.rs:47:25\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmp4pfb0yuw.rs:24:32\n\
    \   |\n24 |         let mut digit = digits.chars().nth(1).unwrap();\n   |    \
    \                     "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_digit() {\n            c.to_digit(10).unwrap()\n    \
    \    } else {\n            0\n        }\n    });\n    let mut result = digits[0];\n\
    \    let mut i = 0;\n    while i < digits.len() {\n        if digits[i] > result\
    \ {\n            result = digits[i];\n        }\n        i += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp0vy_8n_2.rs:36:17\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp0vy_8n_2.rs:36:25\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp0vy_8n_2.rs:37:17\n   |\n37 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp0vy_8n_2.rs:37:25\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp0vy_8n_2.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp0vy_8n_2.rs:38:25\n   |\n38 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp0vy_8n_2.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp0vy_8n_2.rs:39:25\n   |\n39 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp0vy_8n_2.rs:40:17\n  \
    \ |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp0vy_8n_2.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp0vy_8n_2.rs:17:14\n\
    \    |\n17  |         if c.is_digit() {\n    |              ^^^^^^^^- supplied\
    \ 0 arguments\n    |       "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            0\n        }\n    });\n    let mut smallest_digit\
    \ = digits[0];\n    let mut closest_digit = smallest_digit;\n    let mut closest_distance\
    \ = std::cmp::max(1, digits[1] - smallest_digit);\n    for &(digit, distance)\
    \ in &digits[2..] {\n        let distance = closest_distance - distance;\n   \
    \     if distance < 0 {\n            closest_distance -= 1;\n            closest_digit\
    \ = digit;\n        } else {\n            closest_distance += 1;\n           \
    \ closest_digit = digit;\n        }\n    }\n    closest_digit\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpdsoxsnkv.rs:41:17\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpdsoxsnkv.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpdsoxsnkv.rs:42:17\n   |\n42 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpdsoxsnkv.rs:42:25\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpdsoxsnkv.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpdsoxsnkv.rs:43:25\n   |\n43 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpdsoxsnkv.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpdsoxsnkv.rs:44:25\n   |\n44 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpdsoxsnkv.rs:45:17\n  \
    \ |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpdsoxsnkv.rs:45:25\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0608]: cannot\
    \ index into a value of type `Map<Enumerate<Chars<'_>>, [closure@/tmp/tmpdsoxsnkv.rs:16:52:\
    \ 22:6]>`\n  --> /tmp/tmpdsoxsnkv.rs:23:30\n   |\n23 |     let mut smallest_digit\
    \ = digits[0];\n   |   "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut k = 0;\n    while i < digits.len() && j < digits.len()\
    \ {\n        if digits[i] > digits[j] {\n            swap(&mut digits, i, k);\n\
    \            swap(&mut digits, j, k);\n            i += 1;\n            j += 1;\n\
    \            k += 1;\n        } else if digits[i] < digits[j] {\n            swap(&mut\
    \ digits, i, k);\n            i += 1;\n        } else {\n            swap(&mut\
    \ digits, j, k);\n            j += 1;\n        }\n    }\n    digits.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp_dayohlv.rs:23:13\n\
    \   |\n23 |             swap(&mut digits, i, k);\n   |             ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot\
    \ find function `swap` in this scope\n  --> /tmp/tmp_dayohlv.rs:24:13\n   |\n\
    24 |             swap(&mut digits, j, k);\n   |             ^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use\
    \ std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot\
    \ find function `swap` in this scope\n  --> /tmp/tmp_dayohlv.rs:29:13\n   |\n\
    29 |             swap(&mut digits, i, k);\n   |             ^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use\
    \ std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot\
    \ find function `swap` in this scope\n  --> /tmp/tmp_dayohlv.rs:32:13\n   |\n\
    32 |             swap(&mut digits, j, k);\n   |             ^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use\
    \ std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_dayohlv.rs:41:17\n   |\n41 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_dayohlv.rs:41:25\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_dayohlv.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_dayohlv.rs:42:25\n   |\n42 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_dayohlv.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut index =\
    \ 0;\n    let mut digit = digits.iter().nth(index).unwrap();\n    let mut remainder\
    \ = 0;\n    while digit != 0 {\n        remainder = digit % 10;\n        digit\
    \ = digit / 10;\n        digits[index] = remainder;\n        index += 1;\n   \
    \ }\n    let mut index = 0;\n    let mut digit = digits.iter().nth(index).unwrap();\n\
    \    let mut remainder = 0;\n    while digit != 0 {\n        remainder = digit\
    \ % 10;\n        digit = digit / 10;\n        digits[index] = remainder;\n   \
    \     index += 1;\n    }\n    let mut index = 0;\n    let mut digit = digits.iter().nth(index).unwrap();\n\
    \    let mut remainder = 0;\n    while digit != 0 {\n        remainder = digit\
    \ % 10;\n        digit = digit / 10;\n        digits[index] = remainder;\n   \
    \     index += 1;\n    }\n    let mut index = 0;\n    let mut digit = digits.iter().nth(index).unwrap();\n\
    \    let mut remainder = 0;\n    while digit != 0 {\n        remainder = digit\
    \ % 10;\n        digit = digit / 10;\n        digits[index] = remainder;\n   \
    \     index += 1;\n    }\n    let mut index = 0;\n    let mut digit = digits.iter().nth(index).unwrap();\n\
    \    let mut remainder = 0;\n    while digit != 0 {\n        remainder = digit\
    \ % 10;\n        digit = digit / 10;\n        digits[index] = remainder;\n   \
    \     index += 1;\n    }\n    let mut index = 0;\n    let mut digit = digits.iter().nth(index).unwrap();\n\
    \    let mut remainder = 0;\n    while digit != 0 {\n        remainder = digit\
    \ % 10;\n        digit = digit / 10;\n        digits[index] = remainder;\n   \
    \     index += 1;\n    }\n    let mut index = 0;\n    let mut digit = digits.iter().nth(index).unwrap();\n\
    \    let mut remainder = 0;\n    while digit != 0 {\n        remainder = digit\
    \ % 10;\n        digit = digit / 10;\n        digits[index] = remainder;\n   \
    \     index += 1;\n    }\n    let mut index = 0;\n    let mut digit = digits.iter().nth(index).unwrap();\n\
    \    let mut remainder = 0;\n    while digit != 0 {\n        remainder = digit\
    \ % 10;\n        digit = digit / 10;\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp502dtbot.rs:96:3\n\
    \   |\n14 | fn closest_integer(value: String) -> isize {\n   |               \
    \                             - unclosed delimiter\n...\n84 |     while digit\
    \ != 0 {\n   |                      - this delimiter might not be properly closed...\n\
    ...\n87 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    96 | }\n   |   ^\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp502dtbot.rs:91:17\n   |\n91 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp502dtbot.rs:91:25\n   |\n91 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp502dtbot.rs:92:17\n  \
    \ |\n92 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp502dtbot.rs:92:25\n   |\n92 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp502dtbot.rs:93:17\n   |\n93 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp502dtbot.rs:93:25\n\
    \   |\n93 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp502dtbot.rs:94:17\n   |\n94 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp502dtbot.rs:94:25\n   |\n94 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp502dtbot.rs:95:17\n   |\n95 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(0).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        let mut digit = digits.chars().nth(i).unwrap();\n\
    \        if digit == '.' {\n            digit = digits.chars().nth(i - 1).unwrap();\n\
    \        }\n        let mut digit = digit.chars().nth(1).unwrap();\n        if\
    \ digit == '.' {\n            digit = digits.chars().nth(i - 1).unwrap();\n  \
    \      }\n        if digit == 'e' || digit == 'E' {\n            digit = digits.chars().nth(i\
    \ - 1).unwrap();\n        }\n        if digit == '+' || digit == '-' {\n     \
    \       digit = digits.chars().nth(i - 1).unwrap();\n        }\n        if digit\
    \ == '0' {\n            digit = digits.chars().nth(i - 1).unwrap();\n        }\n\
    \        if digit == '.' {\n            digit = digits.chars().nth(i - 1).unwrap();\n\
    \        }\n        if digit == 'e' || digit == 'E' {\n            digit = digits.chars().nth(i\
    \ - 1).unwrap();\n        }\n        if digit == '+' || digit == '-' {\n     \
    \       digit = digits.chars().nth(i - 1).unwrap();\n        }\n        if digit\
    \ == '0' {\n            digit = digits.chars().nth(i - 1).unwrap();\n        }\n\
    \        if digit == '.' {\n            digit = digits.chars().nth(i - 1).unwrap();\n\
    \        }\n        if digit == 'e' || digit == 'E' {\n            digit = digits.chars().nth(i\
    \ - 1).unwrap();\n        }\n        if digit == '+' || digit == '-' {\n     \
    \       digit = digits.chars().nth(i - 1).unwrap();\n        }\n        if digit\
    \ == '0' {\n            digit = digits.chars().nth(i - 1).unwrap();\n        }\n\
    \        if digit == '.' {\n            digit = digits.chars().nth(i - 1).unwrap();\n\
    \        }\n        if digit == 'e' || digit == 'E' {\n            digit = digits.chars().nth(i\
    \ - 1).unwrap();\n        }\n        if digit == '+' || digit == '-' {\n     \
    \       digit = digits.chars().nth(i - 1).unwrap();\n        }\n        if digit\
    \ == '0' {\n            digit = digits.chars().nth(i - 1).unwrap();\n        }\n\
    \        if digit == '.' {\n            digit = digits.chars().nth(i - 1).unwrap();\n\
    \        }\n        if digit == 'e' || digit == 'E' {\n            digit = \n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpbspyy6ig.rs:87:3\n\
    \   |\n14 | fn closest_integer(value: String) -> isize {\n   |               \
    \                             - unclosed delimiter\n...\n19 |     while i < value.len()\
    \ {\n   |                           - unclosed delimiter\n...\n76 |         if\
    \ digit == 'e' || digit == 'E' {\n   |                                       \
    \  - this delimiter might not be properly closed...\n77 |             digit =\
    \ \n78 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    87 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpbspyy6ig.rs:78:1\n\
    \   |\n78 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpbspyy6ig.rs:82:17\n   |\n82 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpbspyy6ig.rs:82:25\n \
    \  |\n82 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpbspyy6ig.rs:83:17\n   |\n83 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpbspyy6ig.rs:83:25\n   |\n83 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpbspyy6ig.rs:84:17\n   |\n84 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpbspyy6ig.rs:84:25\n   |\n84 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpbspyy6ig.rs:85:17\n  \
    \ |\n85 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpbspyy6ig.rs:85:25\n   |\n85 |     ass"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().filter(|&(_,\
    \ c)| c.is_numeric()).map(|(_, c)| c.to_digit(10)).collect::<Vec<_>>();\n    let\
    \ mut result = value.chars().enumerate().filter(|&(_, c)| c.is_numeric()).map(|(_,\
    \ c)| c.to_digit(10)).collect::<Vec<_>>();\n    let mut min: isize = 0;\n    let\
    \ mut max: isize = 0;\n    let mut min_digits = result.len();\n    let mut max_digits\
    \ = result.len();\n    let mut min_digits_index = 0;\n    let mut max_digits_index\
    \ = 0;\n    let mut min_digits_index2 = 0;\n    let mut max_digits_index2 = 0;\n\
    \    let mut min_digits_index3 = 0;\n    let mut max_digits_index3 = 0;\n    let\
    \ mut min_digits_index4 = 0;\n    let mut max_digits_index4 = 0;\n    let mut\
    \ min_digits_index5 = 0;\n    let mut max_digits_index5 = 0;\n    let mut min_digits_index6\
    \ = 0;\n    let mut max_digits_index6 = 0;\n    let mut min_digits_index7 = 0;\n\
    \    let mut max_digits_index7 = 0;\n    let mut min_digits_index8 = 0;\n    let\
    \ mut max_digits_index8 = 0;\n    let mut min_digits_index9 = 0;\n    let mut\
    \ max_digits_index9 = 0;\n    let mut min_digits_index10 = 0;\n    let mut max_digits_index10\
    \ = 0;\n    let mut min_digits_index11 = 0;\n    let mut max_digits_index11 =\
    \ 0;\n    let mut min_digits_index12 = 0;\n    let mut max_digits_index12 = 0;\n\
    \    let mut min_digits_index13 = 0;\n    let mut max_digits_index13 = 0;\n  \
    \  let mut min_digits_index14 = 0;\n    let mut max_digits_index14 = 0;\n    let\
    \ mut min_digits_index15 = 0;\n    let mut max_digits_index15 = 0;\n    let mut\
    \ min_digits_index16 = 0;\n    let mut max_digits_index16 = 0;\n    let mut min_digits_index17\
    \ = 0;\n    let mut max_digits_index17 = 0;\n    let mut min_digits_index18 =\
    \ 0;\n    let mut max_digits_index18 = 0;\n    let mut min_digits_index19 = 0;\n\
    \    let mut max_digits_index19 = 0;\n    let mut min_digits_index20 = 0;\n  \
    \  let mut max_digit\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpceklwgjz.rs:61:22\n   |\n\
    61 |     let mut max_digit\n   |                      ^ help: add `;` here\n62\
    \ | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n  --> /tmp/tmpceklwgjz.rs:66:17\n   |\n66 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpceklwgjz.rs:66:25\n   |\n66 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpceklwgjz.rs:67:17\n   |\n67 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpceklwgjz.rs:67:25\n   |\n67 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpceklwgjz.rs:68:17\n  \
    \ |\n68 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpceklwgjz.rs:68:25\n   |\n68 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpceklwgjz.rs:69:17\n   |\n69 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpceklwgjz.rs:69:25\n\
    \   |\n69 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpceklwgjz.rs:70:17\n   |\n70 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpceklwgjz.rs:70:25\n   |\n70 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  -"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n    let mut result = value.parse::<isize>().unwrap();\n\
    \    let mut remainder = 0;\n    let mut last_digit = 0;\n    while result > 0\
    \ {\n        let mut digit = digits.next().unwrap();\n        if digit < last_digit\
    \ {\n            result -= digit;\n        } else {\n            result -= digit\
    \ - last_digit;\n            remainder += digit - last_digit;\n            last_digit\
    \ = digit;\n        }\n    }\n    remainder += last_digit;\n    result\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpqd1veokp.rs:36:17\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpqd1veokp.rs:36:25\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpqd1veokp.rs:37:17\n   |\n37 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpqd1veokp.rs:37:25\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpqd1veokp.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpqd1veokp.rs:38:25\n   |\n38 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpqd1veokp.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpqd1veokp.rs:39:25\n   |\n39 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpqd1veokp.rs:40:17\n  \
    \ |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpqd1veokp.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqd1veokp.rs:16:56\n   |\n16 |     let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n   |                                               \
    \         ^^"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_digit(16).unwrap()\n        }\n    });\n   \
    \ let mut min_value = digits[0];\n    let mut max_value = digits[0];\n    for\
    \ i in 1..digits.len() {\n        if digits[i] < min_value {\n            min_value\
    \ = digits[i];\n        }\n        if digits[i] > max_value {\n            max_value\
    \ = digits[i];\n        }\n    }\n    let mut min_value = min_value.to_digit(10).unwrap();\n\
    \    let mut max_value = max_value.to_digit(10).unwrap();\n    let mut min_value\
    \ = min_value.saturating_add((max_value - min_value) / 2);\n    let mut max_value\
    \ = max_value.saturating_add((max_value - min_value) / 2);\n    min_value.saturating_sub((max_value\
    \ - min_value) / 2)\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmptbu2fma3.rs:42:17\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptbu2fma3.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmptbu2fma3.rs:43:17\n   |\n43 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmptbu2fma3.rs:43:25\n\
    \   |\n43 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmptbu2fma3.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmptbu2fma3.rs:44:25\n   |\n44 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmptbu2fma3.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmptbu2fma3.rs:45:25\n   |\n45 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmptbu2fma3.rs:46:17\n  \
    \ |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptbu2fma3.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0608]: cannot\
    \ index into a value of type `Map<Enumerate<Chars<'_>>, [closure@/tmp/tmptbu2fma3.rs:16:52:\
    \ 22:6]>`\n  --> /tmp/tmptbu2fma3.rs:23:25\n   |\n23 |     let mut min_value =\
    \ digits[0];\n   |        "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(0).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if digits[i] != '.' {\n            digits =\
    \ &digits[1..];\n            result = &result[1..];\n        } else {\n      \
    \      i += 1;\n        }\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut result = result.chars().nth(0).unwrap();\n    let mut i = 0;\n  \
    \  while i < value.len() {\n        if digits[i] != '.' {\n            digits\
    \ = &digits[1..];\n            result = &result[1..];\n        } else {\n    \
    \        i += 1;\n        }\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut result = result.chars().nth(0).unwrap();\n    let mut i = 0;\n  \
    \  while i < value.len() {\n        if digits[i] != '.' {\n            digits\
    \ = &digits[1..];\n            result = &result[1..];\n        } else {\n    \
    \        i += 1;\n        }\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut result = result.chars().nth(0).unwrap();\n    let mut i = 0;\n  \
    \  while i < value.len() {\n        if digits[i] != '.' {\n            digits\
    \ = &digits[1..];\n            result = &result[1..];\n        } else {\n    \
    \        i += 1;\n        }\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut result = result.chars().nth(0).unwrap();\n    let mut i = 0;\n  \
    \  while i < value.len() {\n        if digits[i] != '.' {\n            digits\
    \ = &digits[1..];\n            result = &result[1..];\n        } else {\n    \
    \        i += 1;\n        }\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut result = result.chars().nth(0).unwrap();\n    let mut i = 0;\n  \
    \  while i < value.len() {\n        if digits[i] != '.' {\n            digits\
    \ = &digits[1..];\n            result = &result[1..];\n        } else {\n    \
    \        i += 1;\n        }\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut result = result.chars().nth(0).unwrap();\n    let mut i = 0;\n  \
    \  while i < value.len() {\n        if digits[i] != '.' {\n            digits\
    \ = &digits[1..];\n            result = &result[1..];\n        } else {\n    \
    \        i += 1;\n        }\n    }\n\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpofupzb0h.rs:98:17\n\
    \   |\n98 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpofupzb0h.rs:98:25\n   |\n98 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpofupzb0h.rs:99:17\n   |\n99 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpofupzb0h.rs:99:25\n\
    \   |\n99 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \   --> /tmp/tmpofupzb0h.rs:100:17\n    |\n100 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpofupzb0h.rs:100:25\n    |\n100 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpofupzb0h.rs:101:17\n    |\n101 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpofupzb0h.rs:101:25\n    |\n101 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpofupzb0h.rs:102:17\n    |\n102 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpofupzb0h.rs:102:25\n    |\n102 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0608]: cannot index into a value of type `char`\n  -->\
    \ /tmp/tmpofupzb0h.rs:20:12\n   |\n20 |         if digits[i] != '.' {\n   |  \
    \          ^^^^^^^^^\n\nerror[E0608]: cannot ind"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut closest_integer = digits[0];\n\
    \    let mut closest_distance = std::cmp::min(digits.len(), 2);\n    for d in\
    \ &digits[1..] {\n        let distance = std::cmp::min(d, closest_integer);\n\
    \        if distance < closest_distance {\n            closest_integer = d;\n\
    \            closest_distance = distance;\n        }\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpfd1zco0f.rs:31:17\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfd1zco0f.rs:31:25\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpfd1zco0f.rs:32:17\n   |\n32 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpfd1zco0f.rs:32:25\n\
    \   |\n32 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpfd1zco0f.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpfd1zco0f.rs:33:25\n   |\n33 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpfd1zco0f.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpfd1zco0f.rs:34:25\n   |\n34 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpfd1zco0f.rs:35:17\n  \
    \ |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfd1zco0f.rs:35:25\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfd1zco0f.rs:20:41\n   |\n20 |         let distance = std::cmp::min(d,\
    \ closest_integer);\n   |                                         ^^^^^^^^^^^^^^^\n\
    \   |            "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_digit(16).unwrap()\n        }\n    });\n   \
    \ let mut result = value.chars().enumerate().map(|(i, c)| {\n        if c.is_numeric()\
    \ {\n            c.to_digit(10).unwrap()\n        } else {\n            c.to_digit(16).unwrap()\n\
    \        }\n    });\n    let mut min_value = result.iter().min().unwrap();\n \
    \   let mut max_value = result.iter().max().unwrap();\n    let mut min_value =\
    \ min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n    let mut\
    \ min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let mut min_value = min_value.unwrap();\n    let mut max_value = max_value.unwrap();\n\
    \    let \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp6thi5fta.rs:71:1\n  \
    \ |\n71 | }\n   | ^ expected pattern\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmp6thi5fta.rs:75:17\n   |\n75 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp6thi5fta.rs:75:25\n \
    \  |\n75 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp6thi5fta.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp6thi5fta.rs:76:25\n   |\n76 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp6thi5fta.rs:77:17\n   |\n77 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp6thi5fta.rs:77:25\n   |\n77 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp6thi5fta.rs:78:17\n  \
    \ |\n78 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6thi5fta.rs:78:25\n   |\n78 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp6thi5fta.rs:79:17\n   |\n79 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp6thi5fta.rs:79:25\n\
    \   |\n79 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `iter` found for struct\
    \ `Map` in the current scope\n  --> /tmp/tmp6thi5fta.r"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.parse().unwrap();\n    let mut min_value = result.to_f64();\n\
    \    let mut max_value = min_value;\n    let mut min_digits = digits.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut max_digits = min_digits.clone();\n    let mut min_value = result.to_f64();\n\
    \    let mut max_value = min_value;\n    let mut min_digits = digits.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut max_digits = min_digits.clone();\n    let mut min_value = result.to_f64();\n\
    \    let mut max_value = min_value;\n    let mut min_digits = digits.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut max_digits = min_digits.clone();\n    let mut min_value = result.to_f64();\n\
    \    let mut max_value = min_value;\n    let mut min_digits = digits.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut max_digits = min_digits.clone();\n    let mut min_value = result.to_f64();\n\
    \    let mut max_value = min_value;\n    let mut min_digits = digits.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut max_digits = min_digits.clone();\n    let mut min_value = result.to_f64();\n\
    \    let mut max_value = min_value;\n    let mut min_digits = digits.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut max_digits = min_digits.clone();\n    let mut min_value = result.to_f64();\n\
    \    let mut max_value = min_value;\n    let mut min_digits = digits.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut max_digits = min_digits.clone();\n    let mut min_value = result.to_f64();\n\
    \    let mut max_value = min_value;\n    let mut min_digits = digits.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut max_digits = min_digits.clone();\n    let mut min_value = result.to_f64();\n\
    \    let mut max_value = min_value;\n    let mut min_digits = digits.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut max_digits = min_digits.clone();\n    let mut min_value = result.to_f64();\n\
    \    let mut max_value = min_value;\n    let mut min_digits = digits.iter().cloned().collect::<Vec<_>>();\n\
    \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpydm_hgkh.rs:62:17\n\
    \   |\n62 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpydm_hgkh.rs:62:25\n   |\n62 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpydm_hgkh.rs:63:17\n   |\n63 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpydm_hgkh.rs:63:25\n\
    \   |\n63 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpydm_hgkh.rs:64:17\n   |\n64 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpydm_hgkh.rs:64:25\n   |\n64 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpydm_hgkh.rs:65:17\n   |\n65 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpydm_hgkh.rs:65:25\n   |\n65 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpydm_hgkh.rs:66:17\n  \
    \ |\n66 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpydm_hgkh.rs:66:25\n   |\n66 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0282]: type\
    \ annotations needed\n  --> /tmp/tmpydm_hgkh.rs:18:25\n   |\n17 |     let mut\
    \ result = value.parse().unwrap();\n   |         ---------- consider giving `result`\
    \ a type\n18 |     let mut min_value "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(0).unwrap();\n    let mut exponent = 0;\n\
    \    let mut last_digit = digits.chars().nth(1).unwrap();\n    while last_digit\
    \ != '.' {\n        if last_digit == 'e' {\n            exponent += 1;\n     \
    \       last_digit = digits.chars().nth(1).unwrap();\n        } else {\n     \
    \       exponent += 1;\n            last_digit = digits.chars().nth(1).unwrap();\n\
    \        }\n    }\n    if exponent == 0 {\n        exponent = 1;\n    }\n    let\
    \ mut result = result.chars().nth(0).unwrap();\n    while exponent > 0 {\n   \
    \     if result == '0' {\n            result = '1';\n        } else {\n      \
    \      result = '0';\n        }\n        exponent = exponent - 1;\n    }\n   \
    \ result.parse().unwrap()\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpokcyzhjx.rs:46:17\n\
    \   |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpokcyzhjx.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpokcyzhjx.rs:47:17\n   |\n47 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpokcyzhjx.rs:47:25\n\
    \   |\n47 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpokcyzhjx.rs:48:17\n   |\n48 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpokcyzhjx.rs:48:25\n   |\n48 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpokcyzhjx.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpokcyzhjx.rs:49:25\n   |\n49 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpokcyzhjx.rs:50:17\n  \
    \ |\n50 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpokcyzhjx.rs:50:25\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmpokcyzhjx.rs:19:33\n\
    \   |\n19 |     let mut last_digit = digits.chars().nth(1).unwrap();\n   |   \
    \                     "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(0).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if digits.is_empty() {\n            digits\
    \ = value.chars().nth(1).unwrap();\n            result = value.chars().nth(0).unwrap();\n\
    \            i += 1;\n            continue;\n        }\n        if digits.is_digit()\
    \ {\n            if result < value {\n                result = value;\n      \
    \      }\n            i += 1;\n            continue;\n        }\n        if digits.is_digit(10)\
    \ {\n            if result < value {\n                result = value;\n      \
    \      }\n            i += 1;\n            continue;\n        }\n        if digits.is_digit(16)\
    \ {\n            if result < value {\n                result = value;\n      \
    \      }\n            i += 1;\n            continue;\n        }\n        if digits.is_digit(32)\
    \ {\n            if result < value {\n                result = value;\n      \
    \      }\n            i += 1;\n            continue;\n        }\n        if digits.is_digit(64)\
    \ {\n            if result < value {\n                result = value;\n      \
    \      }\n            i += 1;\n            continue;\n        }\n        if digits.is_digit(128)\
    \ {\n            if result < value {\n                result = value;\n      \
    \      }\n            i += 1;\n            continue;\n        }\n        if digits.is_digit(256)\
    \ {\n            if result < value {\n                result = value;\n      \
    \      }\n            i += 1;\n            continue;\n        }\n        if digits.is_digit(512)\
    \ {\n            if result < value {\n                result = value;\n      \
    \      }\n            i += 1;\n            continue;\n        }\n        if digits.is_digit(1024)\
    \ {\n            if result < value {\n                result = value;\n      \
    \      }\n            i += 1;\n            continue;\n        }\n        if digits.is_digit(2048)\
    \ {\n            if result < value {\n                result = value;\n      \
    \      }\n            i += 1;\n            continue;\n        }\n        if digits.is_digit(4096)\
    \ {\n            if result < value {\n                result = value;\n      \
    \      }\n            i += 1;\n            continue;\n        }\n        if digits.is_digit(8192)\
    \ {\n            if result < value {\n                result = value;\n      \
    \      }\n            i += 1;\n            continue;\n        }\n        if digits.is_digit(16384)\
    \ {\n            if result < value {\n                result = value;\n      \
    \      }\n            i += 1;\n            continue;\n        }\n        if digits.is_digit(32768)\
    \ {\n            if result < value {\n                result = value;\n      \
    \      }\n            i += 1;\n            continue;\n        }\n        if digits.is_digit(65536)\
    \ {\n            if result < value {\n                result = value;\n      \
    \      }\n            i += 1;\n            continue;\n        }\n        if digits.is_digit(131072)\
    \ {\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpfgg2eow8.rs:141:3\n\
    \    |\n14  | fn closest_integer(value: String) -> isize {\n    |            \
    \                                - unclosed delimiter\n...\n19  |     while i\
    \ < value.len() {\n    |                           - unclosed delimiter\n...\n\
    131 |         if digits.is_digit(131072) {\n    |                            \
    \        - this delimiter might not be properly closed...\n132 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n141 | }\n    |   ^\n\n\
    error[E0425]: cannot find value `left` in this scope\n   --> /tmp/tmpfgg2eow8.rs:136:17\n\
    \    |\n136 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpfgg2eow8.rs:136:25\n    |\n136 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpfgg2eow8.rs:137:17\n\
    \    |\n137 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpfgg2eow8.rs:137:25\n    |\n137 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpfgg2eow8.rs:138:17\n\
    \    |\n138 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpfgg2eow8.rs:138:25\n    |\n138 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpfgg2eow8.rs:139:17\n\
    \    |\n139 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpfgg2eow8.rs:139:25\n    |\n139 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror["
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.parse::<isize>().unwrap();\n    let mut last_digit\
    \ = digits.last();\n    let mut last_digit = last_digit as isize;\n    let mut\
    \ last_digit = last_digit % 10;\n    let mut last_digit = last_digit as isize;\n\
    \    let mut last_digit = last_digit % 10;\n    let mut last_digit = last_digit\
    \ as isize;\n    let mut last_digit = last_digit as isize;\n    let mut last_digit\
    \ = last_digit as isize;\n    let mut last_digit = last_digit as isize;\n    let\
    \ mut last_digit = last_digit as isize;\n    let mut last_digit = last_digit as\
    \ isize;\n    let mut last_digit = last_digit as isize;\n    let mut last_digit\
    \ = last_digit as isize;\n    let mut last_digit = last_digit as isize;\n    let\
    \ mut last_digit = last_digit as isize;\n    let mut last_digit = last_digit as\
    \ isize;\n    let mut last_digit = last_digit as isize;\n    let mut last_digit\
    \ = last_digit as isize;\n    let mut last_digit = last_digit as isize;\n    let\
    \ mut last_digit = last_digit as isize;\n    let mut last_digit = last_digit as\
    \ isize;\n    let mut last_digit = last_digit as isize;\n    let mut last_digit\
    \ = last_digit as isize;\n    let mut last_digit = last_digit as isize;\n    let\
    \ mut last_digit = last_digit as isize;\n    let mut last_digit = last_digit as\
    \ isize;\n    let mut last_digit = last_digit as isize;\n    let mut last_digit\
    \ = last_digit as isize;\n    let mut last_digit = last_digit as isize;\n    let\
    \ mut last_digit = last_digit as isize;\n    let mut last_digit = last_digit as\
    \ isize;\n    let mut last_digit = last_digit as isize;\n    let mut last_digit\
    \ = last_digit as isize;\n    let mut last_digit = last_digit as isize;\n    let\
    \ mut last_digit = last_digit as isize;\n    let mut last_digit = last_digit as\
    \ isize;\n    let mut last_digit = last_digit as isize;\n    let mut last_digit\
    \ = last_digit as isize;\n    let mut last_digit = last_digit as isize;\n    let\
    \ mut last_digit = last_digit as \n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmp5731pbby.rs:58:1\n   |\n\
    58 | }\n   | ^ expected type\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n  --> /tmp/tmp5731pbby.rs:62:17\n   |\n62 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp5731pbby.rs:62:25\n   |\n62 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp5731pbby.rs:63:17\n   |\n63 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp5731pbby.rs:63:25\n   |\n63 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp5731pbby.rs:64:17\n  \
    \ |\n64 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5731pbby.rs:64:25\n   |\n64 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp5731pbby.rs:65:17\n   |\n65 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp5731pbby.rs:65:25\n\
    \   |\n65 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp5731pbby.rs:66:17\n   |\n66 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp5731pbby.rs:66:25\n   |\n66 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0605]: non-primitive cast: `Option<&char>` as `isize`\n\
    \  --> /tmp/tmp5731pbby.rs:19:26\n   |\n19 |     let "
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_digit(16).unwrap()\n        }\n    }).collect::<Vec<_>>();\n\
    \    let mut result = value.chars().enumerate().map(|(i, c)| {\n        if c.is_numeric()\
    \ {\n            c.to_digit(10).unwrap()\n        } else {\n            c.to_digit(16).unwrap()\n\
    \        }\n    }).collect::<Vec<_>>();\n    let mut min = result.len();\n   \
    \ let mut max = result.len();\n    let mut min_digits = result.len();\n    let\
    \ mut max_digits = result.len();\n    let mut min_value = result.len();\n    let\
    \ mut max_value = result.len();\n    let mut min_digit = result.len();\n    let\
    \ mut max_digit = result.len();\n    let mut min_value = result.len();\n    let\
    \ mut max_value = result.len();\n    let mut min_digit = result.len();\n    let\
    \ mut max_digit = result.len();\n    let mut min_value = result.len();\n    let\
    \ mut max_value = result.len();\n    let mut min_digit = result.len();\n    let\
    \ mut max_digit = result.len();\n    let mut min_value = result.len();\n    let\
    \ mut max_value = result.len();\n    let mut min_digit = result.len();\n    let\
    \ mut max_digit = result.len();\n    let mut min_value = result.len();\n    let\
    \ mut max_value = result.len();\n    let mut min_digit = result.len();\n    let\
    \ mut max_digit = result.len();\n    let mut min_value = result.len();\n    let\
    \ mut max_value = result.len();\n    let mut min_digit = result.len();\n    let\
    \ mut max_digit = result.len();\n    let mut min_value = result.len();\n    let\
    \ mut max_value = result.len();\n    let mut min_digit = result.len();\n    let\
    \ mut max_digit = result.len();\n    let mut min_value = result.len();\n    let\
    \ mut max_value = result.len();\n    let mut min_digit = result.len();\n    let\
    \ mut max_digit = result.len();\n    let mut min_value = result.len();\n    let\
    \ mut max_value = result.len();\n    let mut min_digit = result.len();\n    let\
    \ mut max_digit = result.len();\n    let mut min_value = result.len();\n    let\
    \ mut max_\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpinir8s59.rs:71:17\n   |\n\
    71 |     let mut max_\n   |                 ^ help: add `;` here\n72 | }\n   |\
    \ - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpinir8s59.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpinir8s59.rs:76:25\n   |\n76 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpinir8s59.rs:77:17\n   |\n77 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpinir8s59.rs:77:25\n   |\n77 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpinir8s59.rs:78:17\n  \
    \ |\n78 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpinir8s59.rs:78:25\n   |\n78 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpinir8s59.rs:79:17\n   |\n79 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpinir8s59.rs:79:25\n\
    \   |\n79 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpinir8s59.rs:80:17\n   |\n80 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpinir8s59.rs:80:25\n   |\n80 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tm"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.parse::<isize>().unwrap();\n    let mut closest_integer\
    \ = result;\n    let mut closest_digit = digits[0];\n    let mut closest_digit_value\
    \ = 1;\n    let mut closest_digit_index = 1;\n    let mut closest_digit_index2\
    \ = 0;\n    let mut closest_digit_index3 = 0;\n    let mut closest_digit_index4\
    \ = 0;\n    let mut closest_digit_index5 = 0;\n    let mut closest_digit_index6\
    \ = 0;\n    let mut closest_digit_index7 = 0;\n    let mut closest_digit_index8\
    \ = 0;\n    let mut closest_digit_index9 = 0;\n    let mut closest_digit_index10\
    \ = 0;\n    let mut closest_digit_index11 = 0;\n    let mut closest_digit_index12\
    \ = 0;\n    let mut closest_digit_index13 = 0;\n    let mut closest_digit_index14\
    \ = 0;\n    let mut closest_digit_index15 = 0;\n    let mut closest_digit_index16\
    \ = 0;\n    let mut closest_digit_index17 = 0;\n    let mut closest_digit_index18\
    \ = 0;\n    let mut closest_digit_index19 = 0;\n    let mut closest_digit_index20\
    \ = 0;\n    let mut closest_digit_index21 = 0;\n    let mut closest_digit_index22\
    \ = 0;\n    let mut closest_digit_index23 = 0;\n    let mut closest_digit_index24\
    \ = 0;\n    let mut closest_digit_index25 = 0;\n    let mut closest_digit_index26\
    \ = 0;\n    let mut closest_digit_index27 = 0;\n    let mut closest_digit_index28\
    \ = 0;\n    let mut closest_digit_index29 = 0;\n    let mut closest_digit_index30\
    \ = 0;\n    let mut closest_digit_index31 = 0;\n    let mut closest_digit_index32\
    \ = 0;\n    let mut closest_digit_index33 = 0;\n    let mut closest_digit_index34\
    \ = 0;\n    let mut closest_digit_index35 = 0;\n    let mut closest_digit_index36\
    \ = 0;\n    let mut closest_digit_index37 = 0;\n    let mut closest_digit_index38\
    \ = 0;\n    let mut closest_digit_index39 = 0;\n    let mut closest_digit_index40\
    \ = 0;\n    let mut closest_digit_index41 = 0;\n    let mut closest_digit_index42\
    \ = 0;\n    let mut closest_digit_index43 = 0;\n    let mut closest_digit_index44\
    \ = 0;\n    let mut closest_digit_index45 = 0;\n    let mut closest_digit_index46\
    \ = 0;\n    let mut closest_digit_index47 = 0;\n    let mut closest_digit_index48\
    \ = 0;\n    let mut closest_digit_index49 = 0;\n    let mut closest_digit_index50\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpgiii99zj.rs:72:1\n\
    \   |\n72 | }\n   | ^ expected identifier\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpgiii99zj.rs:76:17\n   |\n76 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpgiii99zj.rs:76:25\n \
    \  |\n76 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpgiii99zj.rs:77:17\n   |\n77 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpgiii99zj.rs:77:25\n   |\n77 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpgiii99zj.rs:78:17\n   |\n78 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpgiii99zj.rs:78:25\n   |\n78 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpgiii99zj.rs:79:17\n  \
    \ |\n79 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpgiii99zj.rs:79:25\n   |\n79 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpgiii99zj.rs:80:17\n   |\n80 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpgiii99zj.rs:80:25\n\
    \   |\n80 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --expl"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    if value.chars().count() > 2 {\n  \
    \      value = &value[..value.len() - 1];\n    }\n    let mut value = value.parse::<isize>().unwrap();\n\
    \    if value % 2 == 0 {\n        value /= 2;\n    }\n    value\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpb9t3xus3.rs:28:17\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpb9t3xus3.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpb9t3xus3.rs:29:17\n   |\n29 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpb9t3xus3.rs:29:25\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpb9t3xus3.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpb9t3xus3.rs:30:25\n   |\n30 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpb9t3xus3.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpb9t3xus3.rs:31:25\n   |\n31 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpb9t3xus3.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpb9t3xus3.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb9t3xus3.rs:17:17\n   |\n17 |         value = &value[..value.len()\
    \ - 1];\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nh"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut exponent = 0;\n\
    \    let mut remainder = 0;\n    while let Some(digit) = digits.next() {\n   \
    \     let mut new_remainder = 0;\n        if let Some(digit) = digits.next() {\n\
    \            new_remainder = digit - remainder;\n        }\n        remainder\
    \ = new_remainder;\n        exponent = exponent + 1;\n        if exponent > 10\
    \ {\n            break;\n        }\n    }\n    if remainder < 0 {\n        result\
    \ = -result;\n    }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpt_a0sglj.rs:39:17\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpt_a0sglj.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpt_a0sglj.rs:40:17\n   |\n40 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpt_a0sglj.rs:40:25\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpt_a0sglj.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpt_a0sglj.rs:41:25\n   |\n41 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpt_a0sglj.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpt_a0sglj.rs:42:25\n   |\n42 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpt_a0sglj.rs:43:17\n  \
    \ |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpt_a0sglj.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `next` found for type `char` in the current scope\n  --> /tmp/tmpt_a0sglj.rs:20:36\n\
    \   |\n20 |     while let Some(digit) = digits.next() {\n   |                \
    \                    ^^"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_digit() {\n            c.to_digit(10).unwrap()\n    \
    \    } else {\n            i\n        }\n    });\n    let mut smallest = std::i32::MAX;\n\
    \    let mut largest = std::i32::MIN;\n    let mut mid = 0;\n    let mut i = 0;\n\
    \    while i < digits.len() {\n        let digit = digits[i];\n        if digit\
    \ < smallest {\n            smallest = digit;\n        }\n        if digit > largest\
    \ {\n            largest = digit;\n        }\n        if digit == 0 {\n      \
    \      break;\n        }\n        mid = i;\n        i += 1;\n    }\n    if smallest\
    \ == largest {\n        smallest\n    } else {\n        smallest + (largest -\
    \ smallest) / 2\n    }\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpo5hiczgj.rs:50:17\n\
    \   |\n50 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpo5hiczgj.rs:50:25\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpo5hiczgj.rs:51:17\n   |\n51 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpo5hiczgj.rs:51:25\n\
    \   |\n51 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpo5hiczgj.rs:52:17\n   |\n52 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpo5hiczgj.rs:52:25\n   |\n52 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpo5hiczgj.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpo5hiczgj.rs:53:25\n   |\n53 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpo5hiczgj.rs:54:17\n  \
    \ |\n54 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpo5hiczgj.rs:54:25\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpo5hiczgj.rs:17:14\n\
    \    |\n17  |         if c.is_digit() {\n    |              ^^^^^^^^- supplied\
    \ 0 arguments\n    |       "
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.parse::<isize>().unwrap();\n    let mut closest_integer =\
    \ value;\n    let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer - isize::MAX\n    };\n \
    \   let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer - isize::MAX\n    };\n \
    \   let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer - isize::MAX\n    };\n \
    \   let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer - isize::MAX\n    };\n \
    \   let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer - isize::MAX\n    };\n \
    \   let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer - isize::MAX\n    };\n \
    \   let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer - isize::MAX\n    };\n \
    \   let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer - isize::MAX\n    };\n \
    \   let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer - isize::MAX\n    };\n \
    \   let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer - isize::MAX\n    };\n \
    \   let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer - isize::MAX\n    };\n \
    \   let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer - isize::MAX\n    };\n \
    \   let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer - isize::MAX\n    };\n \
    \   let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ + isize::MAX\n    } else {\n        closest_integer - isize::MAX\n    };\n \
    \   let mut closest_integer = if closest_integer < 0 {\n        closest_integer\
    \ \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpefwk3rih.rs:98:3\n\
    \   |\n14 | fn closest_integer(value: String) -> isize {\n   |               \
    \                             - unclosed delimiter\n...\n87 |     let mut closest_integer\
    \ = if closest_integer < 0 {\n   |                                           \
    \           - this delimiter might not be properly closed...\n88 |         closest_integer\
    \ \n89 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    98 | }\n   |   ^\n\nerror: expected one of `.`, `;`, `?`, `else`, or an operator,\
    \ found keyword `fn`\n  --> /tmp/tmpefwk3rih.rs:91:1\n   |\n89 | }\n   |  - expected\
    \ one of `.`, `;`, `?`, `else`, or an operator\n90 | \n91 | fn main() {\n   |\
    \ ^^ unexpected token\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.parse::<isize>().unwrap();\n    let mut i = 0;\n \
    \   let mut last_digit = digits.get(0);\n    while i < digits.len() {\n      \
    \  let digit = digits.get(i);\n        if digit != last_digit {\n            last_digit\
    \ = digit;\n            i += 1;\n        } else {\n            i += 1;\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp9wmyn5y3.rs:34:17\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp9wmyn5y3.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp9wmyn5y3.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp9wmyn5y3.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp9wmyn5y3.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp9wmyn5y3.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp9wmyn5y3.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp9wmyn5y3.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp9wmyn5y3.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp9wmyn5y3.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 10 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_digit(16).unwrap()\n        }\n    }).collect::<Vec<_>>();\n\
    \    let mut result = value.chars().enumerate().map(|(i, c)| {\n        if c.is_numeric()\
    \ {\n            c.to_digit(10).unwrap()\n        } else {\n            c.to_digit(16).unwrap()\n\
    \        }\n    }).collect::<Vec<_>>();\n    let mut min_digits = result.len();\n\
    \    let mut min_digits_index = result.len();\n    let mut max_digits = result.len();\n\
    \    let mut max_digits_index = result.len();\n    let mut min_value = result.len();\n\
    \    let mut max_value = result.len();\n    let mut min_value_index = result.len();\n\
    \    let mut max_value_index = result.len();\n    let mut min_digits_index = result.len();\n\
    \    let mut max_digits_index = result.len();\n    let mut min_value = result.len();\n\
    \    let mut max_value = result.len();\n    let mut min_value_index = result.len();\n\
    \    let mut max_value_index = result.len();\n    let mut min_digits = result.len();\n\
    \    let mut max_digits = result.len();\n    let mut min_digits_index = result.len();\n\
    \    let mut max_digits_index = result.len();\n    let mut min_value = result.len();\n\
    \    let mut max_value = result.len();\n    let mut min_value_index = result.len();\n\
    \    let mut max_value_index = result.len();\n    let mut min_digits = result.len();\n\
    \    let mut max_digits = result.len();\n    let mut min_digits_index = result.len();\n\
    \    let mut max_digits_index = result.len();\n    let mut min_value = result.len();\n\
    \    let mut max_value = result.len();\n    let mut min_value_index = result.len();\n\
    \    let mut max_value_index = result.len();\n    let mut min_digits = result.len();\n\
    \    let mut max_digits = result.len();\n    let mut min_digits_index = result.len();\n\
    \    let mut max_digits_index = result.len();\n    let mut min_value = result.len();\n\
    \    let mut max_value = result.len();\n    let mut min_value_index = result.len();\n\
    \    let mut max_value_index = result.len();\n    let mut min_digits = result.len();\n\
    \    let \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmplu2w7pin.rs:70:1\n  \
    \ |\n70 | }\n   | ^ expected pattern\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmplu2w7pin.rs:74:17\n   |\n74 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmplu2w7pin.rs:74:25\n \
    \  |\n74 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmplu2w7pin.rs:75:17\n   |\n75 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmplu2w7pin.rs:75:25\n   |\n75 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmplu2w7pin.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmplu2w7pin.rs:76:25\n   |\n76 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmplu2w7pin.rs:77:17\n  \
    \ |\n77 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmplu2w7pin.rs:77:25\n   |\n77 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmplu2w7pin.rs:78:17\n   |\n78 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmplu2w7pin.rs:78:25\n\
    \   |\n78 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0"
  stdout: ''
  timestamp: 1659823261
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_digit() {\n            c.to_digit(10).unwrap()\n    \
    \    } else {\n            c.to_digit(16).unwrap()\n        }\n    });\n    let\
    \ mut result = digits.iter().cloned().collect::<Vec<_>>();\n    let mut min =\
    \ result.len();\n    let mut max = result.len();\n    let mut min_value = result.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut max_value = result.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut min_value = min_value.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ max_value = max_value.iter().cloned().collect::<Vec<_>>();\n    let mut min_value\
    \ = min_value.iter().cloned().collect::<Vec<_>>();\n    let mut max_value = max_value.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value = min_value.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut max_value = max_value.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ min_value = min_value.iter().cloned().collect::<Vec<_>>();\n    let mut max_value\
    \ = max_value.iter().cloned().collect::<Vec<_>>();\n    let mut min_value = min_value.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut max_value = max_value.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut min_value = min_value.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ max_value = max_value.iter().cloned().collect::<Vec<_>>();\n    let mut min_value\
    \ = min_value.iter().cloned().collect::<Vec<_>>();\n    let mut max_value = max_value.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut min_value = min_value.iter().cloned().collect::<Vec<_>>();\n    let\
    \ mut max_value = max_value.iter().cloned().collect::<Vec<_>>();\n    let mut\
    \ min_value = min_value.iter().cloned().collect::<Vec<_>>();\n    let mut max_value\
    \ = max_value.iter().cloned().collect::<Vec<_>>();\n    let mut min_value = min_value.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpr6duab1y.rs:48:1\n\
    \   |\n48 | }\n   | ^ expected identifier\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpr6duab1y.rs:52:17\n   |\n52 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpr6duab1y.rs:52:25\n \
    \  |\n52 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpr6duab1y.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpr6duab1y.rs:53:25\n   |\n53 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpr6duab1y.rs:54:17\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpr6duab1y.rs:54:25\n   |\n54 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpr6duab1y.rs:55:17\n  \
    \ |\n55 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpr6duab1y.rs:55:25\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpr6duab1y.rs:56:17\n   |\n56 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpr6duab1y.rs:56:25\n\
    \   |\n56 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0061]: this function takes 1 argument but\
    \ 0 arguments were supplied\n   --> /tmp/tmpr6duab1y."
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if digits[i] != '.' {\n            digits =\
    \ &digits[..i];\n            break;\n        }\n        i += 1;\n    }\n    let\
    \ mut digits = digits.chars().nth(1).unwrap();\n    let mut i = 0;\n    while\
    \ i < value.len() {\n        if digits[i] != '.' {\n            digits = &digits[..i];\n\
    \            break;\n        }\n        i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut i = 0;\n    while i < value.len() {\n        if digits[i] != '.'\
    \ {\n            digits = &digits[..i];\n            break;\n        }\n     \
    \   i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n   \
    \ let mut i = 0;\n    while i < value.len() {\n        if digits[i] != '.' {\n\
    \            digits = &digits[..i];\n            break;\n        }\n        i\
    \ += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let\
    \ mut i = 0;\n    while i < value.len() {\n        if digits[i] != '.' {\n   \
    \         digits = &digits[..i];\n            break;\n        }\n        i +=\
    \ 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let mut\
    \ i = 0;\n    while i < value.len() {\n        if digits[i] != '.' {\n       \
    \     digits = &digits[..i];\n            break;\n        }\n        i += 1;\n\
    \    }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let mut i =\
    \ 0;\n    while i < value.len() {\n        if digits[i] != '.' {\n           \
    \ digits = &digits[..i];\n            break;\n        }\n        i += 1;\n   \
    \ }\n    let mut digits = digits.chars().nth(1).unwrap();\n    let mut i = 0;\n\
    \    while i < value.len() {\n        if digits[i] != '.' {\n            digits\
    \ = &digits[..i];\n            break;\n        }\n        i += 1;\n    }\n   \
    \ let mut digits = digits.chars().nth(1).unwrap();\n    let mut i = 0;\n    while\
    \ i < value.len() {\n        if digits[i] != '.' {\n            digits = &digits[..i];\n\
    \            break;\n        }\n        i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n   --> /tmp/tmpyh4adedh.rs:104:17\n\
    \    |\n104 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpyh4adedh.rs:104:25\n    |\n104 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpyh4adedh.rs:105:17\n\
    \    |\n105 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpyh4adedh.rs:105:25\n    |\n105 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpyh4adedh.rs:106:17\n\
    \    |\n106 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpyh4adedh.rs:106:25\n    |\n106 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpyh4adedh.rs:107:17\n\
    \    |\n107 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpyh4adedh.rs:107:25\n    |\n107 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpyh4adedh.rs:108:17\n\
    \    |\n108 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpyh4adedh.rs:108:25\n    |\n108 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0608]:\
    \ cannot index into a value of type `char`\n  --> /tmp/tmpyh4adedh.rs:20:12\n\
    \   |\n20 |         if digits[i] != '.' {\n   |            ^^^^^^^^^\n\nerro"
  stdout: ''
  timestamp: 1659805389
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(0).unwrap();\n    let mut exponent = 0;\n\
    \    let mut remainder = 0;\n    while digits.is_some() {\n        let mut digit\
    \ = digits.unwrap();\n        if digit == '.' {\n            exponent = exponent\
    \ + 1;\n            digits = value.chars().nth(exponent + 1).unwrap();\n     \
    \   } else {\n            digits = value.chars().nth(exponent + 1).unwrap();\n\
    \        }\n        let mut remainder = digit - remainder;\n        result = result\
    \ + remainder;\n        remainder = remainder % 10;\n    }\n    if remainder >\
    \ 0 {\n        result = result + remainder;\n    }\n    result as isize\n}\n\n\
    fn main() {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp_wnt8xbm.rs:40:17\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_wnt8xbm.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_wnt8xbm.rs:41:17\n   |\n41 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_wnt8xbm.rs:41:25\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_wnt8xbm.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_wnt8xbm.rs:42:25\n   |\n42 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_wnt8xbm.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_wnt8xbm.rs:43:25\n   |\n43 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_wnt8xbm.rs:44:17\n  \
    \ |\n44 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_wnt8xbm.rs:44:25\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `is_some` found for type `char` in the current scope\n  --> /tmp/tmp_wnt8xbm.rs:20:18\n\
    \   |\n20 |     while digits.is_some() {\n   |                  ^^^^^^^ method\
    \ not found in `cha"
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut result = 0.0;\n    let mut\
    \ exponent = value.chars().count();\n    let mut last_digit = digits[digits.len()\
    \ - 1];\n    let mut last_exponent = exponent;\n    while exponent > 0 {\n   \
    \     if last_exponent > exponent {\n            last_exponent -= exponent;\n\
    \            last_digit = digits[digits.len() - exponent];\n        }\n      \
    \  result *= 10.0;\n        result += last_digit;\n        exponent--;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpp6azy1ur.rs:28:19\n\
    \   |\n28 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpp6azy1ur.rs:35:17\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpp6azy1ur.rs:35:25\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpp6azy1ur.rs:36:17\n   |\n36 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpp6azy1ur.rs:36:25\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpp6azy1ur.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpp6azy1ur.rs:37:25\n   |\n37 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpp6azy1ur.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpp6azy1ur.rs:38:25\n   |\n38 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpp6azy1ur.rs:39:17\n  \
    \ |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpp6azy1ur.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: cannot\
    \ add-assign `Option<u32>` to `{float}`\n  -"
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut i = 0;\n    let mut closest_integer = isize::MAX;\n    while i <\
    \ digits.len() {\n        let digit = digits[i];\n        if digit == '.' {\n\
    \            digits.remove(&i);\n            digits.remove(&i);\n            i\
    \ += 1;\n        } else {\n            if digit == 'e' || digit == 'E' {\n   \
    \             digits.remove(&i);\n                digits.remove(&i);\n       \
    \         i += 1;\n            } else {\n                i += 1;\n           \
    \ }\n        }\n        if digits.len() == 0 {\n            break;\n        }\n\
    \        let digit = digits[i];\n        if digit < '0' {\n            break;\n\
    \        }\n        let digit = digits[i];\n        let digit = digit.parse::<isize>().unwrap();\n\
    \        if digit < closest_integer {\n            closest_integer = digit;\n\
    \        }\n    }\n    closest_integer\n}\n\nfn main() {\n    let candidate =\
    \ closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpz11m267p.rs:52:17\n\
    \   |\n52 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpz11m267p.rs:52:25\n   |\n52 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpz11m267p.rs:53:17\n   |\n53 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpz11m267p.rs:53:25\n\
    \   |\n53 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpz11m267p.rs:54:17\n   |\n54 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpz11m267p.rs:54:25\n   |\n54 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpz11m267p.rs:55:17\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpz11m267p.rs:55:25\n   |\n55 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpz11m267p.rs:56:17\n  \
    \ |\n56 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpz11m267p.rs:56:25\n   |\n56 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz11m267p.rs:22:27\n   |\n22 |             digits.remove(&i);\n\
    \   |                           ^^ expected `usize`, found `&usize`\n   |\nhelp:\
    \ consider removing the borr"
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut v = value.to_string().parse::<isize>().unwrap();\n    if v < 0 {\n\
    \        v = -v;\n    }\n    v.round() as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp_w3e7o6_.rs:24:17\n\
    \   |\n24 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_w3e7o6_.rs:24:25\n   |\n24 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_w3e7o6_.rs:25:17\n   |\n25 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_w3e7o6_.rs:25:25\n\
    \   |\n25 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_w3e7o6_.rs:26:17\n   |\n26 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_w3e7o6_.rs:26:25\n   |\n26 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_w3e7o6_.rs:27:17\n   |\n27 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_w3e7o6_.rs:27:25\n   |\n27 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_w3e7o6_.rs:28:17\n  \
    \ |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_w3e7o6_.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `round` found for type `isize` in the current scope\n  --> /tmp/tmp_w3e7o6_.rs:19:7\n\
    \   |\n19 |     v.round() as isize\n   |       ^^^^^ method not found in `isize`\n\
    \nerror: aborting "
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut k = 0;\n    while i < digits.len() && j < digits.len()\
    \ {\n        if digits[i] > digits[j] {\n            swap(&mut digits, i, k);\n\
    \            swap(&mut digits, j, k);\n            i += 1;\n            j += 1;\n\
    \            k += 1;\n        } else {\n            i += 1;\n            j +=\
    \ 1;\n        }\n    }\n    digits.reverse();\n    let mut i = 0;\n    while i\
    \ < digits.len() {\n        if digits[i] != 0 {\n            return i;\n     \
    \   }\n        i += 1;\n    }\n    digits.len()\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp1ppgwykp.rs:23:13\n\
    \   |\n23 |             swap(&mut digits, i, k);\n   |             ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot\
    \ find function `swap` in this scope\n  --> /tmp/tmp1ppgwykp.rs:24:13\n   |\n\
    24 |             swap(&mut digits, j, k);\n   |             ^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing one of these items\n   |\n1  | use\
    \ std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp1ppgwykp.rs:46:17\n   |\n46 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp1ppgwykp.rs:46:25\n\
    \   |\n46 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp1ppgwykp.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp1ppgwykp.rs:47:25\n   |\n47 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp1ppgwykp.rs:48:17\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp1ppgwykp.rs:48:25\n   |\n48 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp1ppgwykp.rs:49:17\n  \
    \ |\n49 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp1ppgwykp.rs:49:25\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found"
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.parse::<isize>().unwrap();\n    let mut i = 0;\n \
    \   let mut j = 0;\n    while i < digits.len() && j < digits.len() {\n       \
    \ if digits[i] > digits[j] {\n            result += 1;\n            i += 1;\n\
    \        } else {\n            result += 1;\n            j += 1;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmptro7zg_9.rs:34:17\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptro7zg_9.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmptro7zg_9.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmptro7zg_9.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmptro7zg_9.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmptro7zg_9.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmptro7zg_9.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmptro7zg_9.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmptro7zg_9.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptro7zg_9.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 10 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.chars().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    while i < digits.len() && digits.len() > 0 {\n        let mut digit = digits.remove(i);\n\
    \        if digit == '.' {\n            digits.remove(i);\n            digits.remove(i);\n\
    \        }\n        if digit == 'e' || digit == 'E' {\n            digits.remove(i);\n\
    \            digits.remove(i);\n            digits.remove(i);\n        }\n   \
    \     i += 1;\n    }\n    let mut i = 0;\n    while i < result.len() && result.len()\
    \ > 0 {\n        let mut digit = result.remove(i);\n        if digit == '.' {\n\
    \            result.remove(i);\n            result.remove(i);\n        }\n   \
    \     i += 1;\n    }\n    digits.iter().cloned().collect::<isize>()\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp7_c_c_i2.rs:46:17\n\
    \   |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7_c_c_i2.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp7_c_c_i2.rs:47:17\n   |\n47 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp7_c_c_i2.rs:47:25\n\
    \   |\n47 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp7_c_c_i2.rs:48:17\n   |\n48 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp7_c_c_i2.rs:48:25\n   |\n48 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp7_c_c_i2.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp7_c_c_i2.rs:49:25\n   |\n49 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp7_c_c_i2.rs:50:17\n  \
    \ |\n50 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7_c_c_i2.rs:50:25\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: a value\
    \ of type `isize` cannot be built from an iterator over elements of type `char`\n\
    \  --> /tmp/tmp7_c_c_i2.rs:41:28\n   |\n41 |     digits.iter().cloned().collect::<isize>()\n\
    \   |                "
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    if value.chars().count() > 1 {\n  \
    \      value = &value[1..];\n    }\n    let mut result = value.parse::<isize>().unwrap();\n\
    \    if result < 0 {\n        result = -result;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpzeduu0zm.rs:28:17\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpzeduu0zm.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpzeduu0zm.rs:29:17\n   |\n29 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpzeduu0zm.rs:29:25\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpzeduu0zm.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpzeduu0zm.rs:30:25\n   |\n30 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpzeduu0zm.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpzeduu0zm.rs:31:25\n   |\n31 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpzeduu0zm.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpzeduu0zm.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzeduu0zm.rs:17:17\n   |\n17 |         value = &value[1..];\n\
    \   |                 ^^^^^^^^^^^ expected struct `String`, found `&str`\n   |\n\
    help: try using a conversion "
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut i = 0;\n   \
    \ while i < value.len() {\n        if digits[i] != '.' {\n            digits =\
    \ &digits[..i];\n            break;\n        }\n        i += 1;\n    }\n    let\
    \ mut digits = digits.chars().nth(1).unwrap();\n    let mut result = result.chars().nth(1).unwrap();\n\
    \    let mut i = 0;\n    while i < value.len() {\n        if digits[i] != '.'\
    \ {\n            digits = &digits[..i];\n            break;\n        }\n     \
    \   i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n   \
    \ let mut result = result.chars().nth(1).unwrap();\n    let mut i = 0;\n    while\
    \ i < value.len() {\n        if digits[i] != '.' {\n            digits = &digits[..i];\n\
    \            break;\n        }\n        i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut result = result.chars().nth(1).unwrap();\n    let mut i = 0;\n  \
    \  while i < value.len() {\n        if digits[i] != '.' {\n            digits\
    \ = &digits[..i];\n            break;\n        }\n        i += 1;\n    }\n   \
    \ let mut digits = digits.chars().nth(1).unwrap();\n    let mut result = result.chars().nth(1).unwrap();\n\
    \    let mut i = 0;\n    while i < value.len() {\n        if digits[i] != '.'\
    \ {\n            digits = &digits[..i];\n            break;\n        }\n     \
    \   i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n   \
    \ let mut result = result.chars().nth(1).unwrap();\n    let mut i = 0;\n    while\
    \ i < value.len() {\n        if digits[i] != '.' {\n            digits = &digits[..i];\n\
    \            break;\n        }\n        i += 1;\n    }\n    let mut digits = digits.chars().nth(1).unwrap();\n\
    \    let mut result = result.chars().nth(1).unwrap();\n    let mut i = 0;\n  \
    \  while i < value.len() {\n        if digits[i] != '.' {\n            digits\
    \ = &digits[..i];\n            break;\n        }\n        i += 1;\n    }\n   \
    \ let mut digits = digits.chars().nth(1).unwrap();\n    let mut result = result.chars().nth(1).unwrap();\n\
    \    let mut i = 0;\n    while i < value.len() {\n        if digits[i] != \n}\n\
    \nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmplrt3q4ns.rs:100:3\n\
    \    |\n14  | fn closest_integer(value: String) -> isize {\n    |            \
    \                                - unclosed delimiter\n...\n89  |     while i\
    \ < value.len() {\n    |                           - this delimiter might not\
    \ be properly closed...\n90  |         if digits[i] != \n91  | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n100 | }\n    |   ^\n\n\
    error: expected expression, found `}`\n  --> /tmp/tmplrt3q4ns.rs:91:1\n   |\n\
    91 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `left` in\
    \ this scope\n  --> /tmp/tmplrt3q4ns.rs:95:17\n   |\n95 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmplrt3q4ns.rs:95:25\n \
    \  |\n95 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmplrt3q4ns.rs:96:17\n   |\n96 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmplrt3q4ns.rs:96:25\n   |\n96 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmplrt3q4ns.rs:97:17\n   |\n97 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmplrt3q4ns.rs:97:25\n   |\n97 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmplrt3q4ns.rs:98:17\n  \
    \ |\n98 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmplrt3q4ns.rs:98:25\n   |\n98 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: c"
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().collect::<Vec<_>>();\n\
    \    let mut result = value.parse::<isize>().unwrap();\n    let mut i = 0;\n \
    \   while i < digits.len() && result < 0 {\n        i += 1;\n        result =\
    \ result * 10 + digits[i];\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp8n3vx3lu.rs:28:17\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8n3vx3lu.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp8n3vx3lu.rs:29:17\n   |\n29 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp8n3vx3lu.rs:29:25\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8n3vx3lu.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8n3vx3lu.rs:30:25\n   |\n30 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp8n3vx3lu.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp8n3vx3lu.rs:31:25\n   |\n31 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp8n3vx3lu.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8n3vx3lu.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: cannot\
    \ add `char` to `isize`\n  --> /tmp/tmp8n3vx3lu.rs:21:30\n   |\n21 |         result\
    \ = result * 10 + digits[i];\n   |                              ^ no implementation\
    \ for `isize + char`\n   |\n   "
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().filter(|&(_,\
    \ c)| c.is_numeric()).map(|(i, c)| {\n        if c.is_numeric() {\n          \
    \  c.to_digit(10).unwrap()\n        } else {\n            i\n        }\n    });\n\
    \    let mut result = digits.iter().cloned().collect::<Vec<_>>();\n    result.sort_unstable_by_key(|&x|\
    \ x.0);\n    result.iter().cloned().next().unwrap().0\n}\n\nfn main() {\n    let\
    \ candidate = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpt_6m1swg.rs:30:17\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpt_6m1swg.rs:30:25\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpt_6m1swg.rs:31:17\n   |\n31 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpt_6m1swg.rs:31:25\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpt_6m1swg.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpt_6m1swg.rs:32:25\n   |\n32 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpt_6m1swg.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpt_6m1swg.rs:33:25\n   |\n33 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpt_6m1swg.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpt_6m1swg.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: `if`\
    \ and `else` have incompatible types\n  --> /tmp/tmpt_6m1swg.rs:20:13\n   |\n\
    17 | /         if c.is_numeric() {\n18 | |             c.to_digit(10).unwrap()\n\
    \   | |             --------------------"
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n    let mut result = value.parse::<isize>().unwrap();\n\
    \    let mut last_digit = digits.last();\n    if last_digit < 0 {\n        digits\
    \ = digits.rev();\n        last_digit = digits.last();\n    }\n    let mut last_digit\
    \ = digits.last();\n    if last_digit < 0 {\n        digits = digits.rev();\n\
    \        last_digit = digits.last();\n    }\n    if last_digit < 0 {\n       \
    \ result = result - 1;\n    }\n    let mut last_digit = digits.last();\n    if\
    \ last_digit < 0 {\n        digits = digits.rev();\n        last_digit = digits.last();\n\
    \    }\n    if last_digit < 0 {\n        result = result - 1;\n    }\n    let\
    \ mut last_digit = digits.last();\n    if last_digit < 0 {\n        digits = digits.rev();\n\
    \        last_digit = digits.last();\n    }\n    if last_digit < 0 {\n       \
    \ result = result - 1;\n    }\n    if result < 0 {\n        result = result +\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpdmdjqg67.rs:55:17\n\
    \   |\n55 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpdmdjqg67.rs:55:25\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpdmdjqg67.rs:56:17\n   |\n56 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpdmdjqg67.rs:56:25\n\
    \   |\n56 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpdmdjqg67.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpdmdjqg67.rs:57:25\n   |\n57 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpdmdjqg67.rs:58:17\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpdmdjqg67.rs:58:25\n   |\n58 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpdmdjqg67.rs:59:17\n  \
    \ |\n59 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpdmdjqg67.rs:59:25\n   |\n59 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdmdjqg67.rs:16:56\n   |\n16 |     let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n   |                                               \
    \         ^^"
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().filter(|&(_,\
    \ c)| c.is_numeric()).map(|(_, c)| c.to_digit(10)).collect::<Vec<_>>();\n    let\
    \ mut result = value.chars().enumerate().filter(|&(_, c)| c.is_numeric()).map(|(_,\
    \ c)| c.to_digit(10)).collect::<Vec<_>>();\n    let mut closest_integer = value.chars().enumerate().filter(|&(_,\
    \ c)| c.is_numeric()).map(|(_, c)| c.to_digit(10)).collect::<Vec<_>>();\n    let\
    \ mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut closest_integer = closest_integer.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpazj2uu5o.rs:38:1\n\
    \   |\n38 | }\n   | ^ expected identifier\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpazj2uu5o.rs:42:17\n   |\n42 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpazj2uu5o.rs:42:25\n \
    \  |\n42 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpazj2uu5o.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpazj2uu5o.rs:43:25\n   |\n43 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpazj2uu5o.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpazj2uu5o.rs:44:25\n   |\n44 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpazj2uu5o.rs:45:17\n  \
    \ |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpazj2uu5o.rs:45:25\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpazj2uu5o.rs:46:17\n   |\n46 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpazj2uu5o.rs:46:25\n\
    \   |\n46 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --expl"
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            c.to_ascii_lowercase().unwrap()\n        }\n    });\n\
    \    let mut result = value.chars().enumerate().map(|(i, c)| {\n        if c.is_numeric()\
    \ {\n            c.to_digit(10).unwrap()\n        } else {\n            c.to_ascii_lowercase().unwrap()\n\
    \        }\n    });\n    let mut min = result.iter().min().unwrap();\n    let\
    \ mut max = result.iter().max().unwrap();\n    let mut min_digits = digits.iter().min().unwrap();\n\
    \    let mut max_digits = digits.iter().max().unwrap();\n    let mut min_result\
    \ = result.iter().min().unwrap();\n    let mut max_result = result.iter().max().unwrap();\n\
    \    let mut min_digit = min_digits.iter().min().unwrap();\n    let mut max_digit\
    \ = max_digits.iter().max().unwrap();\n    let mut min_result = min_result.iter().min().unwrap();\n\
    \    let mut max_result = max_result.iter().max().unwrap();\n    let mut min_digit\
    \ = min_digit.iter().min().unwrap();\n    let mut max_digit = max_digit.iter().max().unwrap();\n\
    \    let mut min_result = min_result.iter().min().unwrap();\n    let mut max_result\
    \ = max_result.iter().max().unwrap();\n    let mut min_digit = min_digit.iter().min().unwrap();\n\
    \    let mut max_digit = max_digit.iter().max().unwrap();\n    let mut min_result\
    \ = min_result.iter().min().unwrap();\n    let mut max_result = max_result.iter().max().unwrap();\n\
    \    let mut min_digit = min_digit.iter().min().unwrap();\n    let mut max_digit\
    \ = max_digit.iter().max().unwrap();\n    let mut min_result = min_result.iter().min().unwrap();\n\
    \    let mut max_result = max_result.iter().max().unwrap();\n    let mut min_digit\
    \ = min_digit.iter().min().unwrap();\n    let mut max_digit = max_digit.iter().max().unwrap();\n\
    \    let mut min_result = min_result.iter().min().unwrap();\n    let mut max_result\
    \ = max_result.iter().max().unwrap();\n    let mut min_digit = min_digit.iter().min().unwrap();\n\
    \    let mut max_digit = max_digit.iter().max().unwrap();\n    let \n}\n\nfn main()\
    \ {\n    let candidate = closest_integer;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpa_rq_n6f.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpa_rq_n6f.rs:63:17\n   |\n63 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpa_rq_n6f.rs:63:25\n \
    \  |\n63 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpa_rq_n6f.rs:64:17\n   |\n64 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpa_rq_n6f.rs:64:25\n   |\n64 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpa_rq_n6f.rs:65:17\n   |\n65 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpa_rq_n6f.rs:65:25\n   |\n65 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpa_rq_n6f.rs:66:17\n  \
    \ |\n66 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpa_rq_n6f.rs:66:25\n   |\n66 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpa_rq_n6f.rs:67:17\n   |\n67 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpa_rq_n6f.rs:67:25\n\
    \   |\n67 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `unwrap` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpa_rq_n6f."
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().nth(1).unwrap();\n\
    \    let mut result = value.chars().nth(1).unwrap();\n    let mut remainder =\
    \ value.chars().nth(1).unwrap();\n    while remainder.is_digit() {\n        let\
    \ mut digit = remainder.chars().nth(1).unwrap();\n        if digit < '0' || digit\
    \ > '9' {\n            break;\n        }\n        digit = digit - '0';\n     \
    \   let mut new_remainder = remainder.chars().nth(1).unwrap();\n        while\
    \ new_remainder.is_digit() {\n            let mut new_digit = new_remainder.chars().nth(1).unwrap();\n\
    \            if new_digit < '0' || new_digit > '9' {\n                break;\n\
    \            }\n            new_digit = new_digit - '0';\n            if digit\
    \ < new_digit {\n                digit = new_digit;\n                break;\n\
    \            }\n            new_remainder = new_remainder.chars().nth(1).unwrap();\n\
    \        }\n        result = digit;\n        remainder = new_remainder;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpm1rd0zco.rs:46:17\n\
    \   |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpm1rd0zco.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpm1rd0zco.rs:47:17\n   |\n47 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpm1rd0zco.rs:47:25\n\
    \   |\n47 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpm1rd0zco.rs:48:17\n   |\n48 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpm1rd0zco.rs:48:25\n   |\n48 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpm1rd0zco.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpm1rd0zco.rs:49:25\n   |\n49 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpm1rd0zco.rs:50:17\n  \
    \ |\n50 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpm1rd0zco.rs:50:25\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpm1rd0zco.rs:19:21\n\
    \    |\n19  |     while remainder.is_digit() {\n    |                     ^^^^^^^^-\
    \ supplied 0 argument"
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let value = value.to_string();\n    let mut value = value.parse::<isize>().unwrap();\n\
    \    let mut closest_integer = value;\n    let mut prev_value = value;\n    while\
    \ prev_value != value {\n        closest_integer = prev_value;\n        prev_value\
    \ = value;\n        value = value.parse::<isize>().unwrap();\n    }\n    closest_integer\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpmvtqlwuo.rs:29:17\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmvtqlwuo.rs:29:25\n   |\n29 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpmvtqlwuo.rs:30:17\n   |\n30 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpmvtqlwuo.rs:30:25\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpmvtqlwuo.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpmvtqlwuo.rs:31:25\n   |\n31 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpmvtqlwuo.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpmvtqlwuo.rs:32:25\n   |\n32 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpmvtqlwuo.rs:33:17\n  \
    \ |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmvtqlwuo.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `parse` found for type `isize` in the current scope\n  --> /tmp/tmpmvtqlwuo.rs:22:23\n\
    \   |\n22 |         value = value.parse::<isize>().unwrap();\n   |           \
    \            ^^^^^ me"
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut v = value.parse::<isize>().unwrap();\n    if v < 0 {\n        v = -v;\n\
    \    }\n    v\n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmphldyn3kx.rs:24:17\n\
    \   |\n24 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmphldyn3kx.rs:24:25\n   |\n24 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmphldyn3kx.rs:25:17\n   |\n25 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmphldyn3kx.rs:25:25\n\
    \   |\n25 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmphldyn3kx.rs:26:17\n   |\n26 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmphldyn3kx.rs:26:25\n   |\n26 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmphldyn3kx.rs:27:17\n   |\n27 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmphldyn3kx.rs:27:25\n   |\n27 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmphldyn3kx.rs:28:17\n  \
    \ |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmphldyn3kx.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 10 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n    let mut result = value.chars().take_while(|c| c\
    \ >= '0' && c <= '9').count();\n    let mut i = 0;\n    while i < digits {\n \
    \       if result > digits {\n            break;\n        }\n        i += 1;\n\
    \        result -= 1;\n    }\n    i as isize\n}\n\nfn main() {\n    let candidate\
    \ = closest_integer;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpnez7y_ed.rs:31:17\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpnez7y_ed.rs:31:25\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpnez7y_ed.rs:32:17\n   |\n32 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpnez7y_ed.rs:32:25\n\
    \   |\n32 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpnez7y_ed.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpnez7y_ed.rs:33:25\n   |\n33 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpnez7y_ed.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpnez7y_ed.rs:34:25\n   |\n34 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpnez7y_ed.rs:35:17\n  \
    \ |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpnez7y_ed.rs:35:25\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnez7y_ed.rs:16:56\n   |\n16 |     let mut digits = value.chars().take_while(|c|\
    \ c >= '0' && c <= '9');\n   |                                               \
    \         ^^"
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().map(|c|\
    \ c.to_digit(10)).collect::<Vec<_>>();\n    let mut result = 0.0;\n    let mut\
    \ max_diff = 0.0;\n    let mut min_diff = 0.0;\n    let mut max_digits = digits.len();\n\
    \    let mut min_digits = digits.len();\n    let mut max_digit = digits.iter().max().unwrap();\n\
    \    let mut min_digit = digits.iter().min().unwrap();\n    let mut max_digit\
    \ = digits.iter().max().unwrap();\n    let mut min_digit = digits.iter().min().unwrap();\n\
    \    let mut max_digit = digits.iter().max().unwrap();\n    let mut min_digit\
    \ = digits.iter().min().unwrap();\n    let mut max_digit = digits.iter().max().unwrap();\n\
    \    let mut min_digit = digits.iter().min().unwrap();\n    let mut max_digit\
    \ = digits.iter().max().unwrap();\n    let mut min_digit = digits.iter().min().unwrap();\n\
    \    let mut max_digit = digits.iter().max().unwrap();\n    let mut min_digit\
    \ = digits.iter().min().unwrap();\n    let mut max_digit = digits.iter().max().unwrap();\n\
    \    let mut min_digit = digits.iter().min().unwrap();\n    let mut max_digit\
    \ = digits.iter().max().unwrap();\n    let mut min_digit = digits.iter().min().unwrap();\n\
    \    let mut max_digit = digits.iter().max().unwrap();\n    let mut min_digit\
    \ = digits.iter().min().unwrap();\n    let mut max_digit = digits.iter().max().unwrap();\n\
    \    let mut min_digit = digits.iter().min().unwrap();\n    let mut max_digit\
    \ = digits.iter().max().unwrap();\n    let mut min_digit = digits.iter().min().unwrap();\n\
    \    let mut max_digit = digits.iter().max().unwrap();\n    let mut min_digit\
    \ = digits.iter().min().unwrap();\n    let mut max_digit = digits.iter().max().unwrap();\n\
    \    let mut min_digit = digits.iter().min().unwrap();\n    let mut max_digit\
    \ = digits.iter().max().unwrap();\n    let mut min_digit = digits.iter().min().unwrap();\n\
    \    let mut max_digit = digits.iter().max().unwrap();\n    let mut min_digit\
    \ = digits.iter().min().unwrap();\n    let mut max_digit = digits.iter().max().unwrap();\n\
    \    let \n}\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpz0n2_ot0.rs:54:1\n  \
    \ |\n54 | }\n   | ^ expected pattern\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpz0n2_ot0.rs:58:17\n   |\n58 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpz0n2_ot0.rs:58:25\n \
    \  |\n58 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpz0n2_ot0.rs:59:17\n   |\n59 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpz0n2_ot0.rs:59:25\n   |\n59 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpz0n2_ot0.rs:60:17\n   |\n60 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpz0n2_ot0.rs:60:25\n   |\n60 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpz0n2_ot0.rs:61:17\n  \
    \ |\n61 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpz0n2_ot0.rs:61:25\n   |\n61 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpz0n2_ot0.rs:62:17\n   |\n62 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpz0n2_ot0.rs:62:25\n\
    \   |\n62 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0"
  stdout: ''
  timestamp: 1659823262
- exit_code: 1
  program: "/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(String::from(\"\
    10\"))\n/// 10\n/// >>> closest_integer(String::from(\"15.3\"))\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfn closest_integer(value: String) -> isize {\n  \
    \  let mut value = value.to_string();\n    let mut digits = value.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_numeric() {\n            c.to_digit(10).unwrap()\n  \
    \      } else {\n            0\n        }\n    });\n    let mut result = digits[0];\n\
    \    let mut max_diff = 0;\n    for (i, digit) in digits.iter().enumerate() {\n\
    \        let diff = digit - result;\n        if diff > max_diff {\n          \
    \  result = digit;\n            max_diff = diff;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = closest_integer;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp5i1ebpjf.rs:37:17\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5i1ebpjf.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp5i1ebpjf.rs:38:17\n   |\n38 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp5i1ebpjf.rs:38:25\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp5i1ebpjf.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp5i1ebpjf.rs:39:25\n   |\n39 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp5i1ebpjf.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp5i1ebpjf.rs:40:25\n   |\n40 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp5i1ebpjf.rs:41:17\n  \
    \ |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5i1ebpjf.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0608]: cannot\
    \ index into a value of type `Map<Enumerate<Chars<'_>>, [closure@/tmp/tmp5i1ebpjf.rs:16:52:\
    \ 22:6]>`\n  --> /tmp/tmp5i1ebpjf.rs:23:22\n   |\n23 |     let mut result = digits[0];\n\
    \   |           "
  stdout: ''
  timestamp: 1659823262
