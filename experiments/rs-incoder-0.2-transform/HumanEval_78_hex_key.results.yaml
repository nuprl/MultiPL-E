language: rs
name: HumanEval_78_hex_key
results:
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpjx9mhcuc.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpjx9mhcuc.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut count: usize\
    \ = 0;\n    let mut i: usize = 0;\n    while i < num.len() {\n        if num[i]\
    \ == num[num.len() - 1] {\n            i += 1;\n        } else {\n           \
    \ if num[i] == prime[count] {\n                count += 1;\n            } else\
    \ {\n                i += 1;\n            }\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpgql6h1ga.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgql6h1ga.rs:38:5\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \   ----- expected `isize` because of return type\n...\n38 |     count\n   | \
    \    ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n38 |     count.try_into().unwrap()\n\
    \   |          ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut primes\
    \ = vec![false; 26];\n    let mut primes_counter = 0;\n    let mut primes_counter2\
    \ = 0;\n    let mut primes_counter3 = 0;\n    let mut primes_counter4 = 0;\n \
    \   let mut primes_counter5 = 0;\n    let mut primes_counter6 = 0;\n    let mut\
    \ primes_counter7 = 0;\n    let mut primes_counter8 = 0;\n    let mut primes_counter9\
    \ = 0;\n    let mut primes_counter10 = 0;\n    let mut primes_counter11 = 0;\n\
    \    let mut primes_counter12 = 0;\n    let mut primes_counter13 = 0;\n    let\
    \ mut primes_counter14 = 0;\n    let mut primes_counter15 = 0;\n    let mut primes_counter16\
    \ = 0;\n    let mut primes_counter17 = 0;\n    let mut primes_counter18 = 0;\n\
    \    let mut primes_counter19 = 0;\n    let mut primes_counter20 = 0;\n    let\
    \ mut primes_counter21 = 0;\n    let mut primes_counter22 = 0;\n    let mut primes_counter23\
    \ = 0;\n    let mut primes_counter24 = 0;\n    let mut primes_counter25 = 0;\n\
    \    let mut primes_counter26 = 0;\n    let mut primes_counter27 = 0;\n    let\
    \ mut primes_counter28 = 0;\n    let mut primes_counter29 = 0;\n    let mut primes_counter30\
    \ = 0;\n    let mut primes_counter31 = 0;\n    let mut primes_counter32 = 0;\n\
    \    let mut primes_counter33 = 0;\n    let mut primes_counter34 = 0;\n    let\
    \ mut primes_counter35 = 0;\n    let mut primes_counter36 = 0;\n    let mut primes_counter37\
    \ = 0;\n    let mut primes_counter38 = 0;\n    let mut primes_counter39 = 0;\n\
    \    let mut primes_counter40 = 0;\n    let mut primes_counter41 = 0;\n    let\
    \ mut primes_counter42 = 0;\n    let mut primes_counter43 = 0;\n    let mut primes_counter44\
    \ = 0;\n    let mut primes_counter45 = 0;\n    let mut primes_counter46 = 0;\n\
    \    let mut primes_counter47 = 0;\n    let mut primes_counter48 = 0;\n    let\
    \ mut primes_counter49 = 0;\n    let mut primes_counter50 = 0;\n    let mut primes_counter51\
    \ = 0;\n    let mut primes_counter52 = 0;\n    let mut primes_counter53 = 0;\n\
    \    let mut primes_counter54 = 0;\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpn9xy4hsy.rs:79:11\n   |\n\
    79 |     let mu\n   |           ^ help: add `;` here\n80 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn9xy4hsy.rs:22:28\n \
    \  |\n22 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut counter: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_counter:\
    \ usize = 2;\n    let mut prime_counter2: usize = 2;\n    let mut prime_counter3:\
    \ usize = 2;\n    let mut prime_counter4: usize = 2;\n    let mut prime_counter5:\
    \ usize = 2;\n    let mut prime_counter6: usize = 2;\n    let mut prime_counter7:\
    \ usize = 2;\n    let mut prime_counter8: usize = 2;\n    let mut prime_counter9:\
    \ usize = 2;\n    let mut prime_counter10: usize = 2;\n    let mut prime_counter11:\
    \ usize = 2;\n    let mut prime_counter12: usize = 2;\n    let mut prime_counter13:\
    \ usize = 2;\n    let mut prime_counter14: usize = 2;\n    let mut prime_counter15:\
    \ usize = 2;\n    let mut prime_counter16: usize = 2;\n    let mut prime_counter17:\
    \ usize = 2;\n    let mut prime_counter18: usize = 2;\n    let mut prime_counter19:\
    \ usize = 2;\n    let mut prime_counter20: usize = 2;\n    let mut prime_counter21:\
    \ usize = 2;\n    let mut prime_counter22: usize = 2;\n    let mut prime_counter23:\
    \ usize = 2;\n    let mut prime_counter24: usize = 2;\n    let mut prime_counter25:\
    \ usize = 2;\n    let mut prime_counter26: usize = 2;\n    let mut prime_counter27:\
    \ usize = 2;\n    let mut prime_counter28: usize = 2;\n    let mut prime_counter29:\
    \ usize = 2;\n    let mut prime_counter30: usize = 2;\n    let mut prime_counter31:\
    \ usize = 2;\n    let mut prime_counter32: usize = 2;\n    let mut prime_counter33:\
    \ usize = 2;\n    let mut prime_counter34: usize = 2;\n    let mut prime_counter35:\
    \ usize = 2;\n    let mut prime_counter36: usize = 2;\n    let mut prime_counter37:\
    \ usize = 2;\n    let mut prime_counter38: usize = 2;\n    let mut prime_counter39:\
    \ usize = 2;\n    let mut prime_counter40: usize = 2;\n\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2_15qlhw.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmp2_15qlhw.rs:23:55\n     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjxjs0km5.rs:39:36\n   |\n\
    39 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpjxjs0km5.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjxjs0km5.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjxjs0km5.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpjxjs0km5.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjxjs0km5.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut counter: usize\
    \ = 0;\n    let mut digit: usize = 0;\n    let mut prime_digit: usize = 0;\n \
    \   let mut prime_counter: usize = 0;\n    let mut prime_digit_counter: usize\
    \ = 0;\n    let mut prime_digit_counter2: usize = 0;\n    let mut prime_digit_counter3:\
    \ usize = 0;\n    let mut prime_digit_counter4: usize = 0;\n    let mut prime_digit_counter5:\
    \ usize = 0;\n    let mut prime_digit_counter6: usize = 0;\n    let mut prime_digit_counter7:\
    \ usize = 0;\n    let mut prime_digit_counter8: usize = 0;\n    let mut prime_digit_counter9:\
    \ usize = 0;\n    let mut prime_digit_counter10: usize = 0;\n    let mut prime_digit_counter11:\
    \ usize = 0;\n    let mut prime_digit_counter12: usize = 0;\n    let mut prime_digit_counter13:\
    \ usize = 0;\n    let mut prime_digit_counter14: usize = 0;\n    let mut prime_digit_counter15:\
    \ usize = 0;\n    let mut prime_digit_counter16: usize = 0;\n    let mut prime_digit_counter17:\
    \ usize = 0;\n    let mut prime_digit_counter18: usize = 0;\n    let mut prime_digit_counter19:\
    \ usize = 0;\n    let mut prime_digit_counter20: usize = 0;\n    let mut prime_digit_counter21:\
    \ usize = 0;\n    let mut prime_digit_counter22: usize = 0;\n    let mut prime_digit_counter23:\
    \ usize = 0;\n    let mut prime_digit_counter24: usize = 0;\n    let mut prime_digit_counter25:\
    \ usize = 0;\n    let mut prime_digit_counter26: usize = 0;\n    let mut prime_digit_counter27:\
    \ usize = 0;\n    let mut prime_digit_counter28: usize = 0;\n    let mut prime_digit_counter29:\
    \ usize = 0;\n    let mut prime_digit_counter30: usize = 0;\n    let mut prime_digit_counter31:\
    \ usize = 0;\n    let mut prime_digit_counter32: u\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfbjbor76.rs:60:37\n   |\n\
    60 |     let mut prime_digit_counter32: u\n   |                              \
    \       ^ help: add `;` here\n61 | }\n   | - unexpected token\n\nerror[E0412]:\
    \ cannot find type `u` in this scope\n  --> /tmp/tmpfbjbor76.rs:60:36\n   |\n\
    60 |     let mut prime_digit_counter32: u\n   |                              \
    \      ^ help: a builtin type with a similar name exists: `u8`\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpfbjbor76.rs:23:55\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_lowercase().chars().collect();\n     |                    \
    \                                   ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfbjbor76.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_found\
    \ = false;\n    loop {\n        if num[count] == b'a' {\n            prime_found\
    \ = true;\n            break;\n        }\n        count += 1;\n    }\n    if prime_found\
    \ {\n        return prime + 1;\n    }\n    let mut prime_found = false;\n    loop\
    \ {\n        if num[count] == b'b' {\n            prime_found = true;\n      \
    \      break;\n        }\n        count += 1;\n    }\n    if prime_found {\n \
    \       return prime + 2;\n    }\n    let mut prime_found = false;\n    loop {\n\
    \        if num[count] == b'c' {\n            prime_found = true;\n          \
    \  break;\n        }\n        count += 1;\n    }\n    if prime_found {\n     \
    \   return prime + 3;\n    }\n    let mut prime_found = false;\n    loop {\n \
    \       if num[count] == b'd' {\n            prime_found = true;\n           \
    \ break;\n        }\n        count += 1;\n    }\n    if prime_found {\n      \
    \  return prime + 5;\n    }\n    let mut prime_found = false;\n    loop {\n  \
    \      if num[count] == b'e' {\n            prime_found = true;\n            break;\n\
    \        }\n        count += 1;\n    }\n    if prime_found {\n        return prime\
    \ + 7;\n    }\n    let mut prime_found = false;\n    loop {\n        if num[count]\
    \ == b'f' {\n            prime_found = true;\n            break;\n        }\n\
    \        count += 1;\n    }\n    if prime_found {\n        return prime + 11;\n\
    \    }\n    let mut prime_found = false;\n    loop {\n        if num[count] ==\
    \ b'0' {\n            prime_found = true;\n            break;\n        }\n   \
    \     count += 1;\n    }\n    if prime_found {\n        return prime + 13;\n \
    \   }\n    let mut prime_found = false;\n    loop {\n        if num[count] ==\
    \ b'1' {\n            prime_found = true;\n            break;\n        }\n   \
    \     count += 1;\n    }\n    if prime_found {\n        return prime + 17;\n \
    \   }\n    let mut prime_found = false;\n    loop {\n        if num[count] ==\
    \ b'2' {\n            prime_found = true;\n            break;\n        }\n   \
    \     count += 1;\n    }\n    if prime_found {\n        return prime + 19;\n \
    \   }\n    let mut prime_found = false;\n    \n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmputxppzwi.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmputxppzwi.rs:35:16\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \   ----- expected `isize` because of return type\n...\n35 |         return prime\
    \ + 1;\n   |                ^^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n35 |         return (prime + 1).try_into().unwrap();\n  \
    \ |                +         +++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmputxppzwi.rs:22:28\n   |\n22 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut count:\
    \ usize = 0;\n    let mut digit: u8 = 0;\n    let mut i: usize = 0;\n    while\
    \ i < num.len() {\n        digit = num[i] - '0';\n        if prime == digit {\n\
    \            count += 1;\n        }\n        i += 1;\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp60g3iu7s.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: cannot subtract `char` from `u8`\n\
    \  --> /tmp/tmp60g3iu7s.rs:29:24\n   |\n29 |         digit = num[i] - '0';\n \
    \  |                        ^ no implementation for `u8 - char`\n   |\n   = help:\
    \ the trait `Sub<char>` is not implemented for `u8`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n            \
    \ <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]: can't compare\
    \ `Vec<u8>` with `u8`\n  --> /tmp/tmp60g3iu7s.rs:30:18\n   |\n30 |         if\
    \ prime == digit {\n   |                  ^^ no implementation for `Vec<u8> ==\
    \ u8`\n   |\n   = help: the trait `PartialEq<u8>` is not implemented for `Vec<u8>`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as\
    \ PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n      \
    \       <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp60g3iu7s.rs:35:5\n   |\n22 | fn hex_key(num: String) -> isize {\n  \
    \ |                            ----- expected `isize` because of return type\n\
    ...\n35 |     count\n   |     ^^^^^ expected `isize`, found `usize`\n   |\nhelp: "
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_len\
    \ = nums.len();\n    let mut nums_prime: Vec<isize> = vec![0; nums_len];\n   \
    \ let mut nums_prime_len = nums_prime.len();\n    let mut nums_prime_prime: Vec<isize>\
    \ = vec![0; nums_prime_len];\n    let mut nums_prime_prime_len = nums_prime_prime.len();\n\
    \    let mut nums_prime_prime_prime: Vec<isize> = vec![0; nums_prime_prime_len];\n\
    \    let mut nums_prime_prime_prime_len = nums_prime_prime_prime.len();\n    let\
    \ mut nums_prime_prime_prime_prime: Vec<isize> = vec![0; nums_prime_prime_prime_len];\n\
    \    let mut nums_prime_prime_prime_prime_len = nums_prime_prime_prime_prime.len();\n\
    \    let mut nums_prime_prime_prime_prime_prime: Vec<isize> = vec![0; nums_prime_prime_prime_prime_len];\n\
    \    let mut nums_prime_prime_prime_prime_prime_len = nums_prime_prime_prime_prime_prime.len();\n\
    \    let mut nums_prime_prime_prime_prime_prime_len = nums_prime_prime_prime_prime_prime_len.len();\n\
    \    let mut nums_prime_prime_prime_prime_prime_len = nums_prime_prime_prime_prime_prime_len.len();\n\
    \    let mut nums_prime_prime_prime_prime_prime_len = nums_prime_prime_prime_prime_prime_prime_len.len();\n\
    \    let mut nums_prime_prime_prime_prime_prime_prime_len = nums_prime_prime_prime_prime_prime_prime_prime_len.len();\n\
    \    let mut nums_prime_prime_prime_prime_prime_prime_len = nums_prime_prime_prime_prime_prime_prime_prime_len.len();\n\
    \    let mut nums_prime_prime_prime_prime_prime_prime_prime_len = nums_prime_prime_prime_prime_prime_prime_prime_prime_len.len();\n\
    \    let mut nums_prime_prime_prime_prime\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaua6329q.rs:41:41\n   |\n\
    41 |     let mut nums_prime_prime_prime_prime\n   |                          \
    \               ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `nums_prime_prime_prime_prime_prime_prime_len` in this scope\n\
    \  --> /tmp/tmpaua6329q.rs:37:54\n   |\n37 |     let mut nums_prime_prime_prime_prime_prime_len\
    \ = nums_prime_prime_prime_prime_prime_prime_len.len();\n   |                \
    \                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `nums_prime_prime_prime_prime_prime_len`\n\
    \nerror[E0425]: cannot find value `nums_prime_prime_prime_prime_prime_prime_prime_len`\
    \ in this scope\n  --> /tmp/tmpaua6329q.rs:38:60\n   |\n38 |     let mut nums_prime_prime_prime_prime_prime_prime_len\
    \ = nums_prime_prime_prime_prime_prime_prime_prime_len.len();\n   |          \
    \                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `nums_prime_prime_prime_prime_prime_len`\n\
    \nerror[E0425]: cannot find value `nums_prime_prime_prime_prime_prime_prime_prime_len`\
    \ in this scope\n  --> /tmp/tmpaua6329q.rs:39:60\n   |\n39 |     let mut nums_prime_prime_prime_prime_prime_prime_len\
    \ = nums_prime_prime_prime_prime_prime_prime_prime_len.len();\n   |          \
    \                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `nums_prime_prime_prime_prime_prime_prime_len`\n\
    \nerror[E0425]: cannot find value `nums_prime_prime_prime_prime_prime_prime_prime_prime_len`\
    \ in this scope\n  --> /tmp/tmpaua6329q.rs:40:66\n   |\n40 |     let mut nums_prime_prime_prime_prime_prime_prime_prime_len\
    \ = nums_prime_prime_prime_prime_prime_prime_prime_prime_len.len();\n   |    \
    \                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `nums_pr"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digit: Vec<u8>\
    \ = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97];\n    let mut prime_digit_count: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1ufrmn05.rs:46:11\n   |\n\
    46 |     let mu\n   |           ^ help: add `;` here\n47 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp1ufrmn05.rs:23:52\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1ufrmn05.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.to_owned();\n    let mut num: Vec<u8> = num.to_owned();\n\
    \    let mut num: Vec<u8> = num.to_owned();\n    let mut num: Vec<u8> = num.to_owned();\n\
    \    let mut num: Vec<u8> = num.to_owned();\n    let mut num: Vec<u8> = num.to_owned();\n\
    \    let mut num: Vec<u8> = num.to_owned();\n    let mut num: Vec<u8> = num.to_owned();\n\
    \    let mut num: Vec<u8> = num.to_owned();\n    let mut num: Vec<u8> = num.to_owned();\n\
    \    let mut num: Vec<u8> = num.to_owned();\n    let mut num: Vec<u8> = num.to_owned();\n\
    \    let mut num: Vec<u8> = num.to_owned();\n    let mut num: Vec<u8> = num.to_owned();\n\
    \    let mut num: Vec<u8> = num.to_owned();\n    let mut num: Vec<u8> = num.to_owned();\n\
    \    let mut num: Vec<u8> = num.to_owned();\n    let mut num: Vec<u8> = num.to_owned();\n\
    \    let mut num: Vec<u8> = num.to_owned();\n    let mut num: Vec<u8> = num.to_owned();\n\
    \    let mut num: Vec<u8> = num.to_owned();\n    let mut num: Vec<u8> = num.to_owned();\n\
    \    let mut num: Vec<u8> = num.to_owned();\n    let mut num: Vec<u8> = num.to_owned();\n\
    \    let mut num: Vec<u8> = num.to_owned();\n    let mut num: Vec<u8> = num.to_owned();\n\
    \    let mut num: Vec<u8> = num.to_owned();\n    let mut num: Vec<u8> = num.to_owned();\n\
    \    let mut num: Vec<u8> = num.to_owned();\n    let mut num: Vec<u8> = num.to_owned();\n\
    \    let mut num: Vec<u8> = num.to_ow\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpejr4xmwo.rs:54:37\n   |\n\
    54 |     let mut num: Vec<u8> = num.to_ow\n   |                              \
    \       ^ help: add `;` here\n55 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpejr4xmwo.rs:23:52\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_string().chars().collect();\n     |                       \
    \                             ^^^^^^^ value of type `Vec<u8>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0609]:\
    \ no field `to_ow` on type `Vec<u8>`\n  --> /tmp/tmpejr4xmwo.rs:54:32\n   |\n\
    54 |     let mut num: Vec<u8> = num.to_ow\n   |                              \
    \  ^^^^^ unknown field\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpejr4xmwo.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0609.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.in\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `in`\n  --> /tmp/tmpdp6kfoi9.rs:39:32\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \      ^^ expected identifier, found keyword\n   |\nhelp: escape `in` to use it\
    \ as an identifier\n   |\n39 |     let mut num: Vec<u8> = num.r#in\n   |     \
    \                           ++\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpdp6kfoi9.rs:39:34\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \        ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpdp6kfoi9.rs:23:52\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_string().chars().collect();\n     |                       \
    \                             ^^^^^^^ value of type `Vec<u8>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdp6kfoi9.rs:24:61\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |\
    \                                                             ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdp6kfoi9.rs:24:73\n\
    \   |\n24 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' &&\
    \ x <= '9').collect();\n   |                                                 \
    \                        ^^^ expected `u8`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdp6kfoi9.rs:25:61\n   |\n25 |     let mut num: Vec<u8>\
    \ = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n   |       \
    \                                                      ^^^ expected `u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdp6kfoi9.rs:25:73\n\
    \   |\n25 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' &&\
    \ x <= 'F').collect();\n   |              "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: isize = 0;\n    let mut prime_found = false;\n    let mut\
    \ prime_found2 = false;\n    let mut prime_found3 = false;\n    let mut prime_found4\
    \ = false;\n    let mut prime_found5 = false;\n    let mut prime_found6 = false;\n\
    \    let mut prime_found7 = false;\n    let mut prime_found8 = false;\n    let\
    \ mut prime_found9 = false;\n    let mut prime_found10 = false;\n    let mut prime_found11\
    \ = false;\n    let mut prime_found12 = false;\n    let mut prime_found13 = false;\n\
    \    let mut prime_found14 = false;\n    let mut prime_found15 = false;\n    let\
    \ mut prime_found16 = false;\n    let mut prime_found17 = false;\n    let mut\
    \ prime_found18 = false;\n    let mut prime_found19 = false;\n    let mut prime_found20\
    \ = false;\n    let mut prime_found21 = false;\n    let mut prime_found22 = false;\n\
    \    let mut prime_found23 = false;\n    let mut prime_found24 = false;\n    let\
    \ mut prime_found25 = false;\n    let mut prime_found26 = false;\n    let mut\
    \ prime_found27 = false;\n    let mut prime_found28 = false;\n    let mut prime_found29\
    \ = false;\n    let mut prime_found30 = false;\n    let mut prime_found31 = false;\n\
    \    let mut prime_found32 = false;\n    let mut prime_found33 = false;\n    let\
    \ mut prime_found34 = false;\n    let mut prime_found35 = false;\n    let mut\
    \ prime_found36 = false;\n    let mut prime_found37 = false;\n    let mut prime_found38\
    \ = false;\n    let mut prime_found39 = false;\n    let mut prime_found40 = false;\n\
    \    let mut prime_found41 = false;\n    let mut prime_found42 = false;\n    let\
    \ mut prime_found43 = false;\n    let mut prime_found44 = false;\n    let mut\
    \ prime_found45 = false;\n    let mut prime_found46 = false;\n    let mut prime_found47\
    \ = false;\n    let mut prime_found48 = false;\n    let mut prime_found49 = false;\n\
    \    let mut prime_found50 = false;\n    let mut prime_found51 = false;\n    let\
    \ mut prime_found52 = false;\n    let mut prime_found53 = false;\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp0dw1soub.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0dw1soub.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut\
    \ num_prime_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23];\n    let mut\
    \ num_prime_prime_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29];\n\
    \    let mut num_prime_prime_prime_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31];\n    let mut num_prime_prime_prime_prime_prime: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37];\n    let mut num_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41];\n    let mut\
    \ num_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = vec![2, 3, 5, 7, 11,\
    \ 13, 17, 19, 23, 29, 31, 37, 41, 43 ];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53 ];\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61 ];\n    let\
    \ mut num_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = vec![2, 3,\
    \ 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71 ];\n  \
    \  let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8>\
    \ = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73 ];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79 ];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzz_0qz9q.rs:36:59\n   |\n\
    36 |     let mut num_prime_prime_prime_prime_prime_prime_prime_\n   |        \
    \                                                   ^ help: add `;` here\n37 |\
    \ }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpzz_0qz9q.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzz_0qz9q.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: isize = 0;\n    let mut prime_digit_index: isize = 0;\n\
    \    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index: isize\
    \ = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ isize = 0;\n    let mut prime_digit_count: isize = 0;\n\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp256i9lk2.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmp256i9lk2.rs:23:55\n     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|&c| match c {\n        'a' => 0xa,\n\
    \        'b' => 0xb,\n        'c' => 0xc,\n        'd' => 0xd,\n        'e' =>\
    \ 0xe,\n        'f' => 0xf,\n        _ => c,\n    }).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|&c| match c {\n        '0' => 0x0,\n        '1' =>\
    \ 0x1,\n        '2' => 0x2,\n        '3' => 0x3,\n        '4' => 0x4,\n      \
    \  '5' => 0x5,\n        '6' => 0x6,\n        '7' => 0x7,\n        '8' => 0x8,\n\
    \        '9' => 0x9,\n        _ => c,\n    }).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|&c| match c {\n        'A' => 0xa,\n        'B' => 0xb,\n\
    \        'C' => 0xc,\n        'D' => 0xd,\n        'E' => 0xe,\n        'F' =>\
    \ 0xf,\n        _ => c,\n    }).collect();\n    let mut num: Vec<u8> = num.iter().map(|&c|\
    \ match c {\n        '2' => 0x2,\n        '3' => 0x3,\n        '5' => 0x5,\n \
    \       '7' => 0x7,\n        'B' => 0xb,\n        'D' => 0xd,\n        _ => c,\n\
    \    }).collect();\n    let mut num: Vec<u8> = num.iter().map(|&c| match c {\n\
    \        '3' => 0x3,\n        '5' => 0x5,\n        '7' => 0x7,\n        'B' =>\
    \ 0xb,\n        'D' => 0xd,\n        _ => c,\n    }).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|&c| match c {\n        '5' => 0x5,\n        '7' =>\
    \ 0x7,\n        'B' => 0xb,\n        'D' => 0xd,\n        _ => c,\n    }).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|&c| match c {\n        '7' => 0x7,\n\
    \        'B' => 0xb,\n        'D' => 0xd,\n        _ => c,\n    }).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|&c| match c {\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp5xaqtz6n.rs:96:3\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - unclosed delimiter\n...\n85 |     let mut num: Vec<u8> = num.iter().map(|&c|\
    \ match c {\n   |                                          - unclosed delimiter\n\
    ...\n96 | }\n   |   ^\n\nerror: expected one of `)`, `,`, `.`, `?`, or an operator,\
    \ found keyword `fn`\n  --> /tmp/tmp5xaqtz6n.rs:88:1\n   |\n86 | }\n   |  - expected\
    \ one of `)`, `,`, `.`, `?`, or an operator\n87 | \n88 | fn main() {\n   | ^^\
    \ unexpected token\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c != 'b' && c !=\
    \ 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|&c| c != '0').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c != '1').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c !=\
    \ '2').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c != '3').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c != '4').collect();\n    let\
    \ mut num: Vec<u8> = num.iter().filter(|&c| c != '5').collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|&c| c != '6').collect();\n    let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c != '7').collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|&c| c != '8').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c != '9').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c !=\
    \ 'A').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c != 'B').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c != 'C').collect();\n    let\
    \ mut num: Vec<u8> = num.iter().filter(|&c| c != 'D').collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|&c| c != 'E').collect();\n    let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c != 'F').collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|&c| c != 'a').collect();\n    let mut num: \n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpy2t0fh0c.rs:43:1\n   |\n\
    42 |     let mut num: \n   |         ------- while parsing the type for `mut num`\n\
    43 | }\n   | ^ expected type\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpy2t0fh0c.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy2t0fh0c.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c !=\
    \ 'b' && c != 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n   |      \
    \                                                  ^^^ expected `u8`, found `char`\n\
    \nerror[E0277]: can't compare `&u8` with `char`\n  --> /tmp/tmpy2t0fh0c.rs:24:53\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c !=\
    \ 'b' && c != 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n   |      \
    \                                               ^^ no implementation for `&u8\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&u8`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy2t0fh0c.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c !=\
    \ 'b' && c != 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n   |      \
    \                                                              ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0277]: can't compare `&u8` with `char`\n  --> /tmp/tmpy2t0fh0c.rs:24:65\n\
    \   |\n24 |"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count = 1;\n    let mut prime: Vec<u8> = vec![2, 3];\n    let mut\
    \ prime_found = false;\n    let mut prime_found2 = false;\n    let mut prime_found3\
    \ = false;\n    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n\
    \    let mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let\
    \ mut prime_found8 = false;\n    let mut prime_found9 = false;\n    let mut prime_found10\
    \ = false;\n    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n\
    \    let mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let\
    \ mut prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut\
    \ prime_found17 = false;\n    let mut prime_found18 = false;\n    let mut prime_found19\
    \ = false;\n    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n\
    \    let mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let\
    \ mut prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut\
    \ prime_found26 = false;\n    let mut prime_found27 = false;\n    let mut prime_found28\
    \ = false;\n    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n\
    \    let mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let\
    \ mut prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut\
    \ prime_found35 = false;\n    let mut prime_found36 = false;\n    let mut prime_found37\
    \ = false;\n    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n\
    \    let mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let\
    \ mut prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut\
    \ prime_found44 = false;\n    let mut prime_found45 = false;\n    let mut prime_found46\
    \ = false;\n    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n\
    \    let mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let\
    \ mut prime_found51 = false;\n    let mut prime_found\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8y4f56sh.rs:77:24\n   |\n\
    77 |     let mut prime_found\n   |                        ^ help: add `;` here\n\
    78 | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmp8y4f56sh.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8y4f56sh.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpq2uawl3y.rs:39:36\n   |\n\
    39 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpq2uawl3y.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq2uawl3y.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq2uawl3y.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpq2uawl3y.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq2uawl3y.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf8uq_llq.rs:39:36\n   |\n\
    39 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpf8uq_llq.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf8uq_llq.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8uq_llq.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpf8uq_llq.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8uq_llq.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgqi8w048.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpgqi8w048.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgqi8w048.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgqi8w048.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpgqi8w048.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgqi8w048.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut counter: usize\
    \ = 0;\n    for &c in num {\n        if prime == vec![2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] {\n\
    \            counter += 1;\n        }\n        if prime == vec![2, 3, 5, 7, 11,\
    \ 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\
    \ 97] {\n            counter += 1;\n        }\n        if prime == vec![2, 3,\
    \ 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79,\
    \ 83, 89, 97] {\n            counter += 1;\n        }\n        if prime == vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97] {\n            counter += 1;\n        }\n        if prime ==\
    \ vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97] {\n            counter += 1;\n        }\n        if\
    \ prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97] {\n            counter += 1;\n        }\n  \
    \      if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,\
    \ 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] {\n            counter += 1;\n     \
    \   }\n        if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] {\n            counter += 1;\n\
    \        }\n        if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] {\n            counter +=\
    \ 1;\n        }\n        if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 7\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpp0hq5gsx.rs:65:3\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - unclosed delimiter\n...\n26 |     for &c in num {\n   |          \
    \         - this delimiter might not be properly closed...\n...\n55 | }\n   |\
    \ - ...as it matches this but it has different indentation\n...\n65 | }\n   |\
    \   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpp0hq5gsx.rs:54:25\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n54 |         if prime\
    \ == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 7\n   |                         ^ unclosed delimiter\n55 | }\n   | ^\
    \ mismatched closing delimiter\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpp0hq5gsx.rs:55:1\n\
    \   |\n54 |         if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 7\n   |         -- this `if` expression has\
    \ a condition, but no block\n55 | }\n   | ^ expected `{`\n\nerror[E0277]: a value\
    \ of type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmpp0hq5gsx.rs:23:55\n     |\n23   |     let mut num: Vec<u8> =\
    \ num.to_lowercase().chars().collect();\n     |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp0hq5gsx.rs:26:9\n   |\n26 |     for &c in num\
    \ {\n   |         ^^    --- this expression has type `Option<u8>`\n   |      \
    \   |\n   |         expected `u8`, found reference\n   |         help: you can\
    \ probably remove the explicit borrow: `c`\n   |\n   = note:   expected type `u8`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp0hq5gsx.rs:22:28\n\
    \   |\n22 | fn hex_key(num: "
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_digits = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_count = prime_digits_len;\n\
    \    let mut prime_digits_count_2 = prime_digits_count_2;\n    let mut prime_digits_count_3\
    \ = prime_digits_count_3;\n    let mut prime_digits_count_4 = prime_digits_count_4;\n\
    \    let mut prime_digits_count_5 = prime_digits_count_5;\n    let mut prime_digits_count_6\
    \ = prime_digits_count_6;\n    let mut prime_digits_count_7 = prime_digits_count_7;\n\
    \    let mut prime_digits_count_8 = prime_digits_count_8;\n    let mut prime_digits_count_9\
    \ = prime_digits_count_9;\n    let mut prime_digits_count_10 = prime_digits_count_10;\n\
    \    let mut prime_digits_count_11 = prime_digits_count_11;\n    let mut prime_digits_count_12\
    \ = prime_digits_count_12;\n    let mut prime_digits_count_13 = prime_digits_count_13;\n\
    \    let mut prime_digits_count_14 = prime_digits_count_14;\n    let mut prime_digits_count_15\
    \ = prime_digits_count_15;\n    let mut prime_digits_count_16 = prime_digits_count_16;\n\
    \    let mut prime_digits_count_17 = prime_digits_count_17;\n    let mut prime_digits_count_18\
    \ = prime_digits_count_18;\n    let mut prime_digits_count_19 = prime_digits_count_19;\n\
    \    let mut prime_digits_count_20 = prime_digits_count_20;\n    let mut prime_digits_count_21\
    \ = prime_digits_count_21;\n    let mut prime_digits_count_22 = prime_digits_count_22;\n\
    \    let mut prime_digits_count_23 = prime_digits_count_23;\n    let mut prime_digits_count_24\
    \ = prime_digits_count_24;\n    let mut prime_digits_count_25 = prime_digits_count_25;\n\
    \    let mut prime_digits_count_26 = prime_digits_count_26;\n    let mut prime_digits_count_27\
    \ = prime_digits_count_27;\n    let mut prime_digit\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpue_1uew8.rs:53:24\n   |\n\
    53 |     let mut prime_digit\n   |                        ^ help: add `;` here\n\
    54 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `prime_digits_count_2`\
    \ in this scope\n  --> /tmp/tmpue_1uew8.rs:27:36\n   |\n27 |     let mut prime_digits_count_2\
    \ = prime_digits_count_2;\n   |                                    ^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `prime_digits_count`\n\n\
    error[E0425]: cannot find value `prime_digits_count_3` in this scope\n  --> /tmp/tmpue_1uew8.rs:28:36\n\
    \   |\n28 |     let mut prime_digits_count_3 = prime_digits_count_3;\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `prime_digits_count_2`\n\nerror[E0425]: cannot find\
    \ value `prime_digits_count_4` in this scope\n  --> /tmp/tmpue_1uew8.rs:29:36\n\
    \   |\n29 |     let mut prime_digits_count_4 = prime_digits_count_4;\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `prime_digits_count_2`\n\nerror[E0425]: cannot find\
    \ value `prime_digits_count_5` in this scope\n  --> /tmp/tmpue_1uew8.rs:30:36\n\
    \   |\n30 |     let mut prime_digits_count_5 = prime_digits_count_5;\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `prime_digits_count_2`\n\nerror[E0425]: cannot find\
    \ value `prime_digits_count_6` in this scope\n  --> /tmp/tmpue_1uew8.rs:31:36\n\
    \   |\n31 |     let mut prime_digits_count_6 = prime_digits_count_6;\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `prime_digits_count_2`\n\nerror[E0425]: cannot find\
    \ value `prime_digits_count_7` in this scope\n  --> /tmp/tmpue_1uew8.rs:32:36\n\
    \   |\n32 |     let mut prime_digits_count_7 = prime_digits_count_7;\n   |   \
    \                                 ^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `prime_digits_count_2`\n\nerror[E0425]: cannot find\
    \ value `prime_digits_co"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_len\
    \ = nums.len();\n    let mut prime_digits = vec![2, 3];\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_counter = vec![false, false];\n\
    \    let mut prime_digits_counter_len = prime_digits_counter.len();\n    let mut\
    \ prime_digits_counter2 = vec![false, false];\n    let mut prime_digits_counter2_len\
    \ = prime_digits_counter2.len();\n    let mut prime_digits_counter3 = vec![false,\
    \ false];\n    let mut prime_digits_counter3_len = prime_digits_counter3.len();\n\
    \    let mut prime_digits_counter4 = vec![false, false];\n    let mut prime_digits_counter4_len\
    \ = prime_digits_counter4.len();\n    let mut prime_digits_counter5 = vec![false,\
    \ false];\n    let mut prime_digits_counter5_len = prime_digits_counter5.len();\n\
    \    let mut prime_digits_counter6 = vec![false, false];\n    let mut prime_digits_counter6_len\
    \ = prime_digits_counter6.len();\n    let mut prime_digits_counter7 = vec![false,\
    \ false];\n    let mut prime_digits_counter7_len = prime_digits_counter7.len();\n\
    \    let mut prime_digits_counter8 = vec![false, false];\n    let mut prime_digits_counter8_len\
    \ = prime_digits_counter8.len();\n    let mut prime_digits_counter9 = vec![false,\
    \ false];\n    let mut prime_digits_counter9_len = prime_digits_counter9.len();\n\
    \    let mut prime_digits_counter10 = vec![false, false];\n    let mut prime_digits_counter10_len\
    \ = prime_digits_counter10.len();\n    let mut prime_digits_counter11 = vec![false,\
    \ false];\n    let mut prime_digits_counter11_len = prime_digits_counter11.len();\n\
    \    let mut prime_digits_counter12 = vec![false, false];\n    let mut prime_digits_counter12_len\
    \ = prime_digits_counter12.len();\n    let mut prime_digits_counter13 = vec![false,\
    \ false];\n    let mut prime_digits_counter13_len = prime_digits_counter13.len();\n\
    \    let mut prime_digits_counter14 = vec![false, false];\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9qlkivf2.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_digits: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let\
    \ mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_count =\
    \ prime_digits_len;\n    let mut prime_digits_index = 0;\n    let mut prime_digits_index_max\
    \ = prime_digits_len - 1;\n    let mut prime_digits_index_min = 0;\n    let mut\
    \ prime_digits_index_step = 1;\n    let mut prime_digits_index_max = prime_digits_len\
    \ - 1;\n    let mut prime_digits_index_min = 0;\n    let mut prime_digits_index_step\
    \ = 1;\n    let mut prime_digits_index_max = prime_digits_len - 1;\n    let mut\
    \ prime_digits_index_min = 0;\n    let mut prime_digits_index_step = 1;\n    let\
    \ mut prime_digits_index_max = prime_digits_len - 1;\n    let mut prime_digits_index_min\
    \ = 0;\n    let mut prime_digits_index_step = 1;\n    let mut prime_digits_index_max\
    \ = prime_digits_len - 1;\n    let mut prime_digits_index_min = 0;\n    let mut\
    \ prime_digits_index_step = 1;\n    let mut prime_digits_index_max = prime_digits_len\
    \ - 1;\n    let mut prime_digits_index_min = 0;\n    let mut prime_digits_index_step\
    \ = 1;\n    let mut prime_digits_index_max = prime_digits_len - 1;\n    let mut\
    \ prime_digits_index_min = 0;\n    let mut prime_digits_index_step = 1;\n    let\
    \ mut prime_digits_index_max = prime_digits_len - 1;\n    let mut prime_digits_index_min\
    \ = 0;\n    let mut prime_digits_index_step = 1;\n    let mut prime_digits_index_max\
    \ = prime_digits_len - 1;\n    let mut prime_digits_index_min = 0;\n    let mut\
    \ prime_digits_index_step = 1;\n    let mut prime_digits_index_max = prime_digits_len\
    \ - 1;\n    let mut prime_digits_index_min = 0;\n    let mut prime_digits_index_step\
    \ = 1;\n    let mut prime_digits_index_max = prime_digits_len - 1;\n    let mut\
    \ prime_digits_index_min = 0;\n    let mut prime_digits_index_step = 1;\n    let\
    \ mut prime_digits_index_max = prime_digits_len - \n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmplfgcws_w.rs:62:1\n\
    \   |\n62 | }\n   | ^ expected expression\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmplfgcws_w.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![];\n    let mut prime_counter: usize = 0;\n\
    \    let mut prime_counter2: usize = 0;\n    let mut prime_counter3: usize = 0;\n\
    \    let mut prime_counter4: usize = 0;\n    let mut prime_counter5: usize = 0;\n\
    \    let mut prime_counter6: usize = 0;\n    let mut prime_counter7: usize = 0;\n\
    \    let mut prime_counter8: usize = 0;\n    let mut prime_counter9: usize = 0;\n\
    \    let mut prime_counter10: usize = 0;\n    let mut prime_counter11: usize =\
    \ 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13: usize\
    \ = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: usize = 0;\n    let mut prime\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5wxe86xi.rs:65:18\n   |\n\
    65 |     let mut prime\n   |                  ^ help: add `;` here\n66 | }\n \
    \  | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n    --> /tmp/tmp5wxe86xi.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5wxe86xi.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut result: Vec<u8>\
    \ = vec![];\n    let mut i: usize = 0;\n    while i < num.len() {\n        let\
    \ mut j: usize = 0;\n        while j < prime.len() {\n            if num[i] ==\
    \ prime[j] {\n                result.push(num[i]);\n                break;\n \
    \           }\n            j += 1\n        }\n        i += 1;\n    }\n    result.len()\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpqpxhb5fr.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqpxhb5fr.rs:38:5\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \   ----- expected `isize` because of return type\n...\n38 |     result.len()\n\
    \   |     ^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    38 |     result.len().try_into().unwrap()\n   |                 ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count = 1;\n    let mut prime_digits = vec![2, 3];\n    let mut prime_digits_count\
    \ = vec![2, 3];\n    let mut prime_digits_count_2 = vec![2, 3];\n    let mut prime_digits_count_3\
    \ = vec![2, 3];\n    let mut prime_digits_count_4 = vec![2, 3];\n    let mut prime_digits_count_5\
    \ = vec![2, 3];\n    let mut prime_digits_count_6 = vec![2, 3];\n    let mut prime_digits_count_7\
    \ = vec![2, 3];\n    let mut prime_digits_count_8 = vec![2, 3];\n    let mut prime_digits_count_9\
    \ = vec![2, 3];\n    let mut prime_digits_count_10 = vec![2, 3];\n    let mut\
    \ prime_digits_count_11 = vec![2, 3];\n    let mut prime_digits_count_12 = vec![2,\
    \ 3];\n    let mut prime_digits_count_13 = vec![2, 3];\n    let mut prime_digits_count_14\
    \ = vec![2, 3];\n    let mut prime_digits_count_15 = vec![2, 3];\n    let mut\
    \ prime_digits_count_16 = vec![2, 3];\n    let mut prime_digits_count_17 = vec![2,\
    \ 3];\n    let mut prime_digits_count_18 = vec![2, 3];\n    let mut prime_digits_count_19\
    \ = vec![2, 3];\n    let mut prime_digits_count_20 = vec![2, 3];\n    let mut\
    \ prime_digits_count_21 = vec![2, 3];\n    let mut prime_digits_count_22 = vec![2,\
    \ 3];\n    let mut prime_digits_count_23 = vec![2, 3];\n    let mut prime_digits_count_24\
    \ = vec![2, 3];\n    let mut prime_digits_count_25 = vec![2, 3];\n    let mut\
    \ prime_digits_count_26 = vec![2, 3];\n    let mut prime_digits_count_27 = vec![2,\
    \ 3];\n    let mut prime_digits_count_28 = vec![2, 3];\n    let mut prime_digits_count_29\
    \ = vec![2, 3];\n    let mut prime_digits_count_30 = vec![2, 3];\n    let mut\
    \ prime_digits_\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmps9wpr9xd.rs:56:26\n   |\n\
    56 |     let mut prime_digits_\n   |                          ^ help: add `;`\
    \ here\n57 | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmps9wpr9xd.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps9wpr9xd.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoz99ncue.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpoz99ncue.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpoz99ncue.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoz99ncue.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_digits = num.len();\n    let mut prime_digits = 2;\n    let mut\
    \ prime_digits_counter = 0;\n    let mut prime_digits_counter_2 = 0;\n    let\
    \ mut prime_digits_counter_3 = 0;\n    let mut prime_digits_counter_4 = 0;\n \
    \   let mut prime_digits_counter_5 = 0;\n    let mut prime_digits_counter_6 =\
    \ 0;\n    let mut prime_digits_counter_7 = 0;\n    let mut prime_digits_counter_8\
    \ = 0;\n    let mut prime_digits_counter_9 = 0;\n    let mut prime_digits_counter_10\
    \ = 0;\n    let mut prime_digits_counter_11 = 0;\n    let mut prime_digits_counter_12\
    \ = 0;\n    let mut prime_digits_counter_13 = 0;\n    let mut prime_digits_counter_14\
    \ = 0;\n    let mut prime_digits_counter_15 = 0;\n    let mut prime_digits_counter_16\
    \ = 0;\n    let mut prime_digits_counter_17 = 0;\n    let mut prime_digits_counter_18\
    \ = 0;\n    let mut prime_digits_counter_19 = 0;\n    let mut prime_digits_counter_20\
    \ = 0;\n    let mut prime_digits_counter_21 = 0;\n    let mut prime_digits_counter_22\
    \ = 0;\n    let mut prime_digits_counter_23 = 0;\n    let mut prime_digits_counter_24\
    \ = 0;\n    let mut prime_digits_counter_25 = 0;\n    let mut prime_digits_counter_26\
    \ = 0;\n    let mut prime_digits_counter_27 = 0;\n    let mut prime_digits_counter_28\
    \ = 0;\n    let mut prime_digits_counter_29 = 0;\n    let mut prime_digits_counter_30\
    \ = 0;\n    let mut prime_digits_counter_31 = 0;\n    let mut prime_digits_counter_32\
    \ = 0;\n    let mut prime_digits_counter_33 = 0;\n    let mut prime_digits_counter_34\
    \ = 0;\n    let mut prime_digits_counter_35 = 0;\n    let mut prime_digits_counter_36\
    \ = 0;\n    let mut prime_digits_counter_37 = 0;\n    let mut prime_digits_counter_38\
    \ = 0;\n    let mut prime_digits_counter_39 = 0;\n    let mut prime_digits_counter_40\
    \ = 0;\n    let mut prime_digits_counter_41 = 1;\n    let mut prime_digits_counter_42\
    \ = 0;\n    let mut prime_digits_counter_43 = 0;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpm0ts9792.rs:70:1\n\
    \   |\n70 | }\n   | ^ expected identifier\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpm0ts9792.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoz99ncue.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpoz99ncue.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpoz99ncue.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoz99ncue.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_len\
    \ = nums.len();\n    let mut prime_digits = vec![false; 9];\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_sum = 0;\n    let mut prime_digits_sum_len\
    \ = 0;\n    let mut prime_digits_product = 1;\n    let mut prime_digits_product_len\
    \ = 0;\n    let mut prime_digits_product2 = 1;\n    let mut prime_digits_product2_len\
    \ = 0;\n    let mut prime_digits_product3 = 1;\n    let mut prime_digits_product3_len\
    \ = 0;\n    let mut prime_digits_product4 = 1;\n    let mut prime_digits_product4_len\
    \ = 0;\n    let mut prime_digits_product5 = 1;\n    let mut prime_digits_product5_len\
    \ = 0;\n    let mut prime_digits_product6 = 1;\n    let mut prime_digits_product6_len\
    \ = 0;\n    let mut prime_digits_product7 = 1;\n    let mut prime_digits_product7_len\
    \ = 0;\n    let mut prime_digits_product8 = 1;\n    let mut prime_digits_product8_len\
    \ = 0;\n    let mut prime_digits_product9 = 1;\n    let mut prime_digits_product9_len\
    \ = 0;\n    let mut prime_digits_product10 = 1;\n    let mut prime_digits_product10_len\
    \ = 0;\n    let mut prime_digits_product11 = 1;\n    let mut prime_digits_product11_len\
    \ = 0;\n    let mut prime_digits_product12 = 1;\n    let mut prime_digits_product12_len\
    \ = 0;\n    let mut prime_digits_product13 = 1;\n    let mut prime_digits_product13_len\
    \ = 0;\n    let mut prime_digits_product14 = 1;\n    let mut prime_digits_product14_len\
    \ = 0;\n    let mut prime_digits_product15 = 1;\n    let mut prime_digits_product15_len\
    \ = 0;\n    let mut prime_digits_product16 = 1;\n    let mut prime_digits_product16_len\
    \ = 0;\n    let mut prime_digits_product17 = 1;\n    let mut prime_digits_product17_len\
    \ = 0;\n    let mut prime_digits_product18 = 1;\n    let mut prime_digits_product18_len\
    \ = 0;\n    let mut prime_digits_product19 = 1;\n    let mut prime_digits_product19_len\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpt6nctn2i.rs:68:1\n  \
    \ |\n68 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|c| match c {\n        'a' => 1,\n\
    \        'b' => 2,\n        'c' => 3,\n        'd' => 4,\n        'e' => 5,\n\
    \        'f' => 6,\n        _ => 0,\n    }).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|c| match c {\n        '0' => 0,\n        '1' => 1,\n     \
    \   '2' => 2,\n        '3' => 3,\n        '4' => 4,\n        '5' => 5,\n     \
    \   '6' => 6,\n        '7' => 7,\n        '8' => 8,\n        '9' => 9,\n     \
    \   _ => 0,\n    }).collect();\n    let mut num: Vec<u8> = num.iter().map(|c|\
    \ match c {\n        'A' => 10,\n        'B' => 11,\n        'C' => 12,\n    \
    \    'D' => 13,\n        'E' => 14,\n        'F' => 15,\n        _ => 0,\n   \
    \ }).collect();\n    let mut num: Vec<u8> = num.iter().map(|c| match c {\n   \
    \     '2' => 2,\n        '3' => 3,\n        '5' => 5,\n        '7' => 7,\n   \
    \     'B' => 11,\n        'D' => 13,\n        _ => 0,\n    }).collect();\n   \
    \ let mut num: Vec<u8> = num.iter().map(|c| match c {\n        '3' => 3,\n   \
    \     '5' => 5,\n        '7' => 7,\n        'B' => 11,\n        'D' => 13,\n \
    \       _ => 0,\n    }).collect();\n    let mut num: Vec<u8> = num.iter().map(|c|\
    \ match c {\n        '5' => 5,\n        '7' => 7,\n        'B' => 11,\n      \
    \  'D' => 13,\n        _ => 0,\n    }).collect();\n    let mut num: Vec<u8> =\
    \ num.iter().map(|c| match c {\n        '7' => 7,\n        'B' => 11,\n      \
    \  'D' => 13,\n        _ => 0,\n    }).collect();\n    let mut num: Vec<u8> =\
    \ num.iter().map(|c| match c {\n        'B' => 11,\n        'D' => 13,\n     \
    \   _ => 0,\n    }).collect();\n    let mut num: Vec<u8> = num.iter().map(|c|\
    \ match c {\n        'D' => 13,\n\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp1mzp1qgu.rs:103:3\n\
    \    |\n22  | fn hex_key(num: String) -> isize {\n    |                      \
    \            - unclosed delimiter\n...\n90  |     let mut num: Vec<u8> = num.iter().map(|c|\
    \ match c {\n    |                                          - unclosed delimiter\n\
    ...\n103 | }\n    |   ^\n\nerror: expected one of `)`, `,`, `.`, `?`, or an operator,\
    \ found keyword `fn`\n  --> /tmp/tmp1mzp1qgu.rs:95:1\n   |\n93 | }\n   |  - expected\
    \ one of `)`, `,`, `.`, `?`, or an operator\n94 | \n95 | fn main() {\n   | ^^\
    \ unexpected token\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut\
    \ num_prime_2: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_3:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_4: Vec<u8>\
    \ = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_5: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_6: Vec<u8> = vec![2, 3, 5,\
    \ 7, 11, 13, 17, 19];\n    let mut num_prime_7: Vec<u8> = vec![2, 3, 5, 7, 11,\
    \ 13, 17, 19];\n    let mut num_prime_8: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17,\
    \ 19];\n    let mut num_prime_9: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n\
    \    let mut num_prime_10: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let\
    \ mut num_prime_11: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_12:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_13: Vec<u8>\
    \ = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_14: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_15: Vec<u8> = vec![2, 3, 5,\
    \ 7, 11, 13, 17, 19];\n    let mut num_prime_16: Vec<u8> = vec![2, 3, 5, 7, 11,\
    \ 13, 17, 19];\n    let mut num_prime_17: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17,\
    \ 19];\n    let mut num_prime_18: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n\
    \    let mut num_prime_19: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let\
    \ mut num_prime_20: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut num_prime_21:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, \n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpjwyowwlh.rs:44:41\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n44 |     let mut num_prime_21:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, \n   |                                      \
    \   ^ unclosed delimiter\n45 | }\n   | ^ mismatched closing delimiter\n\nerror:\
    \ expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmpjwyowwlh.rs:45:1\n\
    \   |\n45 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\n\
    error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmpjwyowwlh.rs:23:55\n     |\n23   | \
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |    \
    \                                                   ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut counter: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_counter:\
    \ usize = 2;\n    let mut prime_counter2: usize = 2;\n    let mut prime_counter3:\
    \ usize = 2;\n    let mut prime_counter4: usize = 2;\n    let mut prime_counter5:\
    \ usize = 2;\n    let mut prime_counter6: usize = 2;\n    let mut prime_counter7:\
    \ usize = 2;\n    let mut prime_counter8: usize = 2;\n    let mut prime_counter9:\
    \ usize = 2;\n    let mut prime_counter10: usize = 2;\n    let mut prime_counter11:\
    \ usize = 2;\n    let mut prime_counter12: usize = 2;\n    let mut prime_counter13:\
    \ usize = 2;\n    let mut prime_counter14: usize = 2;\n    let mut prime_counter15:\
    \ usize = 2;\n    let mut prime_counter16: usize = 2;\n    let mut prime_counter17:\
    \ usize = 2;\n    let mut prime_counter18: usize = 2;\n    let mut prime_counter19:\
    \ usize = 2;\n    let mut prime_counter20: usize = 2;\n    let mut prime_counter21:\
    \ usize = 2;\n    let mut prime_counter22: usize = 2;\n    let mut prime_counter23:\
    \ usize = 2;\n    let mut prime_counter24: usize = 2;\n    let mut prime_counter25:\
    \ usize = 2;\n    let mut prime_counter26: usize = 2;\n    let mut prime_counter27:\
    \ usize = 2;\n    let mut prime_counter28: usize = 2;\n    let mut prime_counter29:\
    \ usize = 2;\n    let mut prime_counter30: usize = 2;\n    let mut prime_counter31:\
    \ usize = 2;\n    let mut prime_counter32: usize = 2;\n    let mut prime_counter33:\
    \ usize = 2;\n    let mut prime_counter34: usize = 2;\n    let mut prime_counter35:\
    \ usize = 2;\n    let mut prime_counter36: usize = 2;\n    let mut prime_counter37:\
    \ usize = 2;\n    let mut prime_counter38: usize = 2;\n    let mut prime_counter39:\
    \ usize = 2;\n    let mut prime_counter40: usize = 2;\n\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2_15qlhw.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmp2_15qlhw.rs:23:55\n     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_digits = num.len();\n    let mut num_primes = 0;\n    let mut\
    \ num_primes_digits = 0;\n    let mut num_primes_digits_primes = 0;\n    let mut\
    \ num_primes_digits_primes_primes = 0;\n    let mut num_primes_digits_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes = 0;\n    let\
    \ mut num_primes_digits_primes_primes_primes_primes_primes = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_prime\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk5hr7fjn.rs:44:78\n   |\n\
    44 |     let mut num_primes_digits_primes_primes_primes_primes_primes_primes_prime\n\
    \   |                                                                        \
    \      ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpk5hr7fjn.rs:23:55\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_lowercase().chars().collect();\n     |                    \
    \                                   ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk5hr7fjn.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_prime: Vec<u8> = vec![0; 8];\n    let mut num_prime_counter: usize\
    \ = 0;\n    let mut num_prime_counter2: usize = 0;\n    let mut num_prime_counter3:\
    \ usize = 0;\n    let mut num_prime_counter4: usize = 0;\n    let mut num_prime_counter5:\
    \ usize = 0;\n    let mut num_prime_counter6: usize = 0;\n    let mut num_prime_counter7:\
    \ usize = 0;\n    let mut num_prime_counter8: usize = 0;\n    let mut num_prime_counter9:\
    \ usize = 0;\n    let mut num_prime_counter10: usize = 0;\n    let mut num_prime_counter11:\
    \ usize = 0;\n    let mut num_prime_counter12: usize = 0;\n    let mut num_prime_counter13:\
    \ usize = 0;\n    let mut num_prime_counter14: usize = 0;\n    let mut num_prime_counter15:\
    \ usize = 0;\n    let mut num_prime_counter16: usize = 0;\n    let mut num_prime_counter17:\
    \ usize = 0;\n    let mut num_prime_counter18: usize = 0;\n    let mut num_prime_counter19:\
    \ usize = 0;\n    let mut num_prime_counter20: usize = 0;\n    let mut num_prime_counter21:\
    \ usize = 0;\n    let mut num_prime_counter22: usize = 0;\n    let mut num_prime_counter23:\
    \ usize = 0;\n    let mut num_prime_counter24: usize = 0;\n    let mut num_prime_counter25:\
    \ usize = 0;\n    let mut num_prime_counter26: usize = 0;\n    let mut num_prime_counter27:\
    \ usize = 0;\n    let mut num_prime_counter28: usize = 0;\n    let mut num_prime_counter29:\
    \ usize = 0;\n    let mut num_prime_counter30: usize = 0;\n    let mut num_prime_counter31:\
    \ usize = 0;\n    let mut num_prime_counter32: usize = 0;\n    let mut num_prime_counter33:\
    \ usize = 0;\n    let mut num_prime_counter34: usize = 0;\n    let mut num_prime_counter35:\
    \ usize = 0;\n    let mut num_prime_counter36: usize = 0;\n    let mut num_prime_counter37:\
    \ usize = 0;\n\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpz3pbnbml.rs:23:52\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz3pbnbml.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut counter: usize\
    \ = 0;\n    let mut prime_counter: usize = 0;\n    let mut prime_counter2: usize\
    \ = 0;\n    let mut prime_counter3: usize = 0;\n    let mut prime_counter4: usize\
    \ = 0;\n    let mut prime_counter5: usize = 0;\n    let mut prime_counter6: usize\
    \ = 0;\n    let mut prime_counter7: usize = 0;\n    let mut prime_counter8: usize\
    \ = 0;\n    let mut prime_counter9: usize = 0;\n    let mut prime_counter10: usize\
    \ = 0;\n    let mut prime_counter11: usize = 0;\n    let mut prime_counter12:\
    \ usize = 0;\n    let mut prime_counter13: usize = 0;\n    let mut prime_counter14:\
    \ usize = 0;\n    let mut prime_counter15: usize = 0;\n    let mut prime_counter16:\
    \ usize = 0;\n    let mut prime_counter17: usize = 0;\n    let mut prime_counter18:\
    \ usize = 0;\n    let mut prime_counter19: usize = 0;\n    let mut prime_counter20:\
    \ usize = 0;\n    let mut prime_counter21: usize = 0;\n    let mut prime_counter22:\
    \ usize = 0;\n    let mut prime_counter23: usize = 0;\n    let mut prime_counter24:\
    \ usize = 0;\n    let mut prime_counter25: usize = 0;\n    let mut prime_counter26:\
    \ usize = 0;\n    let mut prime_counter27: usize = 0;\n    let mut prime_counter28:\
    \ usize = 0;\n    let mut prime_counter29: usize = 0;\n    let mut prime_counter30:\
    \ usize = 0;\n    let mut prime_counter31: usize = 0;\n    let mut prime_counter32:\
    \ usize = 0;\n    let mut prime_counter33: usize = 0;\n    let mut prime_counter34:\
    \ usize = 0;\n    let mut prime_counter35: usize = 0;\n    let mut prime_counter36:\
    \ usize = 0;\n    let mut prime_counter37: usize = 0;\n\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpzj3mo_xg.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzj3mo_xg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = num.clone(); // clone num\n    num_prime.pop();\n\
    \    let mut num_prime_prime: Vec<u8> = num_prime.clone(); // clone num_prime\n\
    \    num_prime_prime.pop();\n    let mut num_prime_prime_prime: Vec<u8> = num_prime_prime.clone();\
    \ // clone num_prime_prime\n    num_prime_prime_prime.pop();\n    let mut num_prime_prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime.clone(); // clone num_prime_prime_prime\n  \
    \  num_prime_prime_prime_prime.pop();\n    let mut num_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime.clone(); // clone num_prime_prime_prime_prime\n\
    \    num_prime_prime_prime_prime_prime.pop();\n    let mut num_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime.clone(); // clone num_prime_prime_prime_prime_prime\n\
    \    num_prime_prime_prime_prime_prime_prime.pop();\n    let mut num_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_prime.clone(); // clone num_prime_prime_prime_prime_prime_prime\n\
    \    num_prime_prime_prime_prime_prime_prime.pop();\n    let mut num_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime.clone(); // clone num_prime_prime_prime_prime_prime_prime_prime\n\
    \    num_prime_prime_prime_prime_prime_prime_prime.pop();\n    let mut num_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime.clone(); // clone\
    \ num_prime_prime_prime_prime_prime_prime_prime_prime\n    num_prime_prime_prime_prime_prime_prime_prime_prime.pop();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp412c90mo.rs:42:86\n   |\n\
    42 |     let mut num_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8>\
    \ = num_prime_\n   |                                                         \
    \                             ^ help: add `;` here\n43 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `num_prime_prime_prime_prime_prime_prime_prime`\
    \ in this scope\n  --> /tmp/tmp412c90mo.rs:38:70\n   |\n38 | ...prime_prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime.clone(); // clone num_prime_prime_prime_prime_prime_p...\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `num_prime_prime_prime_prime_prime_prime`\n\
    \nerror[E0425]: cannot find value `num_prime_prime_prime_prime_prime_prime_prime_prime`\
    \ in this scope\n  --> /tmp/tmp412c90mo.rs:40:70\n   |\n40 | ...ime_prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime.clone(); // clone\
    \ num_prime_prime_prime_prime_pri...\n   |                                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `num_prime_prime_prime_prime_prime_prime_prime`\n\
    \nerror[E0425]: cannot find value `num_prime_prime_prime_prime_prime_prime_prime_prime`\
    \ in this scope\n  --> /tmp/tmp412c90mo.rs:41:5\n   |\n41 |     num_prime_prime_prime_prime_prime_prime_prime_prime.pop();\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `num_prime_prime_prime_prime_prime_prime_prime`\n\
    \nerror[E0425]: cannot find value `num_prime_` in this scope\n  --> /tmp/tmp412c90mo.rs:42:76\n\
    \   |\n42 |     let mut num_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8>\
    \ = num_prime_\n   |                                                         \
    \                   ^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `num_prime`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpvehoplbw.rs:23:52\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0599]: no method named `to_digit` found for type\
    \ `u8` in the current scope\n  --> /tmp/tmpvehoplbw.rs:24:54\n   |\n24 |     let\
    \ mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n   |\
    \                                                      ^^^^^^^^ method not found\
    \ in `u8`\n\nerror[E0599]: no method named `to_digit` found for type `u8` in the\
    \ current scope\n  --> /tmp/tmpvehoplbw.rs:25:54\n   |\n25 |     let mut num:\
    \ Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n   |         \
    \                                             ^^^^^^^^ method not found in `u8`\n\
    \nerror[E0599]: no method named `to_digit` found for type `u8` in the current\
    \ scope\n  --> /tmp/tmpvehoplbw.rs:26:54\n   |\n26 |     let mut num: Vec<u8>\
    \ = num.into_iter().map(|x| x.to_digit(16)).collect();\n   |                 \
    \                                     ^^^^^^^^ method not found in `u8`\n\nerror[E0599]:\
    \ no method named `to_digit` found for type `u8` in the current scope\n  --> /tmp/tmpvehoplbw.rs:27:54\n\
    \   |\n27 |     let mut num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n\
    \   |                                                      ^^^^^^^^ method not\
    \ found in `u8`\n\nerror[E0599]: no method named `to_digit` found for type `u8`\
    \ in the current scope\n  --> /tmp/tmpvehoplbw.rs:28:54\n   |\n28 |     let mut\
    \ num: Vec<u8> = num.into_iter().map(|x| x.to_digit(16)).collect();\n   |    \
    \                                                  ^^^^^^^^ method not found in\
    \ `u8`\n\nerror[E0599]: no method "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime_count: isize = 0;\n    let mut prime: isize = 2;\n    while prime\
    \ < num.len() {\n        if num[prime] == '0' {\n            prime_count = prime_count\
    \ + 1;\n        }\n        prime = prime + 2;\n    }\n    prime_count\n}\n\nfn\
    \ main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpzn23a9si.rs:23:52\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzn23a9si.rs:26:19\n\
    \   |\n26 |     while prime < num.len() {\n   |                   ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n26 |     while prime < num.len().try_into().unwrap()\
    \ {\n   |                            ++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[u8]` cannot be indexed by `isize`\n  --> /tmp/tmpzn23a9si.rs:27:12\n\
    \   |\n27 |         if num[prime] == '0' {\n   |            ^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<u8>`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpjx9mhcuc.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpjx9mhcuc.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_digits = num.len();\n    let mut prime_digits = false;\n    let\
    \ mut prime_number = 0;\n    let mut prime_number_counter = 0;\n    let mut prime_number_counter2\
    \ = 0;\n    let mut prime_number_counter3 = 0;\n    let mut prime_number_counter4\
    \ = 0;\n    let mut prime_number_counter5 = 0;\n    let mut prime_number_counter6\
    \ = 0;\n    let mut prime_number_counter7 = 0;\n    let mut prime_number_counter8\
    \ = 0;\n    let mut prime_number_counter9 = 0;\n    let mut prime_number_counter10\
    \ = 0;\n    let mut prime_number_counter11 = 0;\n    let mut prime_number_counter12\
    \ = 0;\n    let mut prime_number_counter13 = 0;\n    let mut prime_number_counter14\
    \ = 0;\n    let mut prime_number_counter15 = 0;\n    let mut prime_number_counter16\
    \ = 0;\n    let mut prime_number_counter17 = 0;\n    let mut prime_number_counter18\
    \ = 0;\n    let mut prime_number_counter19 = 0;\n    let mut prime_number_counter20\
    \ = 0;\n    let mut prime_number_counter21 = 0;\n    let mut prime_number_counter22\
    \ = 0;\n    let mut prime_number_counter23 = 0;\n    let mut prime_number_counter24\
    \ = 0;\n    let mut prime_number_counter25 = 0;\n    let mut prime_number_counter26\
    \ = 0;\n    let mut prime_number_counter27 = 0;\n    let mut prime_number_counter28\
    \ = 0;\n    let mut prime_number_counter29 = 0;\n    let mut prime_number_counter30\
    \ = 0;\n    let mut prime_number_counter31 = 0;\n    let mut prime_number_counter32\
    \ = 0;\n    let mut prime_number_counter33 = 0;\n    let mut prime_number_counter34\
    \ = 0;\n    let mut prime_number_counter35 = 0;\n    let mut prime_number_counter36\
    \ = 0;\n    let mut prime_number_counter37 = 0;\n    let mut prime_number_counter38\
    \ = 0;\n    let mut prime_number_counter39 = 0;\n    let mut prime_number_counter40\
    \ = 0;\n    let mut prime_number_counter41 = 0;\n    let mut prime_number_counter42\
    \ = 0;\n    let mut prime_number_counter43 = 0;\n    let mut prime_number_counter44\
    \ = 0;\n    let mut prime_number_counter45 = 0;\n    let mut prime_number_counter46\
    \ = 0;\n    let mut prime_number_counter47 = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp2mkjgqif.rs:23:52\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2mkjgqif.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmf3oq_4v.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpmf3oq_4v.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpmf3oq_4v.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmf3oq_4v.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let mut\
    \ prime_digit_count: isize = 0;\n    let mut prime_digit_sum: isize = 0;\n   \
    \ let mut prime_digit_sum2: isize = 0;\n    let mut prime_digit_sum3: isize =\
    \ 0;\n    let mut prime_digit_sum4: isize = 0;\n    let mut prime_digit_sum5:\
    \ isize = 0;\n    let mut prime_digit_sum6: isize = 0;\n    let mut prime_digit_sum7:\
    \ isize = 0;\n    let mut prime_digit_sum8: isize = 0;\n    let mut prime_digit_sum9:\
    \ isize = 0;\n    let mut prime_digit_sum10: isize = 0;\n    let mut prime_digit_sum11:\
    \ isize = 0;\n    let mut prime_digit_sum12: isize = 0;\n    let mut prime_digit_sum13:\
    \ isize = 0;\n    let mut prime_digit_sum14: isize = 0;\n    let mut prime_digit_sum15:\
    \ isize = 0;\n    let mut prime_digit_sum16: isize = 0;\n    let mut prime_digit_sum17:\
    \ isize = 0;\n    let mut prime_digit_sum18: isize = 0;\n    let mut prime_digit_sum19:\
    \ isize = 0;\n    let mut prime_digit_sum20: isize = 0;\n    let mut prime_digit_sum21:\
    \ isize = 0;\n    let mut prime_digit_sum22: isize = 0;\n    let mut prime_digit_sum23:\
    \ isize = 0;\n    let mut prime_digit_sum24: isize = 0;\n    let mut prime_digit_sum25:\
    \ isize = 0;\n    let mut prime_digit_sum26: isize = 0;\n    let mut prime_digit_sum27:\
    \ isize = 0;\n    let mut prime_digit_sum28: isize = 0;\n    let mut prime_digit_sum29:\
    \ isize = 0;\n    let mut prime_digit_sum30: isize = 0;\n    let mut prime_digit_sum31:\
    \ isize = 0;\n    let mut prime_digit_sum32: isize = 0;\n    let mut prime_digit_sum33:\
    \ isize = 0;\n    let mut prime_digit_sum34: isize = 0;\n    let mut prime_digit_sum35:\
    \ isize = 0;\n    let mut prime_digit_sum36: isize = 0;\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp13eza8if.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmp13eza8if.rs:23:52\n     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = 0;\n    let mut nums: Vec<isize> = num.chars().collect();\n\
    \    let mut prime_digits: Vec<isize> = vec![2, 3];\n    let mut prime_digits_count:\
    \ usize = 0;\n    let mut prime_digits_count_2: usize = 0;\n    let mut prime_digits_count_3:\
    \ usize = 0;\n    let mut prime_digits_count_4: usize = 0;\n    let mut prime_digits_count_5:\
    \ usize = 0;\n    let mut prime_digits_count_6: usize = 0;\n    let mut prime_digits_count_7:\
    \ usize = 0;\n    let mut prime_digits_count_8: usize = 0;\n    let mut prime_digits_count_9:\
    \ usize = 0;\n    let mut prime_digits_count_10: usize = 0;\n    let mut prime_digits_count_11:\
    \ usize = 0;\n    let mut prime_digits_count_12: usize = 0;\n    let mut prime_digits_count_13:\
    \ usize = 0;\n    let mut prime_digits_count_14: usize = 0;\n    let mut prime_digits_count_15:\
    \ usize = 0;\n    let mut prime_digits_count_16: usize = 0;\n    let mut prime_digits_count_17:\
    \ usize = 0;\n    let mut prime_digits_count_18: usize = 0;\n    let mut prime_digits_count_19:\
    \ usize = 0;\n    let mut prime_digits_count_20: usize = 0;\n    let mut prime_digits_count_21:\
    \ usize = 0;\n    let mut prime_digits_count_22: usize = 0;\n    let mut prime_digits_count_23:\
    \ usize = 0;\n    let mut prime_digits_count_24: usize = 0;\n    let mut prime_digits_count_25:\
    \ usize = 0;\n    let mut prime_digits_count_26: usize = 0;\n    let mut prime_digits_count_27:\
    \ usize = 0;\n    let mut prime_digits_count_28: usize = 0;\n    let mut prime_digits_count_29:\
    \ usize = 0;\n    let mut prime_digits_count_30: usize = 0;\n    let mut prime_digits_count_31:\
    \ usize = 0;\n    let mut prime_digits_count_32: usize = 0;\n    let mut prime_digits_count_33:\
    \ usize = 0;\n    let mut prime_digits_count_34: \n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpnjnvern3.rs:60:1\n   |\n\
    59 |     let mut prime_digits_count_34: \n   |         -------------------------\
    \ while parsing the type for `mut prime_digits_count_34`\n60 | }\n   | ^ expected\
    \ type\n\nerror[E0599]: no method named `chars` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpnjnvern3.rs:24:36\n   |\n24 |     let mut nums:\
    \ Vec<isize> = num.chars().collect();\n   |                                  \
    \  ^^^^^ method not found in `isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime: isize = 0;\n    let mut prime_found = false;\n    let mut prime_found2\
    \ = false;\n    let mut prime_found3 = false;\n    let mut prime_found4 = false;\n\
    \    let mut prime_found5 = false;\n    let mut prime_found6 = false;\n    let\
    \ mut prime_found7 = false;\n    let mut prime_found8 = false;\n    let mut prime_found9\
    \ = false;\n    let mut prime_found10 = false;\n    let mut prime_found11 = false;\n\
    \    let mut prime_found12 = false;\n    let mut prime_found13 = false;\n    let\
    \ mut prime_found14 = false;\n    let mut prime_found15 = false;\n    let mut\
    \ prime_found16 = false;\n    let mut prime_found17 = false;\n    let mut prime_found18\
    \ = false;\n    let mut prime_found19 = false;\n    let mut prime_found20 = false;\n\
    \    let mut prime_found21 = false;\n    let mut prime_found22 = false;\n    let\
    \ mut prime_found23 = false;\n    let mut prime_found24 = false;\n    let mut\
    \ prime_found25 = false;\n    let mut prime_found26 = false;\n    let mut prime_found27\
    \ = false;\n    let mut prime_found28 = false;\n    let mut prime_found29 = false;\n\
    \    let mut prime_found30 = false;\n    let mut prime_found31 = false;\n    let\
    \ mut prime_found32 = false;\n    let mut prime_found33 = false;\n    let mut\
    \ prime_found34 = false;\n    let mut prime_found35 = false;\n    let mut prime_found36\
    \ = false;\n    let mut prime_found37 = false;\n    let mut prime_found38 = false;\n\
    \    let mut prime_found39 = false;\n    let mut prime_found40 = false;\n    let\
    \ mut prime_found41 = false;\n    let mut prime_found42 = false;\n    let mut\
    \ prime_found43 = false;\n    let mut prime_found44 = false;\n    let mut prime_found45\
    \ = false;\n    let mut prime_found46 = false;\n    let mut prime_found47 = false;\n\
    \    let mut prime_found48 = false;\n    let mut prime_found49 = false;\n    let\
    \ mut prime_found50 = false;\n    let mut prime_found51 = false;\n    let mut\
    \ prime_found52 = false;\n    let mut prime_found53 = false;\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpfkmtk9ke.rs:23:52\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfkmtk9ke.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![];\n    let mut prime_counter: usize = 0;\n\
    \    let mut prime_counter2: usize = 0;\n    let mut prime_counter3: usize = 0;\n\
    \    let mut prime_counter4: usize = 0;\n    let mut prime_counter5: usize = 0;\n\
    \    let mut prime_counter6: usize = 0;\n    let mut prime_counter7: usize = 0;\n\
    \    let mut prime_counter8: usize = 0;\n    let mut prime_counter9: usize = 0;\n\
    \    let mut prime_counter10: usize = 0;\n    let mut prime_counter11: usize =\
    \ 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13: usize\
    \ = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: usize = 0;\n    let mut prime\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5wxe86xi.rs:65:18\n   |\n\
    65 |     let mut prime\n   |                  ^ help: add `;` here\n66 | }\n \
    \  | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n    --> /tmp/tmp5wxe86xi.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5wxe86xi.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime: Vec<u8> = Vec::new();\n    let mut prime_count: usize = 0;\n\
    \    let mut prime_digit: u8 = 0;\n    let mut prime_digit_count: usize = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_value: u8 = 0;\n\
    \    let mut prime_digit_value: \n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmp6b73uzey.rs:73:1\n   |\n\
    72 |     let mut prime_digit_value: \n   |         --------------------- while\
    \ parsing the type for `mut prime_digit_value`\n73 | }\n   | ^ expected type\n\
    \nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmp6b73uzey.rs:23:52\n     |\n23   | \
    \    let mut num: Vec<u8> = num.to_string().chars().collect();\n     |       \
    \                                             ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.into_iter().map(|x| *x).collect();\n    let mut num: Vec<u8> =\
    \ num.into_iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.into_iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.into_iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| *x).collect();\n    let mut\
    \ num: Vec<u8> = num.into_iter().map(|x| *x).collect();\n    let mut num: Vec<u8>\
    \ = num.into_iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.into_iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.into_iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| *x).collect();\n    let mut\
    \ num: Vec<u8> = num.into_iter().map(|x| *x).collect();\n    let mut num: Vec<u8>\
    \ = num.into_iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.into_iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.into_iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().map(|x| *x).collect();\n    let mut\
    \ num: Vec<u8> = num.into_iter().map(|x| *x).collect();\n    let mut num: Vec<u8>\
    \ = num.into_iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.into_iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.into_iter().map(|\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpu2k08etx.rs:43:47\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n43 |     let mut num:\
    \ Vec<u8> = num.into_iter().map(|\n   |                                      \
    \         ^ unclosed delimiter\n44 | }\n   | ^ mismatched closing delimiter\n\n\
    error: expected `|`, found `)`\n  --> /tmp/tmpu2k08etx.rs:44:1\n   |\n43 |   \
    \  let mut num: Vec<u8> = num.into_iter().map(|\n   |                        \
    \                         - expected `|`\n44 | }\n   | ^ unexpected token\n\n\
    error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmpu2k08etx.rs:23:52\n     |\n23   | \
    \    let mut num: Vec<u8> = num.to_string().chars().collect();\n     |       \
    \                                             ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0614]: type `u8` cannot be dereferenced\n  -->\
    \ /tmp/tmpu2k08etx.rs:24:52\n   |\n24 |     let mut num: Vec<u8> = num.into_iter().map(|x|\
    \ *x).collect();\n   |                                                    ^^\n\
    \nerror[E0614]: type `u8` cannot be dereferenced\n  --> /tmp/tmpu2k08etx.rs:25:52\n\
    \   |\n25 |     let mut num: Vec<u8> = num.into_iter().map(|x| *x).collect();\n\
    \   |                                                    ^^\n\nerror[E0614]: type\
    \ `u8` cannot be dereferenced\n  --> /tmp/tmpu2k08etx.rs:26:52\n   |\n26 |   \
    \  let mut num: Vec<u8> = num.into_iter().map(|x| *x).collect();\n   |       \
    \                                             ^^\n\nerror[E0614]: type `u8` cannot\
    \ be dereferenced\n  --> /tmp/tmpu2k08etx.rs:27:52\n   |\n27 |     let mut num:\
    \ Vec<u8> = num.into_iter().map(|x| *x).collect();\n   |                     \
    \                               ^^\n\nerror[E0614]: type `u8` cannot be dereferenc"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoz99ncue.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpoz99ncue.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpoz99ncue.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoz99ncue.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf8uq_llq.rs:39:36\n   |\n\
    39 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpf8uq_llq.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf8uq_llq.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8uq_llq.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpf8uq_llq.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8uq_llq.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgqi8w048.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpgqi8w048.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgqi8w048.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgqi8w048.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpgqi8w048.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgqi8w048.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.in\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `in`\n  --> /tmp/tmpdp6kfoi9.rs:39:32\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \      ^^ expected identifier, found keyword\n   |\nhelp: escape `in` to use it\
    \ as an identifier\n   |\n39 |     let mut num: Vec<u8> = num.r#in\n   |     \
    \                           ++\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpdp6kfoi9.rs:39:34\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \        ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpdp6kfoi9.rs:23:52\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_string().chars().collect();\n     |                       \
    \                             ^^^^^^^ value of type `Vec<u8>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdp6kfoi9.rs:24:61\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |\
    \                                                             ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdp6kfoi9.rs:24:73\n\
    \   |\n24 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' &&\
    \ x <= '9').collect();\n   |                                                 \
    \                        ^^^ expected `u8`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdp6kfoi9.rs:25:61\n   |\n25 |     let mut num: Vec<u8>\
    \ = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n   |       \
    \                                                      ^^^ expected `u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdp6kfoi9.rs:25:73\n\
    \   |\n25 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' &&\
    \ x <= 'F').collect();\n   |              "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut count: isize = 0;\n    let mut prime: isize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpki57mhig.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpki57mhig.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsnkn74gh.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpsnkn74gh.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsnkn74gh.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsnkn74gh.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpsnkn74gh.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsnkn74gh.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![];\n    let mut prime_counter: usize = 0;\n\
    \    let mut prime_counter2: usize = 0;\n    let mut prime_counter3: usize = 0;\n\
    \    let mut prime_counter4: usize = 0;\n    let mut prime_counter5: usize = 0;\n\
    \    let mut prime_counter6: usize = 0;\n    let mut prime_counter7: usize = 0;\n\
    \    let mut prime_counter8: usize = 0;\n    let mut prime_counter9: usize = 0;\n\
    \    let mut prime_counter10: usize = 0;\n    let mut prime_counter11: usize =\
    \ 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13: usize\
    \ = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: usize = 0;\n    let mut prime\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5wxe86xi.rs:65:18\n   |\n\
    65 |     let mut prime\n   |                  ^ help: add `;` here\n66 | }\n \
    \  | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n    --> /tmp/tmp5wxe86xi.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5wxe86xi.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_digits = num.len();\n    let mut num_primes = 0;\n    let mut\
    \ num_primes_digits = 0;\n    let mut num_primes_digits_prime = 0;\n    let mut\
    \ num_primes_digits_prime_prime = 0;\n    let mut num_primes_digits_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime = 0;\n    let mut\
    \ num_primes_digits_prime_prime_prime_prime_prime = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_primes_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpsd8innno.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsd8innno.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut count: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_found\
    \ = false;\n    loop {\n        if num[count] == b'A' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'B' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'C' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'D' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'E' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'F' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'0' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'1' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'2' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'3' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'4' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'5' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'6' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'7' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'8' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'9' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'A' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'B' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'C' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'D' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'E' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'F' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'0' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'1' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'2' {\n            prime_found\
    \ = true;\n        }\n        if num[count] == b'3' {\n            prime_found\
    \ = true;\n        }\n\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpytvk7sqf.rs:117:3\n\
    \    |\n22  | fn hex_key(num: String) -> isize {\n    |                      \
    \            - unclosed delimiter\n...\n27  |     loop {\n    |          - this\
    \ delimiter might not be properly closed...\n...\n107 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n117 | }\n    |   ^\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpytvk7sqf.rs:23:52\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_string().chars().collect();\n     |                       \
    \                             ^^^^^^^ value of type `Vec<u8>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmposdlhzpp.rs:38:50\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n38 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(\n   |                                    \
    \              ^ unclosed delimiter\n39 | }\n   | ^ mismatched closing delimiter\n\
    \nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  -->\
    \ /tmp/tmposdlhzpp.rs:39:1\n   |\n39 | }\n   | ^ expected one of `.`, `;`, `?`,\
    \ `else`, or an operator\n\nerror[E0277]: a value of type `Vec<u8>` cannot be\
    \ built from an iterator over elements of type `char`\n    --> /tmp/tmposdlhzpp.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmposdlhzpp.rs:24:61\n\
    \   |\n24 |     let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= '0' &&\
    \ c <= '9').collect();\n   |                                                 \
    \            ^^^ expected `u8`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmposdlhzpp.rs:24:73\n   |\n24 |     let mut num: Vec<u8> = num.into_iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n   |                                     \
    \                                    ^^^ expected `u8`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmposdlhzpp.rs:25:61\n   |\n25 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n   |\
    \                                                             ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmposdlhzpp.rs:25:73\n\
    \   |\n25 |     let mut num: Vec<u8> = num.into_iter().filter(|&c| c >= 'A' &&\
    \ c <= 'F').coll"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut counter: usize\
    \ = 0;\n    let mut prime_counter: usize = 0;\n    let mut prime_counter2: usize\
    \ = 0;\n    let mut prime_counter3: usize = 0;\n    let mut prime_counter4: usize\
    \ = 0;\n    let mut prime_counter5: usize = 0;\n    let mut prime_counter6: usize\
    \ = 0;\n    let mut prime_counter7: usize = 0;\n    let mut prime_counter8: usize\
    \ = 0;\n    let mut prime_counter9: usize = 0;\n    let mut prime_counter10: usize\
    \ = 0;\n    let mut prime_counter11: usize = 0;\n    let mut prime_counter12:\
    \ usize = 0;\n    let mut prime_counter13: usize = 0;\n    let mut prime_counter14:\
    \ usize = 0;\n    let mut prime_counter15: usize = 0;\n    let mut prime_counter16:\
    \ usize = 0;\n    let mut prime_counter17: usize = 0;\n    let mut prime_counter18:\
    \ usize = 0;\n    let mut prime_counter19: usize = 0;\n    let mut prime_counter20:\
    \ usize = 0;\n    let mut prime_counter21: usize = 0;\n    let mut prime_counter22:\
    \ usize = 0;\n    let mut prime_counter23: usize = 0;\n    let mut prime_counter24:\
    \ usize = 0;\n    let mut prime_counter25: usize = 0;\n    let mut prime_counter26:\
    \ usize = 0;\n    let mut prime_counter27: usize = 0;\n    let mut prime_counter28:\
    \ usize = 0;\n    let mut prime_counter29: usize = 0;\n    let mut prime_counter30:\
    \ usize = 0;\n    let mut prime_counter31: usize = 0;\n    let mut prime_counter32:\
    \ usize = 0;\n    let mut prime_counter33: usize = 0;\n    let mut prime_counter34:\
    \ usize = 0;\n    let mut prime_counter35: usize = 0;\n    let mut prime_counter36:\
    \ usize = 0;\n    let mut prime_counter37: usize = 0;\n\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpzj3mo_xg.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzj3mo_xg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|c| match c {\n        'a' => 0xa,\n\
    \        'b' => 0xb,\n        'c' => 0xc,\n        'd' => 0xd,\n        'e' =>\
    \ 0xe,\n        'f' => 0xf,\n        _ => c,\n    }).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|c| match c {\n        '0' => 0x0,\n        '1' =>\
    \ 0x1,\n        '2' => 0x2,\n        '3' => 0x3,\n        '4' => 0x4,\n      \
    \  '5' => 0x5,\n        '6' => 0x6,\n        '7' => 0x7,\n        '8' => 0x8,\n\
    \        '9' => 0x9,\n        _ => c,\n    }).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|c| match c {\n        'A' => 0xa,\n        'B' => 0xb,\n \
    \       'C' => 0xc,\n        'D' => 0xd,\n        'E' => 0xe,\n        'F' =>\
    \ 0xf,\n        _ => c,\n    }).collect();\n    let mut num: Vec<u8> = num.iter().map(|c|\
    \ match c {\n        '2' => 0x2,\n        '3' => 0x3,\n        '5' => 0x5,\n \
    \       '7' => 0x7,\n        'B' => 0xb,\n        'D' => 0xd,\n        _ => c,\n\
    \    }).collect();\n    let mut num: Vec<u8> = num.iter().map(|c| match c {\n\
    \        '3' => 0x3,\n        '5' => 0x5,\n        '7' => 0x7,\n        'B' =>\
    \ 0xb,\n        'D' => 0xd,\n        _ => c,\n    }).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|c| match c {\n        '5' => 0x5,\n        '7' =>\
    \ 0x7,\n        'B' => 0xb,\n        'D' => 0xd,\n        _ => c,\n    }).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|c| match c {\n        '7' => 0x7,\n\
    \        'B' => 0xb,\n        'D' => 0xd,\n        _ => c,\n    }).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|c| match c {\n        'B' => 0xb,\n\
    \        '\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpn14ltlt6.rs:87:9\n\
    \   |\n87 |         '\n   |         ^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_digits = num.len();\n    let mut num_primes = 0;\n    let mut\
    \ num_primes_digits = 0;\n    let mut num_primes_digits_primes = 0;\n    let mut\
    \ num_primes_digits_primes_primes = 0;\n    let mut num_primes_digits_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes = 0;\n    let\
    \ mut num_primes_digits_primes_primes_primes_primes_primes = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_prime\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpopo7qk1r.rs:44:22\n   |\n\
    44 |     let mut num_prime\n   |                      ^ help: add `;` here\n45\
    \ | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpopo7qk1r.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpopo7qk1r.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_str: String = String::new();\n    let mut num_str2: String = String::new();\n\
    \    let mut num_str3: String = String::new();\n    let mut num_str4: String =\
    \ String::new();\n    let mut num_str5: String = String::new();\n    let mut num_str6:\
    \ String = String::new();\n    let mut num_str7: String = String::new();\n   \
    \ let mut num_str8: String = String::new();\n    let mut num_str9: String = String::new();\n\
    \    let mut num_str10: String = String::new();\n    let mut num_str11: String\
    \ = String::new();\n    let mut num_str12: String = String::new();\n    let mut\
    \ num_str13: String = String::new();\n    let mut num_str14: String = String::new();\n\
    \    let mut num_str15: String = String::new();\n    let mut num_str16: String\
    \ = String::new();\n    let mut num_str17: String = String::new();\n    let mut\
    \ num_str18: String = String::new();\n    let mut num_str19: String = String::new();\n\
    \    let mut num_str20: String = String::new();\n    let mut num_str21: String\
    \ = String::new();\n    let mut num_str22: String = String::new();\n    let mut\
    \ num_str23: String = String::new();\n    let mut num_str24: String = String::new();\n\
    \    let mut num_str25: String = String::new();\n    let mut num_str26: String\
    \ = String::new();\n    let mut num_str27: String = String::new();\n    let mut\
    \ num_str28: String = String::new();\n    let mut num_str29: String = String::new();\n\
    \    let mut num_str30: String = String::new();\n    let mut num_str31: String\
    \ = String::new();\n    let mut num_str32: String = String::new();\n    let mut\
    \ num_str33: String = String::new();\n    let mut num_str34: String = String::new();\n\
    \    let mut num_str35: String = String::new();\n    let mut num_str36: String\
    \ = String::new();\n    let mut num_str37: String = String::new();\n    let mut\
    \ num_str38: String = String::new();\n    let mut num_\n}\n\nfn main() {\n   \
    \ let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2z_czrbm.rs:62:17\n   |\n\
    62 |     let mut num_\n   |                 ^ help: add `;` here\n63 | }\n   |\
    \ - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n    --> /tmp/tmp2z_czrbm.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2z_czrbm.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoz99ncue.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpoz99ncue.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpoz99ncue.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoz99ncue.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_iter\
    \ = nums.iter();\n    let mut nums_len = nums.len();\n    let mut prime_digits\
    \ = vec![false; 10];\n    let mut prime_digits_iter = prime_digits.iter();\n \
    \   let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_iter\
    \ = prime_digits.iter();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_iter = prime_digits.iter();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_iter = prime_digits.iter();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_iter\
    \ = prime_digits.iter();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_iter = prime_digits.iter();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_iter = prime_digits.iter();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_iter\
    \ = prime_digits.iter();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_iter = prime_digits.iter();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_iter = prime_digits.iter();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_iter\
    \ = prime_digits.iter();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_iter = prime_digits.iter();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_iter = prime_digits.iter();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_iter\
    \ = prime_digits.iter();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_iter = prime_digits.iter();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_iter = prime_digits.iter();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_iter\
    \ = prime_digits.\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpo41t9g03.rs:60:1\n   |\n60\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpo41t9g03.rs:59:46\n\
    \   |\n59 |     let mut prime_digits_iter = prime_digits.\n   |              \
    \                                ^ help: add `;` here\n60 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo41t9g03.rs:22:28\n \
    \  |\n22 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c != 'b' && c !=\
    \ 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|&c| c != '0').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c != '1').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c !=\
    \ '2').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c != '3').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c != '4').collect();\n    let\
    \ mut num: Vec<u8> = num.iter().filter(|&c| c != '5').collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|&c| c != '6').collect();\n    let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c != '7').collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|&c| c != '8').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c != '9').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c !=\
    \ 'A').collect();\n    let mut num: Vec<u8> = num.iter().filter(|&c| c != 'B').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c != 'C').collect();\n    let\
    \ mut num: Vec<u8> = num.iter().filter(|&c| c != 'D').collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|&c| c != 'E').collect();\n    let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c != 'F').collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|&c| c != 'a').collect();\n    let mut num: \n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpy2t0fh0c.rs:43:1\n   |\n\
    42 |     let mut num: \n   |         ------- while parsing the type for `mut num`\n\
    43 | }\n   | ^ expected type\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpy2t0fh0c.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy2t0fh0c.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c !=\
    \ 'b' && c != 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n   |      \
    \                                                  ^^^ expected `u8`, found `char`\n\
    \nerror[E0277]: can't compare `&u8` with `char`\n  --> /tmp/tmpy2t0fh0c.rs:24:53\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c !=\
    \ 'b' && c != 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n   |      \
    \                                               ^^ no implementation for `&u8\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&u8`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy2t0fh0c.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c != 'a' && c !=\
    \ 'b' && c != 'c' && c != 'd' && c != 'e' && c != 'f').collect();\n   |      \
    \                                                              ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0277]: can't compare `&u8` with `char`\n  --> /tmp/tmpy2t0fh0c.rs:24:65\n\
    \   |\n24 |"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for struct `Vec<u8>` in the\
    \ current scope\n  --> /tmp/tmpo7c1ix_y.rs:24:32\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.chars().collect();\n   |                                ^^^^^\
    \ method not found in `Vec<u8>`\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpo7c1ix_y.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `chars` found for struct\
    \ `Vec<u8>` in the current scope\n  --> /tmp/tmpo7c1ix_y.rs:25:32\n   |\n25 |\
    \     let mut num: Vec<u8> = num.chars().collect();\n   |                    \
    \            ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]: no method named\
    \ `chars` found for struct `Vec<u8>` in the current scope\n  --> /tmp/tmpo7c1ix_y.rs:26:32\n\
    \   |\n26 |     let mut num: Vec<u8> = num.chars().collect();\n   |          \
    \                      ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]: no\
    \ method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmpo7c1ix_y.rs:27:32\n   |\n27 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmpo7c1ix_y.rs:28:32\n   |\n28 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmpo7c1ix_y.rs:29:32\n   |\n29 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_len\
    \ = nums.len();\n    let mut prime_digits = vec![2, 3];\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_count = prime_digits_len;\n\
    \    let mut prime_digits_count_max = prime_digits_len;\n    let mut prime_digits_count_min\
    \ = prime_digits_len;\n    let mut prime_digits_count_max_prime_digits = prime_digits_len;\n\
    \    let mut prime_digits_count_min_prime_digits = prime_digits_len;\n    let\
    \ mut prime_digits_count_max_prime_digits_prime_digits = prime_digits_len;\n \
    \   let mut prime_digits_count_min_prime_digits_prime_digits = prime_digits_len;\n\
    \    let mut prime_digits_count_max_prime_digits_prime_digits_prime_digits = prime_digits_len;\n\
    \    let mut prime_digits_count_min_prime_digits_prime_digits_prime_digits = prime_digits_len;\n\
    \    let mut prime_digits_count_max_prime_digits_prime_digits_prime_digits_prime_digits\
    \ = prime_digits_len;\n    let mut prime_digits_count_min_prime_digits_prime_digits_prime_digits_prime_digits\
    \ = prime_digits_len;\n    let mut prime_digits_count_max_prime_digits_prime_digits_prime_digits_prime_digits_prime_digits\
    \ = prime_digits_len;\n    let mut prime_digits_count_min_prime_digits_prime_digits_prime_digits_prime_digits_prime_digits\
    \ = prime_digits_len;\n    let mut prime_digits_count_max_prime_digits_prime_digits_prime_digits_prime_digits_prime_digits_prime_digits\
    \ = prime_digits_len;\n    let mut prime_digits_count_min_prime_digits_prime_digits_prime_digits_prime_digits_prime_digits_prime_digits\
    \ = prime_digits_len;\n    let mut prime_digits_count_max_prime_digits_prime_digits_prime_digits_prime_digits_prime_digits_prime_digits_prime_digits\
    \ = prime_digits_len;\n    let mut prime_digits_count_min_prime_digits_prime_digits_prime_digits_prime\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpk_322pu0.rs:43:80\n   |\n\
    43 |     let mut prime_digits_count_min_prime_digits_prime_digits_prime_digits_prime\n\
    \   |                                                                        \
    \        ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk_322pu0.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for struct `Vec<u8>` in the\
    \ current scope\n  --> /tmp/tmpo7c1ix_y.rs:24:32\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.chars().collect();\n   |                                ^^^^^\
    \ method not found in `Vec<u8>`\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpo7c1ix_y.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `chars` found for struct\
    \ `Vec<u8>` in the current scope\n  --> /tmp/tmpo7c1ix_y.rs:25:32\n   |\n25 |\
    \     let mut num: Vec<u8> = num.chars().collect();\n   |                    \
    \            ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]: no method named\
    \ `chars` found for struct `Vec<u8>` in the current scope\n  --> /tmp/tmpo7c1ix_y.rs:26:32\n\
    \   |\n26 |     let mut num: Vec<u8> = num.chars().collect();\n   |          \
    \                      ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]: no\
    \ method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmpo7c1ix_y.rs:27:32\n   |\n27 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmpo7c1ix_y.rs:28:32\n   |\n28 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmpo7c1ix_y.rs:29:32\n   |\n29 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().map(|x| x as u8).collect();\n    let\
    \ mut num: Vec<u8> = num.iter().filter(|x| x % 2 == 0).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|x| x % 3 == 0).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().filter(|x| x % 5 == 0).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|x| x % 7 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x|\
    \ x % 11 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x\
    \ % 13 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x %\
    \ 17 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x % 19\
    \ == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x % 23 ==\
    \ 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x % 29 == 0).collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|x| x % 31 == 0).collect();\n  \
    \  let mut num: Vec<u8> = num.iter().filter(|x| x % 37 == 0).collect();\n    let\
    \ mut num: Vec<u8> = num.iter().filter(|x| x % 41 == 0).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|x| x % 43 == 0).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().filter(|x| x % 47 == 0).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|x| x % 53 == 0).collect();\n    let mut num: Vec<u8> =\
    \ num.iter().filter(|x| x % 59 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x|\
    \ x % 61 == 0).collect();\n    let \n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfgypqmdj.rs:44:1\n  \
    \ |\n44 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpfgypqmdj.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0369]: cannot mod `&&u8` by `{integer}`\n\
    \  --> /tmp/tmpfgypqmdj.rs:25:52\n   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|x|\
    \ x % 2 == 0).collect();\n   |                                               \
    \   - ^ - {integer}\n   |                                                  |\n\
    \   |                                                  &&u8\n   |\nhelp: `%` can\
    \ be used on `u8`, you can dereference `x`\n   |\n25 |     let mut num: Vec<u8>\
    \ = num.iter().filter(|x| *x % 2 == 0).collect();\n   |                      \
    \                            +\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `&u8`\n    --> /tmp/tmpfgypqmdj.rs:25:62\n\
    \     |\n25   |     let mut num: Vec<u8> = num.iter().filter(|x| x % 2 == 0).collect();\n\
    \     |                                                              ^^^^^^^ value\
    \ of type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=&u8>`\n   \
    \  |\n     = help: the trait `FromIterator<&u8>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0369]: cannot mod `&&u8` by `{integer}`\n\
    \  --> /tmp/tmpfgypqmdj.rs:26:52\n   |\n26 |     let mut num: Vec<u8> = num.iter().filter(|x|\
    \ x % 3 == 0).collect();\n   |                                               \
    \   - ^ - {integer}\n   |                                                 "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut count: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfqv7589b.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpfqv7589b.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmf3oq_4v.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpmf3oq_4v.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpmf3oq_4v.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmf3oq_4v.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut num_digits\
    \ = nums.len();\n    let mut num_primes = 0;\n    let mut num_primes_digits =\
    \ 0;\n    let mut num_primes_digits_primes = 0;\n    let mut num_primes_digits_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes = 0;\n    let mut num_primes_digits_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes = 0;\n\
    \    let mut num_primes_digits_primes_primes_primes_primes_primes_primes = 0;\n\
    \    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_prime\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0qxp3x41.rs:44:36\n   |\n\
    44 |     let mut num_primes_digits_prime\n   |                               \
    \     ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0qxp3x41.rs:22:28\n   |\n22 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = 0;\n    let mut num_digits = num.chars().count();\n\
    \    let mut num_primes = 0;\n    while num_digits > 0 {\n        let mut digit\
    \ = num_digits;\n        let mut num_digits = 0;\n        while digit > 0 {\n\
    \            let mut digit = num.chars().next().unwrap().to_digit(16).unwrap();\n\
    \            if digit % 2 == 0 {\n                digit /= 2;\n              \
    \  num_digits += 1;\n            }\n        }\n        if num_digits == 2 {\n\
    \            num_primes += 1;\n        }\n        num_digits -= 1;\n    }\n  \
    \  num_primes\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpclbrpxls.rs:24:30\n   |\n24 |     let mut num_digits =\
    \ num.chars().count();\n   |                              ^^^^^ method not found\
    \ in `isize`\n\nerror[E0599]: no method named `chars` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmpclbrpxls.rs:30:33\n   |\n30 |             let\
    \ mut digit = num.chars().next().unwrap().to_digit(16).unwrap();\n   |       \
    \                          ^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_digit: Vec<u8> = vec![2, 3, 4, 5, 6, 7, 8,\
    \ 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\
    \ 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\
    \ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,\
    \ 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,\
    \ 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut prime_digit_len\
    \ = prime_digit.len();\n    let mut prime_digit_count: Vec<u8> = vec![0, 0, 0,\
    \ 0, 0, 0, 0, 0];\n    let mut prime_digit_count_len = prime_digit_count.len();\n\
    \    let mut prime_digit_count_len2 = prime_digit_count_len.clone();\n    let\
    \ mut prime_digit_count_len3 = prime_digit_count_len2.clone();\n    let mut prime_digit_count_len4\
    \ = prime_digit_count_len3.clone();\n    let mut prime_digit_count_len5 = prime_digit_count_len4.clone();\n\
    \    let mut prime_digit_count_len6 = prime_digit_count_len5.clone();\n    let\
    \ mut prime_digit_count_len7 = prime_digit_count_len6.clone();\n    let mut prime_digit_count_len8\
    \ = prime_digit_count_len7.clone();\n    let mut prime_digit_count_len9 = prime_digit_count_len8.clone();\n\
    \    let mut prime_digit_count_len10 = prime_digit_count_len9.clone();\n    let\
    \ mut prime_digit_count_len11 = prime_digit_count_len10.clone();\n    let mut\
    \ prime_digit_count_len12 = prime_digit_count_len11.clone();\n    let mut prime_digit_count_len13\
    \ = prime_digit_count_len12.clone();\n    let mut prime_digit_count_len14 = prime_digit_count_len13.clone();\n\
    \    let mut prime_digit_count_len15 = prime_digit_count_len14.clone();\n    let\
    \ mut prime_digit_\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphosjtb71.rs:44:25\n   |\n\
    44 |     let mut prime_digit_\n   |                         ^ help: add `;` here\n\
    45 | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmphosjtb71.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphosjtb71.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut counter: usize\
    \ = 0;\n    for &c in num {\n        if prime == vec![2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] {\n\
    \            counter = counter + 1;\n        }\n        if prime == vec![2, 3,\
    \ 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79,\
    \ 83, 89, 97] {\n            counter = counter + 1;\n        }\n        if prime\
    \ == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 73, 79, 83, 89, 97] {\n            counter = counter + 1;\n        }\n\
    \        if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] {\n            counter = counter\
    \ + 1;\n        }\n        if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] {\n            counter\
    \ = counter + 1;\n        }\n        if prime == vec![2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] {\n\
    \            counter = counter + 1;\n        }\n        if prime == vec![2, 3,\
    \ 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79,\
    \ 83, 89, 97] {\n            counter = counter + 1;\n        }\n        if prime\
    \ == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 73, 79, 83, 89, 97] {\n            counter = counter + 1;\n        }\n\
    \        if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] {\n            counter = counter\
    \ + 1;\n        }\n        if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpam43pzlr.rs:65:3\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - unclosed delimiter\n...\n26 |     for &c in num {\n   |          \
    \         - this delimiter might not be properly closed...\n...\n55 | }\n   |\
    \ - ...as it matches this but it has different indentation\n...\n65 | }\n   |\
    \   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpam43pzlr.rs:54:25\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n54 |         if prime\
    \ == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, \n   |         \
    \                ^ unclosed delimiter\n55 | }\n   | ^ mismatched closing delimiter\n\
    \nerror: expected `{`, found `}`\n  --> /tmp/tmpam43pzlr.rs:55:1\n   |\n54 | \
    \        if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ \n   |         -- this `if` expression has a condition, but no block\n55 | }\n\
    \   | ^ expected `{`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n    --> /tmp/tmpam43pzlr.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpam43pzlr.rs:26:9\n\
    \   |\n26 |     for &c in num {\n   |         ^^    --- this expression has type\
    \ `Option<u8>`\n   |         |\n   |         expected `u8`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `u8`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpam43pzlr.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_digits = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits_len.saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpkj52xiro.rs:26:1583\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n26 |     let mut prime_digits_len\
    \ = prime_digits_len.saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((num.len()\
    \ / 2).saturating_add((num.len() / 2).saturating_add((num.len() / 2).saturating_add((n...\n\
    \   |                                                                        \
    \                                                                            \
    \                                                                            \
    \                     "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_digits = num.len();\n    let mut prime_digits = vec![];\n    let\
    \ mut prime_numbers = vec![];\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_len = prime_numbers.len();\n    let mut prime_numbers_len\
    \ = prime_numbers.len();\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_len = prime_numbers.len();\n    let mut prime_numbers_len\
    \ = prime_numbers.len();\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_len = prime_numbers.len();\n    let mut prime_numbers_len\
    \ = prime_numbers.len();\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_len = prime_numbers.len();\n    let mut prime_numbers_len\
    \ = prime_numbers.len();\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_len = prime_numbers.len();\n    let mut prime_numbers_len\
    \ = prime_numbers.len();\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_len = prime_numbers.len();\n    let mut prime_numbers_len\
    \ = prime_numbers.len();\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_len = prime_numbers.len();\n    let mut prime_numbers_len\
    \ = prime_numbers.len();\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_len = prime_numbers.len();\n    let mut prime_numbers_len\
    \ = prime_numbers.len();\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_len = prime_numbers.len();\n    let mut prime_numbers_len\
    \ = prime_numbers.len();\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_len = prime_numbers.len();\n    let mut prime_numbers_len\
    \ = prime_numbers.len();\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_len = prime_numbers.len();\n    let mut prime_numbers_len\
    \ = prime_numbers.len\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsyvi509v.rs:59:50\n   |\n\
    59 |     let mut prime_numbers_len = prime_numbers.len\n   |                 \
    \                                 ^ help: add `;` here\n60 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpsyvi509v.rs:23:52\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0616]: field `len` of struct `Vec` is private\n\
    \  --> /tmp/tmpsyvi509v.rs:59:47\n   |\n59 |     let mut prime_numbers_len = prime_numbers.len\n\
    \   |                                               ^^^ private field\n   |\n\
    help: a method `len` also exists, call it with parentheses\n   |\n59 |     let\
    \ mut prime_numbers_len = prime_numbers.len()\n   |                          \
    \                        ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsyvi509v.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0616.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_str: String = String::new();\n    let mut num_hex: String = String::new();\n\
    \    let mut num_hex_len: usize = 0;\n    let mut num_hex_len_len: usize = 0;\n\
    \    let mut num_hex_len_len_len: usize = 0;\n    let mut num_hex_len_len_len_len:\
    \ usize = 0;\n    let mut num_hex_len_len_len_len: usize = 0;\n    let mut num_hex_len_len_len_len:\
    \ usize = 0;\n    let mut num_hex_len_len_len_len: usize = 0;\n    let mut num_hex_len_len_len_len:\
    \ usize = 0;\n    let mut num_hex_len_len_len_len: usize = 0;\n    let mut num_hex_len_len_len_len:\
    \ usize = 0;\n    let mut num_hex_len_len_len_len: usize = 0;\n    let mut num_hex_len_len_len_len:\
    \ usize = 0;\n    let mut num_hex_len_len_len_len: usize = 0;\n    let mut num_hex_len_len_len_len:\
    \ usize = 0;\n    let mut num_hex_len_len_len_len: usize = 0;\n    let mut num_hex_len_len_len_len:\
    \ usize = 0;\n    let mut num_hex_len_len_len_len: usize = 0;\n    let mut num_hex_len_len_len_len:\
    \ usize = 0;\n    let mut num_hex_len_len_len_len: usize = 0;\n    let mut num_hex_len_len_len_len:\
    \ usize = 0;\n    let mut num_hex_len_len_len_len: usize = 0;\n    let mut num_hex_len_len_len_len:\
    \ usize = 0;\n    let mut num_hex_len_len_len_len: usize = 0;\n    let mut num_hex_len_len_len_len:\
    \ usize = 0;\n    let mut num_hex_len_len_len_len: usize = 0;\n    let mut num_hex_len_len_len_len:\
    \ usize = 0;\n    let mut num_hex_len_len_len_len: usize = 0;\n    let mut num_hex_len_len_len_len:\
    \ usize = 0;\n    let mut num_hex_len_len_len_len: usize = 0;\n    let mut num_hex_len_len_len_len:\
    \ usize = 0;\n    let mut num_hex_len_len_len_len: usize = 0;\n    let mut num_hex_len_len_len_len:\
    \ usize = 0;\n    let mut num_hex_len_len_len_len: usize = 0;\n    let mut num_hex_len_len_len_len:\
    \ usize = 0;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpdf4zca_h.rs:23:52\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdf4zca_h.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgqi8w048.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpgqi8w048.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgqi8w048.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgqi8w048.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpgqi8w048.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgqi8w048.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi7xvf4vd.rs:64:31\n   |\n\
    64 |     let mut prime_counter40: u\n   |                               ^ help:\
    \ add `;` here\n65 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpi7xvf4vd.rs:64:30\n   |\n64 |     let mut prime_counter40:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpi7xvf4vd.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi7xvf4vd.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut count: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpfqv7589b.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpfqv7589b.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf8uq_llq.rs:39:36\n   |\n\
    39 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpf8uq_llq.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf8uq_llq.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8uq_llq.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpf8uq_llq.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8uq_llq.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut num_primes\
    \ = 0;\n    let mut num_digits = 0;\n    let mut num_digits_prime = 0;\n    let\
    \ mut num_digits_prime_prime = 0;\n    let mut num_digits_prime_prime_prime =\
    \ 0;\n    let mut num_digits_prime_prime_prime_prime = 0;\n    let mut num_digits_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_prime = 0;\n    let\
    \ mut num_digits_prime_prime_prime_prime_prime_prime_prime = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut num_digits_prime_prime_prime_prime_prime_prime_prime_prime_\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphsamd5a8.rs:45:72\n   |\n\
    45 |     let mut num_digits_prime_prime_prime_prime_prime_prime_prime_prime_\n\
    \   |                                                                        ^\
    \ help: add `;` here\n46 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphsamd5a8.rs:22:28\n   |\n22 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut digits:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut prime_digits: Vec<u8>\
    \ = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut prime_digits_count: usize =\
    \ 0;\n    let mut prime_digits_sum: usize = 0;\n    let mut prime_digits_product:\
    \ usize = 1;\n    let mut prime_digits_product2: usize = 1;\n    let mut prime_digits_product3:\
    \ usize = 1;\n    let mut prime_digits_product4: usize = 1;\n    let mut prime_digits_product5:\
    \ usize = 1;\n    let mut prime_digits_product6: usize = 1;\n    let mut prime_digits_product7:\
    \ usize = 1;\n    let mut prime_digits_product8: usize = 1;\n    let mut prime_digits_product9:\
    \ usize = 1;\n    let mut prime_digits_product10: usize = 1;\n    let mut prime_digits_product11:\
    \ usize = 1;\n    let mut prime_digits_product12: usize = 1;\n    let mut prime_digits_product13:\
    \ usize = 1;\n    let mut prime_digits_product14: usize = 1;\n    let mut prime_digits_product15:\
    \ usize = 1;\n    let mut prime_digits_product16: usize = 1;\n    let mut prime_digits_product17:\
    \ usize = 1;\n    let mut prime_digits_product18: usize = 1;\n    let mut prime_digits_product19:\
    \ usize = 1;\n    let mut prime_digits_product20: usize = 1;\n    let mut prime_digits_product21:\
    \ usize = 1;\n    let mut prime_digits_product22: usize = 1;\n    let mut prime_digits_product23:\
    \ usize = 1;\n    let mut prime_digits_product24: usize = 1;\n    let mut prime_digits_product25:\
    \ usize = 1;\n    let mut prime_digits_product26: usize = 1;\n    let mut prime_digits_product27:\
    \ usize = 1;\n    let mut prime_digits_product28: usize = 1;\n    let mut prime_digits_product29:\
    \ usize = 1;\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptdfahibb.rs:58:11\n   |\n\
    58 |     let mu\n   |           ^ help: add `;` here\n59 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmptdfahibb.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptdfahibb.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![];\n    let mut num_prime_counter: usize\
    \ = 0;\n    let mut num_prime_counter2: usize = 0;\n    let mut num_prime_counter3:\
    \ usize = 0;\n    let mut num_prime_counter4: usize = 0;\n    let mut num_prime_counter5:\
    \ usize = 0;\n    let mut num_prime_counter6: usize = 0;\n    let mut num_prime_counter7:\
    \ usize = 0;\n    let mut num_prime_counter8: usize = 0;\n    let mut num_prime_counter9:\
    \ usize = 0;\n    let mut num_prime_counter10: usize = 0;\n    let mut num_prime_counter11:\
    \ usize = 0;\n    let mut num_prime_counter12: usize = 0;\n    let mut num_prime_counter13:\
    \ usize = 0;\n    let mut num_prime_counter14: usize = 0;\n    let mut num_prime_counter15:\
    \ usize = 0;\n    let mut num_prime_counter16: usize = 0;\n    let mut num_prime_counter17:\
    \ usize = 0;\n    let mut num_prime_counter18: usize = 0;\n    let mut num_prime_counter19:\
    \ usize = 0;\n    let mut num_prime_counter20: usize = 0;\n    let mut num_prime_counter21:\
    \ usize = 0;\n    let mut num_prime_counter22: usize = 0;\n    let mut num_prime_counter23:\
    \ usize = 0;\n    let mut num_prime_counter24: usize = 0;\n    let mut num_prime_counter25:\
    \ usize = 0;\n    let mut num_prime_counter26: usize = 0;\n    let mut num_prime_counter27:\
    \ usize = 0;\n    let mut num_prime_counter28: usize = 0;\n    let mut num_prime_counter29:\
    \ usize = 0;\n    let mut num_prime_counter30: usize = 0;\n    let mut num_prime_counter31:\
    \ usize = 0;\n    let mut num_prime_counter32: usize = 0;\n    let mut num_prime_counter33:\
    \ usize = 0;\n    let mut num_prime_counter34: usize = 0;\n    let mut num_prime_counter35:\
    \ usize = 0;\n    let mut num_prime_counter36: usize = 0;\n    let mut num_prime_counter37:\
    \ usize = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprawpc3jg.rs:62:11\n   |\n\
    62 |     let mu\n   |           ^ help: add `;` here\n63 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmprawpc3jg.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprawpc3jg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![];\n    let mut prime_counter: usize = 0;\n\
    \    let mut prime_counter2: usize = 0;\n    let mut prime_counter3: usize = 0;\n\
    \    let mut prime_counter4: usize = 0;\n    let mut prime_counter5: usize = 0;\n\
    \    let mut prime_counter6: usize = 0;\n    let mut prime_counter7: usize = 0;\n\
    \    let mut prime_counter8: usize = 0;\n    let mut prime_counter9: usize = 0;\n\
    \    let mut prime_counter10: usize = 0;\n    let mut prime_counter11: usize =\
    \ 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13: usize\
    \ = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: usize = 0;\n    let mut prime\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5wxe86xi.rs:65:18\n   |\n\
    65 |     let mut prime\n   |                  ^ help: add `;` here\n66 | }\n \
    \  | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n    --> /tmp/tmp5wxe86xi.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5wxe86xi.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.in\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `in`\n  --> /tmp/tmpdp6kfoi9.rs:39:32\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \      ^^ expected identifier, found keyword\n   |\nhelp: escape `in` to use it\
    \ as an identifier\n   |\n39 |     let mut num: Vec<u8> = num.r#in\n   |     \
    \                           ++\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpdp6kfoi9.rs:39:34\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \        ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpdp6kfoi9.rs:23:52\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_string().chars().collect();\n     |                       \
    \                             ^^^^^^^ value of type `Vec<u8>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdp6kfoi9.rs:24:61\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |\
    \                                                             ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdp6kfoi9.rs:24:73\n\
    \   |\n24 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' &&\
    \ x <= '9').collect();\n   |                                                 \
    \                        ^^^ expected `u8`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdp6kfoi9.rs:25:61\n   |\n25 |     let mut num: Vec<u8>\
    \ = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n   |       \
    \                                                      ^^^ expected `u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdp6kfoi9.rs:25:73\n\
    \   |\n25 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' &&\
    \ x <= 'F').collect();\n   |              "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf8uq_llq.rs:39:36\n   |\n\
    39 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpf8uq_llq.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf8uq_llq.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8uq_llq.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpf8uq_llq.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8uq_llq.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3k8iu8vu.rs:65:34\n   |\n\
    65 |     let mut prime_len = prime_len\n   |                                 \
    \ ^ help: add `;` here\n66 | }\n   | - unexpected token\n\nerror[E0277]: a value\
    \ of type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmp3k8iu8vu.rs:23:55\n     |\n23   |     let mut num: Vec<u8> =\
    \ num.to_lowercase().chars().collect();\n     |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3k8iu8vu.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoz99ncue.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpoz99ncue.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpoz99ncue.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoz99ncue.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for struct `Vec<u8>` in the\
    \ current scope\n  --> /tmp/tmpo7c1ix_y.rs:24:32\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.chars().collect();\n   |                                ^^^^^\
    \ method not found in `Vec<u8>`\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpo7c1ix_y.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `chars` found for struct\
    \ `Vec<u8>` in the current scope\n  --> /tmp/tmpo7c1ix_y.rs:25:32\n   |\n25 |\
    \     let mut num: Vec<u8> = num.chars().collect();\n   |                    \
    \            ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]: no method named\
    \ `chars` found for struct `Vec<u8>` in the current scope\n  --> /tmp/tmpo7c1ix_y.rs:26:32\n\
    \   |\n26 |     let mut num: Vec<u8> = num.chars().collect();\n   |          \
    \                      ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]: no\
    \ method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmpo7c1ix_y.rs:27:32\n   |\n27 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmpo7c1ix_y.rs:28:32\n   |\n28 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmpo7c1ix_y.rs:29:32\n   |\n29 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_prime: Vec<u8> = vec![];\n    let mut num_prime_2: Vec<u8> = vec![];\n\
    \    let mut num_prime_3: Vec<u8> = vec![];\n    let mut num_prime_4: Vec<u8>\
    \ = vec![];\n    let mut num_prime_5: Vec<u8> = vec![];\n    let mut num_prime_6:\
    \ Vec<u8> = vec![];\n    let mut num_prime_7: Vec<u8> = vec![];\n    let mut num_prime_8:\
    \ Vec<u8> = vec![];\n    let mut num_prime_9: Vec<u8> = vec![];\n    let mut num_prime_10:\
    \ Vec<u8> = vec![];\n    let mut num_prime_11: Vec<u8> = vec![];\n    let mut\
    \ num_prime_12: Vec<u8> = vec![];\n    let mut num_prime_13: Vec<u8> = vec![];\n\
    \    let mut num_prime_14: Vec<u8> = vec![];\n    let mut num_prime_15: Vec<u8>\
    \ = vec![];\n    let mut num_prime_16: Vec<u8> = vec![];\n    let mut num_prime_17:\
    \ Vec<u8> = vec![];\n    let mut num_prime_18: Vec<u8> = vec![];\n    let mut\
    \ num_prime_19: Vec<u8> = vec![];\n    let mut num_prime_20: Vec<u8> = vec![];\n\
    \    let mut num_prime_21: Vec<u8> = vec![];\n    let mut num_prime_22: Vec<u8>\
    \ = vec![];\n    let mut num_prime_23: Vec<u8> = vec![];\n    let mut num_prime_24:\
    \ Vec<u8> = vec![];\n    let mut num_prime_25: Vec<u8> = vec![];\n    let mut\
    \ num_prime_26: Vec<u8> = vec![];\n    let mut num_prime_27: Vec<u8> = vec![];\n\
    \    let mut num_prime_28: Vec<u8> = vec![];\n    let mut num_prime_29: Vec<u8>\
    \ = vec![];\n    let mut num_prime_\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp07r3b6ic.rs:53:23\n   |\n\
    53 |     let mut num_prime_\n   |                       ^ help: add `;` here\n\
    54 | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmp07r3b6ic.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp07r3b6ic.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let mut\
    \ prime_digit_count: isize = 0;\n    let mut prime_digit_sum: isize = 0;\n   \
    \ let mut prime_digit_sum2: isize = 0;\n    let mut prime_digit_sum3: isize =\
    \ 0;\n    let mut prime_digit_sum4: isize = 0;\n    let mut prime_digit_sum5:\
    \ isize = 0;\n    let mut prime_digit_sum6: isize = 0;\n    let mut prime_digit_sum7:\
    \ isize = 0;\n    let mut prime_digit_sum8: isize = 0;\n    let mut prime_digit_sum9:\
    \ isize = 0;\n    let mut prime_digit_sum10: isize = 0;\n    let mut prime_digit_sum11:\
    \ isize = 0;\n    let mut prime_digit_sum12: isize = 0;\n    let mut prime_digit_sum13:\
    \ isize = 0;\n    let mut prime_digit_sum14: isize = 0;\n    let mut prime_digit_sum15:\
    \ isize = 0;\n    let mut prime_digit_sum16: isize = 0;\n    let mut prime_digit_sum17:\
    \ isize = 0;\n    let mut prime_digit_sum18: isize = 0;\n    let mut prime_digit_sum19:\
    \ isize = 0;\n    let mut prime_digit_sum20: isize = 0;\n    let mut prime_digit_sum21:\
    \ isize = 0;\n    let mut prime_digit_sum22: isize = 0;\n    let mut prime_digit_sum23:\
    \ isize = 0;\n    let mut prime_digit_sum24: isize = 0;\n    let mut prime_digit_sum25:\
    \ isize = 0;\n    let mut prime_digit_sum26: isize = 0;\n    let mut prime_digit_sum27:\
    \ isize = 0;\n    let mut prime_digit_sum28: isize = 0;\n    let mut prime_digit_sum29:\
    \ isize = 0;\n    let mut prime_digit_sum30: isize = 0;\n    let mut prime_digit_sum31:\
    \ isize = 0;\n    let mut prime_digit_sum32: isize = 0;\n    let mut prime_digit_sum33:\
    \ isize = 0;\n    let mut prime_digit_sum34: isize = 0;\n    let mut prime_digit_sum35:\
    \ isize = 0;\n    let mut prime_digit_sum36: isize = 0;\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp13eza8if.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmp13eza8if.rs:23:52\n     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_2:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_3: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut num_prime_4: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut num_prime_5: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_6:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_7: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut num_prime_8: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut num_prime_9: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_10:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_11: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp0_5hsfdc.rs:34:41\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n34 |     let mut num_prime_11:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, \n   |                                      \
    \   ^ unclosed delimiter\n35 | }\n   | ^ mismatched closing delimiter\n\nerror:\
    \ expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmp0_5hsfdc.rs:35:1\n\
    \   |\n35 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\n\
    error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmp0_5hsfdc.rs:23:55\n     |\n23   | \
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |    \
    \                                                   ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoz99ncue.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpoz99ncue.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpoz99ncue.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoz99ncue.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgqi8w048.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpgqi8w048.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgqi8w048.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgqi8w048.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpgqi8w048.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgqi8w048.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digit:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digit_count: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut prime_digit_count_2: Vec<u8> = vec![2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97];\n    let mut prime_digit_count_3: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut prime_digit_count_4: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut\
    \ prime_digit_count_5: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digit_count_6:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digit_count_7: Vec<u8> =\
    \ vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97];\n    let mut prime_digit_count_8: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut prime_digit_count_9: Vec<u8> = vec\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7f8nd1s8.rs:34:47\n   |\n\
    34 |     let mut prime_digit_count_9: Vec<u8> = vec\n   |                    \
    \                           ^ help: add `;` here\n35 | }\n   | - unexpected token\n\
    \nerror[E0423]: expected value, found macro `vec`\n  --> /tmp/tmp7f8nd1s8.rs:34:44\n\
    \   |\n34 |     let mut prime_digit_count_9: Vec<u8> = vec\n   |             \
    \                               ^^^ not a value\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmp7f8nd1s8.rs:23:55\n     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7f8nd1s8.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0423.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut num_digits\
    \ = nums.len();\n    let mut num_primes = 0;\n    let mut num_primes_digits =\
    \ 0;\n    let mut num_primes_digits_pow2 = 0;\n    let mut num_primes_digits_pow3\
    \ = 0;\n    let mut num_primes_digits_pow4 = 0;\n    let mut num_primes_digits_pow5\
    \ = 0;\n    let mut num_primes_digits_pow6 = 0;\n    let mut num_primes_digits_pow7\
    \ = 0;\n    let mut num_primes_digits_pow8 = 0;\n    let mut num_primes_digits_pow9\
    \ = 0;\n    let mut num_primes_digits_pow10 = 0;\n    let mut num_primes_digits_pow11\
    \ = 0;\n    let mut num_primes_digits_pow12 = 0;\n    let mut num_primes_digits_pow13\
    \ = 0;\n    let mut num_primes_digits_pow14 = 0;\n    let mut num_primes_digits_pow15\
    \ = 0;\n    let mut num_primes_digits_pow16 = 0;\n    let mut num_primes_digits_pow17\
    \ = 0;\n    let mut num_primes_digits_pow18 = 0;\n    let mut num_primes_digits_pow19\
    \ = 0;\n    let mut num_primes_digits_pow20 = 0;\n    let mut num_primes_digits_pow21\
    \ = 0;\n    let mut num_primes_digits_pow22 = 0;\n    let mut num_primes_digits_pow23\
    \ = 0;\n    let mut num_primes_digits_pow24 = 0;\n    let mut num_primes_digits_pow25\
    \ = 0;\n    let mut num_primes_digits_pow26 = 0;\n    let mut num_primes_digits_pow27\
    \ = 0;\n    let mut num_primes_digits_pow28 = 0;\n    let mut num_primes_digits_pow29\
    \ = 0;\n    let mut num_primes_digits_pow30 = 0;\n    let mut num_primes_digits_pow31\
    \ = 0;\n    let mut num_primes_digits_pow32 = 0;\n    let mut num_primes_digits_pow33\
    \ = 0;\n    let mut num_primes_digits_pow34 = 0;\n    let mut num_primes_digits_pow35\
    \ = 0;\n    let mut num_primes_digits_pow36 = 0;\n    let mut num_primes_digits_pow37\
    \ = 0;\n    let mut num_primes_digits_pow38 = 0;\n    let mut num_primes_digits_pow39\
    \ = 0;\n    let mut num_primes_digits_pow40 = 0;\n    let mut num_\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprjbob38a.rs:66:17\n   |\n\
    66 |     let mut num_\n   |                 ^ help: add `;` here\n67 | }\n   |\
    \ - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprjbob38a.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: isize = 0;\n    let mut prime_digit_sum: isize = 0;\n\
    \    let mut prime_digit_sum2: isize = 0;\n    let mut prime_digit_sum3: isize\
    \ = 0;\n    let mut prime_digit_sum4: isize = 0;\n    let mut prime_digit_sum5:\
    \ isize = 0;\n    let mut prime_digit_sum6: isize = 0;\n    let mut prime_digit_sum7:\
    \ isize = 0;\n    let mut prime_digit_sum8: isize = 0;\n    let mut prime_digit_sum9:\
    \ isize = 0;\n    let mut prime_digit_sum10: isize = 0;\n    let mut prime_digit_sum11:\
    \ isize = 0;\n    let mut prime_digit_sum12: isize = 0;\n    let mut prime_digit_sum13:\
    \ isize = 0;\n    let mut prime_digit_sum14: isize = 0;\n    let mut prime_digit_sum15:\
    \ isize = 0;\n    let mut prime_digit_sum16: isize = 0;\n    let mut prime_digit_sum17:\
    \ isize = 0;\n    let mut prime_digit_sum18: isize = 0;\n    let mut prime_digit_sum19:\
    \ isize = 0;\n    let mut prime_digit_sum20: isize = 0;\n    let mut prime_digit_sum21:\
    \ isize = 0;\n    let mut prime_digit_sum22: isize = 0;\n    let mut prime_digit_sum23:\
    \ isize = 0;\n    let mut prime_digit_sum24: isize = 0;\n    let mut prime_digit_sum25:\
    \ isize = 0;\n    let mut prime_digit_sum26: isize = 0;\n    let mut prime_digit_sum27:\
    \ isize = 0;\n    let mut prime_digit_sum28: isize = 0;\n    let mut prime_digit_sum29:\
    \ isize = 0;\n    let mut prime_digit_sum30: isize = 0;\n    let mut prime_digit_sum31:\
    \ isize = 0;\n    let mut prime_digit_sum32: isize = 0;\n    let mut prime_digit_sum33:\
    \ isize = 0;\n    let mut prime_digit_sum34: isize = 0;\n    let mut prime_digit_sum35:\
    \ isize = 0;\n    let mut prime_digit_sum36: isize = 0;\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwxfzejdb.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmpwxfzejdb.rs:23:55\n     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_digits = num.len();\n    let mut num_primes = 0;\n    let mut num_primes_digits\
    \ = 0;\n    let mut num_primes_digits_pow2 = 0;\n    let mut num_primes_digits_pow3\
    \ = 0;\n    let mut num_primes_digits_pow4 = 0;\n    let mut num_primes_digits_pow5\
    \ = 0;\n    let mut num_primes_digits_pow6 = 0;\n    let mut num_primes_digits_pow7\
    \ = 0;\n    let mut num_primes_digits_pow8 = 0;\n    let mut num_primes_digits_pow9\
    \ = 0;\n    let mut num_primes_digits_pow10 = 0;\n    let mut num_primes_digits_pow11\
    \ = 0;\n    let mut num_primes_digits_pow12 = 0;\n    let mut num_primes_digits_pow13\
    \ = 0;\n    let mut num_primes_digits_pow14 = 0;\n    let mut num_primes_digits_pow15\
    \ = 0;\n    let mut num_primes_digits_pow16 = 0;\n    let mut num_primes_digits_pow17\
    \ = 0;\n    let mut num_primes_digits_pow18 = 0;\n    let mut num_primes_digits_pow19\
    \ = 0;\n    let mut num_primes_digits_pow20 = 0;\n    let mut num_primes_digits_pow21\
    \ = 0;\n    let mut num_primes_digits_pow22 = 0;\n    let mut num_primes_digits_pow23\
    \ = 0;\n    let mut num_primes_digits_pow24 = 0;\n    let mut num_primes_digits_pow25\
    \ = 0;\n    let mut num_primes_digits_pow26 = 0;\n    let mut num_primes_digits_pow27\
    \ = 0;\n    let mut num_primes_digits_pow28 = 0;\n    let mut num_primes_digits_pow29\
    \ = 0;\n    let mut num_primes_digits_pow30 = 0;\n    let mut num_primes_digits_pow31\
    \ = 0;\n    let mut num_primes_digits_pow32 = 0;\n    let mut num_primes_digits_pow33\
    \ = 0;\n    let mut num_primes_digits_pow34 = 0;\n    let mut num_primes_digits_pow35\
    \ = 0;\n    let mut num_primes_digits_pow36 = 0;\n    let mut num_primes_digits_pow37\
    \ = 0;\n    let mut num_primes_digits_pow38 = 0;\n    let mut num_primes_digits_pow39\
    \ = 0;\n    let mut num_primes_digits_pow40 = 0;\n    let mu\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphgd9plhb.rs:66:11\n   |\n\
    66 |     let mu\n   |           ^ help: add `;` here\n67 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmphgd9plhb.rs:23:52\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphgd9plhb.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.to_string().chars().collect::<Vec<_>>();\n \
    \   let mut nums_iter = nums.iter();\n    let mut num_digits = nums.len();\n \
    \   let mut prime_digits = vec![];\n    let mut prime_digits_iter = prime_digits.iter();\n\
    \    let mut prime_digits_len = prime_digits_iter.len();\n    let mut prime_digits_iter\
    \ = prime_digits.iter();\n    let mut prime_digits_len = prime_digits_iter.len();\n\
    \    let mut prime_digits_iter = prime_digits.iter();\n    let mut prime_digits_len\
    \ = prime_digits_iter.len();\n    let mut prime_digits_iter = prime_digits.iter();\n\
    \    let mut prime_digits_len = prime_digits_iter.len();\n    let mut prime_digits_iter\
    \ = prime_digits.iter();\n    let mut prime_digits_len = prime_digits_iter.len();\n\
    \    let mut prime_digits_iter = prime_digits.iter();\n    let mut prime_digits_len\
    \ = prime_digits_iter.len();\n    let mut prime_digits_iter = prime_digits.iter();\n\
    \    let mut prime_digits_len = prime_digits_iter.len();\n    let mut prime_digits_iter\
    \ = prime_digits.iter();\n    let mut prime_digits_len = prime_digits_iter.len();\n\
    \    let mut prime_digits_iter = prime_digits.iter();\n    let mut prime_digits_len\
    \ = prime_digits_iter.len();\n    let mut prime_digits_iter = prime_digits.iter();\n\
    \    let mut prime_digits_len = prime_digits_iter.len();\n    let mut prime_digits_iter\
    \ = prime_digits.iter();\n    let mut prime_digits_len = prime_digits_iter.len();\n\
    \    let mut prime_digits_iter = prime_digits.iter();\n    let mut prime_digits_len\
    \ = prime_digits_iter.len();\n    let mut prime_digits_iter = prime_digits.iter();\n\
    \    let mut prime_digits_len = prime_digits_iter.len();\n    let mut prime_digits_iter\
    \ = prime_digits.iter();\n    let mut prime_digits_len = prime_digits_iter.len();\n\
    \    let mut prime_digits_iter = prime_digits.iter();\n    let mut prime_digits_len\
    \ = prime_digits_iter.len();\n    let mut prime_digits_iter = prime_\n}\n\nfn\
    \ main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxezgmxh_.rs:57:39\n   |\n\
    57 |     let mut prime_digits_iter = prime_\n   |                            \
    \           ^ help: add `;` here\n58 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `prime_` in this scope\n  --> /tmp/tmpxezgmxh_.rs:57:33\n\
    \   |\n57 |     let mut prime_digits_iter = prime_\n   |                     \
    \            ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxezgmxh_.rs:22:28\n   |\n22 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len - 1;\n    let mut prime_len = prime_len - 1;\n    let mut prime_len\
    \ = prime_len\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3k8iu8vu.rs:65:34\n   |\n\
    65 |     let mut prime_len = prime_len\n   |                                 \
    \ ^ help: add `;` here\n66 | }\n   | - unexpected token\n\nerror[E0277]: a value\
    \ of type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmp3k8iu8vu.rs:23:55\n     |\n23   |     let mut num: Vec<u8> =\
    \ num.to_lowercase().chars().collect();\n     |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3k8iu8vu.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17];\n    let mut num_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17];\n    let mut num_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17];\n    let mut num_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17];\n    let mut num_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17];\n    let mut num_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17];\n    let mut num_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17];\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpvvbhg17q.rs:39:1\n\
    \   |\n39 | }\n   | ^ expected expression\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpvvbhg17q.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_len\
    \ = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n    let mut\
    \ num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqkb8wb1z.rs:59:22\n   |\n\
    59 |     let mut num_prime\n   |                      ^ help: add `;` here\n60\
    \ | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpqkb8wb1z.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqkb8wb1z.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter_index: usize\
    \ = 0;\n    let mut prime_counter_index2: usize = 0;\n    let mut prime_counter_index3:\
    \ usize = 0;\n    let mut prime_counter_index4: usize = 0;\n    let mut prime_counter_index5:\
    \ usize = 0;\n    let mut prime_counter_index6: usize = 0;\n    let mut prime_counter_index7:\
    \ usize = 0;\n    let mut prime_counter_index8: usize = 0;\n    let mut prime_counter_index9:\
    \ usize = 0;\n    let mut prime_counter_index10: usize = 0;\n    let mut prime_counter_index11:\
    \ usize = 0;\n    let mut prime_counter_index12: usize = 0;\n    let mut prime_counter_index13:\
    \ usize = 0;\n    let mut prime_counter_index14: usize = 0;\n    let mut prime_counter_index15:\
    \ usize = 0;\n    let mut prime_counter_index16: usize = 0;\n    let mut prime_counter_index17:\
    \ usize = 0;\n    let mut prime_counter_index18: usize = 0;\n    let mut prime_counter_index19:\
    \ usize = 0;\n    let mut prime_counter_index20: usize = 0;\n    let mut prime_counter_index21:\
    \ usize = 0;\n    let mut prime_counter_index22: usize = 0;\n    let mut prime_counter_index23:\
    \ usize = 0;\n    let mut prime_counter_index24: usize = 0;\n    let mut prime_counter_index25:\
    \ usize = 0;\n    let mut prime_counter_index26: usize = 0;\n    let mut prime_counter_index27:\
    \ usize = 0;\n    let mut prime_counter_index28: usize = 0;\n    let mut prime_counter_index29:\
    \ usize = 0;\n    let mut prime_counter_index30: usize = 0;\n    let mut prime_counter_index31:\
    \ usize = 0;\n    let mut prime_counter_index32: usize = 0;\n    let mut prime_counter_index33:\
    \ usize = 0;\n    let mut prime_\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpw2o6zrt8.rs:59:19\n   |\n\
    59 |     let mut prime_\n   |                   ^ help: add `;` here\n60 | }\n\
    \   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be\
    \ built from an iterator over elements of type `char`\n    --> /tmp/tmpw2o6zrt8.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw2o6zrt8.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count = 0;\n    let mut prime_digits = vec![];\n    let mut\
    \ prime_digit = vec![];\n    let mut prime_digit_count = 0;\n    let mut prime_digit_index\
    \ = 0;\n    let mut prime_digit_value = 1;\n    let mut prime_digit_index2 = 0;\n\
    \    let mut prime_digit_value2 = 1;\n    let mut prime_digit_index3 = 0;\n  \
    \  let mut prime_digit_value3 = 1;\n    let mut prime_digit_index4 = 0;\n    let\
    \ mut prime_digit_value4 = 1;\n    let mut prime_digit_index5 = 0;\n    let mut\
    \ prime_digit_value5 = 1;\n    let mut prime_digit_index6 = 0;\n    let mut prime_digit_value6\
    \ = 1;\n    let mut prime_digit_index7 = 0;\n    let mut prime_digit_value7 =\
    \ 1;\n    let mut prime_digit_index8 = 0;\n    let mut prime_digit_value8 = 1;\n\
    \    let mut prime_digit_index9 = 0;\n    let mut prime_digit_value9 = 1;\n  \
    \  let mut prime_digit_index10 = 0;\n    let mut prime_digit_value10 = 1;\n  \
    \  let mut prime_digit_index11 = 0;\n    let mut prime_digit_value11 = 1;\n  \
    \  let mut prime_digit_index12 = 0;\n    let mut prime_digit_value12 = 1;\n  \
    \  let mut prime_digit_index13 = 0;\n    let mut prime_digit_value13 = 1;\n  \
    \  let mut prime_digit_index14 = 0;\n    let mut prime_digit_value14 = 1;\n  \
    \  let mut prime_digit_index15 = 0;\n    let mut prime_digit_value15 = 1;\n  \
    \  let mut prime_digit_index16 = 0;\n    let mut prime_digit_value16 = 1;\n  \
    \  let mut prime_digit_index17 = 0;\n    let mut prime_digit_value17 = 1;\n  \
    \  let mut prime_digit_index18 = 0;\n    let mut prime_digit_value18 = 1;\n  \
    \  let mut prime_digit_index19 = 0;\n    let mut prime_digit_value19 = 1;\n  \
    \  let mut prime_digit_index20 = 0;\n    let mut prime_digit_value20 = 1;\n  \
    \  let mut prime_digit_index21 = 0;\n    let mut prime_digit_value21 = 1;\n  \
    \  let mut prime_digit_index22 = 0;\n    let mut prime_digit_value22 = 1;\n  \
    \  let mut prime_digit_index23 = 0;\n    let mut prime_digit_value23 = 1;\n  \
    \  let mut \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpvwooazls.rs:75:1\n\
    \   |\n75 | }\n   | ^ expected identifier\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpvwooazls.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut counter:\
    \ usize = 0;\n    let mut i: usize = 0;\n    while i < num.len() {\n        if\
    \ num[i] == num[num.len() - 1] {\n            i += 1;\n        } else {\n    \
    \        prime = prime.iter().filter(|&x| num[i] == x).collect();\n          \
    \  counter += prime.len();\n            i += 1;\n        }\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpv7pkodad.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv7pkodad.rs:31:56\n\
    \   |\n31 |             prime = prime.iter().filter(|&x| num[i] == x).collect();\n\
    \   |                                                        ^ expected `u8`,\
    \ found `&u8`\n   |\nhelp: consider dereferencing the borrow\n   |\n31 |     \
    \        prime = prime.iter().filter(|&x| num[i] == *x).collect();\n   |     \
    \                                                   +\n\nerror[E0277]: a value\
    \ of type `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n\
    \    --> /tmp/tmpv7pkodad.rs:31:59\n     |\n31   |             prime = prime.iter().filter(|&x|\
    \ num[i] == x).collect();\n     |                                            \
    \               ^^^^^^^ value of type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=&u8>`\n\
    \     |\n     = help: the trait `FromIterator<&u8>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv7pkodad.rs:36:5\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \   ----- expected `isize` because of return type\n...\n36 |     counter\n   |\
    \     ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n36 |     counter.try_into().unwrap()\n\
    \   |            ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime_digits = vec![false; 16];\n    let mut prime_digits_count = vec![0;\
    \ 16];\n    let mut prime_digits_count_max = vec![0; 16];\n    let mut prime_digits_count_max_index\
    \ = vec![0; 16];\n    let mut prime_digits_count_min = vec![0; 16];\n    let mut\
    \ prime_digits_count_min_index = vec![0; 16];\n    let mut prime_digits_count_max\
    \ = vec![0; 16];\n    let mut prime_digits_count_max_index = vec![0; 16];\n  \
    \  let mut prime_digits_count_min = vec![0; 16];\n    let mut prime_digits_count_min_index\
    \ = vec![0; 16];\n    let mut prime_digits_count_max = vec![0; 16];\n    let mut\
    \ prime_digits_count_max_index = vec![0; 16];\n    let mut prime_digits_count_min\
    \ = vec![0; 16];\n    let mut prime_digits_count_min_index = vec![0; 16];\n  \
    \  let mut prime_digits_count_max = vec![0; 16];\n    let mut prime_digits_count_max_index\
    \ = vec![0; 16];\n    let mut prime_digits_count_min = vec![0; 16];\n    let mut\
    \ prime_digits_count_min_index = vec![0; 16];\n    let mut prime_digits_count_max\
    \ = vec![0; 16];\n    let mut prime_digits_count_max_index = vec![0; 16];\n  \
    \  let mut prime_digits_count_min = vec![0; 16];\n    let mut prime_digits_count_min_index\
    \ = vec![0; 16];\n    let mut prime_digits_count_max = vec![0; 16];\n    let mut\
    \ prime_digits_count_max_index = vec![0; 16];\n    let mut prime_digits_count_min\
    \ = vec![0; 16];\n    let mut prime_digits_count_min_index = vec![0; 16];\n  \
    \  let mut prime_digits_count_max = vec![0; 16];\n    let mut prime_digits_count_max_index\
    \ = vec![0; 16];\n    let mut prime_digits_count_min = vec![0; 16];\n    let mut\
    \ prime_digits_count_min_index = vec![0; 16];\n    let mut prime_digits_count_max\
    \ = vec![0; 16];\n    let mut prime_digits_count_max_index = vec![0; 16];\n\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpuujpwymr.rs:23:52\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuujpwymr.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count: isize = 0;\n    let mut prime: isize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpzu97yleu.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpzu97yleu.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_2:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_3: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut num_prime_4: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut num_prime_5: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_6:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_7: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut num_prime_8: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut num_prime_9: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_10:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_11: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp0_5hsfdc.rs:34:41\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n34 |     let mut num_prime_11:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, \n   |                                      \
    \   ^ unclosed delimiter\n35 | }\n   | ^ mismatched closing delimiter\n\nerror:\
    \ expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmp0_5hsfdc.rs:35:1\n\
    \   |\n35 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\n\
    error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmp0_5hsfdc.rs:23:55\n     |\n23   | \
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |    \
    \                                                   ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut i: usize =\
    \ 0;\n    let mut j: usize = 0;\n    let mut k: usize = 0;\n    let mut l: usize\
    \ = 0;\n    let mut m: usize = 0;\n    let mut n: usize = 0;\n    let mut o: usize\
    \ = 0;\n    let mut p: usize = 0;\n    let mut q: usize = 0;\n    let mut r: usize\
    \ = 0;\n    let mut s: usize = 0;\n    let mut t: usize = 0;\n    let mut u: usize\
    \ = 0;\n    let mut v: usize = 0;\n    let mut w: usize = 0;\n    let mut x: usize\
    \ = 0;\n    let mut y: usize = 0;\n    let mut z: usize = 0;\n    let mut a: usize\
    \ = 0;\n    let mut b: usize = 0;\n    let mut c: usize = 0;\n    let mut d: usize\
    \ = 0;\n    let mut e: usize = 0;\n    let mut f: usize = 0;\n    let mut g: usize\
    \ = 0;\n    let mut h: usize = 0;\n    let mut i: usize = 0;\n    let mut j: usize\
    \ = 0;\n    let mut k: usize = 0;\n    let mut l: usize = 0;\n    let mut m: usize\
    \ = 0;\n    let mut n: usize = 0;\n    let mut o: usize = 0;\n    let mut p: usize\
    \ = 0;\n    let mut q: usize = 0;\n    let mut r: usize = 0;\n    let mut s: usize\
    \ = 0;\n    let mut t: usize = 0;\n    let mut u: usize = 0;\n    let mut v: usize\
    \ = 0;\n    let mut w: usize = 0;\n    let mut x: usize = 0;\n    let mut y: usize\
    \ = 0;\n    let mut z: usize = 0;\n    let mut a: usize = 0;\n    let mut b: usize\
    \ = 0;\n    let mut c: usize = 0;\n    let mut d: usize = 0;\n    let mut e: usize\
    \ = 0;\n    let mut f: usize = 0;\n    let mut g: usize = 0;\n    let mut h: usize\
    \ = 0;\n    let mut i: usize = 0;\n    let mut j: usize = 0;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmps0fr3912.rs:80:1\n  \
    \ |\n80 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmps0fr3912.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let mut\
    \ prime_digit_count: usize = 0;\n    let mut prime_digit_index: usize = 0;\n \
    \   let mut prime_digit_value: u8 = 0;\n    let mut prime_digit_is_prime: u8 =\
    \ 0;\n    let mut prime_digit_is_prime_2: u8 = 0;\n    let mut prime_digit_is_prime_3:\
    \ u8 = 0;\n    let mut prime_digit_is_prime_4: u8 = 0;\n    let mut prime_digit_is_prime_5:\
    \ u8 = 0;\n    let mut prime_digit_is_prime_6: u8 = 0;\n    let mut prime_digit_is_prime_7:\
    \ u8 = 0;\n    let mut prime_digit_is_prime_8: u8 = 0;\n    let mut prime_digit_is_prime_9:\
    \ u8 = 0;\n    let mut prime_digit_is_prime_10: u8 = 0;\n    let mut prime_digit_is_prime_11:\
    \ u8 = 0;\n    let mut prime_digit_is_prime_12: u8 = 0;\n    let mut prime_digit_is_prime_13:\
    \ u8 = 0;\n    let mut prime_digit_is_prime_14: u8 = 0;\n    let mut prime_digit_is_prime_15:\
    \ u8 = 0;\n    let mut prime_digit_is_prime_16: u8 = 0;\n    let mut prime_digit_is_prime_17:\
    \ u8 = 0;\n    let mut prime_digit_is_prime_18: u8 = 0;\n    let mut prime_digit_is_prime_19:\
    \ u8 = 0;\n    let mut prime_digit_is_prime_20: u8 = 0;\n    let mut prime_digit_is_prime_21:\
    \ u8 = 0;\n    let mut prime_digit_is_prime_22: u8 = 0;\n    let mut prime_digit_is_prime_23:\
    \ u8 = 0;\n    let mut prime_digit_is_prime_24: u8 = 0;\n    let mut prime_digit_is_prime_25:\
    \ u8 = 0;\n    let mut prime_digit_is_prime_26: u8 = 0;\n    let mut prime_digit_is_prime_27:\
    \ u8 = 0;\n    let mut prime_digit_is_prime_28: u8 = 0;\n    let mut prime_digit_is_prime_29:\
    \ u8 = 0;\n    let mut prime_digit_is_prime_30: u8 = 0;\n    let mut prime_digit_is_prime_31:\
    \ u8 = 0;\n    let mut prime_digit_is_prime_32: u8 = 0;\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpib76p8se.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmpib76p8se.rs:23:52\n     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoz99ncue.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpoz99ncue.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpoz99ncue.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoz99ncue.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_str: String = String::new();\n    let mut num_str2: String = String::new();\n\
    \    let mut num_str3: String = String::new();\n    let mut num_str4: String =\
    \ String::new();\n    let mut num_str5: String = String::new();\n    let mut num_str6:\
    \ String = String::new();\n    let mut num_str7: String = String::new();\n   \
    \ let mut num_str8: String = String::new();\n    let mut num_str9: String = String::new();\n\
    \    let mut num_str10: String = String::new();\n    let mut num_str11: String\
    \ = String::new();\n    let mut num_str12: String = String::new();\n    let mut\
    \ num_str13: String = String::new();\n    let mut num_str14: String = String::new();\n\
    \    let mut num_str15: String = String::new();\n    let mut num_str16: String\
    \ = String::new();\n    let mut num_str17: String = String::new();\n    let mut\
    \ num_str18: String = String::new();\n    let mut num_str19: String = String::new();\n\
    \    let mut num_str20: String = String::new();\n    let mut num_str21: String\
    \ = String::new();\n    let mut num_str22: String = String::new();\n    let mut\
    \ num_str23: String = String::new();\n    let mut num_str24: String = String::new();\n\
    \    let mut num_str25: String = String::new();\n    let mut num_str26: String\
    \ = String::new();\n    let mut num_str27: String = String::new();\n    let mut\
    \ num_str28: String = String::new();\n    let mut num_str29: String = String::new();\n\
    \    let mut num_str30: String = String::new();\n    let mut num_str31: String\
    \ = String::new();\n    let mut num_str32: String = String::new();\n    let mut\
    \ num_str33: String = String::new();\n    let mut num_str34: String = String::new();\n\
    \    let mut num_str35: String = String::new();\n    let mut num_str36: String\
    \ = String::new();\n    let mut num_str37: String = String::new();\n    let mut\
    \ num_str38: String = String::new();\n    let mut num_\n}\n\nfn main() {\n   \
    \ let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2z_czrbm.rs:62:17\n   |\n\
    62 |     let mut num_\n   |                 ^ help: add `;` here\n63 | }\n   |\
    \ - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n    --> /tmp/tmp2z_czrbm.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2z_czrbm.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|x| x != 0).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|x| x % 2 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x|\
    \ x % 3 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x %\
    \ 5 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x % 7 ==\
    \ 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x % 11 == 0).collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|x| x % 13 == 0).collect();\n  \
    \  let mut num: Vec<u8> = num.iter().filter(|x| x % 17 == 0).collect();\n    let\
    \ mut num: Vec<u8> = num.iter().filter(|x| x % 19 == 0).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().filter(|x| x % 23 == 0).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().filter(|x| x % 29 == 0).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().filter(|x| x % 31 == 0).collect();\n    let mut num: Vec<u8> =\
    \ num.iter().filter(|x| x % 37 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x|\
    \ x % 41 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x\
    \ % 43 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x %\
    \ 47 == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x % 53\
    \ == 0).collect();\n    let mut num: Vec<u8> = num.iter().filter(|x| x % 59 ==\
    \ 0).collect();\n    let mut num: \n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `}`\n  --> /tmp/tmpte9iglew.rs:44:1\n   |\n\
    43 |     let mut num: \n   |         ------- while parsing the type for `mut num`\n\
    44 | }\n   | ^ expected type\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpte9iglew.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: can't compare `&&u8` with `{integer}`\n\
    \  --> /tmp/tmpte9iglew.rs:25:52\n   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|x|\
    \ x != 0).collect();\n   |                                                   \
    \ ^^ no implementation for `&&u8 == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&&u8`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `&u8`\n    --> /tmp/tmpte9iglew.rs:25:58\n\
    \     |\n25   |     let mut num: Vec<u8> = num.iter().filter(|x| x != 0).collect();\n\
    \     |                                                          ^^^^^^^ value\
    \ of type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=&u8>`\n   \
    \  |\n     = help: the trait `FromIterator<&u8>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0369]: cannot mod `&&u8` by `{integer}`\n\
    \  --> /tmp/tmpte9iglew.rs:26:52\n   |\n26 |     let mut num: Vec<u8> = num.iter().filter(|x|\
    \ x % 2 == 0).collect();\n   |                "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_len\
    \ = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n    let mut\
    \ num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime_len = num_prime.len();\n    let mut num_prime_len = num_prime.len();\n\
    \    let mut num_prime\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpqkb8wb1z.rs:59:22\n   |\n\
    59 |     let mut num_prime\n   |                      ^ help: add `;` here\n60\
    \ | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpqkb8wb1z.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqkb8wb1z.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: isize = 0;\n    let mut prime_digit_index: usize = 0;\n\
    \    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index: usize\
    \ = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n    let mut prime_digit_index:\
    \ usize = 0;\n    let mut prime_digit_count: isize = 0;\n\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu_n8r6hl.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmpu_n8r6hl.rs:23:55\n     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_digits = num.len();\n    let mut prime_digits = Vec::new();\n\
    \    let mut prime_digits_counter = Vec::new();\n    let mut prime_digits_counter2\
    \ = Vec::new();\n    let mut prime_digits_counter3 = Vec::new();\n    let mut\
    \ prime_digits_counter4 = Vec::new();\n    let mut prime_digits_counter5 = Vec::new();\n\
    \    let mut prime_digits_counter6 = Vec::new();\n    let mut prime_digits_counter7\
    \ = Vec::new();\n    let mut prime_digits_counter8 = Vec::new();\n    let mut\
    \ prime_digits_counter9 = Vec::new();\n    let mut prime_digits_counter10 = Vec::new();\n\
    \    let mut prime_digits_counter11 = Vec::new();\n    let mut prime_digits_counter12\
    \ = Vec::new();\n    let mut prime_digits_counter13 = Vec::new();\n    let mut\
    \ prime_digits_counter14 = Vec::new();\n    let mut prime_digits_counter15 = Vec::new();\n\
    \    let mut prime_digits_counter16 = Vec::new();\n    let mut prime_digits_counter17\
    \ = Vec::new();\n    let mut prime_digits_counter18 = Vec::new();\n    let mut\
    \ prime_digits_counter19 = Vec::new();\n    let mut prime_digits_counter20 = Vec::new();\n\
    \    let mut prime_digits_counter21 = Vec::new();\n    let mut prime_digits_counter22\
    \ = Vec::new();\n    let mut prime_digits_counter23 = Vec::new();\n    let mut\
    \ prime_digits_counter24 = Vec::new();\n    let mut prime_digits_counter25 = Vec::new();\n\
    \    let mut prime_digits_counter26 = Vec::new();\n    let mut prime_digits_counter27\
    \ = Vec::new();\n    let mut prime_digits_counter28 = Vec::new();\n    let mut\
    \ prime_digits_counter29 = Vec::new();\n    let mut prime_digits_counter30 = Vec::new();\n\
    \    let mut prime_digits_counter31 = Vec::new();\n    let mut prime_digits_counter32\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmo0l0zi9.rs:58:11\n   |\n\
    58 |     let mu\n   |           ^ help: add `;` here\n59 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpmo0l0zi9.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmo0l0zi9.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgqi8w048.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpgqi8w048.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgqi8w048.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgqi8w048.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpgqi8w048.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgqi8w048.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp05y_kyza.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmp05y_kyza.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp05y_kyza.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp05y_kyza.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmp05y_kyza.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp05y_kyza.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf8uq_llq.rs:39:36\n   |\n\
    39 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpf8uq_llq.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf8uq_llq.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8uq_llq.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpf8uq_llq.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8uq_llq.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoz99ncue.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpoz99ncue.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpoz99ncue.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoz99ncue.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_prime: Vec<u8> = vec![0; 8];\n    let mut num_prime_counter: usize\
    \ = 0;\n    let mut num_prime_counter2: usize = 0;\n    let mut num_prime_counter3:\
    \ usize = 0;\n    let mut num_prime_counter4: usize = 0;\n    let mut num_prime_counter5:\
    \ usize = 0;\n    let mut num_prime_counter6: usize = 0;\n    let mut num_prime_counter7:\
    \ usize = 0;\n    let mut num_prime_counter8: usize = 0;\n    let mut num_prime_counter9:\
    \ usize = 0;\n    let mut num_prime_counter10: usize = 0;\n    let mut num_prime_counter11:\
    \ usize = 0;\n    let mut num_prime_counter12: usize = 0;\n    let mut num_prime_counter13:\
    \ usize = 0;\n    let mut num_prime_counter14: usize = 0;\n    let mut num_prime_counter15:\
    \ usize = 0;\n    let mut num_prime_counter16: usize = 0;\n    let mut num_prime_counter17:\
    \ usize = 0;\n    let mut num_prime_counter18: usize = 0;\n    let mut num_prime_counter19:\
    \ usize = 0;\n    let mut num_prime_counter20: usize = 0;\n    let mut num_prime_counter21:\
    \ usize = 0;\n    let mut num_prime_counter22: usize = 0;\n    let mut num_prime_counter23:\
    \ usize = 0;\n    let mut num_prime_counter24: usize = 0;\n    let mut num_prime_counter25:\
    \ usize = 0;\n    let mut num_prime_counter26: usize = 0;\n    let mut num_prime_counter27:\
    \ usize = 0;\n    let mut num_prime_counter28: usize = 0;\n    let mut num_prime_counter29:\
    \ usize = 0;\n    let mut num_prime_counter30: usize = 0;\n    let mut num_prime_counter31:\
    \ usize = 0;\n    let mut num_prime_counter32: usize = 0;\n    let mut num_prime_counter33:\
    \ usize = 0;\n    let mut num_prime_counter34: usize = 0;\n    let mut num_prime_counter35:\
    \ usize = 0;\n    let mut num_prime_counter36: usize = 0;\n    let mut num_prime_counter37:\
    \ usize = 0;\n\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpz3pbnbml.rs:23:52\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz3pbnbml.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime: isize = 2;\n    while\
    \ prime < num.len() {\n        if num[prime - 1] == num[prime] {\n           \
    \ prime_count = prime_count+1;\n        }\n        prime = prime+1;\n    }\n \
    \   prime_count\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmplhcfaq59.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplhcfaq59.rs:26:19\n\
    \   |\n26 |     while prime < num.len() {\n   |                   ^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n26 |     while prime < num.len().try_into().unwrap()\
    \ {\n   |                            ++++++++++++++++++++\n\nerror[E0277]: the\
    \ type `[u8]` cannot be indexed by `isize`\n  --> /tmp/tmplhcfaq59.rs:27:12\n\
    \   |\n27 |         if num[prime - 1] == num[prime] {\n   |            ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[u8]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<u8>`\n\nerror[E0277]:\
    \ the type `[u8]` cannot be indexed by `isize`\n  --> /tmp/tmplhcfaq59.rs:27:30\n\
    \   |\n27 |         if num[prime - 1] == num[prime] {\n   |                  \
    \            ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[u8]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<u8>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime_digits = vec![];\n    let mut prime_digits_len = vec![];\n   \
    \ let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mut prime_digits_len = vec![];\n\
    \    let mut prime_digits_len = vec![];\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpksx0vjvh.rs:65:11\n   |\n\
    65 |     let mu\n   |           ^ help: add `;` here\n66 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpksx0vjvh.rs:23:52\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpksx0vjvh.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count: isize = 0;\n    let mut prime: isize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpzu97yleu.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpzu97yleu.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = num.clone();\n    let mut num_prime_prime: Vec<u8>\
    \ = num_prime.clone();\n    let mut num_prime_prime_prime: Vec<u8> = num_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8>\
    \ = num_prime_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n    let\
    \ mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8nfbxm84.rs:37:122\n   |\n\
    37 |     let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_\n   |                         \
    \                                                                            \
    \                     ^ help: add `;` here\n38 | }\n   | - unexpected token\n\n\
    error[E0425]: cannot find value `num_prime_prime_prime_prime_prime_prime_prime_prime_prime`\
    \ in this scope\n  --> /tmp/tmp8nfbxm84.rs:35:82\n   |\n35 | ...e_prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `num_prime_prime_prime_prime_prime_prime_prime_prime`\n\
    \nerror[E0425]: cannot find value `num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime`\
    \ in this scope\n  --> /tmp/tmp8nfbxm84.rs:36:82\n   |\n36 | ...prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `num_prime_prime_prime_prime_prime_prime_prime_prime_prime`\n\
    \nerror[E0425]: cannot find value `num_prime_prime_prime_prime_prime_` in this\
    \ scope\n  --> /tmp/tmp8nfbxm84.rs:37:88\n   |\n37 |     let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_\n   |                         \
    \                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `num_prime_prime_prime_prime_prime`\n\
    \nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmp8nfbxm84.rs:23:55\n     |\n23   | \
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |    \
    \                                                   ^^^^^^^ val"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_digits = vec![];\n    let mut prime_digits_counter: usize =\
    \ 0;\n    let mut prime_digits_counter2: usize = 0;\n    let mut prime_digits_counter3:\
    \ usize = 0;\n    let mut prime_digits_counter4: usize = 0;\n    let mut prime_digits_counter5:\
    \ usize = 0;\n    let mut prime_digits_counter6: usize = 0;\n    let mut prime_digits_counter7:\
    \ usize = 0;\n    let mut prime_digits_counter8: usize = 0;\n    let mut prime_digits_counter9:\
    \ usize = 0;\n    let mut prime_digits_counter10: usize = 0;\n    let mut prime_digits_counter11:\
    \ usize = 0;\n    let mut prime_digits_counter12: usize = 0;\n    let mut prime_digits_counter13:\
    \ usize = 0;\n    let mut prime_digits_counter14: usize = 0;\n    let mut prime_digits_counter15:\
    \ usize = 0;\n    let mut prime_digits_counter16: usize = 0;\n    let mut prime_digits_counter17:\
    \ usize = 0;\n    let mut prime_digits_counter18: usize = 0;\n    let mut prime_digits_counter19:\
    \ usize = 0;\n    let mut prime_digits_counter20: usize = 0;\n    let mut prime_digits_counter21:\
    \ usize = 0;\n    let mut prime_digits_counter22: usize = 0;\n    let mut prime_digits_counter23:\
    \ usize = 0;\n    let mut prime_digits_counter24: usize = 0;\n    let mut prime_digits_counter25:\
    \ usize = 0;\n    let mut prime_digits_counter26: usize = 0;\n    let mut prime_digits_counter27:\
    \ usize = 0;\n    let mut prime_digits_counter28: usize = 0;\n    let mut prime_digits_counter29:\
    \ usize = 0;\n    let mut prime_digits_counter30: usize = 0;\n    let mut prime_digits_counter31:\
    \ usize = 0;\n    let mut prime_digits_counter32: usize = 0;\n    let mut prime_digits_counter33:\
    \ usize = 0;\n    let mut prime_digits_counter34: usize = 0;\n    let mut prime_digits_counter35:\
    \ u\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjx7xqfoe.rs:59:38\n   |\n\
    59 |     let mut prime_digits_counter35: u\n   |                             \
    \         ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0412]:\
    \ cannot find type `u` in this scope\n  --> /tmp/tmpjx7xqfoe.rs:59:37\n   |\n\
    59 |     let mut prime_digits_counter35: u\n   |                             \
    \        ^ help: a builtin type with a similar name exists: `u8`\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpjx7xqfoe.rs:23:55\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_lowercase().chars().collect();\n     |                    \
    \                                   ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjx7xqfoe.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = 0;\n    let mut digits: Vec<&str> = num.to_string().chars().collect();\n\
    \    let mut primes: Vec<isize> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut primes_set:\
    \ HashSet<isize> = HashSet::new();\n    let mut primes_set_size: isize = 0;\n\
    \    let mut primes_set_size: isize = 0;\n    let mut primes_set_size: isize =\
    \ 0;\n    let mut primes_set_size: isize = 0;\n    let mut primes_set_size: isize\
    \ = 0;\n    let mut primes_set_size: isize = 0;\n    let mut primes_set_size:\
    \ isize = 0;\n    let mut primes_set_size: isize = 0;\n    let mut primes_set_size:\
    \ isize = 0;\n    let mut primes_set_size: isize = 0;\n    let mut primes_set_size:\
    \ isize = 0;\n    let mut primes_set_size: isize = 0;\n    let mut primes_set_size:\
    \ isize = 0;\n    let mut primes_set_size: isize = 0;\n    let mut primes_set_size:\
    \ isize = 0;\n    let mut primes_set_size: isize = 0;\n    let mut primes_set_size:\
    \ isize = 0;\n    let mut primes_set_size: isize = 0;\n    let mut primes_set_size:\
    \ isize = 0;\n    let mut primes_set_size: isize = 0;\n    let mut primes_set_size:\
    \ isize = 0;\n    let mut primes_set_size: isize = 0;\n    let mut primes_set_size:\
    \ isize = 0;\n    let mut primes_set_size: isize = 0;\n    let mut primes_set_size:\
    \ isize = 0;\n    let mut primes_set_size: isize = 0;\n    let mut primes_set_size:\
    \ isize = 0;\n    let mut primes_set_size: isize = 0;\n    let mut primes_set_size:\
    \ isize = 0;\n    let mut primes_set_size: isize = 0;\n    let mut primes_set_size:\
    \ isize = 0;\n    let mut primes_set_size: isize = 0;\n    let mut primes_set_size:\
    \ isize = 0;\n    let mut primes_set_size: isize = 0;\n    let mut primes_set_size:\
    \ isize = 0;\n    let mut primes_set_size: isize = 0;\n    let mut primes_set_size:\
    \ isize = 0;\n    let mut primes_set_size: isize = 0;\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpbmd62ock.rs:26:25\n\
    \   |\n26 |     let mut primes_set: HashSet<isize> = HashSet::new();\n   |   \
    \                      ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpbmd62ock.rs:26:42\n\
    \   |\n26 |     let mut primes_set: HashSet<isize> = HashSet::new();\n   |   \
    \                                       ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpbmd62ock.rs:24:57\n     |\n24\
    \   |     let mut digits: Vec<&str> = num.to_string().chars().collect();\n   \
    \  |                                                         ^^^^^^^ value of\
    \ type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=char>`\n   \
    \  |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbmd62ock.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi7xvf4vd.rs:64:31\n   |\n\
    64 |     let mut prime_counter40: u\n   |                               ^ help:\
    \ add `;` here\n65 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpi7xvf4vd.rs:64:30\n   |\n64 |     let mut prime_counter40:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpi7xvf4vd.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi7xvf4vd.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut primes\
    \ = vec![];\n    let mut primes_size = primes.len();\n    let mut primes_counter\
    \ = 0;\n    let mut primes_counter_size = 0;\n    let mut primes_counter_rem =\
    \ primes_counter;\n    let mut primes_counter_rem_size = primes_counter;\n   \
    \ let mut primes_counter_rem_primes = primes_counter;\n    let mut primes_counter_rem_primes_size\
    \ = primes_counter;\n    let mut primes_counter_rem_primes_primes = primes_counter;\n\
    \    let mut primes_counter_rem_primes_primes_size = primes_counter;\n    let\
    \ mut primes_counter_rem_primes_primes_primes = primes_counter;\n    let mut primes_counter_rem_primes_primes_primes_size\
    \ = primes_counter;\n    let mut primes_counter_rem_primes_primes_primes_primes_size\
    \ = primes_counter;\n    let mut primes_counter_rem_primes_primes_primes_primes_primes_size\
    \ = primes_counter;\n    let mut primes_counter_rem_primes_primes_primes_primes_primes_primes_size\
    \ = primes_counter;\n    let mut primes_counter_rem_primes_primes_primes_primes_primes_primes_size\
    \ = primes_counter;\n    let mut primes_counter_rem_primes_primes_primes_primes_primes_primes_primes_size\
    \ = primes_counter;\n    let mut primes_counter_rem_primes_primes_primes_primes_primes_primes_primes_primes_size\
    \ = primes_counter;\n    let mut primes_counter_rem_primes_primes_primes_primes_primes_primes_primes_primes_primes_size\
    \ = primes_counter;\n    let mut primes_counter_rem_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_size\
    \ = primes_counter;\n    let mut primes_counter_rem_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_size\
    \ = primes_counter;\n    let mut primes_counter_rem_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_size\
    \ = primes_counter;\n    let mut primes_counter_rem_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_size\
    \ = prime\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjvabwumh.rs:46:128\n   |\n\
    46 |     let mut primes_counter_rem_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_size\
    \ = prime\n   |                                                              \
    \                                                                  ^ help: add\
    \ `;` here\n47 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `prime` in this scope\n  --> /tmp/tmpjvabwumh.rs:46:123\n   |\n46 |     let\
    \ mut primes_counter_rem_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_size\
    \ = prime\n   |                                                              \
    \                                                             ^^^^^ help: a local\
    \ variable with a similar name exists: `primes`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjvabwumh.rs:22:28\n   |\n22 | fn hex_key(num: String) -> isize\
    \ {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![];\n    let mut num_prime_counter: usize\
    \ = 0;\n    let mut num_prime_counter2: usize = 0;\n    let mut num_prime_counter3:\
    \ usize = 0;\n    let mut num_prime_counter4: usize = 0;\n    let mut num_prime_counter5:\
    \ usize = 0;\n    let mut num_prime_counter6: usize = 0;\n    let mut num_prime_counter7:\
    \ usize = 0;\n    let mut num_prime_counter8: usize = 0;\n    let mut num_prime_counter9:\
    \ usize = 0;\n    let mut num_prime_counter10: usize = 0;\n    let mut num_prime_counter11:\
    \ usize = 0;\n    let mut num_prime_counter12: usize = 0;\n    let mut num_prime_counter13:\
    \ usize = 0;\n    let mut num_prime_counter14: usize = 0;\n    let mut num_prime_counter15:\
    \ usize = 0;\n    let mut num_prime_counter16: usize = 0;\n    let mut num_prime_counter17:\
    \ usize = 0;\n    let mut num_prime_counter18: usize = 0;\n    let mut num_prime_counter19:\
    \ usize = 0;\n    let mut num_prime_counter20: usize = 0;\n    let mut num_prime_counter21:\
    \ usize = 0;\n    let mut num_prime_counter22: usize = 0;\n    let mut num_prime_counter23:\
    \ usize = 0;\n    let mut num_prime_counter24: usize = 0;\n    let mut num_prime_counter25:\
    \ usize = 0;\n    let mut num_prime_counter26: usize = 0;\n    let mut num_prime_counter27:\
    \ usize = 0;\n    let mut num_prime_counter28: usize = 0;\n    let mut num_prime_counter29:\
    \ usize = 0;\n    let mut num_prime_counter30: usize = 0;\n    let mut num_prime_counter31:\
    \ usize = 0;\n    let mut num_prime_counter32: usize = 0;\n    let mut num_prime_counter33:\
    \ usize = 0;\n    let mut num_prime_counter34: usize = 0;\n    let mut num_prime_counter35:\
    \ usize = 0;\n    let mut num_prime_counter36: usize = 0;\n    let mut num_prime_counter37:\
    \ usize = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n   \
    \ assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprawpc3jg.rs:62:11\n   |\n\
    62 |     let mu\n   |           ^ help: add `;` here\n63 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmprawpc3jg.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprawpc3jg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digit:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digit_count: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_index: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpw0e6y3ja.rs:46:11\n   |\n\
    46 |     let mu\n   |           ^ help: add `;` here\n47 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpw0e6y3ja.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw0e6y3ja.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = 0;\n    let mut digit: char;\n    let mut\
    \ prime: isize = 0;\n    let mut prime_found = false;\n    let mut prime_found2\
    \ = false;\n    let mut prime_found3 = false;\n    let mut prime_found4 = false;\n\
    \    let mut prime_found5 = false;\n    let mut prime_found6 = false;\n    let\
    \ mut prime_found7 = false;\n    let mut prime_found8 = false;\n    let mut prime_found9\
    \ = false;\n    let mut prime_found10 = false;\n    let mut prime_found11 = false;\n\
    \    let mut prime_found12 = false;\n    let mut prime_found13 = false;\n    let\
    \ mut prime_found14 = false;\n    let mut prime_found15 = false;\n    let mut\
    \ prime_found16 = false;\n    let mut prime_found17 = false;\n    let mut prime_found18\
    \ = false;\n    let mut prime_found19 = false;\n    let mut prime_found20 = false;\n\
    \    let mut prime_found21 = false;\n    let mut prime_found22 = false;\n    let\
    \ mut prime_found23 = false;\n    let mut prime_found24 = false;\n    let mut\
    \ prime_found25 = false;\n    let mut prime_found26 = false;\n    let mut prime_found27\
    \ = false;\n    let mut prime_found28 = false;\n    let mut prime_found29 = false;\n\
    \    let mut prime_found30 = false;\n    let mut prime_found31 = false;\n    let\
    \ mut prime_found32 = false;\n    let mut prime_found33 = false;\n    let mut\
    \ prime_found34 = false;\n    let mut prime_found35 = false;\n    let mut prime_found36\
    \ = false;\n    let mut prime_found37 = false;\n    let mut prime_found38 = false;\n\
    \    let mut prime_found39 = false;\n    let mut prime_found40 = false;\n    let\
    \ mut prime_found41 = false;\n    let mut prime_found42 = false;\n    let mut\
    \ prime_found43 = false;\n    let mut prime_found44 = false;\n    let mut prime_found45\
    \ = false;\n    let mut prime_found46 = false;\n    let mut prime_found47 = false;\n\
    \    let mut prime_found48 = false;\n    let mut prime_found49 = false;\n    let\
    \ mut prime_found50 = false;\n    let mut prime_found51 = false;\n    let mut\
    \ prime_found52 = false;\n    let mut prime_found53 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp1ilw4t9g.rs:80:1\n  \
    \ |\n80 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi7xvf4vd.rs:64:31\n   |\n\
    64 |     let mut prime_counter40: u\n   |                               ^ help:\
    \ add `;` here\n65 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpi7xvf4vd.rs:64:30\n   |\n64 |     let mut prime_counter40:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpi7xvf4vd.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi7xvf4vd.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_digits = num.len();\n    let mut num_primes = 0;\n    let mut num_primes_found\
    \ = 0;\n    let mut num_primes_found2 = 0;\n    let mut num_primes_found3 = 0;\n\
    \    let mut num_primes_found4 = 0;\n    let mut num_primes_found5 = 0;\n    let\
    \ mut num_primes_found6 = 0;\n    let mut num_primes_found7 = 0;\n    let mut\
    \ num_primes_found8 = 0;\n    let mut num_primes_found9 = 0;\n    let mut num_primes_found10\
    \ = 0;\n    let mut num_primes_found11 = 0;\n    let mut num_primes_found12 =\
    \ 0;\n    let mut num_primes_found13 = 0;\n    let mut num_primes_found14 = 0;\n\
    \    let mut num_primes_found15 = 0;\n    let mut num_primes_found16 = 0;\n  \
    \  let mut num_primes_found17 = 0;\n    let mut num_primes_found18 = 0;\n    let\
    \ mut num_primes_found19 = 0;\n    let mut num_primes_found20 = 0;\n    let mut\
    \ num_primes_found21 = 0;\n    let mut num_primes_found22 = 0;\n    let mut num_primes_found23\
    \ = 0;\n    let mut num_primes_found24 = 0;\n    let mut num_primes_found25 =\
    \ 0;\n    let mut num_primes_found26 = 0;\n    let mut num_primes_found27 = 0;\n\
    \    let mut num_primes_found28 = 0;\n    let mut num_primes_found29 = 0;\n  \
    \  let mut num_primes_found30 = 0;\n    let mut num_primes_found31 = 0;\n    let\
    \ mut num_primes_found32 = 0;\n    let mut num_primes_found33 = 0;\n    let mut\
    \ num_primes_found34 = 0;\n    let mut num_primes_found35 = 0;\n    let mut num_primes_found36\
    \ = 0;\n    let mut num_primes_found37 = 0;\n    let mut num_primes_found38 =\
    \ 0;\n    let mut num_primes_found39 = 0;\n    let mut num_primes_found40 = 0;\n\
    \    let mut num_primes_found41 = 0;\n    let mut num_primes_found42 = 0;\n  \
    \  let mut num_primes_found43 = 0;\n    let mut num_primes_found44 = 0;\n    let\
    \ mut num_primes_found45 = 0;\n    let mut num_primes_found46 = 0;\n    let mut\
    \ num_primes_found47 = 0;\n    let mut num_primes_found48 = 0;\n\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp105_slu9.rs:23:52\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp105_slu9.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut counter:\
    \ usize = 0;\n    for &c in num {\n        if prime == vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19] {\n            counter = counter + 1;\n        }\n        if prime ==\
    \ vec![2, 3, 5, 7, 11, 13, 17, 19, 31] {\n            counter = counter + 1;\n\
    \        }\n        if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 37, 61] {\n \
    \           counter = counter + 1;\n        }\n        if prime == vec![2, 3,\
    \ 5, 7, 11, 13, 17, 19, 37, 61, 79] {\n            counter = counter + 1;\n  \
    \      }\n        if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 37, 61, 79, 127]\
    \ {\n            counter = counter + 1;\n        }\n        if prime == vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 37, 61, 79, 127, 255] {\n            counter = counter\
    \ + 1;\n        }\n        if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 37, 61,\
    \ 79, 127, 255, 511] {\n            counter = counter + 1;\n        }\n      \
    \  if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 37, 61, 79, 127, 255, 511, 1023]\
    \ {\n            counter = counter + 1;\n        }\n        if prime == vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 37, 61, 79, 127, 255, 511, 1023, 2047] {\n        \
    \    counter = counter + 1;\n        }\n        if prime == vec![2, 3, 5, 7, 11,\
    \ 13, 17, 19, 37, 61, 79, 127, 255, 511, 1023, 2047, 4095] {\n            counter\
    \ = counter + 1;\n        }\n        if prime == vec![2, 3, 5, 7, 11, 13, 17,\
    \ 19, 37, 61, 79, 127, 255, 511, 1023, 2047, 4095, 8191] {\n            counter\
    \ = counter + 1;\n        }\n        if prime == vec![2, 3, 5, 7, 11, 13, 17,\
    \ 19, 37, 61, 79, 127, 255, 511, 1023, 2047, 4095, 8191, 16383] {\n          \
    \  counter = counter + 1;\n        }\n        if prime == vec![2, 3, 5, 7, 11,\
    \ 13, 17, 19, 37, 61, 79, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767]\
    \ {\n            counter = counter + 1;\n        }\n        if prime == vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 37, 61, 79, 127, 255, 511, 1023, 2047, 4095, 8191,\
    \ 16383, 327\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp_bu58yki.rs:77:3\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - unclosed delimiter\n...\n26 |     for &c in num {\n   |          \
    \         - this delimiter might not be properly closed...\n...\n67 | }\n   |\
    \ - ...as it matches this but it has different indentation\n...\n77 | }\n   |\
    \   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp_bu58yki.rs:66:25\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n66 |         if prime\
    \ == vec![2, 3, 5, 7, 11, 13, 17, 19, 37, 61, 79, 127, 255, 511, 1023, 2047, 4095,\
    \ 8191, 16383, 327\n   |                         ^ unclosed delimiter\n67 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror: expected `{`, found `}`\n  -->\
    \ /tmp/tmp_bu58yki.rs:67:1\n   |\n66 |         if prime == vec![2, 3, 5, 7, 11,\
    \ 13, 17, 19, 37, 61, 79, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 327\n\
    \   |         -- this `if` expression has a condition, but no block\n67 | }\n\
    \   | ^ expected `{`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n    --> /tmp/tmp_bu58yki.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_bu58yki.rs:26:9\n\
    \   |\n26 |     for &c in num {\n   |         ^^    --- this expression has type\
    \ `Option<u8>`\n   |         |\n   |         expected `u8`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `u8`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_bu58yki.rs:22:28\n  "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi7xvf4vd.rs:64:31\n   |\n\
    64 |     let mut prime_counter40: u\n   |                               ^ help:\
    \ add `;` here\n65 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpi7xvf4vd.rs:64:30\n   |\n64 |     let mut prime_counter40:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpi7xvf4vd.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi7xvf4vd.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digit:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digit_count: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_2: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_3: Vec<u8> = vec![0, 0, 0,\
    \ 0, 0, 0, 0, 0];\n    let mut prime_digit_count_4: Vec<u8> = vec![0, 0, 0, 0,\
    \ 0, 0, 0, 0];\n    let mut prime_digit_count_5: Vec<u8> = vec![0, 0, 0, 0, 0,\
    \ 0, 0, 0];\n    let mut prime_digit_count_6: Vec<u8> = vec![0, 0, 0, 0, 0, 0,\
    \ 0, 0];\n    let mut prime_digit_count_7: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0,\
    \ 0];\n    let mut prime_digit_count_8: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n\
    \    let mut prime_digit_count_9: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n  \
    \  let mut prime_digit_count_10: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n   \
    \ let mut prime_digit_count_11: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let\
    \ mut prime_digit_count_12: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut\
    \ prime_digit_count_13: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_14:\
    \ Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_15: Vec<u8>\
    \ = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_16: Vec<u8> =\
    \ vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_17: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_18: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_19: Vec<u8> = vec![0, 0, 0,\
    \ 0, 0, 0, 0, 0];\n    let mut prime_digit_count_20\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl4wu4lud.rs:45:33\n   |\n\
    45 |     let mut prime_digit_count_20\n   |                                 ^\
    \ help: add `;` here\n46 | }\n   | - unexpected token\n\nerror[E0277]: a value\
    \ of type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmpl4wu4lud.rs:23:55\n     |\n23   |     let mut num: Vec<u8> =\
    \ num.to_lowercase().chars().collect();\n     |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl4wu4lud.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.to_string().chars().collect::<Vec<_>>();\n \
    \   let mut primes = vec![false; 16];\n    let mut prime_num = 0;\n    let mut\
    \ prime_num_to_check = prime_num;\n    let mut prime_num_to_check = prime_num_to_check\
    \ - 1;\n    let mut prime_num_to_check = prime_num_to_check - 1;\n    let mut\
    \ prime_num_to_check = prime_num_to_check - 1;\n    let mut prime_num_to_check\
    \ = prime_num_to_check - 1;\n    let mut prime_num_to_check = prime_num_to_check\
    \ - 1;\n    let mut prime_num_to_check = prime_num_to_check - 1;\n    let mut\
    \ prime_num_to_check = prime_num_to_check - 1;\n    let mut prime_num_to_check\
    \ = prime_num_to_check - 1;\n    let mut prime_num_to_check = prime_num_to_check\
    \ - 1;\n    let mut prime_num_to_check = prime_num_to_check - 1;\n    let mut\
    \ prime_num_to_check = prime_num_to_check - 1;\n    let mut prime_num_to_check\
    \ = prime_num_to_check - 1;\n    let mut prime_num_to_check = prime_num_to_check\
    \ - 1;\n    let mut prime_num_to_check = prime_num_to_check - 1;\n    let mut\
    \ prime_num_to_check = prime_num_to_check - 1;\n    let mut prime_num_to_check\
    \ = prime_num_to_check - 1;\n    let mut prime_num_to_check = prime_num_to_check\
    \ - 1;\n    let mut prime_num_to_check = prime_num_to_check - 1;\n    let mut\
    \ prime_num_to_check = prime_num_to_check - 1;\n    let mut prime_num_to_check\
    \ = prime_num_to_check - 1;\n    let mut prime_num_to_check = prime_num_to_check\
    \ - 1;\n    let mut prime_num_to_check = prime_num_to_check - 1;\n    let mut\
    \ prime_num_to_check = prime_num_to_check - 1;\n    let mut prime_num_to_check\
    \ = prime_num_to_check - 1;\n    let mut prime_num_to_check = prime_num_to_check\
    \ - 1;\n    let mut prime_num_to_check = prime_num_to_check - 1;\n    let mut\
    \ prime_num_to_check = prime_num_to_check - 1;\n    let mut prime_num_to_check\
    \ = prime_num_to_check - 1;\n    let mut prime_num_to_check = prime_num_to_check\
    \ - \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmplr8hliz0.rs:56:1\n\
    \   |\n56 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter2: Vec<u8>\
    \ = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter3: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter4: Vec<u8> = vec![0, 0, 0, 0,\
    \ 0, 0, 0, 0];\n    let mut prime_counter5: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0,\
    \ 0];\n    let mut prime_counter6: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n \
    \   let mut prime_counter7: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut\
    \ prime_counter8: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter9:\
    \ Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter10: Vec<u8>\
    \ = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter11: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter12: Vec<u8> = vec![0, 0, 0,\
    \ 0, 0, 0, 0, 0];\n    let mut prime_counter13: Vec<u8> = vec![0, 0, 0, 0, 0,\
    \ 0, 0, 0];\n    let mut prime_counter14: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0,\
    \ 0];\n    let mut prime_counter15: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n\
    \    let mut prime_counter16: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let\
    \ mut prime_counter17: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter18:\
    \ Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter19: Vec<u8>\
    \ = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter20: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_counter21: Vec<u8> = vec![0, 0, 0,\
    \ 0, 0, 0, 0, 0];\n    let mut prime_counter22: Vec<u8> = vec![0, 0, 0, 0, 0,\
    \ 0, 0, 0];\n    let mut prime_counter23: Vec<u8> = \n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp40qx5l4z.rs:48:1\n\
    \   |\n48 | }\n   | ^ expected expression\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmp40qx5l4z.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmf3oq_4v.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpmf3oq_4v.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpmf3oq_4v.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmf3oq_4v.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut counter: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_counter:\
    \ usize = 2;\n    let mut prime_counter2: usize = 2;\n    let mut prime_counter3:\
    \ usize = 2;\n    let mut prime_counter4: usize = 2;\n    let mut prime_counter5:\
    \ usize = 2;\n    let mut prime_counter6: usize = 2;\n    let mut prime_counter7:\
    \ usize = 2;\n    let mut prime_counter8: usize = 2;\n    let mut prime_counter9:\
    \ usize = 2;\n    let mut prime_counter10: usize = 2;\n    let mut prime_counter11:\
    \ usize = 2;\n    let mut prime_counter12: usize = 2;\n    let mut prime_counter13:\
    \ usize = 2;\n    let mut prime_counter14: usize = 2;\n    let mut prime_counter15:\
    \ usize = 2;\n    let mut prime_counter16: usize = 2;\n    let mut prime_counter17:\
    \ usize = 2;\n    let mut prime_counter18: usize = 2;\n    let mut prime_counter19:\
    \ usize = 2;\n    let mut prime_counter20: usize = 2;\n    let mut prime_counter21:\
    \ usize = 2;\n    let mut prime_counter22: usize = 2;\n    let mut prime_counter23:\
    \ usize = 2;\n    let mut prime_counter24: usize = 2;\n    let mut prime_counter25:\
    \ usize = 2;\n    let mut prime_counter26: usize = 2;\n    let mut prime_counter27:\
    \ usize = 2;\n    let mut prime_counter28: usize = 2;\n    let mut prime_counter29:\
    \ usize = 2;\n    let mut prime_counter30: usize = 2;\n    let mut prime_counter31:\
    \ usize = 2;\n    let mut prime_counter32: usize = 2;\n    let mut prime_counter33:\
    \ usize = 2;\n    let mut prime_counter34: usize = 2;\n    let mut prime_counter35:\
    \ usize = 2;\n    let mut prime_counter36: usize = 2;\n    let mut prime_counter37:\
    \ usize = 2;\n    let mut prime_counter38: usize = 2;\n    let mut prime_counter39:\
    \ usize = 2;\n    let mut prime_counter40: usize = 2;\n\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2_15qlhw.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmp2_15qlhw.rs:23:55\n     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: isize = 0;\n    let mut prime_found = false;\n    let mut\
    \ prime_found2 = false;\n    let mut prime_found3 = false;\n    let mut prime_found4\
    \ = false;\n    let mut prime_found5 = false;\n    let mut prime_found6 = false;\n\
    \    let mut prime_found7 = false;\n    let mut prime_found8 = false;\n    let\
    \ mut prime_found9 = false;\n    let mut prime_found10 = false;\n    let mut prime_found11\
    \ = false;\n    let mut prime_found12 = false;\n    let mut prime_found13 = false;\n\
    \    let mut prime_found14 = false;\n    let mut prime_found15 = false;\n    let\
    \ mut prime_found16 = false;\n    let mut prime_found17 = false;\n    let mut\
    \ prime_found18 = false;\n    let mut prime_found19 = false;\n    let mut prime_found20\
    \ = false;\n    let mut prime_found21 = false;\n    let mut prime_found22 = false;\n\
    \    let mut prime_found23 = false;\n    let mut prime_found24 = false;\n    let\
    \ mut prime_found25 = false;\n    let mut prime_found26 = false;\n    let mut\
    \ prime_found27 = false;\n    let mut prime_found28 = false;\n    let mut prime_found29\
    \ = false;\n    let mut prime_found30 = false;\n    let mut prime_found31 = false;\n\
    \    let mut prime_found32 = false;\n    let mut prime_found33 = false;\n    let\
    \ mut prime_found34 = false;\n    let mut prime_found35 = false;\n    let mut\
    \ prime_found36 = false;\n    let mut prime_found37 = false;\n    let mut prime_found38\
    \ = false;\n    let mut prime_found39 = false;\n    let mut prime_found40 = false;\n\
    \    let mut prime_found41 = false;\n    let mut prime_found42 = false;\n    let\
    \ mut prime_found43 = false;\n    let mut prime_found44 = false;\n    let mut\
    \ prime_found45 = false;\n    let mut prime_found46 = false;\n    let mut prime_found47\
    \ = false;\n    let mut prime_found48 = false;\n    let mut prime_found49 = false;\n\
    \    let mut prime_found50 = false;\n    let mut prime_found51 = false;\n    let\
    \ mut prime_found52 = false;\n    let mut prime_found53 = false;\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp0dw1soub.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0dw1soub.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_digits = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_count = prime_digits.len();\n  \
    \  let mut prime_digits_sum = 0;\n    let mut prime_digits_product = 1;\n    let\
    \ mut prime_digits_product2 = 1;\n    let mut prime_digits_product3 = 1;\n   \
    \ let mut prime_digits_product4 = 0;\n    let mut prime_digits_product5 = 1;\n\
    \    let mut prime_digits_product6 = 1;\n    let mut prime_digits_product7 = 1;\n\
    \    let mut prime_digits_product8 = 1;\n    let mut prime_digits_product9 = 1;\n\
    \    let mut prime_digits_product10 = 1;\n    let mut prime_digits_product11 =\
    \ 1;\n    let mut prime_digits_product12 = 1;\n    let mut prime_digits_product13\
    \ = 1;\n    let mut prime_digits_product14 = 1;\n    let mut prime_digits_product15\
    \ = 1;\n    let mut prime_digits_product16 = 1;\n    let mut prime_digits_product17\
    \ = 1;\n    let mut prime_digits_product18 = 1;\n    let mut prime_digits_product19\
    \ = 1;\n    let mut prime_digits_product20 = 1;\n    let mut prime_digits_product21\
    \ = 1;\n    let mut prime_digits_product22 = 1;\n    let mut prime_digits_product23\
    \ = 1;\n    let mut prime_digits_product24 = 1;\n    let mut prime_digits_product25\
    \ = 1;\n    let mut prime_digits_product26 = 1;\n    let mut prime_digits_product27\
    \ = 1;\n    let mut prime_digits_product28 = 1;\n    let mut prime_digits_product29\
    \ = 1;\n    let mut prime_digits_product30 = 1;\n    let mut prime_digits_product31\
    \ = 1;\n    let mut prime_digits_product32 = 1;\n    let mut prime_digits_product33\
    \ = 1;\n    let mut prime_digits_product34 = 1;\n    let mut prime_digits_product35\
    \ = 1;\n    let mut prime_digits_product36 = 1;\n    let mut prime_digits_product37\
    \ = 1;\n    let mut prime_digits_product38\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5tz7sx7j.rs:65:35\n   |\n\
    65 |     let mut prime_digits_product38\n   |                                \
    \   ^ help: add `;` here\n66 | }\n   | - unexpected token\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp5tz7sx7j.rs:25:32\n\
    \   |\n25 |     let mut prime_digits_set = HashSet::new();\n   |             \
    \                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmp5tz7sx7j.rs:23:55\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_lowercase().chars().collect();\n     |                    \
    \                                   ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5tz7sx7j.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf8uq_llq.rs:39:36\n   |\n\
    39 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpf8uq_llq.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf8uq_llq.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8uq_llq.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpf8uq_llq.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8uq_llq.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf8uq_llq.rs:39:36\n   |\n\
    39 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpf8uq_llq.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf8uq_llq.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8uq_llq.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpf8uq_llq.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8uq_llq.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![];\n    let mut num_prime_2: Vec<u8> =\
    \ vec![];\n    let mut num_prime_3: Vec<u8> = vec![];\n    let mut num_prime_4:\
    \ Vec<u8> = vec![];\n    let mut num_prime_5: Vec<u8> = vec![];\n    let mut num_prime_6:\
    \ Vec<u8> = vec![];\n    let mut num_prime_7: Vec<u8> = vec![];\n    let mut num_prime_8:\
    \ Vec<u8> = vec![];\n    let mut num_prime_9: Vec<u8> = vec![];\n    let mut num_prime_10:\
    \ Vec<u8> = vec![];\n    let mut num_prime_11: Vec<u8> = vec![];\n    let mut\
    \ num_prime_12: Vec<u8> = vec![];\n    let mut num_prime_13: Vec<u8> = vec![];\n\
    \    let mut num_prime_14: Vec<u8> = vec![];\n    let mut num_prime_15: Vec<u8>\
    \ = vec![];\n    let mut num_prime_16: Vec<u8> = vec![];\n    let mut num_prime_17:\
    \ Vec<u8> = vec![];\n    let mut num_prime_18: Vec<u8> = vec![];\n    let mut\
    \ num_prime_19: Vec<u8> = vec![];\n    let mut num_prime_20: Vec<u8> = vec![];\n\
    \    let mut num_prime_21: Vec<u8> = vec![];\n    let mut num_prime_22: Vec<u8>\
    \ = vec![];\n    let mut num_prime_23: Vec<u8> = vec![];\n    let mut num_prime_24:\
    \ Vec<u8> = vec![];\n    let mut num_prime_25: Vec<u8> = vec![];\n    let mut\
    \ num_prime_26: Vec<u8> = vec![];\n    let mut num_prime_27: Vec<u8> = vec![];\n\
    \    let mut num_prime_28: Vec<u8> = vec![];\n    let mut num_prime_29: Vec<u8>\
    \ = vec![];\n    let mut num_prime_\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpglhblrn_.rs:53:23\n   |\n\
    53 |     let mut num_prime_\n   |                       ^ help: add `;` here\n\
    54 | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpglhblrn_.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpglhblrn_.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut primes\
    \ = vec![false; 26];\n    let mut primes_counter = 0;\n    let mut primes_counter2\
    \ = 0;\n    let mut primes_counter3 = 0;\n    let mut primes_counter4 = 0;\n \
    \   let mut primes_counter5 = 0;\n    let mut primes_counter6 = 0;\n    let mut\
    \ primes_counter7 = 0;\n    let mut primes_counter8 = 0;\n    let mut primes_counter9\
    \ = 0;\n    let mut primes_counter10 = 0;\n    let mut primes_counter11 = 0;\n\
    \    let mut primes_counter12 = 0;\n    let mut primes_counter13 = 0;\n    let\
    \ mut primes_counter14 = 0;\n    let mut primes_counter15 = 0;\n    let mut primes_counter16\
    \ = 0;\n    let mut primes_counter17 = 0;\n    let mut primes_counter18 = 0;\n\
    \    let mut primes_counter19 = 0;\n    let mut primes_counter20 = 0;\n    let\
    \ mut primes_counter21 = 0;\n    let mut primes_counter22 = 0;\n    let mut primes_counter23\
    \ = 0;\n    let mut primes_counter24 = 0;\n    let mut primes_counter25 = 0;\n\
    \    let mut primes_counter26 = 0;\n    let mut primes_counter27 = 0;\n    let\
    \ mut primes_counter28 = 0;\n    let mut primes_counter29 = 0;\n    let mut primes_counter30\
    \ = 0;\n    let mut primes_counter31 = 0;\n    let mut primes_counter32 = 0;\n\
    \    let mut primes_counter33 = 0;\n    let mut primes_counter34 = 0;\n    let\
    \ mut primes_counter35 = 0;\n    let mut primes_counter36 = 0;\n    let mut primes_counter37\
    \ = 0;\n    let mut primes_counter38 = 0;\n    let mut primes_counter39 = 0;\n\
    \    let mut primes_counter40 = 0;\n    let mut primes_counter41 = 0;\n    let\
    \ mut primes_counter42 = 0;\n    let mut primes_counter43 = 0;\n    let mut primes_counter44\
    \ = 0;\n    let mut primes_counter45 = 0;\n    let mut primes_counter46 = 0;\n\
    \    let mut primes_counter47 = 0;\n    let mut primes_counter48 = 0;\n    let\
    \ mut primes_counter49 = 0;\n    let mut primes_counter50 = 0;\n    let mut primes_counter51\
    \ = 0;\n    let mut primes_counter52 = 0;\n    let mut primes_counter53 = 0;\n\
    \    let mut primes_counter54 = 0;\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpn9xy4hsy.rs:79:11\n   |\n\
    79 |     let mu\n   |           ^ help: add `;` here\n80 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn9xy4hsy.rs:22:28\n \
    \  |\n22 | fn hex_key(num: String) -> isize {\n   |    -------               \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_copy\
    \ = nums.clone();\n    let mut primes = vec![true; 10];\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut primes_copy = primes.clone();\n    let mut primes_copy\
    \ = primes.clone();\n    let mut \n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpz57catru.rs:74:1\n\
    \   |\n74 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = num.to_lowercase().chars().collect();\n    let\
    \ mut num_prime_prime: Vec<u8> = num.to_lowercase().chars().collect();\n    let\
    \ mut num_prime_prime_prime: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime_prime_prime_prime: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime_prime_prime_prime_prime: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_lowercase().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_lowercase().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_lowercase().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_lowercase().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_lowercase().chars().collect();\n    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_lowercase().chars().collect();\n    let mut num_prime\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpso6mpyrd.rs:39:22\n   |\n\
    39 |     let mut num_prime\n   |                      ^ help: add `;` here\n40\
    \ | }\n   | - unexpected token\n\nerror[E0599]: no method named `to_lowercase`\
    \ found for struct `Vec<u8>` in the current scope\n  --> /tmp/tmpso6mpyrd.rs:24:38\n\
    \   |\n24 |     let mut num_prime: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                      ^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_ascii_lowercase`\n\nerror[E0277]: a value\
    \ of type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmpso6mpyrd.rs:23:55\n     |\n23   |     let mut num: Vec<u8> =\
    \ num.to_lowercase().chars().collect();\n     |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0599]:\
    \ no method named `to_lowercase` found for struct `Vec<u8>` in the current scope\n\
    \  --> /tmp/tmpso6mpyrd.rs:25:44\n   |\n25 |     let mut num_prime_prime: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n   |                              \
    \              ^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `to_ascii_lowercase`\n\nerror[E0599]: no method named `to_lowercase` found\
    \ for struct `Vec<u8>` in the current scope\n  --> /tmp/tmpso6mpyrd.rs:26:50\n\
    \   |\n26 |     let mut num_prime_prime_prime: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \   |                                                  ^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_ascii_lowercase`\n\nerror[E0599]:\
    \ no method named `to_lowercase` found for struct `Vec<u8>` in the current scope\n\
    \  --> /tmp/tmpso6mpyrd.rs:27:56\n   |\n27 |     let mut num_prime_prime_prime_prime:\
    \ Vec<u8> = num.to_lowercase().chars().collect();\n   |                      \
    \       "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_digits = num.len();\n    let mut prime_digits = 2;\n    let mut\
    \ prime_digits_counter = 0;\n    let mut prime_digits_counter2 = 0;\n    let mut\
    \ prime_digits_counter3 = 0;\n    let mut prime_digits_counter4 = 0;\n    let\
    \ mut prime_digits_counter5 = 0;\n    let mut prime_digits_counter6 = 0;\n   \
    \ let mut prime_digits_counter7 = 0;\n    let mut prime_digits_counter8 = 0;\n\
    \    let mut prime_digits_counter9 = 0;\n    let mut prime_digits_counter10 =\
    \ 0;\n    let mut prime_digits_counter11 = 0;\n    let mut prime_digits_counter12\
    \ = 0;\n    let mut prime_digits_counter13 = 0;\n    let mut prime_digits_counter14\
    \ = 0;\n    let mut prime_digits_counter15 = 0;\n    let mut prime_digits_counter16\
    \ = 0;\n    let mut prime_digits_counter17 = 0;\n    let mut prime_digits_counter18\
    \ = 0;\n    let mut prime_digits_counter19 = 0;\n    let mut prime_digits_counter20\
    \ = 0;\n    let mut prime_digits_counter21 = 0;\n    let mut prime_digits_counter22\
    \ = 0;\n    let mut prime_digits_counter23 = 0;\n    let mut prime_digits_counter24\
    \ = 0;\n    let mut prime_digits_counter25 = 0;\n    let mut prime_digits_counter26\
    \ = 0;\n    let mut prime_digits_counter27 = 0;\n    let mut prime_digits_counter28\
    \ = 0;\n    let mut prime_digits_counter29 = 0;\n    let mut prime_digits_counter30\
    \ = 0;\n    let mut prime_digits_counter31 = 0;\n    let mut prime_digits_counter32\
    \ = 0;\n    let mut prime_digits_counter33 = 0;\n    let mut prime_digits_counter34\
    \ = 0;\n    let mut prime_digits_counter35 = 0;\n    let mut prime_digits_counter36\
    \ = 0;\n    let mut prime_digits_counter37 = 0;\n    let mut prime_digits_counter38\
    \ = 0;\n    let mut prime_digits_counter39 = 0;\n    let mut prime_digits_counter40\
    \ = 0;\n    let mut prime_digits_counter41 = 0;\n    let mut prime_digits_counter42\
    \ = 0;\n    let mut prime_digits_counter43 = 0;\n    let mut prime_\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7dkz116i.rs:69:19\n   |\n\
    69 |     let mut prime_\n   |                   ^ help: add `;` here\n70 | }\n\
    \   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be\
    \ built from an iterator over elements of type `char`\n    --> /tmp/tmp7dkz116i.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7dkz116i.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: usize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: usize = 0;\n    let mut prime_digit_sum: usize = 0;\n\
    \    let mut prime_digit_product: usize = 1;\n    let mut prime_digit_product2:\
    \ usize = 1;\n    let mut prime_digit_product3: usize = 1;\n    let mut prime_digit_product4:\
    \ usize = 1;\n    let mut prime_digit_product5: usize = 1;\n    let mut prime_digit_product6:\
    \ usize = 1;\n    let mut prime_digit_product7: usize = 1;\n    let mut prime_digit_product8:\
    \ usize = 1;\n    let mut prime_digit_product9: usize = 1;\n    let mut prime_digit_product10:\
    \ usize = 1;\n    let mut prime_digit_product11: usize = 1;\n    let mut prime_digit_product12:\
    \ usize = 1;\n    let mut prime_digit_product13: usize = 1;\n    let mut prime_digit_product14:\
    \ usize = 1;\n    let mut prime_digit_product15: usize = 1;\n    let mut prime_digit_product16:\
    \ usize = 1;\n    let mut prime_digit_product17: usize = 1;\n    let mut prime_digit_product18:\
    \ usize = 1;\n    let mut prime_digit_product19: usize = 1;\n    let mut prime_digit_product20:\
    \ usize = 1;\n    let mut prime_digit_product21: usize = 1;\n    let mut prime_digit_product22:\
    \ usize = 1;\n    let mut prime_digit_product23: usize = 1;\n    let mut prime_digit_product24:\
    \ usize = 1;\n    let mut prime_digit_product25: usize = 1;\n    let mut prime_digit_product26:\
    \ usize = 1;\n    let mut prime_digit_product27: usize = 1;\n    let mut prime_digit_product28:\
    \ usize = 1;\n    let mut prime_digit_product29: usize = 1;\n    let mut prime_digit_product30:\
    \ usize = 1;\n    let mut prime_digit_product31: usize = 1;\n    let mut prime_digit_product32:\
    \ usize = 1;\n    let mut prime_digit_product33: usize = 1;\n    let mut prime_digit_product34:\
    \ usize = 1;\n    let mut prime_digit_product35: usize = 1;\n\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps8f64od7.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmps8f64od7.rs:23:55\n     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.in\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `in`\n  --> /tmp/tmpdp6kfoi9.rs:39:32\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \      ^^ expected identifier, found keyword\n   |\nhelp: escape `in` to use it\
    \ as an identifier\n   |\n39 |     let mut num: Vec<u8> = num.r#in\n   |     \
    \                           ++\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpdp6kfoi9.rs:39:34\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \        ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpdp6kfoi9.rs:23:52\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_string().chars().collect();\n     |                       \
    \                             ^^^^^^^ value of type `Vec<u8>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdp6kfoi9.rs:24:61\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |\
    \                                                             ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdp6kfoi9.rs:24:73\n\
    \   |\n24 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' &&\
    \ x <= '9').collect();\n   |                                                 \
    \                        ^^^ expected `u8`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdp6kfoi9.rs:25:61\n   |\n25 |     let mut num: Vec<u8>\
    \ = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n   |       \
    \                                                      ^^^ expected `u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdp6kfoi9.rs:25:73\n\
    \   |\n25 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' &&\
    \ x <= 'F').collect();\n   |              "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![];\n    let mut num_prime_2: Vec<u8> =\
    \ vec![];\n    let mut num_prime_3: Vec<u8> = vec![];\n    let mut num_prime_4:\
    \ Vec<u8> = vec![];\n    let mut num_prime_5: Vec<u8> = vec![];\n    let mut num_prime_6:\
    \ Vec<u8> = vec![];\n    let mut num_prime_7: Vec<u8> = vec![];\n    let mut num_prime_8:\
    \ Vec<u8> = vec![];\n    let mut num_prime_9: Vec<u8> = vec![];\n    let mut num_prime_10:\
    \ Vec<u8> = vec![];\n    let mut num_prime_11: Vec<u8> = vec![];\n    let mut\
    \ num_prime_12: Vec<u8> = vec![];\n    let mut num_prime_13: Vec<u8> = vec![];\n\
    \    let mut num_prime_14: Vec<u8> = vec![];\n    let mut num_prime_15: Vec<u8>\
    \ = vec![];\n    let mut num_prime_16: Vec<u8> = vec![];\n    let mut num_prime_17:\
    \ Vec<u8> = vec![];\n    let mut num_prime_18: Vec<u8> = vec![];\n    let mut\
    \ num_prime_19: Vec<u8> = vec![];\n    let mut num_prime_20: Vec<u8> = vec![];\n\
    \    let mut num_prime_21: Vec<u8> = vec![];\n    let mut num_prime_22: Vec<u8>\
    \ = vec![];\n    let mut num_prime_23: Vec<u8> = vec![];\n    let mut num_prime_24:\
    \ Vec<u8> = vec![];\n    let mut num_prime_25: Vec<u8> = vec![];\n    let mut\
    \ num_prime_26: Vec<u8> = vec![];\n    let mut num_prime_27: Vec<u8> = vec![];\n\
    \    let mut num_prime_28: Vec<u8> = vec![];\n    let mut num_prime_29: Vec<u8>\
    \ = vec![];\n    let mut num_prime_\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpglhblrn_.rs:53:23\n   |\n\
    53 |     let mut num_prime_\n   |                       ^ help: add `;` here\n\
    54 | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpglhblrn_.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpglhblrn_.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf8uq_llq.rs:39:36\n   |\n\
    39 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpf8uq_llq.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf8uq_llq.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8uq_llq.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpf8uq_llq.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8uq_llq.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ Vec<u8> = vec![0, 0, 0, 0];\n    let mut prime_counter_index: usize = 0;\n \
    \   let mut prime_counter_index2: usize = 0;\n    let mut prime_counter_index3:\
    \ usize = 0;\n    let mut prime_counter_index4: usize = 0;\n    let mut prime_counter_index5:\
    \ usize = 0;\n    let mut prime_counter_index6: usize = 0;\n    let mut prime_counter_index7:\
    \ usize = 0;\n    let mut prime_counter_index8: usize = 0;\n    let mut prime_counter_index9:\
    \ usize = 0;\n    let mut prime_counter_index10: usize = 0;\n    let mut prime_counter_index11:\
    \ usize = 0;\n    let mut prime_counter_index12: usize = 0;\n    let mut prime_counter_index13:\
    \ usize = 0;\n    let mut prime_counter_index14: usize = 0;\n    let mut prime_counter_index15:\
    \ usize = 0;\n    let mut prime_counter_index16: usize = 0;\n    let mut prime_counter_index17:\
    \ usize = 0;\n    let mut prime_counter_index18: usize = 0;\n    let mut prime_counter_index19:\
    \ usize = 0;\n    let mut prime_counter_index20: usize = 0;\n    let mut prime_counter_index21:\
    \ usize = 0;\n    let mut prime_counter_index22: usize = 0;\n    let mut prime_counter_index23:\
    \ usize = 0;\n    let mut prime_counter_index24: usize = 0;\n    let mut prime_counter_index25:\
    \ usize = 0;\n    let mut prime_counter_index26: usize = 0;\n    let mut prime_counter_index27:\
    \ usize = 0;\n    let mut prime_counter_index28: usize = 0;\n    let mut prime_counter_index29:\
    \ usize = 0;\n    let mut prime_counter_index30: usize = 0;\n    let mut prime_counter_index31:\
    \ usize = 0;\n    let mut prime_counter_index32: usize = 0;\n    let mut prime_counter_index33:\
    \ usize = 0;\n    let mut prime_counter\n}\n\nfn main() {\n    let candidate =\
    \ hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp59_kqahj.rs:59:26\n   |\n\
    59 |     let mut prime_counter\n   |                          ^ help: add `;`\
    \ here\n60 | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmp59_kqahj.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp59_kqahj.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_iter\
    \ = nums.iter();\n    let mut nums_iter = nums_iter.filter(|&c| c >= '0' && c\
    \ <= '9');\n    let mut nums_iter = nums_iter.filter(|&c| c != 'A' && c != 'B'\
    \ && c != 'C' && c != 'D' && c != 'E' && c != 'F');\n    let mut nums_iter = nums_iter.map(|&c|\
    \ c as isize);\n    let mut nums_iter = nums_iter.filter(|&c| c < 10);\n    let\
    \ mut nums_iter = nums_iter.map(|&c| c as isize);\n    let mut nums_iter = nums_iter.filter(|&c|\
    \ c < 16);\n    let mut nums_iter = nums_iter.map(|&c| c as isize);\n    let mut\
    \ nums_iter = nums_iter.filter(|&c| c < 20);\n    let mut nums_iter = nums_iter.map(|&c|\
    \ c as isize);\n    let mut nums_iter = nums_iter.filter(|&c| c < 24);\n    let\
    \ mut nums_iter = nums_iter.map(|&c| c as isize);\n    let mut nums_iter = nums_iter.filter(|&c|\
    \ c < 28);\n    let mut nums_iter = nums_iter.map(|&c| c as isize);\n    let mut\
    \ nums_iter = nums_iter.filter(|&c| c < 32);\n    let mut nums_iter = nums_iter.map(|&c|\
    \ c as isize);\n    let mut nums_iter = nums_iter.filter(|&c| c < 36);\n    let\
    \ mut nums_iter = nums_iter.map(|&c| c as isize);\n    let mut nums_iter = nums_iter.filter(|&c|\
    \ c < 40);\n    let mut nums_iter = nums_iter.map(|&c| c as isize);\n    let mut\
    \ nums_iter = nums_iter.filter(|&c| c < 44);\n    let mut nums_iter = nums_iter.map(|&c|\
    \ c as isize);\n    let mut nums_iter = nums_iter.filter(|&c| c < 48);\n    let\
    \ mut nums_iter = nums_iter.map(|&c| c as isize);\n    let mut nums_iter = nums_iter.filter(|&c|\
    \ c < 52);\n    let mut nums_iter = \n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp19jjsmey.rs:50:1\n\
    \   |\n50 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp19jjsmey.rs:25:52\n   |\n25 |     let mut nums_iter = nums_iter.filter(|&c|\
    \ c >= '0' && c <= '9');\n   |                                               \
    \     ^^^\n   |                                                    |\n   |   \
    \                                                 expected `&char`, found `char`\n\
    \   |                                                    help: consider borrowing\
    \ here: `&'0'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp19jjsmey.rs:25:64\n\
    \   |\n25 |     let mut nums_iter = nums_iter.filter(|&c| c >= '0' && c <= '9');\n\
    \   |                                                                ^^^\n   |\
    \                                                                |\n   |     \
    \                                                           expected `&char`,\
    \ found `char`\n   |                                                         \
    \       help: consider borrowing here: `&'9'`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp19jjsmey.rs:26:49\n   |\n26 |     let mut nums_iter\
    \ = nums_iter.filter(|&c| c != 'A' && c != 'B' && c != 'C' && c != 'D' && c !=\
    \ 'E' && c != 'F');\n   |                                                 ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp19jjsmey.rs:26:61\n\
    \   |\n26 |     let mut nums_iter = nums_iter.filter(|&c| c != 'A' && c != 'B'\
    \ && c != 'C' && c != 'D' && c != 'E' && c != 'F');\n   |                    \
    \                                         ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp19jjsmey.rs:26:73\n   |\n26 |   \
    \  let mut nums_iter = nums_iter"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_digits = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digits_set\
    \ = HashSet::new();\n    let mut prime_digits_count = prime_digits.len();\n  \
    \  let mut prime_digits_index = 0;\n    let mut prime_digits_sum = 0;\n    let\
    \ mut prime_digits_product = 1;\n    let mut prime_digits_product2 = 0;\n    let\
    \ mut prime_digits_product3 = 0;\n    let mut prime_digits_product4 = 0;\n   \
    \ let mut prime_digits_product5 = 0;\n    let mut prime_digits_product6 = 0;\n\
    \    let mut prime_digits_product7 = 0;\n    let mut prime_digits_product8 = 0;\n\
    \    let mut prime_digits_product9 = 0;\n    let mut prime_digits_product10 =\
    \ 0;\n    let mut prime_digits_product11 = 0;\n    let mut prime_digits_product12\
    \ = 0;\n    let mut prime_digits_product13 = 0;\n    let mut prime_digits_product14\
    \ = 0;\n    let mut prime_digits_product15 = 0;\n    let mut prime_digits_product16\
    \ = 0;\n    let mut prime_digits_product17 = 0;\n    let mut prime_digits_product18\
    \ = 0;\n    let mut prime_digits_product19 = 0;\n    let mut prime_digits_product20\
    \ = 0;\n    let mut prime_digits_product21 = 0;\n    let mut prime_digits_product22\
    \ = 0;\n    let mut prime_digits_product23 = 0;\n    let mut prime_digits_product24\
    \ = 0;\n    let mut prime_digits_product25 = 0;\n    let mut prime_digits_product26\
    \ = 0;\n    let mut prime_digits_product27 = 0;\n    let mut prime_digits_product28\
    \ = 0;\n    let mut prime_digits_product29 = 0;\n    let mut prime_digits_product30\
    \ = 0;\n    let mut prime_digits_product31 = 0;\n    let mut prime_digits_product32\
    \ = 0;\n    let mut prime_digits_product33 = 0;\n    let mut prime_digits_product34\
    \ = 0;\n    let mut prime_digits_product35 = 0;\n    let mut prime_digits_product36\
    \ = 0;\n    let mut prime_digits_product37 = 0;\n    let \n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmppgasi4u3.rs:67:1\n  \
    \ |\n67 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmppgasi4u3.rs:25:32\n   |\n25 |     let\
    \ mut prime_digits_set = HashSet::new();\n   |                               \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmppgasi4u3.rs:23:55\n     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.in\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `in`\n  --> /tmp/tmpdp6kfoi9.rs:39:32\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \      ^^ expected identifier, found keyword\n   |\nhelp: escape `in` to use it\
    \ as an identifier\n   |\n39 |     let mut num: Vec<u8> = num.r#in\n   |     \
    \                           ++\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpdp6kfoi9.rs:39:34\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \        ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpdp6kfoi9.rs:23:52\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_string().chars().collect();\n     |                       \
    \                             ^^^^^^^ value of type `Vec<u8>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdp6kfoi9.rs:24:61\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |\
    \                                                             ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdp6kfoi9.rs:24:73\n\
    \   |\n24 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' &&\
    \ x <= '9').collect();\n   |                                                 \
    \                        ^^^ expected `u8`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdp6kfoi9.rs:25:61\n   |\n25 |     let mut num: Vec<u8>\
    \ = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n   |       \
    \                                                      ^^^ expected `u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdp6kfoi9.rs:25:73\n\
    \   |\n25 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' &&\
    \ x <= 'F').collect();\n   |              "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|x| x as u8).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ x as u8).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|x| x as u8).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ x as u8).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|x| x as u8).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ x as u8).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|x| x as u8).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ x as u8).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcpkmw0ii.rs:44:36\n   |\n\
    44 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpcpkmw0ii.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0615]:\
    \ attempted to take value of method `iter` on type `Vec<u8>`\n  --> /tmp/tmpcpkmw0ii.rs:44:32\n\
    \   |\n44 |     let mut num: Vec<u8> = num.iter\n   |                        \
    \        ^^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n\
    \   |\n44 |     let mut num: Vec<u8> = num.iter()\n   |                      \
    \              ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcpkmw0ii.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror[E0606]: casting\
    \ `&u8` as `u8` is invalid\n  --> /tmp/tmpcpkmw0ii.rs:24:47\n   |\n24 |     let\
    \ mut num: Vec<u8> = num.iter().map(|x| x as u8).collect();\n   |            \
    \                                   -^^^^^^\n   |                            \
    \                   |\n   |                                               cannot\
    \ cast `&u8` as `u8`\n   |                                               help:\
    \ dereference the expression: `*x`\n\nerror[E0606]: casting `&u8` as `u8` is invalid\n\
    \  --> /tmp/tmpcpkmw0ii.rs:25:47\n   |\n25 |     let mut num: Vec<u8> = num.iter().map(|x|\
    \ x as u8).collect();\n   |                                               -^^^^^^\n\
    \   |                       "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsnkn74gh.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpsnkn74gh.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsnkn74gh.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsnkn74gh.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpsnkn74gh.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsnkn74gh.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = num.clone();\n    let mut num_prime_prime: Vec<u8>\
    \ = num_prime.clone();\n    let mut num_prime_prime_prime: Vec<u8> = num_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8>\
    \ = num_prime_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n    let\
    \ mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime: Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \    let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8nfbxm84.rs:37:122\n   |\n\
    37 |     let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_\n   |                         \
    \                                                                            \
    \                     ^ help: add `;` here\n38 | }\n   | - unexpected token\n\n\
    error[E0425]: cannot find value `num_prime_prime_prime_prime_prime_prime_prime_prime_prime`\
    \ in this scope\n  --> /tmp/tmp8nfbxm84.rs:35:82\n   |\n35 | ...e_prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `num_prime_prime_prime_prime_prime_prime_prime_prime`\n\
    \nerror[E0425]: cannot find value `num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime`\
    \ in this scope\n  --> /tmp/tmp8nfbxm84.rs:36:82\n   |\n36 | ...prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime.clone();\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `num_prime_prime_prime_prime_prime_prime_prime_prime_prime`\n\
    \nerror[E0425]: cannot find value `num_prime_prime_prime_prime_prime_` in this\
    \ scope\n  --> /tmp/tmp8nfbxm84.rs:37:88\n   |\n37 |     let mut num_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime:\
    \ Vec<u8> = num_prime_prime_prime_prime_prime_\n   |                         \
    \                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `num_prime_prime_prime_prime_prime`\n\
    \nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmp8nfbxm84.rs:23:55\n     |\n23   | \
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |    \
    \                                                   ^^^^^^^ val"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![];\n    let mut prime_counter: usize = 0;\n\
    \    let mut prime_counter2: usize = 0;\n    let mut prime_counter3: usize = 0;\n\
    \    let mut prime_counter4: usize = 0;\n    let mut prime_counter5: usize = 0;\n\
    \    let mut prime_counter6: usize = 0;\n    let mut prime_counter7: usize = 0;\n\
    \    let mut prime_counter8: usize = 0;\n    let mut prime_counter9: usize = 0;\n\
    \    let mut prime_counter10: usize = 0;\n    let mut prime_counter11: usize =\
    \ 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13: usize\
    \ = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: usize = 0;\n    let mut prime\n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5wxe86xi.rs:65:18\n   |\n\
    65 |     let mut prime\n   |                  ^ help: add `;` here\n66 | }\n \
    \  | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n    --> /tmp/tmp5wxe86xi.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5wxe86xi.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: isize = 0;\n    let mut digits: Vec<&str> = num.chars().collect();\n\
    \    let mut primes: Vec<&str> = vec![];\n    let mut prime: isize = 0;\n    let\
    \ mut prime_found = false;\n    let mut prime_found2 = false;\n    let mut prime_found3\
    \ = false;\n    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n\
    \    let mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let\
    \ mut prime_found8 = false;\n    let mut prime_found9 = false;\n    let mut prime_found10\
    \ = false;\n    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n\
    \    let mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let\
    \ mut prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut\
    \ prime_found17 = false;\n    let mut prime_found18 = false;\n    let mut prime_found19\
    \ = false;\n    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n\
    \    let mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let\
    \ mut prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut\
    \ prime_found26 = false;\n    let mut prime_found27 = false;\n    let mut prime_found28\
    \ = false;\n    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n\
    \    let mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let\
    \ mut prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut\
    \ prime_found35 = false;\n    let mut prime_found36 = false;\n    let mut prime_found37\
    \ = false;\n    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n\
    \    let mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let\
    \ mut prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut\
    \ prime_found44 = false;\n    let mut prime_found45 = false;\n    let mut prime_found46\
    \ = false;\n    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n\
    \    let mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let\
    \ mut prime_found\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt6gh4flj.rs:77:24\n   |\n\
    77 |     let mut prime_found\n   |                        ^ help: add `;` here\n\
    78 | }\n   | - unexpected token\n\nerror[E0599]: no method named `chars` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmpt6gh4flj.rs:24:37\n   |\n\
    24 |     let mut digits: Vec<&str> = num.chars().collect();\n   |            \
    \                         ^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt6gh4flj.rs:22:28\n   |\n22 | fn hex_key(num: String) ->\
    \ isize {\n   |    -------                 ^^^^^ expected `isize`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_len\
    \ = prime.len();\n    let mut prime_num = prime[0];\n    let mut prime_num_len\
    \ = prime_num.len();\n    let mut prime_num_pow: Vec<u8> = vec![prime_num];\n\
    \    let mut prime_num_pow_len = prime_num_pow.len();\n    let mut prime_num_pow_pow:\
    \ Vec<u8> = vec![prime_num_pow];\n    let mut prime_num_pow_pow_len = prime_num_pow_pow.len();\n\
    \    let mut prime_num_pow_pow_pow: Vec<u8> = vec![prime_num_pow_pow];\n    let\
    \ mut prime_num_pow_pow_pow_len = prime_num_pow_pow_pow.len();\n    let mut prime_num_pow_pow_pow_pow:\
    \ Vec<u8> = vec![prime_num_pow_pow_pow];\n    let mut prime_num_pow_pow_pow_len\
    \ = prime_num_pow_pow_pow_pow.len();\n    let mut prime_num_pow_pow_pow_pow: Vec<u8>\
    \ = vec![prime_num_pow_pow_pow_pow];\n    let mut prime_num_pow_pow_pow_pow_len\
    \ = prime_num_pow_pow_pow_pow_pow.len();\n    let mut prime_num_pow_pow_pow_pow_pow:\
    \ Vec<u8> = vec![prime_num_pow_pow_pow_pow_pow];\n    let mut prime_num_pow_pow_pow_pow_pow_len\
    \ = prime_num_pow_pow_pow_pow_pow_pow_pow.len();\n    let mut prime_num_pow_pow_pow_pow_pow_pow:\
    \ Vec<u8> = vec![prime_num_pow_pow_pow_pow_pow_pow];\n    let mut prime_num_pow_pow_pow_pow_pow_len\
    \ = prime_num_pow_pow_pow_pow_pow_pow_pow.len();\n    let mut prime_num_pow_pow_pow_pow_pow_pow:\
    \ Vec<u8> = vec![prime_num_pow_pow_pow_pow_pow_pow];\n    let mut prime_num_pow_pow_pow_pow_pow_pow_len\
    \ = prime_num_pow_pow_pow_pow_pow_pow_pow_pow.len();\n    let mut prime_num_pow_pow_pow_pow_pow_pow_pow:\
    \ Vec<u8> = vec![prime_num_pow_pow_pow_pow_\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpqm0zlb_v.rs:44:66\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n44 |     let mut prime_num_pow_pow_pow_pow_pow_pow_pow:\
    \ Vec<u8> = vec![prime_num_pow_pow_pow_pow_\n   |                            \
    \                                      ^ unclosed delimiter\n45 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror: expected one of `.`, `;`, `?`, `else`, or an operator,\
    \ found `}`\n  --> /tmp/tmpqm0zlb_v.rs:45:1\n   |\n45 | }\n   | ^ expected one\
    \ of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0425]: cannot find value\
    \ `prime_num_pow_pow_pow_pow_pow` in this scope\n  --> /tmp/tmpqm0zlb_v.rs:37:45\n\
    \   |\n37 |     let mut prime_num_pow_pow_pow_pow_len = prime_num_pow_pow_pow_pow_pow.len();\n\
    \   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `prime_num_pow_pow_pow_pow`\n\
    \nerror[E0425]: cannot find value `prime_num_pow_pow_pow_pow_pow` in this scope\n\
    \  --> /tmp/tmpqm0zlb_v.rs:38:59\n   |\n38 |     let mut prime_num_pow_pow_pow_pow_pow:\
    \ Vec<u8> = vec![prime_num_pow_pow_pow_pow_pow];\n   |                       \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `prime_num_pow_pow_pow_pow_len`\n\nerror[E0425]:\
    \ cannot find value `prime_num_pow_pow_pow_pow_pow_pow_pow` in this scope\n  -->\
    \ /tmp/tmpqm0zlb_v.rs:39:49\n   |\n39 |     let mut prime_num_pow_pow_pow_pow_pow_len\
    \ = prime_num_pow_pow_pow_pow_pow_pow_pow.len();\n   |                       \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `prime_num_pow_pow_pow_pow_pow`\n\nerror[E0425]:\
    \ cannot find value `prime_num_pow_pow_pow_pow_pow_pow` in this scope\n  --> /tmp/tmpqm0zlb_v.rs:40:63\n\
    \   |\n40 |     let mut prime_num_pow_pow_pow_pow_pow_pow: Vec<u8> = vec![prime_num_pow_pow_pow_pow_pow_pow];\n\
    \   |                                                               ^^"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_digits = num.len();\n    let mut prime_digits = 0;\n    let mut\
    \ prime_number = 0;\n    let mut prime_number_prime = 0;\n    let mut prime_number_prime_prime\
    \ = 0;\n    let mut prime_number_prime_prime_prime = 0;\n    let mut prime_number_prime_prime_prime_prime\
    \ = 0;\n    let mut prime_number_prime_prime_prime_prime_prime = 0;\n    let mut\
    \ prime_number_prime_prime_prime_prime_prime_prime = 0;\n    let mut prime_number_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut prime_number_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut prime_number_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut prime_number_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut prime_number_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut prime_number_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut prime_number_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut prime_number_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut prime_number_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut prime_number_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut prime_number_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut prime_number_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut prime_number_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = 0;\n    let mut prime_number_prime_prime_prime_prime_prime_prime_prime\n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpteo6_q0u.rs:46:67\n   |\n\
    46 |     let mut prime_number_prime_prime_prime_prime_prime_prime_prime\n   |\
    \                                                                   ^ help: add\
    \ `;` here\n47 | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpteo6_q0u.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpteo6_q0u.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.in\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `in`\n  --> /tmp/tmpdp6kfoi9.rs:39:32\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \      ^^ expected identifier, found keyword\n   |\nhelp: escape `in` to use it\
    \ as an identifier\n   |\n39 |     let mut num: Vec<u8> = num.r#in\n   |     \
    \                           ++\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpdp6kfoi9.rs:39:34\n\
    \   |\n39 |     let mut num: Vec<u8> = num.in\n   |                          \
    \        ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpdp6kfoi9.rs:23:52\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_string().chars().collect();\n     |                       \
    \                             ^^^^^^^ value of type `Vec<u8>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdp6kfoi9.rs:24:61\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.into_iter().filter(|&x| x >= '0' && x <= '9').collect();\n   |\
    \                                                             ^^^ expected `u8`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdp6kfoi9.rs:24:73\n\
    \   |\n24 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= '0' &&\
    \ x <= '9').collect();\n   |                                                 \
    \                        ^^^ expected `u8`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdp6kfoi9.rs:25:61\n   |\n25 |     let mut num: Vec<u8>\
    \ = num.into_iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n   |       \
    \                                                      ^^^ expected `u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdp6kfoi9.rs:25:73\n\
    \   |\n25 |     let mut num: Vec<u8> = num.into_iter().filter(|&x| x >= 'A' &&\
    \ x <= 'F').collect();\n   |              "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_2:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_3: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut num_prime_4: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut num_prime_5: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_6:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_7: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut num_prime_8: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut num_prime_9: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_10:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_11: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp0_5hsfdc.rs:34:41\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n34 |     let mut num_prime_11:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, \n   |                                      \
    \   ^ unclosed delimiter\n35 | }\n   | ^ mismatched closing delimiter\n\nerror:\
    \ expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmp0_5hsfdc.rs:35:1\n\
    \   |\n35 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\n\
    error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmp0_5hsfdc.rs:23:55\n     |\n23   | \
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |    \
    \                                                   ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![];\n    let mut num_prime_hex: Vec<u8>\
    \ = vec![];\n    let mut num_prime_hex_reverse: Vec<u8> = vec![];\n    let mut\
    \ num_prime_hex_reverse_hex: Vec<u8> = vec![];\n    let mut num_prime_hex_reverse_hex_reverse:\
    \ Vec<u8> = vec![];\n    let mut num_prime_hex_reverse_hex_reverse_hex: Vec<u8>\
    \ = vec![];\n    let mut num_prime_hex_reverse_hex_reverse_hex_reverse: Vec<u8>\
    \ = vec![];\n    let mut num_prime_hex_reverse_hex_reverse_hex_reverse_hex: Vec<u8>\
    \ = vec![];\n    let mut num_prime_hex_reverse_hex_reverse_hex_reverse_hex_reverse:\
    \ Vec<u8> = vec![];\n    let mut num_prime_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex:\
    \ Vec<u8> = vec![];\n    let mut num_prime_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex_reverse:\
    \ Vec<u8> = vec![];\n    let mut num_prime_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex:\
    \ Vec<u8> = vec![];\n    let mut num_prime_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex_reverse:\
    \ Vec<u8> = vec![];\n    let mut num_prime_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex:\
    \ Vec<u8> = vec![];\n    let mut num_prime_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex_reverse:\
    \ Vec<u8> = vec![];\n    let mut num_prime_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex:\
    \ Vec<u8> = vec![];\n    let mut num_prime_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex_reverse:\
    \ Vec<u8> = vec![];\n    let mut num_prime_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjpl6coqe.rs:41:86\n   |\n\
    41 |     let mut num_prime_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex_reverse_hex\n\
    \   |                                                                        \
    \              ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0277]:\
    \ a value of type `Vec<u8>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpjpl6coqe.rs:23:55\n     |\n23   |     let mut num:\
    \ Vec<u8> = num.to_lowercase().chars().collect();\n     |                    \
    \                                   ^^^^^^^ value of type `Vec<u8>` cannot be\
    \ built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjpl6coqe.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime: isize = 0;\n    let mut prime_found = false;\n    let mut prime_found2\
    \ = false;\n    let mut prime_found3 = false;\n    let mut prime_found4 = false;\n\
    \    let mut prime_found5 = false;\n    let mut prime_found6 = false;\n    let\
    \ mut prime_found7 = false;\n    let mut prime_found8 = false;\n    let mut prime_found9\
    \ = false;\n    let mut prime_found10 = false;\n    let mut prime_found11 = false;\n\
    \    let mut prime_found12 = false;\n    let mut prime_found13 = false;\n    let\
    \ mut prime_found14 = false;\n    let mut prime_found15 = false;\n    let mut\
    \ prime_found16 = false;\n    let mut prime_found17 = false;\n    let mut prime_found18\
    \ = false;\n    let mut prime_found19 = false;\n    let mut prime_found20 = false;\n\
    \    let mut prime_found21 = false;\n    let mut prime_found22 = false;\n    let\
    \ mut prime_found23 = false;\n    let mut prime_found24 = false;\n    let mut\
    \ prime_found25 = false;\n    let mut prime_found26 = false;\n    let mut prime_found27\
    \ = false;\n    let mut prime_found28 = false;\n    let mut prime_found29 = false;\n\
    \    let mut prime_found30 = false;\n    let mut prime_found31 = false;\n    let\
    \ mut prime_found32 = false;\n    let mut prime_found33 = false;\n    let mut\
    \ prime_found34 = false;\n    let mut prime_found35 = false;\n    let mut prime_found36\
    \ = false;\n    let mut prime_found37 = false;\n    let mut prime_found38 = false;\n\
    \    let mut prime_found39 = false;\n    let mut prime_found40 = false;\n    let\
    \ mut prime_found41 = false;\n    let mut prime_found42 = false;\n    let mut\
    \ prime_found43 = false;\n    let mut prime_found44 = false;\n    let mut prime_found45\
    \ = false;\n    let mut prime_found46 = false;\n    let mut prime_found47 = false;\n\
    \    let mut prime_found48 = false;\n    let mut prime_found49 = false;\n    let\
    \ mut prime_found50 = false;\n    let mut prime_found51 = false;\n    let mut\
    \ prime_found52 = false;\n    let mut prime_found53 = false;\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpfkmtk9ke.rs:23:52\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfkmtk9ke.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digit:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digit_count: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_2: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_3: Vec<u8> = vec![0, 0, 0,\
    \ 0, 0, 0, 0, 0];\n    let mut prime_digit_count_4: Vec<u8> = vec![0, 0, 0, 0,\
    \ 0, 0, 0, 0];\n    let mut prime_digit_count_5: Vec<u8> = vec![0, 0, 0, 0, 0,\
    \ 0, 0, 0];\n    let mut prime_digit_count_6: Vec<u8> = vec![0, 0, 0, 0, 0, 0,\
    \ 0, 0];\n    let mut prime_digit_count_7: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0,\
    \ 0];\n    let mut prime_digit_count_8: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n\
    \    let mut prime_digit_count_9: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n  \
    \  let mut prime_digit_count_10: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n   \
    \ let mut prime_digit_count_11: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let\
    \ mut prime_digit_count_12: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut\
    \ prime_digit_count_13: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_14:\
    \ Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_15: Vec<u8>\
    \ = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_16: Vec<u8> =\
    \ vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_17: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_18: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_19: Vec<u8> = vec![0, 0, 0,\
    \ 0, 0, 0, 0, 0];\n    let mut prime_digit_count_20\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl4wu4lud.rs:45:33\n   |\n\
    45 |     let mut prime_digit_count_20\n   |                                 ^\
    \ help: add `;` here\n46 | }\n   | - unexpected token\n\nerror[E0277]: a value\
    \ of type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmpl4wu4lud.rs:23:55\n     |\n23   |     let mut num: Vec<u8> =\
    \ num.to_lowercase().chars().collect();\n     |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl4wu4lud.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_digits = num.len();\n    let mut num_primes = 0;\n    let mut\
    \ num_primes_digits = 0;\n    let mut num_primes_digits_primes = 0;\n    let mut\
    \ num_primes_digits_primes_primes = 0;\n    let mut num_primes_digits_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes = 0;\n    let\
    \ mut num_primes_digits_primes_primes_primes_primes_primes = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_primes_digits_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes_primes\
    \ = 0;\n    let mut num_prime\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpopo7qk1r.rs:44:22\n   |\n\
    44 |     let mut num_prime\n   |                      ^ help: add `;` here\n45\
    \ | }\n   | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpopo7qk1r.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpopo7qk1r.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'a' && x <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp28c4_bu5.rs:40:36\n   |\n\
    40 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmp28c4_bu5.rs:23:52\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_string().chars().collect();\n     |                               \
    \                     ^^^^^^^ value of type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp28c4_bu5.rs:24:56\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \  ^^^ expected `&u8`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp28c4_bu5.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= '0' && x <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmp28c4_bu5.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&x|\
    \ x >= '0' && x <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp28c4_bu5.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&x| x >= 'A' && x <=\
    \ 'F').collect();\n   |                                     "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_digits = num.len();\n    let mut num_primes = 0;\n    let mut num_primes_found\
    \ = 0;\n    let mut num_primes_found2 = 0;\n    let mut num_primes_found3 = 0;\n\
    \    let mut num_primes_found4 = 0;\n    let mut num_primes_found5 = 0;\n    let\
    \ mut num_primes_found6 = 0;\n    let mut num_primes_found7 = 0;\n    let mut\
    \ num_primes_found8 = 0;\n    let mut num_primes_found9 = 0;\n    let mut num_primes_found10\
    \ = 0;\n    let mut num_primes_found11 = 0;\n    let mut num_primes_found12 =\
    \ 0;\n    let mut num_primes_found13 = 0;\n    let mut num_primes_found14 = 0;\n\
    \    let mut num_primes_found15 = 0;\n    let mut num_primes_found16 = 0;\n  \
    \  let mut num_primes_found17 = 0;\n    let mut num_primes_found18 = 0;\n    let\
    \ mut num_primes_found19 = 0;\n    let mut num_primes_found20 = 0;\n    let mut\
    \ num_primes_found21 = 0;\n    let mut num_primes_found22 = 0;\n    let mut num_primes_found23\
    \ = 0;\n    let mut num_primes_found24 = 0;\n    let mut num_primes_found25 =\
    \ 0;\n    let mut num_primes_found26 = 0;\n    let mut num_primes_found27 = 0;\n\
    \    let mut num_primes_found28 = 0;\n    let mut num_primes_found29 = 0;\n  \
    \  let mut num_primes_found30 = 0;\n    let mut num_primes_found31 = 0;\n    let\
    \ mut num_primes_found32 = 0;\n    let mut num_primes_found33 = 0;\n    let mut\
    \ num_primes_found34 = 0;\n    let mut num_primes_found35 = 0;\n    let mut num_primes_found36\
    \ = 0;\n    let mut num_primes_found37 = 0;\n    let mut num_primes_found38 =\
    \ 0;\n    let mut num_primes_found39 = 0;\n    let mut num_primes_found40 = 0;\n\
    \    let mut num_primes_found41 = 0;\n    let mut num_primes_found42 = 0;\n  \
    \  let mut num_primes_found43 = 0;\n    let mut num_primes_found44 = 0;\n    let\
    \ mut num_primes_found45 = 0;\n    let mut num_primes_found46 = 0;\n    let mut\
    \ num_primes_found47 = 0;\n    let mut num_primes_found48 = 0;\n\n}\n\nfn main()\
    \ {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp105_slu9.rs:23:52\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp105_slu9.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_digits = num.len();\n    let mut prime_digits = 0;\n    let mut\
    \ prime_number = 0;\n    let mut prime_number_digits = 0;\n    let mut prime_number_digits_sum\
    \ = 0;\n    let mut prime_number_digits_product = 1;\n    let mut prime_number_digits_product2\
    \ = 1;\n    let mut prime_number_digits_product3 = 1;\n    let mut prime_number_digits_product4\
    \ = 1;\n    let mut prime_number_digits_product5 = 1;\n    let mut prime_number_digits_product6\
    \ = 1;\n    let mut prime_number_digits_product7 = 1;\n    let mut prime_number_digits_product8\
    \ = 1;\n    let mut prime_number_digits_product9 = 1;\n    let mut prime_number_digits_product10\
    \ = 1;\n    let mut prime_number_digits_product11 = 1;\n    let mut prime_number_digits_product12\
    \ = 1;\n    let mut prime_number_digits_product13 = 1;\n    let mut prime_number_digits_product14\
    \ = 1;\n    let mut prime_number_digits_product15 = 1;\n    let mut prime_number_digits_product16\
    \ = 1;\n    let mut prime_number_digits_product17 = 1;\n    let mut prime_number_digits_product18\
    \ = 1;\n    let mut prime_number_digits_product19 = 1;\n    let mut prime_number_digits_product20\
    \ = 1;\n    let mut prime_number_digits_product21 = 1;\n    let mut prime_number_digits_product22\
    \ = 1;\n    let mut prime_number_digits_product23 = 1;\n    let mut prime_number_digits_product24\
    \ = 1;\n    let mut prime_number_digits_product25 = 1;\n    let mut prime_number_digits_product26\
    \ = 1;\n    let mut prime_number_digits_product27 = 1;\n    let mut prime_number_digits_product28\
    \ = 1;\n    let mut prime_number_digits_product29 = 1;\n    let mut prime_number_digits_product30\
    \ = 1;\n    let mut prime_number_digits_product31 = 1;\n    let mut prime_number_digits_product32\
    \ = 1;\n    let mut prime_number_digits_product33 = 1;\n    let mut prime_number_digits_product34\
    \ = 1;\n    let mut prime_number_digits_product35 = 1;\n    let mut prime_number_digits_product36\
    \ = 1;\n    let mut prime_number_digits_product37 = 1;\n    let mut prime\n}\n\
    \nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptsf0eoqr.rs:66:18\n   |\n\
    66 |     let mut prime\n   |                  ^ help: add `;` here\n67 | }\n \
    \  | - unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built\
    \ from an iterator over elements of type `char`\n    --> /tmp/tmptsf0eoqr.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptsf0eoqr.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'a' && c <= 'f').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpf8uq_llq.rs:39:36\n   |\n\
    39 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmpf8uq_llq.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpf8uq_llq.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8uq_llq.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmpf8uq_llq.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf8uq_llq.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut primes\
    \ = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97];\n    let mut primes_len = primes.len();\n    let mut\
    \ primes_num = primes.clone();\n    let mut primes_num_len = primes_num.len();\n\
    \    let mut primes_num_num_len = primes_num_len.clone();\n    let mut primes_num_num_num_len\
    \ = primes_num_num_len.clone();\n    let mut primes_num_num_num_num_len = primes_num_num_num_len.clone();\n\
    \    let mut primes_num_num_num_num_num_len = primes_num_num_num_num_len.clone();\n\
    \    let mut primes_num_num_num_num_num_num_len = primes_num_num_num_num_num_len.clone();\n\
    \    let mut primes_num_num_num_num_num_num_num_len = primes_num_num_num_num_num_num_num_len.clone();\n\
    \    let mut primes_num_num_num_num_num_num_num_num_len = primes_num_num_num_num_num_num_num_num_len.clone();\n\
    \    let mut primes_num_num_num_num_num_num_num_num_len = primes_num_num_num_num_num_num_num_num_len.clone();\n\
    \    let mut primes_num_num_num_num_num_num_num_num_len = primes_num_num_num_num_num_num_num_num_num_len.clone();\n\
    \    let mut primes_num_num_num_num_num_num_num_num_num_len = primes_num_num_num_num_num_num_num_num_num_len.clone();\n\
    \    let mut primes_num_num_num_num_num_num_num_num_num_len = primes_num_num_num_num_num_num_num_num_num_num_len.clone();\n\
    \    let mut primes_num_num_num_num_num_num_num_num_num_num_len = primes_num_num_num_num_num_num_num_num_num_num_num_len.clone();\n\
    \    let mut primes_num_num_num_num_num_num_num_num_num_num_len = primes_num_num_num_num_num_num_num_num_num_num_num_len.clone();\n\
    \    let mut primes_num_num_num_num_num_num_num_num_num_num_num_len = primes_num_num_num_num_num_num_num_num_num_num_num_num_len.clone();\n\
    \    let mut primes_num_num_num_num_num_num_num_num_num_num_num_len = primes_num_num_num_num_num_num_num_num_num_num_num_num_num_len.clone();\n\
    \    let mut primes_num_num_num_num_num_num_num_num_num_num_num_len = \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpkx_rwptn.rs:44:1\n\
    \   |\n44 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `primes_num_num_num_num_num_num_num_len`\
    \ in this scope\n  --> /tmp/tmpkx_rwptn.rs:33:54\n   |\n33 |     let mut primes_num_num_num_num_num_num_num_len\
    \ = primes_num_num_num_num_num_num_num_len.clone();\n   |                    \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `primes_num_num_num_num_num_num_len`\n\
    \nerror[E0425]: cannot find value `primes_num_num_num_num_num_num_num_num_len`\
    \ in this scope\n  --> /tmp/tmpkx_rwptn.rs:34:58\n   |\n34 |     let mut primes_num_num_num_num_num_num_num_num_len\
    \ = primes_num_num_num_num_num_num_num_num_len.clone();\n   |                \
    \                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `primes_num_num_num_num_num_num_num_len`\n\
    \nerror[E0425]: cannot find value `primes_num_num_num_num_num_num_num_num_num_len`\
    \ in this scope\n  --> /tmp/tmpkx_rwptn.rs:36:58\n   |\n36 |     let mut primes_num_num_num_num_num_num_num_num_len\
    \ = primes_num_num_num_num_num_num_num_num_num_len.clone();\n   |            \
    \                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `primes_num_num_num_num_num_num_num_num_len`\n\
    \nerror[E0425]: cannot find value `primes_num_num_num_num_num_num_num_num_num_len`\
    \ in this scope\n  --> /tmp/tmpkx_rwptn.rs:37:62\n   |\n37 |     let mut primes_num_num_num_num_num_num_num_num_num_len\
    \ = primes_num_num_num_num_num_num_num_num_num_len.clone();\n   |            \
    \                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `primes_num_num_num_num_num_num_num_num_len`\n\
    \nerror[E0425]: cannot find value `primes_num_num_num_num_num_num_num_num_num_num_len`\
    \ in this scope\n  --> /tmp/tmpkx_rwptn.rs:38:62\n   |\n38 |     let mut primes_num"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut counter: usize\
    \ = 0;\n    let mut prime_counter: usize = 0;\n    let mut prime_counter2: usize\
    \ = 0;\n    let mut prime_counter3: usize = 0;\n    let mut prime_counter4: usize\
    \ = 0;\n    let mut prime_counter5: usize = 0;\n    let mut prime_counter6: usize\
    \ = 0;\n    let mut prime_counter7: usize = 0;\n    let mut prime_counter8: usize\
    \ = 0;\n    let mut prime_counter9: usize = 0;\n    let mut prime_counter10: usize\
    \ = 0;\n    let mut prime_counter11: usize = 0;\n    let mut prime_counter12:\
    \ usize = 0;\n    let mut prime_counter13: usize = 0;\n    let mut prime_counter14:\
    \ usize = 0;\n    let mut prime_counter15: usize = 0;\n    let mut prime_counter16:\
    \ usize = 0;\n    let mut prime_counter17: usize = 0;\n    let mut prime_counter18:\
    \ usize = 0;\n    let mut prime_counter19: usize = 0;\n    let mut prime_counter20:\
    \ usize = 0;\n    let mut prime_counter21: usize = 0;\n    let mut prime_counter22:\
    \ usize = 0;\n    let mut prime_counter23: usize = 0;\n    let mut prime_counter24:\
    \ usize = 0;\n    let mut prime_counter25: usize = 0;\n    let mut prime_counter26:\
    \ usize = 0;\n    let mut prime_counter27: usize = 0;\n    let mut prime_counter28:\
    \ usize = 0;\n    let mut prime_counter29: usize = 0;\n    let mut prime_counter30:\
    \ usize = 0;\n    let mut prime_counter31: usize = 0;\n    let mut prime_counter32:\
    \ usize = 0;\n    let mut prime_counter33: usize = 0;\n    let mut prime_counter34:\
    \ usize = 0;\n    let mut prime_counter35: usize = 0;\n    let mut prime_counter36:\
    \ usize = 0;\n    let mut prime_counter37: usize = 0;\n\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpzj3mo_xg.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzj3mo_xg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut nums_len\
    \ = nums.len();\n    let mut prime_digits = vec![false; 10];\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len2 = prime_digits_len * prime_digits_len;\n\
    \    let mut prime_digits_len3 = prime_digits_len2 * prime_digits_len2;\n    let\
    \ mut prime_digits_len4 = prime_digits_len3 * prime_digits_len3;\n    let mut\
    \ prime_digits_len5 = prime_digits_len4 * prime_digits_len4;\n    let mut prime_digits_len6\
    \ = prime_digits_len5 * prime_digits_len5;\n    let mut prime_digits_len7 = prime_digits_len6\
    \ * prime_digits_len6;\n    let mut prime_digits_len8 = prime_digits_len7 * prime_digits_len7;\n\
    \    let mut prime_digits_len9 = prime_digits_len8 * prime_digits_len8;\n    let\
    \ mut prime_digits_len10 = prime_digits_len9 * prime_digits_len9;\n    let mut\
    \ prime_digits_len11 = prime_digits_len10 * prime_digits_len10;\n    let mut prime_digits_len12\
    \ = prime_digits_len11 * prime_digits_len11;\n    let mut prime_digits_len13 =\
    \ prime_digits_len12 * prime_digits_len12;\n    let mut prime_digits_len14 = prime_digits_len13\
    \ * prime_digits_len13;\n    let mut prime_digits_len15 = prime_digits_len14 *\
    \ prime_digits_len14;\n    let mut prime_digits_len16 = prime_digits_len15 * prime_digits_len15;\n\
    \    let mut prime_digits_len17 = prime_digits_len16 * prime_digits_len16;\n \
    \   let mut prime_digits_len18 = prime_digits_len17 * prime_digits_len17;\n  \
    \  let mut prime_digits_len19 = prime_digits_len18 * prime_digits_len18;\n   \
    \ let mut prime_digits_len20 = prime_digits_len19 * prime_digits_len19;\n    let\
    \ mut prime_digits_len21 = prime_digits_len20 * \n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp9utw1ihm.rs:47:1\n\
    \   |\n47 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpz6u1vz3e.rs:46:1\n\
    \   |\n46 | }\n   | ^ expected expression\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpz6u1vz3e.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count: usize = 0;\n    let mut prime: usize = 2;\n    let mut prime_found\
    \ = false;\n    let mut prime_found2 = false;\n    let mut prime_found3 = false;\n\
    \    let mut prime_found4 = false;\n    let mut prime_found5 = false;\n    let\
    \ mut prime_found6 = false;\n    let mut prime_found7 = false;\n    let mut prime_found8\
    \ = false;\n    let mut prime_found9 = false;\n    let mut prime_found10 = false;\n\
    \    let mut prime_found11 = false;\n    let mut prime_found12 = false;\n    let\
    \ mut prime_found13 = false;\n    let mut prime_found14 = false;\n    let mut\
    \ prime_found15 = false;\n    let mut prime_found16 = false;\n    let mut prime_found17\
    \ = false;\n    let mut prime_found18 = false;\n    let mut prime_found19 = false;\n\
    \    let mut prime_found20 = false;\n    let mut prime_found21 = false;\n    let\
    \ mut prime_found22 = false;\n    let mut prime_found23 = false;\n    let mut\
    \ prime_found24 = false;\n    let mut prime_found25 = false;\n    let mut prime_found26\
    \ = false;\n    let mut prime_found27 = false;\n    let mut prime_found28 = false;\n\
    \    let mut prime_found29 = false;\n    let mut prime_found30 = false;\n    let\
    \ mut prime_found31 = false;\n    let mut prime_found32 = false;\n    let mut\
    \ prime_found33 = false;\n    let mut prime_found34 = false;\n    let mut prime_found35\
    \ = false;\n    let mut prime_found36 = false;\n    let mut prime_found37 = false;\n\
    \    let mut prime_found38 = false;\n    let mut prime_found39 = false;\n    let\
    \ mut prime_found40 = false;\n    let mut prime_found41 = false;\n    let mut\
    \ prime_found42 = false;\n    let mut prime_found43 = false;\n    let mut prime_found44\
    \ = false;\n    let mut prime_found45 = false;\n    let mut prime_found46 = false;\n\
    \    let mut prime_found47 = false;\n    let mut prime_found48 = false;\n    let\
    \ mut prime_found49 = false;\n    let mut prime_found50 = false;\n    let mut\
    \ prime_found51 = false;\n    let mut prime_found52 = false;\n    let \n}\n\n\
    fn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpjx9mhcuc.rs:79:1\n  \
    \ |\n79 | }\n   | ^ expected pattern\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpjx9mhcuc.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut nums = num.chars().collect::<Vec<_>>();\n    let mut primes\
    \ = vec![false; 26];\n    let mut primes_count = vec![0; 26];\n    let mut primes_count_index\
    \ = vec![0; 26];\n    let mut primes_count_index2 = vec![0; 26];\n    let mut\
    \ primes_count_index3 = vec![0; 26];\n    let mut primes_count_index4 = vec![0;\
    \ 26];\n    let mut primes_count_index5 = vec![0; 26];\n    let mut primes_count_index6\
    \ = vec![0; 26];\n    let mut primes_count_index7 = vec![0; 26];\n    let mut\
    \ primes_count_index8 = vec![0; 26];\n    let mut primes_count_index9 = vec![0;\
    \ 26];\n    let mut primes_count_index10 = vec![0; 26];\n    let mut primes_count_index11\
    \ = vec![0; 26];\n    let mut primes_count_index12 = vec![0; 26];\n    let mut\
    \ primes_count_index13 = vec![0; 26];\n    let mut primes_count_index14 = vec![0;\
    \ 26];\n    let mut primes_count_index15 = vec![0; 26];\n    let mut primes_count_index16\
    \ = vec![0; 26];\n    let mut primes_count_index17 = vec![0; 26];\n    let mut\
    \ primes_count_index18 = vec![0; 26];\n    let mut primes_count_index19 = vec![0;\
    \ 26];\n    let mut primes_count_index20 = vec![0; 26];\n    let mut primes_count_index21\
    \ = vec![0; 26];\n    let mut primes_count_index22 = vec![0; 26];\n    let mut\
    \ primes_count_index23 = vec![0; 26];\n    let mut primes_count_index24 = vec![0;\
    \ 26];\n    let mut primes_count_index25 = vec![0; 26];\n    let mut primes_count_index26\
    \ = vec![0; 26];\n    let mut primes_count_index27 = vec![0; 26];\n    let mut\
    \ primes_count_index28 = vec![0; 26];\n    let mut primes_count_index29 = vec![0;\
    \ 26];\n    let mut primes_count_index30 = vec![0; 26];\n    let mut primes_count_index31\
    \ = vec![0; 26];\n    let mut primes_count_index32 = vec![0; 26];\n    let mut\
    \ prime\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbg0qjcru.rs:58:18\n   |\n\
    58 |     let mut prime\n   |                  ^ help: add `;` here\n59 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbg0qjcru.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n  \
    \  let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let\
    \ mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8> =\
    \ num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ x.to_digit(16)).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n  \
    \  let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let\
    \ mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut\
    \ num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8> =\
    \ num.iter().map(|x| x.to_digit(16)).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ x.to_digit(16)).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n\
    \    let mut num: Vec<\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `>`, a const expression, lifetime, or type, found\
    \ `}`\n  --> /tmp/tmpxmfvcjc4.rs:43:1\n   |\n42 |     let mut num: Vec<\n   |\
    \         -------      - expected one of `>`, a const expression, lifetime, or\
    \ type\n   |         |\n   |         while parsing the type for `mut num`\n43\
    \ | }\n   | ^ unexpected token\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpxmfvcjc4.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `to_digit` found for\
    \ reference `&u8` in the current scope\n  --> /tmp/tmpxmfvcjc4.rs:24:49\n   |\n\
    24 |     let mut num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n\
    \   |                                                 ^^^^^^^^ method not found\
    \ in `&u8`\n\nerror[E0599]: no method named `to_digit` found for reference `&u8`\
    \ in the current scope\n  --> /tmp/tmpxmfvcjc4.rs:25:49\n   |\n25 |     let mut\
    \ num: Vec<u8> = num.iter().map(|x| x.to_digit(16)).collect();\n   |         \
    \                                        ^^^^^^^^ method not found in `&u8`\n\n\
    error[E0599]: no method named `to_digit` found for reference `&u8` in the current\
    \ scope\n  --> /tmp/tmpxmfvcjc4.rs:26:49\n   |\n26 |     let mut num: Vec<u8>\
    \ = num.iter().map(|x| x.to_digit(16)).collect();\n   |                      \
    \                           ^^^^^^^^ method not found in `&u8`\n\nerror[E0599]:\
    \ no method named `to_digit` found for reference `&u8` in the current scope\n\
    \  --> /tmp/tmpxmfvcjc4.rs:27:49\n   |\n27 |     let mut num: Vec<u8> = num.iter().map(|x|\
    \ x.to_digit(16)).collect();\n   |                                           \
    \      ^^^^^^^^ method not found in `&u8`\n\ne"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digit:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_digit_count: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_2: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_3: Vec<u8> = vec![0, 0, 0,\
    \ 0, 0, 0, 0, 0];\n    let mut prime_digit_count_4: Vec<u8> = vec![0, 0, 0, 0,\
    \ 0, 0, 0, 0];\n    let mut prime_digit_count_5: Vec<u8> = vec![0, 0, 0, 0, 0,\
    \ 0, 0, 0];\n    let mut prime_digit_count_6: Vec<u8> = vec![0, 0, 0, 0, 0, 0,\
    \ 0, 0];\n    let mut prime_digit_count_7: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0,\
    \ 0];\n    let mut prime_digit_count_8: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n\
    \    let mut prime_digit_count_9: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n  \
    \  let mut prime_digit_count_10: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n   \
    \ let mut prime_digit_count_11: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let\
    \ mut prime_digit_count_12: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut\
    \ prime_digit_count_13: Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_14:\
    \ Vec<u8> = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_15: Vec<u8>\
    \ = vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_16: Vec<u8> =\
    \ vec![0, 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_17: Vec<u8> = vec![0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_18: Vec<u8> = vec![0, 0,\
    \ 0, 0, 0, 0, 0, 0];\n    let mut prime_digit_count_19: Vec<u8> = vec![0, 0, 0,\
    \ 0, 0, 0, 0, 0];\n    let mut prime_digit_count_20\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl4wu4lud.rs:45:33\n   |\n\
    45 |     let mut prime_digit_count_20\n   |                                 ^\
    \ help: add `;` here\n46 | }\n   | - unexpected token\n\nerror[E0277]: a value\
    \ of type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmpl4wu4lud.rs:23:55\n     |\n23   |     let mut num: Vec<u8> =\
    \ num.to_lowercase().chars().collect();\n     |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl4wu4lud.rs:22:28\n   |\n22 | fn hex_key(num:\
    \ String) -> isize {\n   |    -------                 ^^^^^ expected `isize`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n\
    \    let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <= 'F').collect();\n\
    \    let mut num: Vec<u8> = num.iter\n}\n\nfn main() {\n    let candidate = hex_key;\n\
    \    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8kt7f6h8.rs:39:36\n   |\n\
    39 |     let mut num: Vec<u8> = num.iter\n   |                               \
    \     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0277]: a\
    \ value of type `Vec<u8>` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmp8kt7f6h8.rs:23:55\n     |\n23   |     let mut num: Vec<u8>\
    \ = num.to_lowercase().chars().collect();\n     |                            \
    \                           ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8kt7f6h8.rs:24:56\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.iter().filter(|&c| c >= '0' && c <= '9').collect();\n   |    \
    \                                                    ^^^ expected `&u8`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8kt7f6h8.rs:24:68\n\
    \   |\n24 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= '0' && c <=\
    \ '9').collect();\n   |                                                      \
    \              ^^^ expected `&u8`, found `char`\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `&u8`\n   \
    \ --> /tmp/tmp8kt7f6h8.rs:24:73\n     |\n24   |     let mut num: Vec<u8> = num.iter().filter(|&c|\
    \ c >= '0' && c <= '9').collect();\n     |                                   \
    \                                      ^^^^^^^ value of type `Vec<u8>` cannot\
    \ be built from `std::iter::Iterator<Item=&u8>`\n     |\n     = help: the trait\
    \ `FromIterator<&u8>` is not implemented for `Vec<u8>`\n     = help: the trait\
    \ `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound in\
    \ `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8kt7f6h8.rs:25:56\n\
    \   |\n25 |     let mut num: Vec<u8> = num.iter().filter(|&c| c >= 'A' && c <=\
    \ 'F').collect();\n   |                               "
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\
    \    let mut num: Vec<u8> = num.chars().collect();\n    let mut num: Vec<u8> =\
    \ num.chars().collect();\n    let mut num: Vec<u8> = num.chars().collect();\n\n\
    }\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for struct `Vec<u8>` in the\
    \ current scope\n  --> /tmp/tmpo7c1ix_y.rs:24:32\n   |\n24 |     let mut num:\
    \ Vec<u8> = num.chars().collect();\n   |                                ^^^^^\
    \ method not found in `Vec<u8>`\n\nerror[E0277]: a value of type `Vec<u8>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpo7c1ix_y.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `chars` found for struct\
    \ `Vec<u8>` in the current scope\n  --> /tmp/tmpo7c1ix_y.rs:25:32\n   |\n25 |\
    \     let mut num: Vec<u8> = num.chars().collect();\n   |                    \
    \            ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]: no method named\
    \ `chars` found for struct `Vec<u8>` in the current scope\n  --> /tmp/tmpo7c1ix_y.rs:26:32\n\
    \   |\n26 |     let mut num: Vec<u8> = num.chars().collect();\n   |          \
    \                      ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]: no\
    \ method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmpo7c1ix_y.rs:27:32\n   |\n27 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmpo7c1ix_y.rs:28:32\n   |\n28 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<u8>` in the current scope\n  -->\
    \ /tmp/tmpo7c1ix_y.rs:29:32\n   |\n29 |     let mut num: Vec<u8> = num.chars().collect();\n\
    \   |                                ^^^^^ method not found in `Vec"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: usize = 0;\n    let mut prime_counter39:\
    \ usize = 0;\n    let mut prime_counter40: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi7xvf4vd.rs:64:31\n   |\n\
    64 |     let mut prime_counter40: u\n   |                               ^ help:\
    \ add `;` here\n65 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpi7xvf4vd.rs:64:30\n   |\n64 |     let mut prime_counter40:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpi7xvf4vd.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi7xvf4vd.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut num_prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_2:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_3: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut num_prime_4: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut num_prime_5: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_6:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_7: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut num_prime_8: Vec<u8> = vec![2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n\
    \    let mut num_prime_9: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_10:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut num_prime_11: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp0_5hsfdc.rs:34:41\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n34 |     let mut num_prime_11:\
    \ Vec<u8> = vec![2, 3, 5, 7, 11, \n   |                                      \
    \   ^ unclosed delimiter\n35 | }\n   | ^ mismatched closing delimiter\n\nerror:\
    \ expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmp0_5hsfdc.rs:35:1\n\
    \   |\n35 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\n\
    error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmp0_5hsfdc.rs:23:55\n     |\n23   | \
    \    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |    \
    \                                                   ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut counter: usize\
    \ = 0;\n    let mut prime_counter: usize = 0;\n    let mut prime_counter2: usize\
    \ = 0;\n    let mut prime_counter3: usize = 0;\n    let mut prime_counter4: usize\
    \ = 0;\n    let mut prime_counter5: usize = 0;\n    let mut prime_counter6: usize\
    \ = 0;\n    let mut prime_counter7: usize = 0;\n    let mut prime_counter8: usize\
    \ = 0;\n    let mut prime_counter9: usize = 0;\n    let mut prime_counter10: usize\
    \ = 0;\n    let mut prime_counter11: usize = 0;\n    let mut prime_counter12:\
    \ usize = 0;\n    let mut prime_counter13: usize = 0;\n    let mut prime_counter14:\
    \ usize = 0;\n    let mut prime_counter15: usize = 0;\n    let mut prime_counter16:\
    \ usize = 0;\n    let mut prime_counter17: usize = 0;\n    let mut prime_counter18:\
    \ usize = 0;\n    let mut prime_counter19: usize = 0;\n    let mut prime_counter20:\
    \ usize = 0;\n    let mut prime_counter21: usize = 0;\n    let mut prime_counter22:\
    \ usize = 0;\n    let mut prime_counter23: usize = 0;\n    let mut prime_counter24:\
    \ usize = 0;\n    let mut prime_counter25: usize = 0;\n    let mut prime_counter26:\
    \ usize = 0;\n    let mut prime_counter27: usize = 0;\n    let mut prime_counter28:\
    \ usize = 0;\n    let mut prime_counter29: usize = 0;\n    let mut prime_counter30:\
    \ usize = 0;\n    let mut prime_counter31: usize = 0;\n    let mut prime_counter32:\
    \ usize = 0;\n    let mut prime_counter33: usize = 0;\n    let mut prime_counter34:\
    \ usize = 0;\n    let mut prime_counter35: usize = 0;\n    let mut prime_counter36:\
    \ usize = 0;\n    let mut prime_counter37: usize = 0;\n\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpzj3mo_xg.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzj3mo_xg.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut counter: usize\
    \ = 0;\n    for &c in num {\n        if prime == vec![2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] {\n\
    \            counter += 1;\n        }\n        if prime == vec![2, 3, 5, 7, 11,\
    \ 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\
    \ 97] {\n            counter += 1;\n        }\n        if prime == vec![2, 3,\
    \ 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79,\
    \ 83, 89, 97] {\n            counter += 1;\n        }\n        if prime == vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97] {\n            counter += 1;\n        }\n        if prime ==\
    \ vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97] {\n            counter += 1;\n        }\n        if\
    \ prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97] {\n            counter += 1;\n        }\n  \
    \      if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,\
    \ 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] {\n            counter += 1;\n     \
    \   }\n        if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] {\n            counter += 1;\n\
    \        }\n        if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] {\n            counter +=\
    \ 1;\n        }\n        if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 7\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpp0hq5gsx.rs:65:3\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - unclosed delimiter\n...\n26 |     for &c in num {\n   |          \
    \         - this delimiter might not be properly closed...\n...\n55 | }\n   |\
    \ - ...as it matches this but it has different indentation\n...\n65 | }\n   |\
    \   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpp0hq5gsx.rs:54:25\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |                         \
    \         - closing delimiter possibly meant for this\n...\n54 |         if prime\
    \ == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 7\n   |                         ^ unclosed delimiter\n55 | }\n   | ^\
    \ mismatched closing delimiter\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpp0hq5gsx.rs:55:1\n\
    \   |\n54 |         if prime == vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 7\n   |         -- this `if` expression has\
    \ a condition, but no block\n55 | }\n   | ^ expected `{`\n\nerror[E0277]: a value\
    \ of type `Vec<u8>` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmpp0hq5gsx.rs:23:55\n     |\n23   |     let mut num: Vec<u8> =\
    \ num.to_lowercase().chars().collect();\n     |                              \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp0hq5gsx.rs:26:9\n   |\n26 |     for &c in num\
    \ {\n   |         ^^    --- this expression has type `Option<u8>`\n   |      \
    \   |\n   |         expected `u8`, found reference\n   |         help: you can\
    \ probably remove the explicit borrow: `c`\n   |\n   = note:   expected type `u8`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp0hq5gsx.rs:22:28\n\
    \   |\n22 | fn hex_key(num: "
  stdout: ''
  timestamp: 1660010663
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8>\
    \ = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x|\
    \ *x).collect();\n    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n\
    \    let mut num: Vec<u8> = num.iter().map(|x| *x).collect();\n    let mut num:\
    \ Vec<u8> = \n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpybm2djfe.rs:46:1\n\
    \   |\n46 | }\n   | ^ expected expression\n\nerror[E0277]: a value of type `Vec<u8>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpybm2djfe.rs:23:52\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n\
    \     |                                                    ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_counter2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_counter4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_counter6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_counter8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_counter10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_counter12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_counter14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_counter16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_counter18: usize = 0;\n    let mut prime_counter19:\
    \ usize = 0;\n    let mut prime_counter20: usize = 0;\n    let mut prime_counter21:\
    \ usize = 0;\n    let mut prime_counter22: usize = 0;\n    let mut prime_counter23:\
    \ usize = 0;\n    let mut prime_counter24: usize = 0;\n    let mut prime_counter25:\
    \ usize = 0;\n    let mut prime_counter26: usize = 0;\n    let mut prime_counter27:\
    \ usize = 0;\n    let mut prime_counter28: usize = 0;\n    let mut prime_counter29:\
    \ usize = 0;\n    let mut prime_counter30: usize = 0;\n    let mut prime_counter31:\
    \ usize = 0;\n    let mut prime_counter32: usize = 0;\n    let mut prime_counter33:\
    \ usize = 0;\n    let mut prime_counter34: usize = 0;\n    let mut prime_counter35:\
    \ usize = 0;\n    let mut prime_counter36: usize = 0;\n    let mut prime_counter37:\
    \ usize = 0;\n    let mut prime_counter38: u\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpoz99ncue.rs:62:31\n   |\n\
    62 |     let mut prime_counter38: u\n   |                               ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type\
    \ `u` in this scope\n  --> /tmp/tmpoz99ncue.rs:62:30\n   |\n62 |     let mut prime_counter38:\
    \ u\n   |                              ^ help: a builtin type with a similar name\
    \ exists: `u8`\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpoz99ncue.rs:23:55\n\
    \     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoz99ncue.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut count = 1;\n    let mut prime_count = 0;\n    let mut prime_digit\
    \ = 0;\n    let mut prime_digit_count = 0;\n    let mut prime_digit_index = 0;\n\
    \    let mut prime_digit_index2 = 0;\n    let mut prime_digit_index3 = 0;\n  \
    \  let mut prime_digit_index4 = 0;\n    let mut prime_digit_index5 = 0;\n    let\
    \ mut prime_digit_index6 = 0;\n    let mut prime_digit_index7 = 0;\n    let mut\
    \ prime_digit_index8 = 0;\n    let mut prime_digit_index9 = 0;\n    let mut prime_digit_index10\
    \ = 0;\n    let mut prime_digit_index11 = 0;\n    let mut prime_digit_index12\
    \ = 0;\n    let mut prime_digit_index13 = 0;\n    let mut prime_digit_index14\
    \ = 0;\n    let mut prime_digit_index15 = 0;\n    let mut prime_digit_index16\
    \ = 0;\n    let mut prime_digit_index17 = 0;\n    let mut prime_digit_index18\
    \ = 0;\n    let mut prime_digit_index19 = 0;\n    let mut prime_digit_index20\
    \ = 0;\n    let mut prime_digit_index21 = 0;\n    let mut prime_digit_index22\
    \ = 0;\n    let mut prime_digit_index23 = 0;\n    let mut prime_digit_index24\
    \ = 0;\n    let mut prime_digit_index25 = 0;\n    let mut prime_digit_index26\
    \ = 0;\n    let mut prime_digit_index27 = 0;\n    let mut prime_digit_index28\
    \ = 0;\n    let mut prime_digit_index29 = 0;\n    let mut prime_digit_index30\
    \ = 0;\n    let mut prime_digit_index31 = 0;\n    let mut prime_digit_index32\
    \ = 0;\n    let mut prime_digit_index33 = 0;\n    let mut prime_digit_index34\
    \ = 0;\n    let mut prime_digit_index35 = 0;\n    let mut prime_digit_index36\
    \ = 0;\n    let mut prime_digit_index37 = 0;\n    let mut prime_digit_index38\
    \ = 0;\n    let mut prime_digit_index39 = 0;\n    let mut prime_digit_index40\
    \ = 0;\n    let mut prime_digit_index41 = 0;\n    let mut prime_digit_index42\
    \ = 0;\n    let mut prime_digit_index43 = 0;\n    let mut prime_digit_index44\
    \ = 0;\n    let mut prime_digit_index45 = 0;\n    let mut prime_digit_index46\
    \ = 0;\n    let mut prime_digit_index47 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"\
    1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n  \
    \  assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"\
    123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\"\
    )), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpgs_nwlpb.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgs_nwlpb.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut prime: Vec<u8> = vec![2, 3, 5, 7];\n    let mut digit: Vec<u8> = vec![2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n    let mut counter: usize = 0;\n    let mut prime_counter:\
    \ usize = 0;\n    let mut prime_digit: usize = 0;\n    let mut prime_counter2:\
    \ usize = 0;\n    let mut prime_digit2: usize = 0;\n    let mut prime_counter3:\
    \ usize = 0;\n    let mut prime_digit3: usize = 0;\n    let mut prime_counter4:\
    \ usize = 0;\n    let mut prime_digit4: usize = 0;\n    let mut prime_counter5:\
    \ usize = 0;\n    let mut prime_digit5: usize = 0;\n    let mut prime_counter6:\
    \ usize = 0;\n    let mut prime_digit6: usize = 0;\n    let mut prime_counter7:\
    \ usize = 0;\n    let mut prime_digit7: usize = 0;\n    let mut prime_counter8:\
    \ usize = 0;\n    let mut prime_digit8: usize = 0;\n    let mut prime_counter9:\
    \ usize = 0;\n    let mut prime_digit9: usize = 0;\n    let mut prime_counter10:\
    \ usize = 0;\n    let mut prime_digit10: usize = 0;\n    let mut prime_counter11:\
    \ usize = 0;\n    let mut prime_digit11: usize = 0;\n    let mut prime_counter12:\
    \ usize = 0;\n    let mut prime_digit12: usize = 0;\n    let mut prime_counter13:\
    \ usize = 0;\n    let mut prime_digit13: usize = 0;\n    let mut prime_counter14:\
    \ usize = 0;\n    let mut prime_digit14: usize = 0;\n    let mut prime_counter15:\
    \ usize = 0;\n    let mut prime_digit15: usize = 0;\n    let mut prime_counter16:\
    \ usize = 0;\n    let mut prime_digit16: usize = 0;\n    let mut prime_counter17:\
    \ usize = 0;\n    let mut prime_digit17: usize = 0;\n    let mut prime_counter18:\
    \ usize = 0;\n    let mut prime_digit18: usize = 0;\n\n}\n\nfn main() {\n    let\
    \ candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpikc3t_z3.rs:23:52\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpikc3t_z3.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime: Vec<u8> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut count: usize\
    \ = 0;\n    let mut digit: u8 = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: usize = 0;\n    let mut prime_digit_sum: usize = 0;\n\
    \    let mut prime_digit_sum2: usize = 0;\n    let mut prime_digit_sum3: usize\
    \ = 0;\n    let mut prime_digit_sum4: usize = 0;\n    let mut prime_digit_sum5:\
    \ usize = 0;\n    let mut prime_digit_sum6: usize = 0;\n    let mut prime_digit_sum7:\
    \ usize = 0;\n    let mut prime_digit_sum8: usize = 0;\n    let mut prime_digit_sum9:\
    \ usize = 0;\n    let mut prime_digit_sum10: usize = 0;\n    let mut prime_digit_sum11:\
    \ usize = 0;\n    let mut prime_digit_sum12: usize = 0;\n    let mut prime_digit_sum13:\
    \ usize = 0;\n    let mut prime_digit_sum14: usize = 0;\n    let mut prime_digit_sum15:\
    \ usize = 0;\n    let mut prime_digit_sum16: usize = 0;\n    let mut prime_digit_sum17:\
    \ usize = 0;\n    let mut prime_digit_sum18: usize = 0;\n    let mut prime_digit_sum19:\
    \ usize = 0;\n    let mut prime_digit_sum20: usize = 0;\n    let mut prime_digit_sum21:\
    \ usize = 0;\n    let mut prime_digit_sum22: usize = 0;\n    let mut prime_digit_sum23:\
    \ usize = 0;\n    let mut prime_digit_sum24: usize = 0;\n    let mut prime_digit_sum25:\
    \ usize = 0;\n    let mut prime_digit_sum26: usize = 0;\n    let mut prime_digit_sum27:\
    \ usize = 0;\n    let mut prime_digit_sum28: usize = 0;\n    let mut prime_digit_sum29:\
    \ usize = 0;\n    let mut prime_digit_sum30: usize = 0;\n    let mut prime_digit_sum31:\
    \ usize = 0;\n    let mut prime_digit_sum32: usize = 0;\n\n}\n\nfn main() {\n\
    \    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpm64jsxb2.rs:23:55\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm64jsxb2.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \    let mut prime_count: isize = 0;\n    let mut prime_digit: u8 = 0;\n    let\
    \ mut prime_digit_count: isize = 0;\n    let mut prime_digit_sum: isize = 0;\n\
    \    let mut prime_digit_sum2: isize = 0;\n    let mut prime_digit_sum3: isize\
    \ = 0;\n    let mut prime_digit_sum4: isize = 0;\n    let mut prime_digit_sum5:\
    \ isize = 0;\n    let mut prime_digit_sum6: isize = 0;\n    let mut prime_digit_sum7:\
    \ isize = 0;\n    let mut prime_digit_sum8: isize = 0;\n    let mut prime_digit_sum9:\
    \ isize = 0;\n    let mut prime_digit_sum10: isize = 0;\n    let mut prime_digit_sum11:\
    \ isize = 0;\n    let mut prime_digit_sum12: isize = 0;\n    let mut prime_digit_sum13:\
    \ isize = 0;\n    let mut prime_digit_sum14: isize = 0;\n    let mut prime_digit_sum15:\
    \ isize = 0;\n    let mut prime_digit_sum16: isize = 0;\n    let mut prime_digit_sum17:\
    \ isize = 0;\n    let mut prime_digit_sum18: isize = 0;\n    let mut prime_digit_sum19:\
    \ isize = 0;\n    let mut prime_digit_sum20: isize = 0;\n    let mut prime_digit_sum21:\
    \ isize = 0;\n    let mut prime_digit_sum22: isize = 0;\n    let mut prime_digit_sum23:\
    \ isize = 0;\n    let mut prime_digit_sum24: isize = 0;\n    let mut prime_digit_sum25:\
    \ isize = 0;\n    let mut prime_digit_sum26: isize = 0;\n    let mut prime_digit_sum27:\
    \ isize = 0;\n    let mut prime_digit_sum28: isize = 0;\n    let mut prime_digit_sum29:\
    \ isize = 0;\n    let mut prime_digit_sum30: isize = 0;\n    let mut prime_digit_sum31:\
    \ isize = 0;\n    let mut prime_digit_sum32: isize = 0;\n    let mut prime_digit_sum33:\
    \ isize = 0;\n    let mut prime_digit_sum34: isize = 0;\n    let mut prime_digit_sum35:\
    \ isize = 0;\n    let mut prime_digit_sum36: isize = 0;\n}\n\nfn main() {\n  \
    \  let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n\
    \    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwxfzejdb.rs:22:28\n   |\n\
    22 | fn hex_key(num: String) -> isize {\n   |    -------                 ^^^^^\
    \ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n\nerror[E0277]: a value of type\
    \ `Vec<u8>` cannot be built from an iterator over elements of type `char`\n  \
    \  --> /tmp/tmpwxfzejdb.rs:23:55\n     |\n23   |     let mut num: Vec<u8> = num.to_lowercase().chars().collect();\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n\
    \     = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
- exit_code: 1
  program: "/// You have been tasked to write a function that receives \n/// a hexadecimal\
    \ number as a string and counts the number of hexadecimal \n/// digits that are\
    \ primes (prime number, or a prime, is a natural number \n/// greater than 1 that\
    \ is not a product of two smaller natural numbers).\n/// Hexadecimal digits are\
    \ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3,\
    \ 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following\
    \ digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may\
    \ assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F\
    \ are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n\
    /// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"\
    ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n///\
    \ 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) ->\
    \ isize {\n    let mut num: Vec<u8> = num.to_string().chars().collect();\n   \
    \ let mut num_digits = num.len();\n    let mut prime_count = 0;\n    let mut prime_digits\
    \ = vec![];\n    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mut prime_digits_len = prime_digits.len();\n    let mut prime_digits_len\
    \ = prime_digits.len();\n    let mut prime_digits_len = prime_digits.len();\n\
    \    let mu\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"\
    AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"\
    ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n   \
    \ assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"\
    112233445566778899AABBCCDDEEFF00\")), 12);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpc3lzbk3d.rs:60:11\n   |\n\
    60 |     let mu\n   |           ^ help: add `;` here\n61 | }\n   | - unexpected\
    \ token\n\nerror[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpc3lzbk3d.rs:23:52\n     |\n23\
    \   |     let mut num: Vec<u8> = num.to_string().chars().collect();\n     |  \
    \                                                  ^^^^^^^ value of type `Vec<u8>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3lzbk3d.rs:22:28\n\
    \   |\n22 | fn hex_key(num: String) -> isize {\n   |    -------              \
    \   ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010664
