language: rs
name: HumanEval_17_parse_music
results:
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_octave: isize = 0;\n    let mut current_is_last\
    \ = false;\n    let mut current_is_octave = false;\n\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                if current_is_last {\n                    current_beat += 1;\n\
    \                } else {\n                    current_beat = 0;\n           \
    \         current_is_last = true;\n                }\n            } else if c.to_ascii_lowercase()\
    \ == '|' {\n                if current_is_last {\n                    current_beat\
    \ += 1;\n                } else {\n                    current_beat = 0;\n   \
    \                 current_is_last = true;\n                }\n            } else\
    \ if c.to_ascii_lowercase() == '.' {\n                if current_is_last {\n \
    \                   current_beat += 1;\n                } else {\n           \
    \         current_beat = 0;\n                    current_is_last = true;\n   \
    \             }\n            } else {\n                current_is_last = false;\n\
    \                current_is_octave = false;\n                current_octave =\
    \ 0;\n                current_note = c.to_ascii_lowercase();\n            }\n\
    \        } else {\n            if current_is_last {\n                current_beat\
    \ += 1;\n            } else {\n                current_beat = 0;\n           \
    \     current_is_last = true;\n            }\n            current_is_octave =\
    \ false;\n            current_octave = 0;\n            current_note = String::new();\n\
    \        }\n    }\n\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n\n    current_beat = 0;\n    current_is_last =\
    \ false;\n    current_is_octave = false;\n    current_octave = 0;\n    current_note\
    \ = String::new();\n\n    for c in music_string.chars() {\n        if c.is_ascii()\
    \ {\n            if c.to_ascii_lowercase() == 'o' {\n                if current_is_last\
    \ {\n                    current_beat += 1;\n                } else {\n      \
    \              current_beat = 0;\n                    current_is_last = true;\n\
    \                }\n            } else if c.to_ascii_lowercase() == '|' {\n  \
    \              if current_is_last {\n                    current_beat += 1;\n\
    \                } else {\n                    current_beat = 0;\n           \
    \         current_is_last = true;\n                }\n            } else if c.to_ascii_lowercase()\
    \ == '.' {\n                if current_is_last {\n                    current_beat\
    \ += 1;\n                } else {\n                    current_beat = 0;\n   \
    \                 current_is_last = true;\n                }\n            } else\
    \ {\n                current_is_last = false;\n                current_is_octave\
    \ = false;\n                current_octave = 0;\n                current_note\
    \ = c.to_ascii_lowercase();\n            }\n        } else {\n            if current_is_last\
    \ {\n                current_beat += 1;\n            } else {\n              \
    \  current_beat = 0;\n                current_is_last = true;\n            }\n\
    \n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpb3nrsha5.rs:116:3\n\
    \    |\n10  | fn parse_music(music_string: String) -> Vec<isize> {\n    |    \
    \                                                - unclosed delimiter\n...\n70\
    \  |     for c in music_string.chars() {\n    |                              \
    \     - unclosed delimiter\n...\n99  |         } else {\n    |               \
    \ - this delimiter might not be properly closed...\n...\n107 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n116 | }\n    |   ^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpb3nrsha5.rs:45:32\n   |\n13 |  \
    \   let mut current_note = String::new();\n   |                            -------------\
    \ expected due to this value\n...\n45 |                 current_note = c.to_ascii_lowercase();\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                                |\n \
    \  |                                expected struct `String`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpb3nrsha5.rs:97:32\n   |\n13 |  \
    \   let mut current_note = String::new();\n   |                            -------------\
    \ expected due to this value\n...\n97 |                 current_note = c.to_ascii_lowercase();\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                                |\n \
    \  |                                expected struct `String`, found `char`\n\n\
    error[E0308]: mismatched types\n   --> /tmp/tmpb3nrsha5.rs:70:5\n    |\n10  |\
    \   fn parse_music(music_string: String) -> Vec<isize> {\n    |              \
    \                             ---------- expected `Vec<isize>` because of return\
    \ type\n...\n70  | /     for c in music_string.chars() {\n71  | |         if c.is_ascii()\
    \ {\n72  | |             if c.to_ascii_lowercase() == 'o' {\n73  | |         \
    \        if current_is_last {\n...   |\n115 | |     assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n116 | | }\n    | |__^\
    \ expected struct `"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = music_string.len();\n    let mut current_note_length = music_string.len();\n\
    \    let mut current_note_length = music_string.len();\n    let mut current_note_length\
    \ = \n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpviufgltw.rs:55:1\n\
    \   |\n55 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|&(_, note)| note\
    \ != '|');\n    let mut current_note = 0;\n    let mut current_beat = 0;\n   \
    \ for note in notes {\n        if note.1 == '.' {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note += 1;\n        } else\
    \ {\n            current_beat += 1;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmpioz43qx4.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else {\n                current_note.push(c);\n            }\n\
    \        } else {\n            if current_note.is_empty() {\n                println!(\"\
    Invalid music string\");\n                break;\n            }\n            let\
    \ note = current_note.chars().collect::<String>();\n            let beat = note.chars().collect::<String>().parse().unwrap();\n\
    \            beats.push(beat);\n            current_beat = beat;\n           \
    \ current_note = String::new();\n        }\n    }\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[4, 4, 4, 4]`', /tmp/tmprj5ox0uc.rs:41:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4\
    \ = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n\
    \    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let\
    \ mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut\
    \ current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13\
    \ = 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 =\
    \ 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n\
    \    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n  \
    \  let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let\
    \ mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut\
    \ current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26\
    \ = 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 =\
    \ 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n\
    \    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n  \
    \  let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let\
    \ mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut\
    \ current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39\
    \ = 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 =\
    \ 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n\
    \    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n  \
    \  let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let\
    \ mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut\
    \ current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52\
    \ = 0;\n    let mut current_note_oct53 = 0;\n    let mut current_note_\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyl45pi_p.rs:68:26\n   |\n\
    68 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n69 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyl45pi_p.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string {\n        if c == 'o' {\n            if current_beat\
    \ > 0 {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n            }\n            current_note = String::new();\n        } else\
    \ if c == '|' {\n            if current_beat > 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n            }\n            current_note =\
    \ String::new();\n        } else if c == '.' {\n            if current_beat >\
    \ 0 {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n            }\n            current_note = String::new();\n        } else\
    \ {\n            current_note.push(c);\n        }\n    }\n    if current_beat\
    \ > 0 {\n        beats.push(current_beat);\n    }\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpmjhktovg.rs:14:14\n\
    \   |\n14 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.clone();\n    let mut current_beat = 0;\n  \
    \  while current_note.is_not_empty() {\n        let note = current_note.clone();\n\
    \        if note.len() == 1 {\n            beats.push(current_beat);\n       \
    \     current_beat = 0;\n            current_note = notes.clone();\n        }\
    \ else {\n            if note.chars().any(|c| c == 'o') {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = notes.clone();\n\
    \            } else {\n                let mut beat = note.chars().filter(|c|\
    \ c != 'o').count();\n                if beat > current_beat {\n             \
    \       beats.push(current_beat);\n                    current_beat = beat;\n\
    \                }\n                current_note = notes.clone();\n          \
    \  }\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_not_empty` found for struct `Vec<&str>`\
    \ in the current scope\n  --> /tmp/tmpa_vn8wpb.rs:15:24\n   |\n15 |     while\
    \ current_note.is_not_empty() {\n   |                        ^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_empty`\n\nerror[E0599]:\
    \ no method named `chars` found for struct `Vec<&str>` in the current scope\n\
    \  --> /tmp/tmpa_vn8wpb.rs:22:21\n   |\n22 |             if note.chars().any(|c|\
    \ c == 'o') {\n   |                     ^^^^^ method not found in `Vec<&str>`\n\
    \nerror[E0599]: no method named `chars` found for struct `Vec<&str>` in the current\
    \ scope\n  --> /tmp/tmpa_vn8wpb.rs:27:37\n   |\n27 |                 let mut beat\
    \ = note.chars().filter(|c| c != 'o').count();\n   |                         \
    \            ^^^^^ method not found in `Vec<&str>`\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = String::from(\"\");\n    let mut current_beat = 0;\n\
    \    let mut current_note_index = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzjo8vwgx.rs:61:40\n   |\n\
    61 |     let mut current_note_length_index45\n   |                           \
    \             ^ help: add `;` here\n62 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzjo8vwgx.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    for c in music_string.chars() {\n      \
    \  if c.is_whitespace() {\n            continue;\n        }\n        if c.is_ascii_digit()\
    \ {\n            current_note = c.to_string();\n            current_note_len =\
    \ c.len() as isize;\n        } else {\n            if current_note_len == 0 {\n\
    \                continue;\n            }\n            if c.is_ascii_letter()\
    \ {\n                beats.push(current_beat + current_note_len);\n          \
    \      current_beat = 0;\n                current_note = String::new();\n    \
    \            current_note_len = c.len() as isize;\n            } else {\n    \
    \            current_beat += 1;\n            }\n        }\n    }\n    beats.push(current_beat\
    \ + current_note_len);\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpuwrn1bi0.rs:21:34\n   |\n21 |             current_note_len\
    \ = c.len() as isize;\n   |                                  ^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `is_ascii_letter` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpuwrn1bi0.rs:26:18\n   |\n26 |   \
    \          if c.is_ascii_letter() {\n   |                  ^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `len` found for type `char` in the current scope\n  --> /tmp/tmpuwrn1bi0.rs:30:38\n\
    \   |\n30 |                 current_note_len = c.len() as isize;\n   |       \
    \                               ^^^ method not found in `char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut last_note = String::new();\n   \
    \ let mut last_note_len = 0;\n    for c in music_string.chars() {\n        if\
    \ c == 'o' {\n            if current_note_len == 0 {\n                last_note\
    \ = current_note;\n                last_note_len = current_note_len;\n       \
    \     }\n            current_note_len = 0;\n            current_note = String::new();\n\
    \            current_beat += 1;\n        } else if c == '|' {\n            if\
    \ current_note_len == 0 {\n                last_note = current_note;\n       \
    \         last_note_len = current_note_len;\n            }\n            current_note_len\
    \ = 0;\n            current_note = String::new();\n            current_beat +=\
    \ 1;\n        } else if c == '.' {\n            if current_note_len == 0 {\n \
    \               last_note = current_note;\n                last_note_len = current_note_len;\n\
    \            }\n            current_note_len = 0;\n            current_note =\
    \ String::new();\n            current_beat += 1;\n        } else {\n         \
    \   current_note.push(c);\n            current_note_len = current_note.len();\n\
    \        }\n    }\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(current_beat);\n    beats.push(current_beat);\n    beats.push(current_beat);\n\
    \    beats.push(\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpo5ewyiv8.rs:85:15\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - closing delimiter possibly meant\
    \ for this\n...\n85 |     beats.push(\n   |               ^ unclosed delimiter\n\
    86 | }\n   | ^ mismatched closing delimiter\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n    --> /tmp/tmpo5ewyiv8.rs:85:11\n\
    \     |\n85   |     beats.push(\n     |           ^^^^- supplied 0 arguments\n\
    \     |           |\n     |           expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo5ewyiv8.rs:85:5\n\
    \   |\n10 |   fn parse_music(music_string: String) -> Vec<isize> {\n   |     \
    \                                      ---------- expected `Vec<isize>` because\
    \ of return type\n...\n85 | /     beats.push(\n86 | | }\n   | |_^ expected struct\
    \ `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n         \
    \  found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().collect::<Vec<_>>();\n    let mut current_note\
    \ = notes.len() - 1;\n    let mut last_note = -1;\n    while current_note >= 0\
    \ {\n        let note = notes[current_note];\n        let mut beat = 0;\n    \
    \    if note == 'o' {\n            beat = 4;\n            last_note = current_note;\n\
    \        } else if note == 'o|' {\n            beat = 2;\n            last_note\
    \ = current_note;\n        } else if note == '.|' {\n            beat = 1;\n \
    \           last_note = current_note;\n        } else {\n            beat = 1;\n\
    \        }\n        beats.push(beat);\n        current_note = last_note;\n   \
    \ }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpcx9xnuly.rs:21:30\n\
    \   |\n21 |         } else if note == 'o|' {\n   |                           \
    \   ^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = 0;\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let mut current_note_length_index46 = 1;\n    let mut current_note_length_index47\
    \ = 1;\n    let mut current_note_length_index48\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsuoe0_1c.rs:62:40\n   |\n\
    62 |     let mut current_note_length_index48\n   |                           \
    \             ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsuoe0_1c.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length_index48 = 0;\n    let \n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp2y9b3mk6.rs:64:1\n  \
    \ |\n64 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = 0;\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let mut current_note_length_index46 = 1;\n    let mut current_note_length_index47\
    \ = 1;\n    let mut current_note_length_index48\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsuoe0_1c.rs:62:40\n   |\n\
    62 |     let mut current_note_length_index48\n   |                           \
    \             ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsuoe0_1c.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.first().unwrap();\n    let mut current_beat\
    \ = 0;\n    let mut current_note_length = 0;\n    let mut current_note_length_index\
    \ = 0;\n    while current_note != \"\" {\n        if current_note == \"o\" {\n\
    \            beats.push(current_beat);\n            current_beat = 0;\n      \
    \      current_note_length = 0;\n            current_note_length_index = 0;\n\
    \            current_note = notes.next();\n        } else if current_note == \"\
    o|\" {\n            beats.push(current_beat);\n            current_beat = 0;\n\
    \            current_note_length = 2;\n            current_note_length_index =\
    \ 0;\n            current_note = notes.next();\n        } else if current_note\
    \ == \".|\" {\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note_length = 1;\n            current_note_length_index\
    \ = 0;\n            current_note = notes.next();\n        } else {\n         \
    \   current_note_length += 1;\n            current_note_length_index += 1;\n \
    \           current_note = notes.next();\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmp98izlskk.rs:17:24\n\
    \   |\n17 |     while current_note != \"\" {\n   |                        ^^ no\
    \ implementation for `&str == str`\n   |\n   = help: the trait `PartialEq<str>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]: can't compare `&str`\
    \ with `str`\n  --> /tmp/tmp98izlskk.rs:18:25\n   |\n18 |         if current_note\
    \ == \"o\" {\n   |                         ^^ no implementation for `&str == str`\n\
    \   |\n   = help: the trait `PartialEq<str>` is not implemented for `&str`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0599]:\
    \ no method named `next` found for struct `Vec<&str>` in the current scope\n \
    \ --> /tmp/tmp98izlskk.rs:23:34\n   |\n23 |             current_note = notes.next();\n\
    \   |                                  ^^^^ method not found in `Vec<&str>`\n\n\
    error[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmp98izlskk.rs:24:32\n\
    \   |\n24 |         } else if current_note == \"o|\" {\n   |                 \
    \               ^^ no implementation for `&str"
  stdout: ''
  timestamp: 1660011548
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut notes = music_string.split_whitespace();\n    let mut current_note\
    \ = notes.next().unwrap();\n    let mut current_beat = 0;\n    let mut current_note_length\
    \ = current_note.chars().count();\n    for note in notes {\n        if note !=\
    \ current_note {\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note = note;\n            current_note_length = current_note.chars().count();\n\
    \        }\n        current_beat += 1;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmporcobqbs.rs:13:41

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = String::new();\n    let mut current_beat = 0;\n  \
    \  let mut current_note_length = 0;\n    for note in notes {\n        if note\
    \ == \"o\" {\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note_length = 0;\n            current_note = String::new();\n\
    \        } else if note == \"o|\" {\n            beats.push(current_beat);\n \
    \           current_beat = 0;\n            current_note_length = 2;\n        \
    \    current_note = String::new();\n        } else if note == \".|\" {\n     \
    \       beats.push(current_beat);\n            current_beat = 0;\n           \
    \ current_note_length = 1;\n            current_note = String::new();\n      \
    \  } else {\n            current_note.push_str(note);\n            current_note_length\
    \ += 1;\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmpvf0fsp8z.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_len = 0;\n    let mut current_note_char = 0;\n    let\
    \ mut current_note_char_len = 0;\n    let mut current_note_char_index = 0;\n \
    \   let mut current_note_char_length = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n    let mut current_note_char_length_index\
    \ = 0;\n    let mut current_note_char_length_index = 0;\n}\n\nfn main() {\n  \
    \  let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmr1vw6d5.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length = 0;\n    let\
    \ mut current_note_length_to_beat_with_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_note\
    \ = 0;\n    let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwnnybk16.rs:32:96\n   |\n\
    32 |     let mut current_note_length_to_beat_with_note_length_to_beat_with_note_length_to_beat_with_\n\
    \   |                                                                        \
    \                        ^ help: add `;` here\n33 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwnnybk16.rs:10:41\n   |\n10 |\
    \ fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------  \
    \                        ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |  \
    \  |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    for c in music_string {\n        if\
    \ c.is_ascii() {\n            current_note.push_str(&c.to_string());\n       \
    \     current_note_length += 1;\n        } else {\n            if current_note_length\
    \ == 0 {\n                println!(\"Invalid music string\");\n              \
    \  return beats;\n            }\n            if current_note_length == 1 {\n \
    \               if current_note == \"o\" {\n                    beats.push(current_beat);\n\
    \                }\n                current_beat = 0;\n                current_note\
    \ = String::new();\n                current_note_length = 0;\n            } else\
    \ {\n                if current_note == \"o\" {\n                    beats.push(current_beat);\n\
    \                }\n                current_beat = 0;\n                current_note\
    \ = String::new();\n                current_note_length = 0;\n            }\n\
    \        }\n    }\n    if current_note != \"o\" {\n        beats.push(current_beat);\n\
    \    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2hwlsqvb.rs:15:14\n\
    \   |\n15 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut notes = music_string.chars().enumerate().filter(|&(_, c)| c != '|');\n\
    \    let mut current_note = 0;\n    let mut current_beat = 0;\n    for note in\
    \ notes {\n        match note {\n            (0, '.') => {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note += 1;\n     \
    \       }\n            (1, '.') => {\n                current_beat += 1;\n   \
    \         }\n            (2, '.') => {\n                current_beat += 1;\n \
    \           }\n            (3, '|') => {\n                current_beat += 1;\n\
    \            }\n            (4, _) => {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note += 1;\n     \
    \       }\n            _ => {\n                current_beat += 1;\n          \
    \  }\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmpa198royg.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.next();\n    let mut current_beat = 0;\n   \
    \ while let Some(note) = current_note {\n        if note == \"o\" {\n        \
    \    beats.push(current_beat);\n            current_beat = 0;\n            current_note\
    \ = notes.next();\n        } else {\n            current_beat += 1;\n        }\n\
    \    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<&str>` in the\
    \ current scope\n  --> /tmp/tmpccirb2l8.rs:13:34\n   |\n13 |     let mut current_note\
    \ = notes.next();\n   |                                  ^^^^ method not found\
    \ in `Vec<&str>`\n\nerror[E0599]: no method named `next` found for struct `Vec<&str>`\
    \ in the current scope\n  --> /tmp/tmpccirb2l8.rs:19:34\n   |\n19 |          \
    \   current_note = notes.next();\n   |                                  ^^^^ method\
    \ not found in `Vec<&str>`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_index\
    \ = 0;\n    let mut current_note_length = 0;\n    let mut current_note_length_index\
    \ = 0;\n    let mut current_note_length_value = 0;\n    let mut current_note_length_value_index\
    \ = 0;\n    let mut current_note_length_value_value = 0;\n    let mut current_note_length_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpspflq3aw.rs:56:26\n   |\n\
    56 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n57 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpspflq3aw.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 1;\n    let mut current_note_length_index42\
    \ = 1;\n    let mut current_note_length_index43 = 1;\n    let mut current_note_length_index44\
    \ = 1;\n    let mut current_note_length_index45 = 1;\n    let mut current_note_length_index46\
    \ = 1;\n    let mut current_note_length_index47 = 1;\n    let mut current_note_length_index48\
    \ = 1;\n    let mut current_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjter0sou.rs:63:21\n   |\n\
    63 |     let mut current_\n   |                     ^ help: add `;` here\n64 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjter0sou.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_octave = 0;\n    for c in music_string.chars() {\n        if\
    \ c == 'o' {\n            if current_note != String::new() {\n               \
    \ beats.push(current_beat);\n                current_beat = 0;\n             \
    \   current_note = String::new();\n            }\n            current_octave =\
    \ 0;\n            current_note = c.to_string();\n        } else if c == '|' {\n\
    \            if current_note != String::new() {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            }\n            current_octave = 1;\n            current_note = c.to_string();\n\
    \        } else if c == '.' {\n            if current_note != String::new() {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n            }\n            current_note\
    \ = c.to_string();\n        } else {\n            current_note += c.to_string();\n\
    \        }\n        current_beat += 1;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2nt_0327.rs:40:29\n   |\n\
    40 |             current_note += c.to_string();\n   |                        \
    \     ^^^^^^^^^^^^^\n   |                             |\n   |                \
    \             expected `&str`, found struct `String`\n   |                   \
    \          help: consider borrowing here: `&c.to_string()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let mut current_note_length_index46 = 1;\n    let mut current_note_length_index47\
    \ = 1;\n    let mut current_note_length_index\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpafoz5ztf.rs:62:38\n   |\n\
    62 |     let mut current_note_length_index\n   |                             \
    \         ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpafoz5ztf.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_to_beat = 0;\n    let mut current_note_length_to_beat_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter = 0;\n    let\
    \ mut current_note_length_to_beat_counter_counter_counter = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_counter_counter_\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7awzvkhp.rs:37:65\n   |\n\
    37 |     let mut current_note_length_to_beat_counter_counter_counter_\n   |  \
    \                                                               ^ help: add `;`\
    \ here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp7awzvkhp.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkunjr83j.rs:62:32\n   |\n\
    62 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkunjr83j.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    for c\
    \ in music_string.chars() {\n        if c == 'o' {\n            if current_note_len\
    \ == 0 {\n                println!(\"Invalid music string\");\n              \
    \  return beats;\n            }\n            beats.push(current_beat);\n     \
    \       current_beat = 0;\n            current_note = String::new();\n       \
    \     current_note_len = 0;\n            current_note_oct = 0;\n        } else\
    \ if c == '|' {\n            if current_note_len == 0 {\n                println!(\"\
    Invalid music string\");\n                return beats;\n            }\n     \
    \       beats.push(current_beat);\n            current_beat = 0;\n           \
    \ current_note = String::new();\n            current_note_len = 0;\n         \
    \   current_note_oct = 0;\n        } else if c == ' ' {\n            if current_note_len\
    \ == 0 {\n                println!(\"Invalid music string\");\n              \
    \  return beats;\n            }\n            beats.push(current_beat);\n     \
    \       current_beat = 0;\n            current_note = String::new();\n       \
    \     current_note_len = 0;\n            current_note_oct = 0;\n        } else\
    \ {\n            if current_note_len == 0 {\n                current_note.push(c);\n\
    \                current_note_len = c.len_utf8();\n                current_note_oct\
    \ = c.oct();\n            } else {\n                current_note.push(c);\n  \
    \              current_note_len = c.len_utf8();\n                current_note_oct\
    \ = c.oct();\n            }\n        }\n    }\n    if current_note_len == 0 {\n\
    \        println!(\"Invalid music string\");\n        return beats;\n    }\n \
    \   beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `oct` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpujevgvru.rs:51:38\n   |\n51 |                 current_note_oct\
    \ = c.oct();\n   |                                      ^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `oct` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpujevgvru.rs:55:38\n   |\n55 |                 current_note_oct\
    \ = c.oct();\n   |                                      ^^^ method not found in\
    \ `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat: isize = 0;\n    let mut current_note\
    \ = String::new();\n    let mut current_note_length: isize = 0;\n    let mut current_note_length_index:\
    \ usize = 0;\n    let mut current_note_length_index2: usize = 0;\n    let mut\
    \ current_note_length_index3: usize = 0;\n    let mut current_note_length_index4:\
    \ usize = 0;\n    let mut current_note_length_index5: usize = 0;\n    let mut\
    \ current_note_length_index6: usize = 0;\n    let mut current_note_length_index7:\
    \ usize = 0;\n    let mut current_note_length_index8: usize = 0;\n    let mut\
    \ current_note_length_index9: usize = 0;\n    let mut current_note_length_index10:\
    \ usize = 0;\n    let mut current_note_length_index11: usize = 0;\n    let mut\
    \ current_note_length_index12: usize = 0;\n    let mut current_note_length_index13:\
    \ usize = 0;\n    let mut current_note_length_index14: usize = 0;\n    let mut\
    \ current_note_length_index15: usize = 0;\n    let mut current_note_length_index16:\
    \ usize = 0;\n    let mut current_note_length_index17: usize = 0;\n    let mut\
    \ current_note_length_index18: usize = 0;\n    let mut current_note_length_index19:\
    \ usize = 0;\n    let mut current_note_length_index20: usize = 0;\n    let mut\
    \ current_note_length_index21: usize = 0;\n    let mut current_note_length_index22:\
    \ usize = 0;\n    let mut current_note_length_index23: usize = 0;\n    let mut\
    \ current_note_length_index24: usize = 0;\n    let mut current_note_length_index25:\
    \ usize = 0;\n    let mut current_note_length_index26: usize = 0;\n    let mut\
    \ current_note_length_index27: usize = 0;\n    let mut current_note_length_index28:\
    \ usize = 0;\n    let mut current_note_length_index29: usize = 0;\n    let mut\
    \ current_note_length_index30: usize = 0;\n    let mut current_note_length_index31:\
    \ usize = 0;\n    let mut current_note_length_index32: usize = 0;\n    let mut\
    \ current_note_length_index33: usize = 0;\n    let mut current_note_length_index34:\
    \ usize = 0;\n    let mut current_note_length_index35: usize = 0;\n    let mut\
    \ current_note_length_index36: usize = 0;\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpq0_o9n02.rs:52:1\n  \
    \ |\n52 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, note)| note\
    \ != '|');\n    for note in notes {\n        let mut beat = 0;\n        note.for_each(|c|\
    \ {\n            if c == 'o' {\n                beat += 1;\n            }\n  \
    \          beats.push(beat);\n        });\n    }\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3uusscn_.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != '|');\n   |                                                        \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0599]: `(usize, char)` is not\
    \ an iterator\n  --> /tmp/tmp3uusscn_.rs:15:14\n   |\n15 |         note.for_each(|c|\
    \ {\n   |              ^^^^^^^^ `(usize, char)` is not an iterator\n   |\n   =\
    \ note: the following trait bounds were not satisfied:\n           `(usize, char):\
    \ Iterator`\n           which is required by `&mut (usize, char): Iterator`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    for c in music_string.chars()\
    \ {\n        if c == 'o' {\n            if current_note.len() > 0 {\n        \
    \        beats.push(current_beat + 1);\n                current_beat = 0;\n  \
    \              current_note = String::new();\n            }\n            current_note.push_str(&c);\n\
    \            current_note_length.push_str(&c.to_string());\n        } else if\
    \ c == '|' {\n            if current_note.len() > 0 {\n                beats.push(current_beat\
    \ + 1);\n                current_beat = 0;\n                current_note = String::new();\n\
    \            }\n            current_note.push_str(&c);\n            current_note_length.push_str(&c.to_string());\n\
    \        } else if c == ' ' {\n            if current_note.len() > 0 {\n     \
    \           beats.push(current_beat + 1);\n                current_beat = 0;\n\
    \                current_note = String::new();\n            }\n            current_note.push_str(&c);\n\
    \            current_note_length.push_str(&c.to_string());\n        } else {\n\
    \            current_note.push_str(&c);\n            current_note_length.push_str(&c.to_string());\n\
    \        }\n    }\n    if current_note.len() > 0 {\n        beats.push(current_beat\
    \ + 1);\n    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg_avbp37.rs:22:35\n   |\n\
    22 |             current_note.push_str(&c);\n   |                            \
    \       ^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpg_avbp37.rs:30:35\n   |\n30 |             current_note.push_str(&c);\n\
    \   |                                   ^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpg_avbp37.rs:38:35\n   |\n38 |\
    \             current_note.push_str(&c);\n   |                               \
    \    ^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpg_avbp37.rs:41:35\n   |\n41 |             current_note.push_str(&c);\n\
    \   |                                   ^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let\
    \ mut current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut\
    \ current_note_oct4 = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6\
    \ = 0;\n    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n\
    \    let mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n   \
    \ let mut current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let\
    \ mut current_note_oct13 = 0;\n    let mut current_note_oct14 = 0;\n    let mut\
    \ current_note_oct15 = 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17\
    \ = 0;\n    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 =\
    \ 0;\n    let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n\
    \    let mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n  \
    \  let mut current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let\
    \ mut current_note_oct26 = 0;\n    let mut current_note_oct27 = 0;\n    let mut\
    \ current_note_oct28 = 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30\
    \ = 0;\n    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 =\
    \ 0;\n    let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n\
    \    let mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n  \
    \  let mut current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let\
    \ mut current_note_oct39 = 0;\n    let mut current_note_oct40 = 0;\n    let mut\
    \ current_note_oct41 = 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43\
    \ = 0;\n    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 =\
    \ 0;\n    let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n\
    \    let mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n  \
    \  let mut current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let\
    \ mut current_note_oct52 = 0;\n    let mut current_note_oct53\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp504k_35j.rs:67:31\n   |\n\
    67 |     let mut current_note_oct53\n   |                               ^ help:\
    \ add `;` here\n68 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp504k_35j.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                if current_note.is_empty() {\n                    current_note\
    \ = c.to_ascii_lowercase();\n                    current_note_length = c.to_ascii_lowercase();\n\
    \                } else {\n                    current_note += c.to_ascii_lowercase();\n\
    \                    current_note_length += c.to_ascii_lowercase();\n        \
    \        }\n            } else {\n                if current_note.is_empty() {\n\
    \                    current_note = c.to_ascii_lowercase();\n                \
    \    current_note_length = c.to_ascii_lowercase();\n                } else {\n\
    \                    current_note += c.to_ascii_lowercase();\n               \
    \     current_note_length += c.to_ascii_lowercase();\n                }\n    \
    \        }\n        } else {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                if current_note.is_empty() {\n                    current_note\
    \ = c.to_ascii_lowercase();\n                    current_note_length = c.to_ascii_lowercase();\n\
    \                } else {\n                    current_note += c.to_ascii_lowercase();\n\
    \                    current_note_length += c.to_ascii_lowercase();\n        \
    \        }\n            } else {\n                if current_note.is_empty() {\n\
    \                    current_note = c.to_ascii_lowercase();\n                \
    \    current_note_length = c.to_ascii_lowercase();\n                } else {\n\
    \                    current_note += c.to_ascii_lowercase();\n               \
    \     current_note_length += c.to_ascii_lowercase();\n                }\n    \
    \        }\n        }\n    }\n    if current_note.is_empty() {\n        return\
    \ beats;\n    }\n    let mut current_note_length = current_note_length.chars().count();\n\
    \    for c in current_note.chars() {\n        if c.is_ascii() {\n            if\
    \ c.to_ascii_lowercase() == '|' {\n                if current_note_length == 0\
    \ {\n                    current_note_length += 1;\n                } else {\n\
    \                    current_note_length += 1;\n                }\n          \
    \  } else {\n                if current_note_length == 0 {\n                 \
    \   current_note_length += 1;\n                } else {\n                    current_note_length\
    \ += 1;\n                }\n            }\n        } else {\n            if c.to_ascii_lowercase()\
    \ == '|' {\n                if current_note_length == 0 {\n                  \
    \  current_note_length += 1;\n                } else {\n                    current_note_length\
    \ += 1;\n                }\n            } else {\n                if current_note_length\
    \ == 0 {\n                    current_note_length += 1;\n                } else\
    \ {\n                    current_note_length += 1;\n                }\n      \
    \      }\n        }\n    }\n    for c in current_note.chars() {\n        if c.is_ascii()\
    \ {\n            if c.to_ascii_lowercase() == '|' {\n                if current_note_length\
    \ == 0 {\n                    current_note_length += 1;\n                } else\
    \ {\n                    current_note_\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpbxyh42xz.rs:105:3\n\
    \    |\n10  | fn parse_music(music_string: String) -> Vec<isize> {\n    |    \
    \                                                - unclosed delimiter\n...\n89\
    \  |     for c in current_note.chars() {\n    |                              \
    \     - unclosed delimiter\n90  |         if c.is_ascii() {\n    |           \
    \              - unclosed delimiter\n91  |             if c.to_ascii_lowercase()\
    \ == '|' {\n    |                                              - unclosed delimiter\n\
    ...\n94  |                 } else {\n    |                        - this delimiter\
    \ might not be properly closed...\n95  |                     current_note_\n96\
    \  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    105 | }\n    |   ^\n\nerror[E0425]: cannot find value `current_note_` in this\
    \ scope\n  --> /tmp/tmpbxyh42xz.rs:95:21\n   |\n95 |                     current_note_\n\
    \   |                     ^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `current_note`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbxyh42xz.rs:19:36\n\
    \   |\n13 |     let mut current_note = String::new();\n   |                  \
    \          ------------- expected due to this value\n...\n19 |               \
    \      current_note = c.to_ascii_lowercase();\n   |                          \
    \          ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                    |\n   |                             \
    \       expected struct `String`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbxyh42xz.rs:20:43\n   |\n14 |     let mut current_note_length =\
    \ String::new();\n   |                                   ------------- expected\
    \ due to this value\n...\n20 |                     current_note_length = c.to_ascii_lowercase();\n\
    \   |                                           ^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \                   |\n   |                                           expected\
    \ struct `String`, fo"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string {\n        if c == 'o' {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \      } else if c == '|' {\n            beats.push(current_beat);\n         \
    \   current_beat = 0;\n            current_note = String::new();\n        } else\
    \ if c == ' ' {\n            current_beat++;\n        } else {\n            current_note.push(c);\n\
    \        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp2_g3kz7o.rs:24:25\n\
    \   |\n24 |             current_beat++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n24 |         \
    \    { let tmp = current_beat; current_beat += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n24 -             current_beat++;\n24\
    \ +             current_beat += 1;\n   | \n\nerror[E0277]: `String` is not an\
    \ iterator\n  --> /tmp/tmp2_g3kz7o.rs:14:14\n   |\n14 |     for c in music_string\
    \ {\n   |              ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp1856e9ui.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_octave: isize = 0;\n    let mut current_note_is_octave\
    \ = false;\n    let mut current_note_is_rest = false;\n\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            let note = c.to_ascii_lowercase();\n\
    \            if note == \"o\" {\n                if current_note_is_octave {\n\
    \                    current_note_is_octave = false;\n                    current_note_is_rest\
    \ = true;\n                } else {\n                    current_note_is_octave\
    \ = true;\n                    current_note_is_rest = false;\n               \
    \ }\n            } else if note == \"|\" {\n                if current_note_is_octave\
    \ {\n                    current_note_is_octave = false;\n                   \
    \ current_note_is_rest = true;\n                } else {\n                   \
    \ current_note_is_octave = true;\n                    current_note_is_rest = false;\n\
    \                }\n            } else if note == \".\" {\n                if\
    \ current_note_is_octave {\n                    current_note_is_octave = false;\n\
    \                    current_note_is_rest = true;\n                } else {\n\
    \                    current_note_is_octave = true;\n                    current_note_is_rest\
    \ = false;\n                }\n            } else if note == \"o|\" {\n      \
    \          if current_note_is_octave {\n                    current_note_is_octave\
    \ = false;\n                    current_note_is_rest = true;\n               \
    \ } else {\n                    current_note_is_octave = true;\n             \
    \       current_note_is_rest = false;\n                }\n            } else if\
    \ note == \".|\" {\n                if current_note_is_octave {\n            \
    \        current_note_is_octave = false;\n                    current_note_is_rest\
    \ = true;\n                } else {\n                    current_note_is_octave\
    \ = true;\n                    current_note_is_rest = false;\n               \
    \ }\n            } else {\n                if current_note_is_octave {\n     \
    \               current_note_is_octave = false;\n                    current_note_is_rest\
    \ = true;\n                } else {\n                    current_note_is_octave\
    \ = true;\n                    current_note_is_rest = false;\n               \
    \ }\n            }\n            current_note = note;\n            current_octave\
    \ = 0;\n            current_note_is_octave = false;\n            current_note_is_rest\
    \ = false;\n        } else {\n            if current_note_is_octave {\n      \
    \          current_note_is_octave = false;\n                current_note_is_rest\
    \ = true;\n            } else {\n                current_note_is_octave = true;\n\
    \                current_note_is_rest = false;\n            }\n            current_note\
    \ = String::new();\n            current_octave = 0;\n            current_note_is_octave\
    \ = false;\n            current_note_is_rest = false;\n        }\n        if current_note_is_rest\
    \ {\n            beats.push(current_beat);\n            current_beat = 0;\n  \
    \          current_note = String::new();\n            current_octave = 0;\n}\n\
    \nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpj9njo0b8.rs:101:3\n\
    \    |\n10  | fn parse_music(music_string: String) -> Vec<isize> {\n    |    \
    \                                                - unclosed delimiter\n...\n18\
    \  |     for c in music_string.chars() {\n    |                              \
    \     - unclosed delimiter\n...\n87  |         if current_note_is_rest {\n   \
    \ |                                 - this delimiter might not be properly closed...\n\
    ...\n92  | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n101 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj9njo0b8.rs:21:24\n\
    \   |\n21 |             if note == \"o\" {\n   |                        ^^^ expected\
    \ `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal, use\
    \ single quotes\n   |\n21 |             if note == 'o' {\n   |               \
    \         ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj9njo0b8.rs:29:31\n\
    \   |\n29 |             } else if note == \"|\" {\n   |                      \
    \         ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to write\
    \ a `char` literal, use single quotes\n   |\n29 |             } else if note ==\
    \ '|' {\n   |                               ~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpj9njo0b8.rs:37:31\n   |\n37 |             } else if note == \"\
    .\" {\n   |                               ^^^ expected `char`, found `&str`\n\
    \   |\nhelp: if you meant to write a `char` literal, use single quotes\n   |\n\
    37 |             } else if note == '.' {\n   |                               ~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpj9njo0b8.rs:45:31\n   |\n45 |\
    \             } else if note == \"o|\" {\n   |                               ^^^^\
    \ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj9njo0b8.rs:53:31\n\
    \   |\n53 |             } else if note == \".|\" {\n   |                     \
    \          ^^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpj9njo0b8.rs:70:28\n   |\n13 |     let mut current_note = String::new();\n\
    \   |                            --------"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    for c in music_string.chars()\
    \ {\n        if c.is_whitespace() {\n            continue;\n        }\n      \
    \  if c.is_ascii_digit() {\n            current_note.push(c);\n            current_note_length.push(c.to_string());\n\
    \        } else {\n            if current_note.is_empty() {\n                panic!(\"\
    Music string contains invalid note\");\n            }\n            if c.is_ascii_digit()\
    \ {\n                let note = current_note.chars().next().unwrap();\n      \
    \          let note_length = current_note_length.chars().next().unwrap();\n  \
    \              beats.push(note.parse().unwrap() * note_length.parse().unwrap());\n\
    \                current_note.clear();\n                current_note_length.clear();\n\
    \            } else {\n                panic!(\"Music string contains invalid\
    \ note\");\n            }\n        }\n    }\n    if current_note.is_empty() {\n\
    \        panic!(\"Music string contains invalid note\");\n    }\n    let note\
    \ = current_note.chars().next().unwrap();\n    let note_length = current_note_length.chars().next().unwrap();\n\
    \    beats.push(note.parse().unwrap() * note_length.parse().unwrap());\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa65okfa8.rs:21:38\n   |\n\
    21 |             current_note_length.push(c.to_string());\n   |              \
    \                        ^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0599]: no method named `parse` found for type `char` in the current scope\n\
    \  --> /tmp/tmpa65okfa8.rs:29:33\n   |\n29 |                 beats.push(note.parse().unwrap()\
    \ * note_length.parse().unwrap());\n   |                                 ^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `parse` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpa65okfa8.rs:29:64\n   |\n29\
    \ |                 beats.push(note.parse().unwrap() * note_length.parse().unwrap());\n\
    \   |                                                                ^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `parse` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpa65okfa8.rs:42:21\n   |\n42 |   \
    \  beats.push(note.parse().unwrap() * note_length.parse().unwrap());\n   |   \
    \                  ^^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `parse` found for type `char` in the current scope\n  --> /tmp/tmpa65okfa8.rs:42:52\n\
    \   |\n42 |     beats.push(note.parse().unwrap() * note_length.parse().unwrap());\n\
    \   |                                                    ^^^^^ method not found\
    \ in `char`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp1856e9ui.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_octave: isize = 0;\n    let mut current_note_is_last\
    \ = false;\n    let mut current_note_octave: isize = 0;\n    for c in music_string.chars()\
    \ {\n        if c == 'o' {\n            if current_note_is_last {\n          \
    \      beats.push(current_beat);\n            }\n            current_note_is_last\
    \ = true;\n            current_note = String::new();\n            current_octave\
    \ = 0;\n            current_note_is_last = false;\n            current_note_octave\
    \ = 0;\n            current_beat = 0;\n            current_beat += 1;\n      \
    \  } else if c == '|' {\n            if current_note_is_last {\n             \
    \   beats.push(current_beat);\n            }\n            current_note_is_last\
    \ = true;\n            current_note = String::new();\n            current_octave\
    \ = 0;\n            current_note_is_last = false;\n            current_note_octave\
    \ = 0;\n            current_beat = 0;\n            current_beat += 1;\n      \
    \  } else if c == '.' {\n            if current_note_is_last {\n             \
    \   beats.push(current_beat);\n            }\n            current_note_is_last\
    \ = true;\n            current_note = String::new();\n            current_octave\
    \ = 0;\n            current_note_is_last = false;\n            current_note_octave\
    \ = 0;\n            current_beat = 0;\n            current_beat += 1;\n      \
    \  } else {\n            if current_note_is_last {\n                beats.push(current_beat);\n\
    \            }\n            current_note_is_last = false;\n            current_note.push(c);\n\
    \            current_note_octave += 1;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmpwky848hv.rs:66:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    for c in music_string {\n        if c.is_ascii() {\n \
    \           if c == 'o' {\n                if current_note.is_empty() {\n    \
    \                current_note = String::from(\"o\");\n                    current_note_length\
    \ = String::from(\"o\");\n                } else {\n                    current_note\
    \ = String::from(current_note.clone());\n                    current_note_length\
    \ = String::from(current_note_length.clone());\n                }\n          \
    \      beats.push(current_beat);\n                current_beat = 0;\n        \
    \        current_note = String::new();\n                current_note_length =\
    \ String::new();\n            } else if c == '|' {\n                if current_note.is_empty()\
    \ {\n                    current_note = String::from(\"|\");\n               \
    \     current_note_length = String::from(\"|\");\n                } else {\n \
    \                   current_note = String::from(current_note.clone());\n     \
    \               current_note_length = String::from(current_note_length.clone());\n\
    \                }\n                beats.push(current_beat);\n              \
    \  current_beat = 0;\n                current_note = String::new();\n        \
    \        current_note_length = String::new();\n            } else if c == '.'\
    \ {\n                if current_note.is_empty() {\n                    current_note\
    \ = String::from(\".\");\n                    current_note_length = String::from(\"\
    .\");\n                } else {\n                    current_note = String::from(current_note.clone());\n\
    \                    current_note_length = String::from(current_note_length.clone());\n\
    \                }\n                beats.push(current_beat);\n              \
    \  current_beat = 0;\n                current_note = String::new();\n        \
    \        current_note_length = String::new();\n            } else {\n        \
    \        current_note = String::from(current_note.clone());\n                current_note_length\
    \ = String::from(current_note_length.clone());\n            }\n        } else\
    \ {\n            current_note = String::from(current_note.clone());\n        \
    \    current_note_length = String::from(current_note_length.clone());\n      \
    \  }\n        current_beat += 1;\n    }\n    beats.push(current_beat);\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpm98c9b3b.rs:16:14\n\
    \   |\n16 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let mut current_note_length_index46 = 1;\n    let mut current_note_length_index47\
    \ = 1;\n    let mut current_note_length_index48 = 1;\n\n}\n\nfn main() {\n   \
    \ let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3_wmrkhd.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = 0;\n    let mut current_beat = 0;\n    let mut current_note_count\
    \ = 0;\n    let mut current_beat_count = 0;\n    let mut current_note_length =\
    \ 0;\n    let mut current_beat_length = 0;\n    while current_note < notes.len()\
    \ {\n        let note = notes[current_note];\n        if note == \"o\" {\n   \
    \         if current_note_count == 0 {\n                beats.push(current_beat_count);\n\
    \                current_beat_count = 0;\n            }\n            current_note_length\
    \ += 1;\n            current_note_count += 1;\n            current_beat_length\
    \ += 1;\n            current_note += 1;\n        } else if note == \"o|\" {\n\
    \            if current_note_count == 0 {\n                beats.push(current_beat_count);\n\
    \                current_beat_count = 0;\n            }\n            current_note_length\
    \ += 1;\n            current_note_count += 1;\n            current_beat_length\
    \ += 1;\n            current_note += 1;\n        } else if note == \".|\" {\n\
    \            if current_note_count == 0 {\n                beats.push(current_beat_count);\n\
    \                current_beat_count = 0;\n            }\n            current_note_length\
    \ += 1;\n            current_note_count += 1;\n            current_beat_length\
    \ += 1;\n            current_note += 1;\n        } else {\n            assert!(current_note_count\
    \ == 0);\n            assert!(current_beat_count == 0);\n            assert!(current_note_length\
    \ == 0);\n            assert!(current_beat_length == 0);\n            assert!(current_note\
    \ == notes.len());\n            beats.push(current_beat_length);\n           \
    \ current_beat_length = 0;\n            current_beat_count = 0;\n            current_note_length\
    \ = 0;\n            current_note_count = 0;\n            current_note = 0;\n \
    \       }\n    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[4, 4, 4, 4]`', /tmp/tmp0djccwwt.rs:68:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate();\n    let mut current_note\
    \ = notes.next();\n    while let Some(note) = current_note {\n        let note\
    \ = note.0;\n        let note_index = note.to_string();\n        let note_index\
    \ = note_index.parse().unwrap();\n        let note = note_index as usize;\n  \
    \      let note = note as usize;\n        beats.push(note);\n        if note %\
    \ 4 == 0 {\n            beats.push(note - 4);\n        }\n        if note % 2\
    \ == 0 {\n            beats.push(note - 2);\n        }\n        if note == 0 {\n\
    \            beats.push(1);\n        }\n        current_note = notes.next();\n\
    \    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpasglqu7v.rs:32:5\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |              \
    \                           ---------- expected `Vec<isize>` because of return\
    \ type\n...\n32 |     beats\n   |     ^^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length_index48 = 0;\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj4kxmtfk.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_note = String::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_beats_length = 0;\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            if c.is_ascii(10) {\n            \
    \    // new note\n                if current_note.is_empty() {\n             \
    \       current_note = c.to_string();\n                } else {\n            \
    \        current_note = current_note + c.to_string();\n                }\n   \
    \         } else {\n                // new beat\n                if current_note.is_empty()\
    \ {\n                    current_beats_length = 1;\n                } else {\n\
    \                    current_beats_length += 1;\n                }\n         \
    \       if current_beat == 0 {\n                    beats.push(current_beats_length);\n\
    \                    current_beat = 1;\n                } else {\n           \
    \         beats.push(current_beats_length);\n                    current_beat\
    \ = 1;\n                }\n                current_note = String::new();\n   \
    \             current_beats_length = 0;\n            }\n        } else {\n   \
    \         if current_note.is_empty() {\n                // new note\n        \
    \        current_note = c.to_string();\n            } else {\n               \
    \ current_note = current_note + c.to_string();\n            }\n        }\n   \
    \ }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpjk4hcnj7.rs:17:18\n     |\n17   |             if c.is_ascii(10)\
    \ {\n     |                  ^^^^^^^^ -- supplied 1 argument\n     |         \
    \         |\n     |                  expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjk4hcnj7.rs:22:51\n\
    \   |\n22 |                     current_note = current_note + c.to_string();\n\
    \   |                                                   ^^^^^^^^^^^^^\n   |  \
    \                                                 |\n   |                    \
    \                               expected `&str`, found struct `String`\n   | \
    \                                                  help: consider borrowing here:\
    \ `&c.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjk4hcnj7.rs:46:47\n\
    \   |\n46 |                 current_note = current_note + c.to_string();\n   |\
    \                                               ^^^^^^^^^^^^^\n   |          \
    \                                     |\n   |                                \
    \               expected `&str`, found struct `String`\n   |                 \
    \                              help: consider borrowing here: `&c.to_string()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    for c in music_string.chars() {\n      \
    \  if c.is_ascii() {\n            if c.is_ascii(8) {\n                current_note\
    \ = c.to_ascii_lowercase();\n                current_note_len = c.len_utf8();\n\
    \            } else {\n                current_note = c.to_ascii_lowercase();\n\
    \                current_note_len = c.len_utf8();\n            }\n        } else\
    \ {\n            current_note = String::new();\n            current_note_len =\
    \ 0;\n        }\n        if current_note_len == 0 {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \          current_note_len = 0;\n        }\n        if c.is_ascii(8) {\n    \
    \        current_beat += 1;\n        } else {\n            current_beat += 1;\n\
    \        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp8tkyahiz.rs:17:18\n     |\n17   |             if c.is_ascii(8)\
    \ {\n     |                  ^^^^^^^^ - supplied 1 argument\n     |          \
    \        |\n     |                  expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8tkyahiz.rs:18:32\n\
    \   |\n13 |     let mut current_note = String::new();\n   |                  \
    \          ------------- expected due to this value\n...\n18 |               \
    \  current_note = c.to_ascii_lowercase();\n   |                              \
    \  ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                |\n   |                                expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8tkyahiz.rs:21:32\n\
    \   |\n13 |     let mut current_note = String::new();\n   |                  \
    \          ------------- expected due to this value\n...\n21 |               \
    \  current_note = c.to_ascii_lowercase();\n   |                              \
    \  ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                |\n   |                                expected\
    \ struct `String`, found `char`\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n    --> /tmp/tmp8tkyahiz.rs:34:14\n     |\n34 \
    \  |         if c.is_ascii(8) {\n     |              ^^^^^^^^ - supplied 1 argument\n\
    \     |              |\n     |              expected 0 arguments\n     |\nnote:\
    \ associated function defined here\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut last_note = notes.last().unwrap();\n    let mut last_beat = 0;\n\
    \    let mut last_beats: isize = 0;\n    let mut last_beats_len = 0;\n    while\
    \ notes.len() > 0 {\n        let note = notes.remove(0);\n        if note == last_note\
    \ {\n            last_beats_len += 1;\n        } else {\n            beats.push(last_beat);\n\
    \            last_beats_len = 1;\n            last_beat = 0;\n            last_note\
    \ = note;\n        }\n        last_beat += 1;\n    }\n    beats.push(last_beat);\n\
    \    last_beats_len += 1;\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpdltr5yg9.rs:19:17\n\
    \   |\n19 |         if note == last_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdltr5yg9.rs:25:25\n   |\n13 |     let mut last_note\
    \ = notes.last().unwrap();\n   |                         ---------------------\
    \ expected due to this value\n...\n25 |             last_note = note;\n   |  \
    \                       ^^^^ expected `&str`, found `str`\n   |\n   = note: expected\
    \ reference `&&str`\n              found reference `&str`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == 'o|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else {\n                current_note.push(c);\n            }\n\
    \        } else {\n            current_note.push(c);\n        }\n        if c.is_ascii()\
    \ {\n            current_beat += 1;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpjotydlqu.rs:20:52\n\
    \   |\n20 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkunjr83j.rs:62:32\n   |\n\
    62 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkunjr83j.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    for c in music_string.chars() {\n        if c == 'o' {\n         \
    \   if current_note == 0 {\n                beats.push(current_beat);\n      \
    \          current_beat = 0;\n                current_note = 1;\n            \
    \    current_note_length = 4;\n            } else {\n                current_note\
    \ += 1;\n                current_note_length += 4;\n            }\n        } else\
    \ if c == '|' {\n            if current_note == 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = 2;\n      \
    \          current_note_length = 2;\n            } else {\n                current_note\
    \ += 2;\n                current_note_length += 2;\n            }\n        } else\
    \ if c == ' ' {\n            if current_note == 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = 3;\n      \
    \          current_note_length = 1;\n            } else {\n                current_note\
    \ += 3;\n                current_note_length += 1;\n            }\n        } else\
    \ {\n            if current_note == 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = 0;\n      \
    \          current_note_length = 1;\n            } else {\n                current_note\
    \ += 1;\n                current_note_length += 1;\n            }\n        }\n\
    \        current_beat += 1;\n    }\n    beats.push(current_beat);\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmphl82utlx.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate();\n    let mut current_note\
    \ = notes.next();\n    let mut current_beat = 0;\n    while let Some(note) = current_note\
    \ {\n        note = note.1;\n        if note == 'o' {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = notes.next();\n   \
    \     } else if note == '|' {\n            beats.push(current_beat);\n       \
    \     current_beat += 1;\n            current_note = notes.next();\n        }\
    \ else {\n            current_beat += 1;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqb5j7jlv.rs:16:16\n   |\n\
    15 |     while let Some(note) = current_note {\n   |                    ---- expected\
    \ due to the type of this binding\n16 |         note = note.1;\n   |         \
    \       ^^^^^^ expected tuple, found `char`\n   |\n   = note: expected tuple `(usize,\
    \ char)`\n               found type `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqb5j7jlv.rs:17:20\n   |\n17 |         if note == 'o' {\n   |  \
    \                  ^^^ expected tuple, found `char`\n   |\n   = note: expected\
    \ tuple `(usize, char)`\n               found type `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqb5j7jlv.rs:21:27\n   |\n21 |         } else if note ==\
    \ '|' {\n   |                           ^^^ expected tuple, found `char`\n   |\n\
    \   = note: expected tuple `(usize, char)`\n               found type `char`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    for c in music_string.chars() {\n        if c.is_ascii()\
    \ {\n            if c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_length = String::new();\n                current_note_length\
    \ = String::new();\n            } else if c.to_ascii_lowercase() == 'o|' {\n \
    \               beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = String::new();\n                current_note_length = String::new();\n   \
    \         } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_length = String::new();\n                current_note_length\
    \ = String::new();\n            } else {\n                current_note.push(c);\n\
    \                current_note_length.push(c);\n            }\n        } else {\n\
    \            if current_note.is_empty() {\n                println!(\"Invalid\
    \ music string\");\n                return beats;\n            }\n           \
    \ if c.is_ascii() {\n                if c.to_ascii_lowercase() == 'o' {\n    \
    \                beats.push(current_beat);\n                    current_beat =\
    \ 0;\n                    current_note = String::new();\n                    current_note_length\
    \ = String::new();\n                    current_note_length = String::new();\n\
    \                } else if c.to_ascii_lowercase() == 'o|' {\n                \
    \    beats.push(current_beat);\n                    current_beat = 0;\n      \
    \              current_note = String::new();\n                    current_note_length\
    \ = String::new();\n                    current_note_length = String::new();\n\
    \                } else if c.to_ascii_lowercase() == '.|' {\n                \
    \    beats.push(current_beat);\n                    current_beat = 0;\n      \
    \              current_note = String::new();\n                    current_note_length\
    \ = String::new();\n                    current_note_length = String::new();\n\
    \                } else {\n                    current_note.push(c);\n       \
    \             current_note_length.push(c);\n                }\n            } else\
    \ {\n                if current_note.is_empty() {\n                    println!(\"\
    Invalid music string\");\n                    return beats;\n                }\n\
    \                if c.is_ascii() {\n                    if c.to_ascii_lowercase()\
    \ == 'o' {\n                        beats.push(current_beat);\n              \
    \          current_beat = 0;\n                        current_note = String::new();\n\
    \                        current_note_length = String::new();\n              \
    \          current_note_length = String::new();\n                    } else if\
    \ c.to_ascii_lowercase() == '\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmphl9rbc1o.rs:24:52\n\
    \   |\n24 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4\
    \ = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n\
    \    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let\
    \ mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut\
    \ current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13\
    \ = 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 =\
    \ 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n\
    \    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n  \
    \  let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let\
    \ mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut\
    \ current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26\
    \ = 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 =\
    \ 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n\
    \    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n  \
    \  let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let\
    \ mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut\
    \ current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39\
    \ = 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 =\
    \ 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n\
    \    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n  \
    \  let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let\
    \ mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut\
    \ current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52\
    \ = 0;\n    let mut current_note_oct53 = 0;\n    let mut current_note_\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyl45pi_p.rs:68:26\n   |\n\
    68 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n69 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyl45pi_p.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_len = 0;\n    let mut last_note = String::new();\n \
    \   let mut last_note_len = 0;\n    for c in music_string {\n        if c == 'o'\
    \ {\n            if current_note_len > 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_len = last_note_len;\n            }\n          \
    \  last_note = current_note;\n            last_note_len = current_note_len;\n\
    \            current_note_len = 0;\n        } else if c == '|' {\n           \
    \ if current_note_len > 0 {\n                beats.push(current_beat);\n     \
    \           current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_len = last_note_len;\n            }\n          \
    \  last_note = current_note;\n            last_note_len = current_note_len;\n\
    \            current_note_len = 0;\n        } else if c == '.' {\n           \
    \ if current_note_len > 0 {\n                beats.push(current_beat);\n     \
    \           current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_len = last_note_len;\n            }\n          \
    \  last_note = current_note;\n            last_note_len = current_note_len;\n\
    \            current_note_len = 0;\n        } else {\n            current_note.push(c);\n\
    \            current_note_len = current_note.len();\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpn7kv0qaz.rs:17:14\n\
    \   |\n17 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_hsnybli.rs:63:32\n   |\n\
    63 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_hsnybli.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let mut current_note_length_index46 = 1;\n    let mut current_note_length_index47\
    \ = 1;\n    let mut current_note_length_index48 = 1;\n\n}\n\nfn main() {\n   \
    \ let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3_wmrkhd.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    for c in music_string.chars() {\n      \
    \  if c.is_ascii() {\n            if c.is_ascii(8) {\n                current_note\
    \ = c.to_ascii_lowercase();\n                current_note_len = c.len_utf8();\n\
    \            } else {\n                current_note = c.to_ascii_lowercase();\n\
    \                current_note_len = c.len_utf8();\n            }\n        } else\
    \ {\n            current_note = String::new();\n            current_note_len =\
    \ 0;\n        }\n        if c.is_ascii(8) {\n            if c.is_ascii(9) {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_len\
    \ = 0;\n            } else {\n                current_beat += 1;\n           \
    \ }\n        } else {\n            current_beat = 0;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpf2q8jonl.rs:17:18\n     |\n17   |             if c.is_ascii(8)\
    \ {\n     |                  ^^^^^^^^ - supplied 1 argument\n     |          \
    \        |\n     |                  expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf2q8jonl.rs:18:32\n\
    \   |\n13 |     let mut current_note = String::new();\n   |                  \
    \          ------------- expected due to this value\n...\n18 |               \
    \  current_note = c.to_ascii_lowercase();\n   |                              \
    \  ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                |\n   |                                expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf2q8jonl.rs:21:32\n\
    \   |\n13 |     let mut current_note = String::new();\n   |                  \
    \          ------------- expected due to this value\n...\n21 |               \
    \  current_note = c.to_ascii_lowercase();\n   |                              \
    \  ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                |\n   |                                expected\
    \ struct `String`, found `char`\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n    --> /tmp/tmpf2q8jonl.rs:28:14\n     |\n28 \
    \  |         if c.is_ascii(8) {\n     |              ^^^^^^^^ - supplied 1 argument\n\
    \     |              |\n     |              expected 0 arguments\n     |\nnote:\
    \ associated function defined here\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n    --> /tmp/tmpf2q8jonl.rs:29:18\n     |\n29 \
    \  |             if c.is_ascii(9) {\n     |                  ^^^^^^^^ - supplied\
    \ 1 argument\n     |                  |\n     |                  expected 0 arguments\n\
    \     |\nnote: associated function defined here\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an erro"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, c)| c != '|').collect::<Vec<_>>();\n\
    \    let mut last_note = notes.len() - 1;\n    let mut last_beat = 0;\n    let\
    \ mut last_beats = 0;\n    notes.iter().for_each(|(_, note)| {\n        if note\
    \ == 'o' {\n            last_beat = 0;\n            last_beats = 1;\n        }\
    \ else if note == '|' {\n            last_beats = 1;\n        } else {\n     \
    \       last_beats += 1;\n        }\n        if last_note == 0 {\n           \
    \ beats.push(last_beats);\n            last_beats = 0;\n            last_note\
    \ = notes.len() - 1;\n        } else {\n            last_beats += last_beat;\n\
    \            last_beat = 0;\n        }\n    });\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpfs13e4yk.rs:12:72\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c != '|').collect::<Vec<_>>();\n   |                                       \
    \                                 ^^ no implementation for `&char == char`\n \
    \  |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpfs13e4yk.rs:17:17\n   |\n17 |   \
    \      if note == 'o' {\n   |                 ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpfs13e4yk.rs:20:24\n   |\n20\
    \ |         } else if note == '|' {\n   |                        ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate();\n    let mut last_note\
    \ = notes.next();\n    let mut last_beat = 0;\n    let mut last_beats = 4;\n \
    \   loop {\n        let note = notes.next();\n        if note.1 == last_note.1\
    \ {\n            last_beats += 1;\n        } else {\n            beats.push(last_beats);\n\
    \            last_beats = 1;\n            last_beats += 1;\n            last_beats\
    \ += 1;\n            last_beats += 1;\n            last_beats += 1;\n        \
    \    last_beats += 1;\n            last_beats += 1;\n            last_beats +=\
    \ 1;\n            last_beats += 1;\n            last_beats += 1;\n           \
    \ last_beats += 1;\n            last_beats += 1;\n            last_beats += 1;\n\
    \            last_beats += 1;\n            last_beats += 1;\n            last_beats\
    \ += 1;\n            last_beats += 1;\n            last_beats += 1;\n        \
    \    last_beats += 1;\n            last_beats += 1;\n            last_beats +=\
    \ 1;\n            last_beats += 1;\n            last_beats += 1;\n           \
    \ last_beats += 1;\n            last_beats += 1;\n            last_beats += 1;\n\
    \            last_beats += 1;\n            last_beats += 1;\n            last_beats\
    \ += 1;\n            last_beats += 1;\n            last_beats += 1;\n        \
    \    last_beats += 1;\n            last_beats += 1;\n            last_beats +=\
    \ 1;\n            last_beats += 1;\n            last_beats += 1;\n           \
    \ last_beats += 1;\n            last_beats += 1;\n            last_beats += 1;\n\
    \            last_beats += 1;\n            last_beats += 1;\n            last_beats\
    \ += 1;\n            last_beats += 1;\n            last_beats += 1;\n        \
    \    last_beats += 1;\n            last_beats += 1;\n            last_beats +=\
    \ 1;\n            last_beats += 1;\n            last_beats += 1;\n           \
    \ last_beats += 1;\n            last_beats += 1;\n            last_beats += 1;\n\
    \            last_beats += 1;\n            last_beats += 1;\n            last_beats\
    \ += 1;\n            last_beats += 1;\n            last_beats += 1;\n        \
    \    last_beats += 1;\n            last_beats += 1;\n            last_beats +=\
    \ 1;\n            last_beats += 1;\n            last_beats += 1;\n           \
    \ last_beats += 1;\n            last_beats += 1;\n            last_beats += 1;\n\
    \            last_beats += 1;\n            last_beats += 1;\n            last_beats\
    \ += 1;\n            last_beats += 1;\n            last_beats += 1;\n        \
    \    last_beats += 1;\n            last_beats += 1;\n            last_beats +=\
    \ 1;\n            last_beats += 1;\n            last_beats += 1;\n           \
    \ last_beats += 1;\n            last_beats += 1;\n            last_beats += 1;\n\
    \            last_beats += 1;\n            last_beats += 1;\n            last_beats\
    \ += 1;\n            last_beats += 1;\n            last_beats += 1;\n        \
    \    last_beats += 1;\n            last_beats += 1;\n            last_beats +=\
    \ 1;\n            last_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpcz6_z0_r.rs:118:3\n\
    \    |\n10  | fn parse_music(music_string: String) -> Vec<isize> {\n    |    \
    \                                                - unclosed delimiter\n...\n16\
    \  |     loop {\n    |          - unclosed delimiter\n...\n20  |         } else\
    \ {\n    |                - this delimiter might not be properly closed...\n...\n\
    109 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    118 | }\n    |   ^\n\nerror[E0425]: cannot find value `last_` in this scope\n\
    \   --> /tmp/tmpcz6_z0_r.rs:108:13\n    |\n108 |             last_\n    |    \
    \         ^^^^^ not found in this scope\n\nerror[E0609]: no field `1` on type\
    \ `Option<(usize, char)>`\n  --> /tmp/tmpcz6_z0_r.rs:18:17\n   |\n18 |       \
    \  if note.1 == last_note.1 {\n   |                 ^\n\nerror[E0609]: no field\
    \ `1` on type `Option<(usize, char)>`\n  --> /tmp/tmpcz6_z0_r.rs:18:32\n   |\n\
    18 |         if note.1 == last_note.1 {\n   |                                ^\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0609.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp1856e9ui.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, note)| note\
    \ != '|').collect::<Vec<_>>();\n    let mut current_beat = 0;\n    let mut current_note\
    \ = 0;\n    let mut current_note_length = 0;\n    for note in notes {\n      \
    \  if note.1 == '.' {\n            current_note_length += 1;\n        } else {\n\
    \            current_note_length += note.1;\n        }\n        if note.1 == '\
    \ ' {\n            current_note += 1;\n        } else {\n            current_note\
    \ += note.1;\n        }\n        if note.1 == ' ' {\n            current_beat\
    \ += 1;\n        } else {\n            current_beat += note.1;\n        }\n  \
    \      if note.1 == ' ' {\n            beats.push(current_beat);\n           \
    \ current_beat = 0;\n            current_note = 0;\n            current_note_length\
    \ = 0;\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmph_l7hiia.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != '|').collect::<Vec<_>>();\n   |                                    \
    \                                          ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: cannot\
    \ add-assign `char` to `{integer}`\n  --> /tmp/tmph_l7hiia.rs:20:33\n   |\n20\
    \ |             current_note_length += note.1;\n   |                         \
    \        ^^ no implementation for `{integer} += char`\n   |\n   = help: the trait\
    \ `AddAssign<char>` is not implemented for `{integer}`\n   = help: the following\
    \ other types implement trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n\
    \             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n    \
    \         <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n      \
    \       <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n         \
    \    <i16 as AddAssign>\n           and 20 others\n\nerror[E0277]: cannot add-assign\
    \ `char` to `{integer}`\n  --> /tmp/tmph_l7hiia.rs:25:26\n   |\n25 |         \
    \    current_note += note.1;\n   |                          ^^ no implementation\
    \ for `{integer} += char`\n   |\n   = help: the trait `AddAssign<char>` is not\
    \ implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror[E0277]: cannot add-assign `char` to `{integer}`\n\
    \  --> /tmp/tmph_l7hiia.rs:30:26\n   |\n30 |             current_beat += note.1;\n\
    \   |                          ^^ no implementation for `{integer} += char`\n\
    \   |\n   = help: the trait `AddAssign<char"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat: isize = 0;\n    let mut current_note\
    \ = String::new();\n    for c in music_string.chars() {\n        if c.is_ascii()\
    \ {\n            if c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == 'o|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else {\n                current_note += c.to_ascii_lowercase();\n\
    \            }\n        } else {\n            current_note += c.to_ascii_lowercase();\n\
    \        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpl1b739_j.rs:20:52\n\
    \   |\n20 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_octave = 0;\n    let mut current_note_is_octave = false;\n\
    \    let mut current_note_is_rest = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_rested\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_5qx0685.rs:62:35\n   |\n\
    62 |     let mut current_note_is_rested\n   |                                \
    \   ^ help: add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_5qx0685.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length_index48 = 0;\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj4kxmtfk.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate();\n    let mut current_note\
    \ = 0;\n    let mut current_beat = 0;\n    let mut last_note = -1;\n    let mut\
    \ last_beat = -1;\n    let mut last_note_is_half = false;\n    let mut last_note_is_quarter\
    \ = false;\n    let mut last_note_is_whole_note = false;\n    for note, index\
    \ in notes {\n        let note = note.unwrap();\n        if note == 'o' {\n  \
    \          if last_note == -1 {\n                last_note = current_note;\n \
    \               last_beat = current_beat;\n                last_note_is_half =\
    \ false;\n                last_note_is_quarter = false;\n                last_note_is_whole_note\
    \ = false;\n            } else {\n                if last_note == current_note\
    \ {\n                    last_beat = current_beat;\n                    last_note_is_half\
    \ = false;\n                    last_note_is_quarter = false;\n              \
    \      last_note_is_whole_note = false;\n                } else {\n          \
    \          if last_note == current_note + 1 {\n                        last_beat\
    \ = current_beat;\n                        last_note_is_half = true;\n       \
    \                 last_note_is_quarter = false;\n                        last_note_is_whole_note\
    \ = false;\n                    } else {\n                        if last_note\
    \ == current_note + 2 {\n                            last_beat = current_beat;\n\
    \                            last_note_is_half = true;\n                     \
    \       last_note_is_quarter = true;\n                            last_note_is_whole_note\
    \ = false;\n                        } else {\n                            if last_note\
    \ == current_note + 3 {\n                                last_beat = current_beat;\n\
    \                                last_note_is_half = true;\n                 \
    \               last_note_is_quarter = true;\n                               \
    \ last_note_is_whole_note = true;\n                            } else {\n    \
    \                            if last_note == current_note + 4 {\n            \
    \                        last_beat = current_beat;\n                         \
    \           last_note_is_half = true;\n                                    last_note_is_quarter\
    \ = true;\n                                    last_note_is_whole_note = true;\n\
    \                                } else {\n                                  \
    \  if last_note == current_note + 5 {\n                                      \
    \  last_beat = current_beat;\n                                        last_note_is_half\
    \ = true;\n                                        last_note_is_quarter = true;\n\
    \                                        last_note_is_whole_note = true;\n   \
    \                                 } else {\n                                 \
    \       if last_note == current_note + 6 {\n                                 \
    \           last_beat = current_beat;\n                                      \
    \      last_note_is_half = true;\n                                           \
    \ last_note_is_quarter = true;\n                                            last_note_is_whole_note\
    \ = true;\n                                        } else {\n                \
    \                            if last_note == current_note + 7 {\n            \
    \                                    last_beat = current_beat;\n             \
    \                                   last_note_is_half = true;\n              \
    \                                  last_note_is_quarter = true;\n            \
    \                                    last_note_is_whole_note = true;\n       \
    \                                     } else {\n                             \
    \                   if last_note == current_note + 8 {\n                     \
    \                               last_beat\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpz2cms226.rs:89:3\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |       \
    \                                             - unclosed delimiter\n...\n20 |\
    \     for note, index in notes {\n   |                              - unclosed\
    \ delimiter\n21 |         let note = note.unwrap();\n22 |         if note == 'o'\
    \ {\n   |                        - unclosed delimiter\n...\n29 |             }\
    \ else {\n   |                    - unclosed delimiter\n...\n35 |            \
    \     } else {\n   |                        - unclosed delimiter\n...\n41 |  \
    \                   } else {\n   |                            - unclosed delimiter\n\
    ...\n47 |                         } else {\n   |                             \
    \   - unclosed delimiter\n...\n53 |                             } else {\n   |\
    \                                    - unclosed delimiter\n...\n59 |         \
    \                        } else {\n   |                                      \
    \  - unclosed delimiter\n...\n65 |                                     } else\
    \ {\n   |                                            - unclosed delimiter\n...\n\
    71 |                                         } else {\n   |                  \
    \                              - unclosed delimiter\n...\n77 |               \
    \                              } else {\n   |                                \
    \                    - unclosed delimiter\n78 |                              \
    \                   if last_note == current_note + 8 {\n   |                 \
    \                                                                 - this delimiter\
    \ might not be properly closed...\n79 |                                      \
    \               last_beat\n80 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n89 | }\n   |   ^\n\nerror: unexpected `,` in pattern\n  -->\
    \ /tmp/tmpz2cms226.rs:20:13\n   |\n20 |     for note, index in notes {\n   | \
    \            ^\n   |\nhelp: try adding parentheses to match on a tuple\n   |\n\
    20 |     for (note, index) in notes {\n   |         +           +\n\nerror: aborting\
    \ due to "
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.first().unwrap();\n    let mut current_beat\
    \ = 0;\n    let mut current_note_count = 0;\n    let mut current_note_length =\
    \ 0;\n    while current_note != \".\" {\n        if current_note == \"o\" {\n\
    \            beats.push(current_beat);\n            current_beat = 0;\n      \
    \      current_note_count = 0;\n            current_note_length = 0;\n       \
    \     current_note = notes.next();\n        } else {\n            current_note_count\
    \ += 1;\n            current_note_length += 1;\n            current_beat = current_note_length\
    \ * 4;\n            current_note = notes.next();\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmpzo5y17rm.rs:17:24\n\
    \   |\n17 |     while current_note != \".\" {\n   |                        ^^\
    \ no implementation for `&str == str`\n   |\n   = help: the trait `PartialEq<str>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]: can't compare `&str`\
    \ with `str`\n  --> /tmp/tmpzo5y17rm.rs:18:25\n   |\n18 |         if current_note\
    \ == \"o\" {\n   |                         ^^ no implementation for `&str == str`\n\
    \   |\n   = help: the trait `PartialEq<str>` is not implemented for `&str`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0599]:\
    \ no method named `next` found for struct `Vec<&str>` in the current scope\n \
    \ --> /tmp/tmpzo5y17rm.rs:23:34\n   |\n23 |             current_note = notes.next();\n\
    \   |                                  ^^^^ method not found in `Vec<&str>`\n\n\
    error[E0599]: no method named `next` found for struct `Vec<&str>` in the current\
    \ scope\n  --> /tmp/tmpzo5y17rm.rs:28:34\n   |\n28 |             current_note\
    \ = notes.next();\n   |                    "
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat: isize = 0;\n    let mut current_note\
    \ = String::new();\n    let mut current_note_length: isize = 0;\n    for c in\
    \ music_string.chars() {\n        if c.is_ascii() {\n            if c.to_ascii_uppercase()\
    \ == 'O' {\n                if current_note_length == 0 {\n                  \
    \  current_note = c.to_ascii_lowercase();\n                    current_note_length\
    \ = 1;\n                } else {\n                    current_note_length += 1;\n\
    \                }\n            } else if c.to_ascii_uppercase() == '|' {\n  \
    \              if current_note_length == 0 {\n                    current_note\
    \ = c.to_ascii_lowercase();\n                    current_note_length = 1;\n  \
    \              } else {\n                    current_note_length += 1;\n     \
    \           }\n            } else if c.to_ascii_uppercase() == '.' {\n       \
    \         if current_note_length == 0 {\n                    current_note = c.to_ascii_lowercase();\n\
    \                    current_note_length = 1;\n                } else {\n    \
    \                current_note_length += 1;\n                }\n            } else\
    \ {\n                if current_note_length == 0 {\n                    current_note\
    \ = c.to_ascii_lowercase();\n                    current_note_length = 1;\n  \
    \              } else {\n                    current_note_length += 1;\n     \
    \           }\n            }\n        } else {\n            if current_note_length\
    \ == 0 {\n                current_note = c.to_ascii_lowercase();\n           \
    \     current_note_length = 1;\n            } else {\n                current_note_length\
    \ += 1;\n            }\n        }\n    }\n    beats.push(current_beat);\n    current_beat\
    \ = 0;\n    current_note.clear();\n    current_note_length = 0;\n    for c in\
    \ music_string.chars() {\n        if c.is_ascii() {\n            if c.to_ascii_uppercase()\
    \ == 'O' {\n                if current_note_length == 0 {\n                  \
    \  current_note = c.to_ascii_lowercase();\n                    current_note_length\
    \ = 1;\n                } else {\n                    current_note_length += 1;\n\
    \                }\n            } else if c.to_ascii_uppercase() == '|' {\n  \
    \              if current_note_length == 0 {\n                    current_note\
    \ = c.to_ascii_lowercase();\n                    current_note_length = 1;\n  \
    \              } else {\n                    current_note_length += 1;\n     \
    \           }\n            } else if c.to_ascii_uppercase() == '.' {\n       \
    \         if current_note_length == 0 {\n                    current_note = c.to_ascii_lowercase();\n\
    \                    current_note_length = 1;\n                } else {\n    \
    \                current_note_length += 1;\n                }\n            } else\
    \ {\n                if current_note_length == 0 {\n                    current_note\
    \ = c.to_ascii_lowercase();\n                    current_note_length = 1;\n  \
    \              } else {\n                    current_note_length += 1;\n     \
    \           }\n            }\n        } else {\n            if current_note_length\
    \ == 0 {\n                current_note = c.to_ascii_lowercase();\n           \
    \     current_note_length = 1;\n            } else {\n                current_note_length\
    \ += 1;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpfze4v5ek.rs:105:3\n\
    \    |\n10  | fn parse_music(music_string: String) -> Vec<isize> {\n    |    \
    \                                                - unclosed delimiter\n...\n59\
    \  |     for c in music_string.chars() {\n    |                              \
    \     - unclosed delimiter\n...\n90  |         } else {\n    |               \
    \ - unclosed delimiter\n...\n94  |             } else {\n    |               \
    \     - this delimiter might not be properly closed...\n95  |                \
    \ current_note_length += 1;\n96  | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n105 | }\n    |   ^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfze4v5ek.rs:19:36\n   |\n13 |     let mut current_note = String::new();\n\
    \   |                            ------------- expected due to this value\n...\n\
    19 |                     current_note = c.to_ascii_lowercase();\n   |        \
    \                            ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                    |\n   |    \
    \                                expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfze4v5ek.rs:26:36\n   |\n13 |     let mut current_note\
    \ = String::new();\n   |                            ------------- expected due\
    \ to this value\n...\n26 |                     current_note = c.to_ascii_lowercase();\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                                  \
    \  |\n   |                                    expected struct `String`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfze4v5ek.rs:33:36\n\
    \   |\n13 |     let mut current_note = String::new();\n   |                  \
    \          ------------- expected due to this value\n...\n33 |               \
    \      current_note = c.to_ascii_lowercase();\n   |                          \
    \          ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                    |"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_octave = 0;\n    let mut current_note_is_octave = false;\n\
    \    for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c.to_ascii_lowercase() == 'o' {\n                if current_note_is_octave {\n\
    \                    current_octave += 1;\n                } else {\n        \
    \            current_octave = 0;\n                    current_note_is_octave =\
    \ true;\n                }\n            }\n            if c.to_ascii_lowercase()\
    \ == '|' {\n                if current_note_is_octave {\n                    current_octave\
    \ += 1;\n                } else {\n                    current_octave = 0;\n \
    \                   current_note_is_octave = true;\n                }\n      \
    \      }\n            if c.to_ascii_lowercase() == '.' {\n                if current_note_is_octave\
    \ {\n                    current_octave += 1;\n                } else {\n    \
    \                current_octave = 0;\n                    current_note_is_octave\
    \ = true;\n                }\n            }\n            if c.to_ascii_lowercase()\
    \ == 'o' {\n                current_note += c.to_ascii_lowercase();\n        \
    \    } else {\n                current_note += c.to_ascii_lowercase();\n     \
    \       }\n        } else {\n            current_note += c.to_ascii_lowercase();\n\
    \        }\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() ==\
    \ 'o' {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n                current_octave\
    \ = 0;\n                current_note_is_octave = false;\n            }\n     \
    \       if c.to_ascii_lowercase() == '|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_octave = 0;\n                current_note_is_octave =\
    \ false;\n            }\n            if c.to_ascii_lowercase() == '.' {\n    \
    \            beats.push(current_beat);\n                current_beat = 0;\n  \
    \              current_note = String::new();\n                current_octave =\
    \ 0;\n                current_note_is_octave = false;\n            }\n       \
    \     if c.to_ascii_lowercase() == 'o' {\n                current_note += c.to_ascii_lowercase();\n\
    \            } else {\n                current_note += c.to_ascii_lowercase();\n\
    \            }\n        } else {\n            current_note += c.to_ascii_lowercase();\n\
    \        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe2_t2htc.rs:43:33\n   |\n\
    43 |                 current_note += c.to_ascii_lowercase();\n   |           \
    \                      ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpe2_t2htc.rs:45:33\n   |\n45 |  \
    \               current_note += c.to_ascii_lowercase();\n   |                \
    \                 ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe2_t2htc.rs:48:29\n   |\n48 |             current_note\
    \ += c.to_ascii_lowercase();\n   |                             ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe2_t2htc.rs:73:33\n\
    \   |\n73 |                 current_note += c.to_ascii_lowercase();\n   |    \
    \                             ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe2_t2htc.rs:75:33\n   |\n75 |\
    \                 current_note += c.to_ascii_lowercase();\n   |              \
    \                   ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe2_t2htc.rs:78:29\n   |\n78 |             current_note\
    \ += c.to_ascii_lowercase();\n   |                             ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror: aborting due to 6 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut last_note = String::from(\"\");\n    let mut last_beat = 0;\n   \
    \ let mut last_beats: isize = 0;\n    let mut last_beats_length = 0;\n    let\
    \ mut last_beats_lengths: Vec<isize> = vec![];\n    let mut last_beats_lengths_length\
    \ = 0;\n    let mut last_beats_lengths_lengths: Vec<isize> = vec![];\n    let\
    \ mut last_beats_lengths_lengths_length = 0;\n    let mut last_beats_lengths_lengths_lengths:\
    \ Vec<isize> = vec![];\n    let mut last_beats_lengths_lengths_lengths_length\
    \ = 0;\n    let mut last_beats_lengths_lengths_lengths_lengths: Vec<isize> = vec![];\n\
    \    let mut last_beats_lengths_lengths_lengths_lengths_length = 0;\n    let mut\
    \ last_beats_lengths_lengths_lengths_lengths_lengths: Vec<isize> = vec![];\n \
    \   let mut last_beats_lengths_lengths_lengths_lengths_lengths_length = 0;\n \
    \   let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths: Vec<isize>\
    \ = vec![];\n    let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths_length\
    \ = 0;\n    let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths_lengths:\
    \ Vec<isize> = vec![];\n    let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length\
    \ = 0;\n    let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths:\
    \ Vec<isize> = vec![];\n    let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length\
    \ = 0;\n    let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths:\
    \ Vec<isize> = vec![];\n    let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_length\
    \ = 0;\n    let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths:\
    \ Vec<isize> = vec\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpivvxmrn9.rs:35:129\n   |\n\
    35 |     let mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths:\
    \ Vec<isize> = vec\n   |                                                     \
    \                                                                            ^\
    \ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0423]: expected\
    \ value, found macro `vec`\n  --> /tmp/tmpivvxmrn9.rs:35:126\n   |\n35 |     let\
    \ mut last_beats_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths_lengths:\
    \ Vec<isize> = vec\n   |                                                     \
    \                                                                         ^^^\
    \ not a value\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpivvxmrn9.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0423.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = 0;\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length_index48 = 0;\n\n}\n\nfn main() {\n   \
    \ let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprpkquni5.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|&(_, note)| note\
    \ != 'o').collect::<Vec<_>>();\n    let mut current_note = 0;\n    let mut current_beat\
    \ = 0;\n    let mut current_length = 0;\n    for note in notes {\n        let\
    \ note = note.0;\n        let length = note.len();\n        if note == 'o' {\n\
    \            beats.push(current_beat);\n            current_beat += 4;\n     \
    \       current_length += 4;\n        } else if note == 'o|' {\n            beats.push(current_beat);\n\
    \            current_beat += 2;\n            current_length += 2;\n        } else\
    \ if note == '.|' {\n            beats.push(current_beat);\n            current_beat\
    \ += 1;\n            current_length += 1;\n        } else {\n            beats.push(current_beat);\n\
    \            current_beat += 1;\n            current_length += 1;\n        }\n\
    \        if current_length == length {\n            current_note = note;\n   \
    \         current_length = 0;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpspydm009.rs:23:30\n\
    \   |\n23 |         } else if note == 'o|' {\n   |                           \
    \   ^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length_index48 = 0;\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj4kxmtfk.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4\
    \ = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n\
    \    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let\
    \ mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut\
    \ current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13\
    \ = 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 =\
    \ 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n\
    \    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n  \
    \  let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let\
    \ mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut\
    \ current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26\
    \ = 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 =\
    \ 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n\
    \    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n  \
    \  let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let\
    \ mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut\
    \ current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39\
    \ = 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 =\
    \ 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n\
    \    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n  \
    \  let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let\
    \ mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut\
    \ current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52\
    \ = 0;\n    let mut current_note_oct53 = 0;\n    let mut current_note_\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyl45pi_p.rs:68:26\n   |\n\
    68 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n69 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyl45pi_p.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_index = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_length_index = 0;\n    let mut current_note_length_value\
    \ = 0;\n    let mut current_note_length_value_index = 0;\n    let mut current_note_length_value_value\
    \ = 0;\n    let mut current_note_length_value_value_index = 0;\n    let mut current_note_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx2wryinz.rs:55:56\n   |\n\
    55 |     let mut current_note_length_value_value_value_value\n   |           \
    \                                             ^ help: add `;` here\n56 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx2wryinz.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    for c in music_string {\n        if c == 'o' {\n            if current_note_length_index\
    \ == 0 {\n                current_note += c;\n                current_note_length\
    \ += 1;\n            } else {\n                beats.push(current_beat);\n   \
    \             current_beat += 1;\n                current_note += c;\n       \
    \         current_note_length += 1;\n            }\n        } else if c == '|'\
    \ {\n            if current_note_length_index == 0 {\n                current_note\
    \ += c;\n                current_note_length += 1;\n            } else {\n   \
    \             beats.push(current_beat);\n                current_beat += 1;\n\
    \                current_note += c;\n                current_note_length += 1;\n\
    \            }\n        } else if c == '.' {\n            if current_note_length_index\
    \ == 0 {\n                current_note += c;\n                current_note_length\
    \ += 1;\n            } else {\n                beats.push(current_beat);\n   \
    \             current_beat += 1;\n                current_note += c;\n       \
    \         current_note_length += 1;\n            }\n        } else {\n       \
    \     current_note += c;\n            current_note_length += 1;\n        }\n \
    \       current_note_length_index += 1;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpnic7cs4x.rs:16:14\n\
    \   |\n16 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ can't compare `&str` with `char`\n  --> /tmp/tmpnic7cs4x.rs:17:14\n   |\n17\
    \ |         if c == 'o' {\n   |              ^^ no implementation for `&str ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpnic7cs4x.rs:27:21\n   |\n27 |         } else\
    \ if c == '|' {\n   |                     ^^ no implementation for `&str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpnic7cs4x.rs:37:21\n   |\n37 |         } else\
    \ if c == '.' {\n   |                     ^^ no implementation for `&str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the follow"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    for c in music_string.chars() {\n      \
    \  if c.is_ascii() {\n            if c == 'o' {\n                if current_note_len\
    \ == 0 {\n                    current_note_len = 4;\n                    current_note\
    \ = String::from(\"o\");\n                } else {\n                    current_note_len\
    \ += 1;\n                }\n            } else if c == '|' {\n               \
    \ if current_note_len == 0 {\n                    current_note_len = 2;\n    \
    \                current_note = String::from(\"|\");\n                } else {\n\
    \                    current_note_len += 1;\n                }\n            }\
    \ else if c == '.' {\n                if current_note_len == 0 {\n           \
    \         current_note_len = 1;\n                    current_note = String::from(\"\
    .\");\n                } else {\n                    current_note_len = current_note_len\
    \ - 1;\n                }\n            } else {\n                println!(\"Unknown\
    \ music symbol: {}\", c);\n            }\n        } else {\n            println!(\"\
    Music symbol {} is not ASCII\", c);\n        }\n        if current_note_len >\
    \ 0 {\n            beats.push(current_beat);\n            current_beat = 0;\n\
    \            current_note_len = 0;\n            current_note = String::new();\n\
    \        }\n        current_beat += 1;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmpi4e_qm7h.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, c)| c != '|');\n\
    \    let mut last_note = notes.next();\n    for note in notes {\n        let mut\
    \ beat = 0;\n        if note.1 == last_note.1 {\n            beat = note.0;\n\
    \        }\n        beats.push(beat);\n        last_note = note;\n    }\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzj9eo3vt.rs:12:72\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c != '|');\n   |                                                           \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0609]: no field `1` on type `Option<(usize,\
    \ char)>`\n  --> /tmp/tmpzj9eo3vt.rs:16:32\n   |\n16 |         if note.1 == last_note.1\
    \ {\n   |                                ^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzj9eo3vt.rs:20:21\n   |\n13 |     let mut last_note = notes.next();\n\
    \   |                         ------------ expected due to this value\n...\n20\
    \ |         last_note = note;\n   |                     ^^^^ expected enum `Option`,\
    \ found tuple\n   |\n   = note: expected enum `Option<(usize, char)>`\n      \
    \       found tuple `(usize, char)`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n20 |         last_note = Some(note);\n   |                     +++++  \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzj9eo3vt.rs:22:5\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |              \
    \                           ---------- expected `Vec<isize>` because of return\
    \ type\n...\n22 |     beats\n   |     ^^^^^ expected `isize`, found `usize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0609.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut last_note = String::new();\n   \
    \ let mut last_note_len = 0;\n    let mut last_note_len_len = 0;\n    let mut\
    \ last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new();\n    let mut last_note_len = String::new();\n\
    \    let mut last_note_len = String::new\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpc6kuwup7.rs:58:40\n   |\n\
    58 |     let mut last_note_len = String::new\n   |                           \
    \             ^ help: add `;` here\n59 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc6kuwup7.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_octave: isize = 0;\n    for c in music_string.chars()\
    \ {\n        if c == 'o' {\n            if current_note.len() == 0 {\n       \
    \         println!(\"Music string contains invalid note!\");\n               \
    \ return beats;\n            }\n            beats.push(current_beat);\n      \
    \      current_beat = 0;\n            current_note = String::new();\n        \
    \    current_octave = 0;\n        } else if c == '|' {\n            if current_note.len()\
    \ == 0 {\n                println!(\"Music string contains invalid note!\");\n\
    \                return beats;\n            }\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \          current_octave = 0;\n        } else if c == '.' {\n            if current_note.len()\
    \ == 0 {\n                println!(\"Music string contains invalid note!\");\n\
    \                return beats;\n            }\n            current_beat = 0;\n\
    \            current_note = String::new();\n            current_octave = 0;\n\
    \        } else {\n            if current_note.len() == 0 {\n                current_note.push(c);\n\
    \            } else {\n                current_note.push(c);\n               \
    \ current_beat = current_beat + 1;\n            }\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmplug6hj3v.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().collect::<Vec<_>>();\n    let mut current_note\
    \ = 0;\n    let mut current_beat = 0;\n    let mut current_note_length = 0;\n\
    \    let mut current_beat_length = 0;\n    let mut current_note_is_last = false;\n\
    \    let mut current_beat_is_last = false;\n    while notes.len() > 0 {\n    \
    \    let note = notes.remove(0);\n        match note {\n            'o' => current_note_is_last\
    \ = true;\n            current_note += 1;\n            current_note_length +=\
    \ 1;\n            current_beat_length += 1;\n            current_beat_is_last\
    \ = false;\n            beats.push(current_beat);\n            current_beat =\
    \ 0;\n            current_note_is_last = false;\n            current_beat_is_last\
    \ = false;\n            current_note_length = 0;\n            current_beat_length\
    \ = 0;\n            current_note = 0;\n            _ => current_note += 1,\n \
    \       }\n    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: `match` arm body without braces\n  --> /tmp/tmpogolt4b9.rs:22:20\n\
    \   |\n22 |               'o' => current_note_is_last = true;\n   |  _________________--_^\n\
    \   | |                 |\n   | |                 while parsing the `match` arm\
    \ starting here\n23 | |             current_note += 1;\n24 | |             current_note_length\
    \ += 1;\n25 | |             current_beat_length += 1;\n...  |\n32 | |        \
    \     current_beat_length = 0;\n33 | |             current_note = 0;\n   | |_____________________________^\
    \ these statements are not surrounded by a body\n   |\nhelp: surround the statements\
    \ with a body\n   |\n22 ~             'o' => { current_note_is_last = true;\n\
    23 |             current_note += 1;\n24 |             current_note_length += 1;\n\
    25 |             current_beat_length += 1;\n26 |             current_beat_is_last\
    \ = false;\n27 |             beats.push(current_beat);\n ...\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == 'o|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else {\n                current_note.push(c);\n            }\n\
    \        } else {\n            if current_note.is_empty() {\n                continue;\n\
    \            }\n            let note = current_note.chars().collect::<String>().parse().unwrap();\n\
    \            beats.push(note as isize);\n            current_beat = 0;\n     \
    \       current_note = String::new();\n        }\n    }\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpg6lslf19.rs:20:52\n\
    \   |\n20 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4\
    \ = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n\
    \    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let\
    \ mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut\
    \ current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13\
    \ = 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 =\
    \ 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n\
    \    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n  \
    \  let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let\
    \ mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut\
    \ current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26\
    \ = 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 =\
    \ 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n\
    \    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n  \
    \  let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let\
    \ mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut\
    \ current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39\
    \ = 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 =\
    \ 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n\
    \    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n  \
    \  let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let\
    \ mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut\
    \ current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52\
    \ = 0;\n    let mut current_note_oct53 = 0;\n    let mut current_note_\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyl45pi_p.rs:68:26\n   |\n\
    68 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n69 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyl45pi_p.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, note)| note\
    \ != 'o');\n    let mut current_note = 0;\n    let mut current_beat = 0;\n   \
    \ for note in notes {\n        if note == current_note {\n            current_beat\
    \ += 1;\n        } else {\n            beats.push(current_beat);\n           \
    \ current_beat = 1;\n            current_note = note;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpsgce3rmp.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != 'o');\n   |                                                        \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpsgce3rmp.rs:16:20\n   |\n16 |         if note == current_note {\n  \
    \ |                    ^^^^^^^^^^^^ expected tuple, found integer\n   |\n   =\
    \ note: expected tuple `(usize, char)`\n               found type `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsgce3rmp.rs:21:28\n   |\n13 |\
    \     let mut current_note = 0;\n   |                            - expected due\
    \ to this value\n...\n21 |             current_note = note;\n   |            \
    \                ^^^^ expected integer, found tuple\n   |\n   = note: expected\
    \ type `{integer}`\n             found tuple `(usize, char)`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat: isize = 0;\n    let mut current_note\
    \ = String::new();\n    let mut current_note_len = 0;\n    let mut current_note_oct\
    \ = 0;\n    let mut current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n\
    \    let mut current_note_oct4 = 0;\n    let mut current_note_oct5 = 0;\n    let\
    \ mut current_note_oct6 = 0;\n    let mut current_note_oct7 = 0;\n    let mut\
    \ current_note_oct8 = 0;\n    let mut current_note_oct9 = 0;\n    let mut current_note_oct10\
    \ = 0;\n    let mut current_note_oct11 = 0;\n    let mut current_note_oct12 =\
    \ 0;\n    let mut current_note_oct13 = 0;\n    let mut current_note_oct14 = 0;\n\
    \    let mut current_note_oct15 = 0;\n    let mut current_note_oct16 = 0;\n  \
    \  let mut current_note_oct17 = 0;\n    let mut current_note_oct18 = 0;\n    let\
    \ mut current_note_oct19 = 0;\n    let mut current_note_oct20 = 0;\n    let mut\
    \ current_note_oct21 = 0;\n    let mut current_note_oct22 = 0;\n    let mut current_note_oct23\
    \ = 0;\n    let mut current_note_oct24 = 0;\n    let mut current_note_oct25 =\
    \ 0;\n    let mut current_note_oct26 = 0;\n    let mut current_note_oct27 = 0;\n\
    \    let mut current_note_oct28 = 0;\n    let mut current_note_oct29 = 0;\n  \
    \  let mut current_note_oct30 = 0;\n    let mut current_note_oct31 = 0;\n    let\
    \ mut current_note_oct32 = 0;\n    let mut current_note_oct33 = 0;\n    let mut\
    \ current_note_oct34 = 0;\n    let mut current_note_oct35 = 0;\n    let mut current_note_oct36\
    \ = 0;\n    let mut current_note_oct37 = 0;\n    let mut current_note_oct38 =\
    \ 0;\n    let mut current_note_oct39 = 0;\n    let mut current_note_oct40 = 0;\n\
    \    let mut current_note_oct41 = 0;\n    let mut current_note_oct42 = 0;\n  \
    \  let mut current_note_oct43 = 0;\n    let mut current_note_oct44 = 0;\n    let\
    \ mut current_note_oct45 = 0;\n    let mut current_note_oct46 = 0;\n    let mut\
    \ current_note_oct47 = 0;\n    let mut current_note_oct48 = 0;\n    let mut current_note_oct49\
    \ = 0;\n    let mut current_note_oct50 = 0;\n    let mut current_note_oct51 =\
    \ 0;\n    let mut current_note_oct52 = 0;\n    let mut current_\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpw4ruytlv.rs:67:21\n   |\n\
    67 |     let mut current_\n   |                     ^ help: add `;` here\n68 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw4ruytlv.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    for c in music_string {\n        if c == 'o' {\n            if current_note\
    \ == 0 {\n                current_note = 1;\n                current_beat += 1;\n\
    \            }\n            else {\n                current_note += 1;\n     \
    \       }\n        }\n        else if c == '|' {\n            if current_note\
    \ == 0 {\n                current_note = 2;\n                current_beat += 2;\n\
    \            }\n            else {\n                current_note += 2;\n     \
    \       }\n        }\n        else if c == '.' {\n            if current_note\
    \ == 0 {\n                current_note = 4;\n                current_beat += 4;\n\
    \            }\n            else {\n                current_note += 4;\n     \
    \       }\n        }\n        else {\n            if current_note == 0 {\n   \
    \             current_note = 1;\n                current_beat += 1;\n        \
    \    }\n            else {\n                current_note += 1;\n            }\n\
    \        }\n        if current_note == 4 {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = 0;\n            current_note_length\
    \ = 0;\n        }\n        current_note_length += 1;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp7aptrc94.rs:15:14\n\
    \   |\n15 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length_index48 = 0;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphyjd3prq.rs:63:11\n   |\n\
    63 |     let mu\n   |           ^ help: add `;` here\n64 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphyjd3prq.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp1856e9ui.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate();\n    let mut current_note\
    \ = 0;\n    let mut current_beat = 0;\n    let mut current_note_index = 0;\n \
    \   let mut current_beat_length = 0;\n    let mut current_note_length = 0;\n \
    \   let mut current_note_char = 0;\n    let mut current_note_char_index = 0;\n\
    \    let mut current_note_char_length = 0;\n    let mut current_note_char_char\
    \ = 0;\n    let mut current_note_char_char_index = 0;\n    let mut current_note_char_char_length\
    \ = 0;\n    let mut current_note_char_char_char = 0;\n    let mut current_note_char_char_char_index\
    \ = 0;\n    let mut current_note_char_char_char_length = 0;\n    let mut current_note_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_index = 0;\n    let mut current_note_char_char_char_char_length\
    \ = 0;\n    let mut current_note_char_char_char_char_char = 0;\n    let mut current_note_char_char_char_char_char_index\
    \ = 0;\n    let mut current_note_char_char_char_char_char_length = 0;\n    let\
    \ mut current_note_char_char_char_char_char_char = 0;\n    let mut current_note_char_char_char_char_char_char_index\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_length = 0;\n \
    \   let mut current_note_char_char_char_char_char_char_char = 0;\n    let mut\
    \ current_note_char_char_char_char_char_char_char_index = 0;\n    let mut current_note_char_char_char_char_char_char_char_length\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char = 0;\n\
    \    let mut current_note_char_char_char_char_char_char_char_char_index = 0;\n\
    \    let mut current_note_char_char_char_char_char_char_char_char_length = 0;\n\
    \    let mut current_note_char_char_char_char_char_char_char_char_char = 0;\n\
    \    let mut current_note_char_char_char_char_char_char_char_char_char_index =\
    \ 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_length\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_index\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_length\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_index\
    \ = 0;\n    let mut current_note_char_char_char_char_char_char_char_char_char_char_char_length\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp3n4qrtti.rs:52:1\n  \
    \ |\n52 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    for c in music_string {\n        if c == 'o' {\n            beats.push(current_beat);\n\
    \            current_beat += 1;\n            current_note = 0;\n            current_note_length\
    \ = 0;\n        } else if c == '|' {\n            beats.push(current_beat);\n\
    \            current_beat += 1;\n            current_note = 1;\n            current_note_length\
    \ = 0;\n        } else if c == '.' {\n            beats.push(current_beat);\n\
    \            current_beat += 1;\n            current_note = 2;\n            current_note_length\
    \ = 0;\n        } else {\n            current_note += 1;\n            current_note_length\
    \ += 1;\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp12oahx1b.rs:15:14\n\
    \   |\n15 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, note)| note\
    \ != 'o');\n    for note in notes {\n        let mut beat = 0;\n        let mut\
    \ note = note.unwrap();\n        note.chars().for_each(|c| {\n            if c\
    \ == '|' {\n                beat += 1;\n            }\n        });\n        beats.push(beat);\n\
    \    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpm3yl7gqx.rs:12:78\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, note)|\
    \ note != 'o');\n   |                                                        \
    \                      ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0599]: no method named `unwrap`\
    \ found for tuple `(usize, char)` in the current scope\n  --> /tmp/tmpm3yl7gqx.rs:15:29\n\
    \   |\n15 |         let mut note = note.unwrap();\n   |                      \
    \       ^^^^^^ method not found in `(usize, char)`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4\
    \ = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n\
    \    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let\
    \ mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut\
    \ current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13\
    \ = 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 =\
    \ 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n\
    \    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n  \
    \  let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let\
    \ mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut\
    \ current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26\
    \ = 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 =\
    \ 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n\
    \    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n  \
    \  let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let\
    \ mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut\
    \ current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39\
    \ = 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 =\
    \ 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n\
    \    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n  \
    \  let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let\
    \ mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut\
    \ current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52\
    \ = 0;\n    let mut current_note_oct53 = 0;\n    let mut current_note_\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyl45pi_p.rs:68:26\n   |\n\
    68 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n69 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyl45pi_p.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = 0;\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    let mut current_note_length_value = 0;\n    let mut current_note_length_value_length\
    \ = 0;\n    let mut current_note_length_value_length_index = 0;\n    let mut current_note_length_value_length_value\
    \ = 0;\n    let mut current_note_length_value_length_value_index = 0;\n    let\
    \ mut current_note_length_value_length_value_value = 0;\n    let mut current_note_length_value_length_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value = 0;\n    let mut current_note_length_value_length_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value = 0;\n    let mut current_note_length_value_length_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value = 0;\n    let mut current_note_length_value_length_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value = 0;\n    let mut current_note_length_value_length_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value = 0;\n    let mut current_note_length_value_length_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value = 0;\n    let mut current_note_length_value_length_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value = 0;\n    let mut current_note_length_value_length_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value = 0;\n    let mut current_note_length_value_length_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value = 0;\n    let mut current_note_length_value_length_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value = 0;\n    let mut current_note_length_value_length_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value = 0;\n    let mut current_note_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp67v1l1al.rs:55:26\n   |\n\
    55 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n56 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp67v1l1al.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|&(_, note)| note\
    \ != '|');\n    let mut current_note = 0;\n    let mut current_beat = 0;\n   \
    \ for note in notes {\n        let note = note.1;\n        let beat = note.parse::<isize>().unwrap();\n\
    \        beats.push(beat);\n        if note == 'o' {\n            current_note\
    \ += 1;\n            current_beat = 0;\n        } else {\n            current_note\
    \ -= 1;\n            current_beat += 1;\n        }\n    }\n    beats\n}\n\nfn\
    \ main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `parse` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpn92v08qr.rs:17:25\n   |\n17 |         let beat = note.parse::<isize>().unwrap();\n\
    \   |                         ^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.first().unwrap();\n    let mut current_beat\
    \ = 0;\n    let mut current_note_count = 0;\n    while current_note != \".\" {\n\
    \        if current_note == \"o\" {\n            beats.push(current_beat);\n \
    \           current_beat = 0;\n            current_note_count += 1;\n        }\n\
    \        if current_note == \"|\" {\n            beats.push(current_beat);\n \
    \           current_beat = 0;\n            current_note_count += 1;\n        }\n\
    \        if current_note == \".\" {\n            beats.push(current_beat);\n \
    \           current_beat = 0;\n            current_note_count += 1;\n        }\n\
    \        current_note += notes.next()?;\n        current_beat++;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpdqd7nfn5.rs:33:21\n\
    \   |\n33 |         current_beat++;\n   |                     ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n33 |         { let tmp = current_beat;\
    \ current_beat += 1; tmp };\n   |         +++++++++++             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    33 -         current_beat++;\n33 +         current_beat += 1;\n   | \n\nerror[E0277]:\
    \ can't compare `&str` with `str`\n  --> /tmp/tmpdqd7nfn5.rs:16:24\n   |\n16 |\
    \     while current_note != \".\" {\n   |                        ^^ no implementation\
    \ for `&str == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]:\
    \ can't compare `&str` with `str`\n  --> /tmp/tmpdqd7nfn5.rs:17:25\n   |\n17 |\
    \         if current_note == \"o\" {\n   |                         ^^ no implementation\
    \ for `&str == str`\n   |\n   = help: the trait `PartialEq<str>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]:\
    \ can't compare `&str` with"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    for c in music_string.chars() {\n        match c {\n            'o'\
    \ => {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note++;\n                current_note_length =\
    \ 0;\n            }\n            'o|' => {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note++;\n        \
    \        current_note_length = 1;\n            }\n            '.|' => {\n    \
    \            beats.push(current_beat);\n                current_beat = 0;\n  \
    \              current_note++;\n                current_note_length = 2;\n   \
    \         }\n            _ => {\n                current_beat += 1;\n        \
    \        current_note_length += 1;\n            }\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp5hpk4q95.rs:23:16\n\
    \   |\n23 |             'o|' => {\n   |                ^^^^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == 'o|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else {\n                current_note += c.to_ascii_lowercase();\n\
    \            }\n        } else {\n            current_note += c.to_ascii_lowercase();\n\
    \        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpyf2qeh6h.rs:20:52\n\
    \   |\n20 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_note_length: isize = 0;\n    for c in music_string\
    \ {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = 0;\n            } else if c.to_ascii_lowercase() == 'o|' {\n             \
    \   beats.push(current_beat);\n                current_beat = 0;\n           \
    \     current_note = String::new();\n                current_note_length = 1;\n\
    \            } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_length = 2;\n            } else {\n            \
    \    let mut note = c.to_ascii_lowercase();\n                note.push(0);\n \
    \               current_note.push_str(note);\n                current_note_length\
    \ += 1;\n            }\n        } else {\n            if current_note.is_empty()\
    \ {\n                println!(\"Invalid music string\");\n                return\
    \ beats;\n            }\n            let note = current_note.clone();\n      \
    \      let note_length = current_note_length;\n            current_note = String::new();\n\
    \            current_note_length = 0;\n            beats.push(current_beat + note_length);\n\
    \            current_beat += note_length;\n            current_note.push_str(note);\n\
    \        }\n    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpiz1_okr_.rs:22:52\n\
    \   |\n22 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length_index48 = 0;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphyjd3prq.rs:63:11\n   |\n\
    63 |     let mu\n   |           ^ help: add `;` here\n64 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphyjd3prq.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_octave: isize = 0;\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                if current_note != String::new() {\n                    beats.push(current_beat);\n\
    \                    current_beat = 0;\n                    current_note = String::new();\n\
    \                }\n                current_octave = 0;\n            } else if\
    \ c.to_ascii_lowercase() == 'o|' {\n                if current_note != String::new()\
    \ {\n                    beats.push(current_beat);\n                    current_beat\
    \ = 0;\n                    current_note = String::new();\n                }\n\
    \                current_octave = 1;\n            } else if c.to_ascii_lowercase()\
    \ == '.|' {\n                if current_note != String::new() {\n            \
    \        beats.push(current_beat);\n                    current_beat = 0;\n  \
    \                  current_note = String::new();\n                }\n        \
    \        current_octave = 2;\n            } else {\n                panic!(\"\
    Unknown note in music string: {}\", c);\n            }\n        } else {\n   \
    \         current_note.push(c);\n        }\n        current_beat += 1;\n    }\n\
    \    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpw_lnr_z5.rs:24:52\n\
    \   |\n24 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkunjr83j.rs:62:32\n   |\n\
    62 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkunjr83j.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.last().unwrap();\n    let mut current_beat =\
    \ 0;\n    let mut current_length = 0;\n    for note in notes {\n        if note\
    \ == current_note {\n            current_beat += 1;\n            current_length\
    \ += 1;\n        } else {\n            beats.push(current_beat);\n           \
    \ current_beat = 1;\n            current_length = 1;\n            current_note\
    \ = note;\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn\
    \ main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpzqb_ck0y.rs:17:17\n\
    \   |\n17 |         if note == current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzqb_ck0y.rs:24:28\n   |\n13 |     let mut current_note\
    \ = notes.last().unwrap();\n   |                            ---------------------\
    \ expected due to this value\n...\n24 |             current_note = note;\n   |\
    \                            ^^^^ expected `&str`, found `str`\n   |\n   = note:\
    \ expected reference `&&str`\n              found reference `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let\
    \ mut current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut\
    \ current_note_oct4 = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6\
    \ = 0;\n    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n\
    \    let mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n   \
    \ let mut current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let\
    \ mut current_note_oct13 = 0;\n    let mut current_note_oct14 = 0;\n    let mut\
    \ current_note_oct15 = 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17\
    \ = 0;\n    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 =\
    \ 0;\n    let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n\
    \    let mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n  \
    \  let mut current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let\
    \ mut current_note_oct26 = 0;\n    let mut current_note_oct27 = 0;\n    let mut\
    \ current_note_oct28 = 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30\
    \ = 0;\n    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 =\
    \ 0;\n    let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n\
    \    let mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n  \
    \  let mut current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let\
    \ mut current_note_oct39 = 0;\n    let mut current_note_oct40 = 0;\n    let mut\
    \ current_note_oct41 = 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43\
    \ = 0;\n    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 =\
    \ 0;\n    let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n\
    \    let mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n  \
    \  let mut current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let\
    \ mut current_note_oct52 = 0;\n    let mut current_note_oct53 = 0;\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplmcr2siv.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, c)| c != '|');\n\
    \    for note in notes {\n        let note = note.0;\n        let beat = note.parse::<isize>().unwrap();\n\
    \        beats.push(beat);\n    }\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplwysie7_.rs:12:72\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c != '|');\n   |                                                           \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0599]: no method named `parse` found for\
    \ type `usize` in the current scope\n  --> /tmp/tmplwysie7_.rs:15:25\n   |\n15\
    \ |         let beat = note.parse::<isize>().unwrap();\n   |                 \
    \        ^^^^^ method not found in `usize`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    for c in music_string.chars() {\n \
    \       if c.is_ascii() {\n            if c.is_ascii(8) {\n                current_note\
    \ = c.to_ascii_lowercase();\n                current_note_length = 1;\n      \
    \      } else {\n                current_note += c.to_ascii_lowercase();\n   \
    \             current_note_length += 1\n            }\n        } else {\n    \
    \        if current_note.is_empty() {\n                println!(\"Invalid music\
    \ string\");\n                return beats;\n            }\n            if c.is_ascii(8)\
    \ {\n                beats.push(current_beat + current_note_length);\n       \
    \         current_note = String::new();\n                current_note_length =\
    \ 0;\n                current_beat += 1;\n            } else {\n             \
    \   current_note += c.to_ascii_lowercase();\n                current_note_length\
    \ += 1\n            }\n        }\n    }\n    if current_note.is_empty() {\n  \
    \      println!(\"Invalid music string\");\n        return beats;\n    }\n   \
    \ beats.push(current_beat + current_note_length);\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp020vflkg.rs:17:18\n     |\n17   |             if c.is_ascii(8)\
    \ {\n     |                  ^^^^^^^^ - supplied 1 argument\n     |          \
    \        |\n     |                  expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp020vflkg.rs:18:32\n\
    \   |\n13 |     let mut current_note = String::new();\n   |                  \
    \          ------------- expected due to this value\n...\n18 |               \
    \  current_note = c.to_ascii_lowercase();\n   |                              \
    \  ^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                |\n   |                                expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp020vflkg.rs:21:33\n\
    \   |\n21 |                 current_note += c.to_ascii_lowercase();\n   |    \
    \                             ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp020vflkg.rs:29:18\n     |\n29   |             if c.is_ascii(8)\
    \ {\n     |                  ^^^^^^^^ - supplied 1 argument\n     |          \
    \        |\n     |                  expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp020vflkg.rs:35:33\n\
    \   |\n35 |                 current_note += c.to_ascii_lowercase();\n   |    \
    \                             ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_octave = 0;\n    let mut current_note_is_octave = false;\n\
    \    let mut current_note_is_rest = false;\n    let mut current_note_is_rested\
    \ = false;\n    let mut current_note_is_resting = false;\n    let mut current_note_is_resting_octave\
    \ = 0;\n    let mut current_note_is_resting_note = String::new();\n    let mut\
    \ current_note_is_resting_octave_is_octave = false;\n    let mut current_note_is_resting_octave_is_rest\
    \ = false;\n    let mut current_note_is_resting_octave_is_rested = false;\n  \
    \  let mut current_note_is_resting_octave_is_resting = false;\n    let mut current_note_is_resting_note_is_octave\
    \ = false;\n    let mut current_note_is_resting_note_is_rest = false;\n    let\
    \ mut current_note_is_resting_note_is_rested = false;\n    let mut current_note_is_resting_note_is_resting\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_octave = 0;\n\
    \    let mut current_note_is_resting_note_is_resting_note = String::new();\n \
    \   let mut current_note_is_resting_note_is_resting_octave_is_octave = false;\n\
    \    let mut current_note_is_resting_note_is_resting_octave_is_rest = false;\n\
    \    let mut current_note_is_resting_note_is_resting_octave_is_rested = false;\n\
    \    let mut current_note_is_resting_note_is_resting_octave_is_resting = false;\n\
    \    let mut current_note_is_resting_note_is_resting_note_is_octave = false;\n\
    \    let mut current_note_is_resting_note_is_resting_note_is_rest = false;\n \
    \   let mut current_note_is_resting_note_is_resting_note_is_rested = false;\n\
    \    let mut current_note_is_resting_note_is_resting_note_is_resting = false;\n\
    \    let mut current_note_is_resting_note_is_resting_note_is_resting_octave =\
    \ 0;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_note\
    \ = String::new();\n    let mut current_note_is_resting_note_is_resting_note_is_resting_octave_is_octave\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_octave_is_rest\
    \ = false;\n    let mut current_note_is_resting_note_is_resting_note_is_resting_octave_is_rested\
    \ = false;\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_dvkvwjt.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    for c in music_string {\n        if c == 'o' {\n            if current_note\
    \ != \"\" {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n            }\n       \
    \     current_note_length = 0;\n            current_note_length_index = 0;\n \
    \           current_note.push_str(&c);\n        } else if c == '|' {\n       \
    \     if current_note != \"\" {\n                beats.push(current_beat);\n \
    \               current_beat = 0;\n                current_note = String::new();\n\
    \            }\n            current_note_length += 1;\n            current_note_length_index\
    \ += 1;\n            current_note.push_str(&c);\n        } else if c == '.' {\n\
    \            if current_note != \"\" {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            }\n            current_note_length += 1;\n            current_note_length_index\
    \ += 1;\n            current_note.push_str(&c);\n        } else {\n          \
    \  current_beat += 1;\n            current_note.push_str(&c);\n        }\n   \
    \ }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2pwak51y.rs:16:14\n\
    \   |\n16 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmp2pwak51y.rs:16:9\n   |\n16 |     for c in music_string {\n   |     \
    \    ^ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp2pwak51y.rs:16:14\n    |\n16  |     for c in music_string {\n    | \
    \             ^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n\
    \    = help: the trait `Sized` is not implemented for `str`\nnote: required by\
    \ a bound in `Option`\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n   --> /tmp/tmp2pwak51y.rs:16:5\n    |\n16  |\
    \ /     for c in music_string {\n17  | |         if c == 'o' {\n18  | |      \
    \       if current_note != \"\" {\n19  | |                 beats.push(current_beat);\n\
    ...   |\n47  | |         }\n48  | |     }\n    | |_____^ doesn't have a size known\
    \ at compile-time\n    |\n    = help: the trait `Sized` is not implemented for\
    \ `str`\nnote: required by a bound in `None`\n\nerror[E0277]: can't compare `str`\
    \ with `char`\n  --> /tmp/tmp2pwak51y.rs:17:14\n   |\n17 |         if c == 'o'\
    \ {\n   |              ^^ no implementation for `str == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().skip(1).collect::<Vec<_>>();\n\
    \    let mut current_note = 0;\n    let mut current_beat = 0;\n    for note in\
    \ notes {\n        if note.1.is_ascii() {\n            let note = note.1.to_ascii_lowercase();\n\
    \            if note == \"o\" {\n                beats.push(current_beat);\n \
    \               current_beat = 0;\n            } else if note == \"o|\" {\n  \
    \              beats.push(current_beat);\n                current_beat = 0;\n\
    \            } else if note == \".|\" {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n            } else {\n                let\
    \ beat = note.parse().unwrap();\n                beats.push(beat);\n         \
    \       current_beat += beat;\n            }\n        } else {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp33rj3wrw.rs:18:24\n   |\n\
    18 |             if note == \"o\" {\n   |                        ^^^ expected\
    \ `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal, use\
    \ single quotes\n   |\n18 |             if note == 'o' {\n   |               \
    \         ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp33rj3wrw.rs:21:31\n\
    \   |\n21 |             } else if note == \"o|\" {\n   |                     \
    \          ^^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp33rj3wrw.rs:24:31\n   |\n24 |             } else if note == \"\
    .|\" {\n   |                               ^^^^ expected `char`, found `&str`\n\
    \nerror[E0599]: no method named `parse` found for type `char` in the current scope\n\
    \  --> /tmp/tmp33rj3wrw.rs:28:33\n   |\n28 |                 let beat = note.parse().unwrap();\n\
    \   |                                 ^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.split_whitespace();\n    let mut current_note\
    \ = notes.next().unwrap();\n    for note in notes {\n        if note == \"o\"\
    \ {\n            beats.push(4);\n            current_note = note;\n        } else\
    \ if note == \"o|\" {\n            beats.push(2);\n            current_note =\
    \ note;\n        } else if note == \".|\" {\n            beats.push(1);\n    \
    \        current_note = note;\n        } else {\n            beats.push(0);\n\
    \        }\n    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp9bm4zacq.rs:13:41

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_octave = 0;\n    let mut current_note_is_octave = false;\n\
    \    for c in music_string.chars() {\n        match c {\n            'o' | 'o|'\
    \ => current_note_is_octave = true,\n            '.' | '|' => current_note_is_octave\
    \ = false,\n            c => {\n                if current_note_is_octave {\n\
    \                    current_octave += 1;\n                } else {\n        \
    \            current_note += c;\n                }\n            }\n        }\n\
    \        if current_note == \".\" {\n            beats.push(current_beat);\n \
    \           current_beat = 0;\n            current_note = String::new();\n   \
    \         current_octave = 0;\n            current_note_is_octave = false;\n \
    \       }\n        current_beat += 1;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp8jjk37hz.rs:18:22\n\
    \   |\n18 |             'o' | 'o|' => current_note_is_octave = true,\n   |   \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_hsnybli.rs:63:32\n   |\n\
    63 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_hsnybli.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&'static str> = vec![];\n    let mut last_note\
    \ = String::new();\n    let mut last_beat = 0;\n    let mut last_beats: isize\
    \ = 0;\n    let mut last_beats_str: String = String::new();\n    let mut last_beats_str_index\
    \ = 0;\n    let mut last_beats_str_index2 = 0;\n    let mut last_beats_str_index3\
    \ = 0;\n    let mut last_beats_str_index4 = 0;\n    let mut last_beats_str_index5\
    \ = 0;\n    let mut last_beats_str_index6 = 0;\n    let mut last_beats_str_index7\
    \ = 0;\n    let mut last_beats_str_index8 = 0;\n    let mut last_beats_str_index9\
    \ = 0;\n    let mut last_beats_str_index10 = 0;\n    let mut last_beats_str_index11\
    \ = 0;\n    let mut last_beats_str_index12 = 0;\n    let mut last_beats_str_index13\
    \ = 0;\n    let mut last_beats_str_index14 = 0;\n    let mut last_beats_str_index15\
    \ = 0;\n    let mut last_beats_str_index16 = 0;\n    let mut last_beats_str_index17\
    \ = 0;\n    let mut last_beats_str_index18 = 0;\n    let mut last_beats_str_index19\
    \ = 0;\n    let mut last_beats_str_index20 = 0;\n    let mut last_beats_str_index21\
    \ = 0;\n    let mut last_beats_str_index22 = 0;\n    let mut last_beats_str_index23\
    \ = 0;\n    let mut last_beats_str_index24 = 0;\n    let mut last_beats_str_index25\
    \ = 0;\n    let mut last_beats_str_index26 = 0;\n    let mut last_beats_str_index27\
    \ = 0;\n    let mut last_beats_str_index28 = 0;\n    let mut last_beats_str_index29\
    \ = 0;\n    let mut last_beats_str_index30 = 0;\n    let mut last_beats_str_index31\
    \ = 0;\n    let mut last_beats_str_index32 = 0;\n    let mut last_beats_str_index33\
    \ = 0;\n    let mut last_beats_str_index34 = 0;\n    let mut last_beats_str_index35\
    \ = 0;\n    let mut last_beats_str_index36 = 0;\n    let mut last_beats_str_index37\
    \ = 0;\n    let mut last_beats_str_index38 = 0;\n    let mut last_beats_str_index39\
    \ = 0;\n    let mut last_beats_str_index40 = 0;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp5thk8ceh.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4\
    \ = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n\
    \    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let\
    \ mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut\
    \ current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13\
    \ = 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 =\
    \ 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n\
    \    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n  \
    \  let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let\
    \ mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut\
    \ current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26\
    \ = 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 =\
    \ 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n\
    \    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n  \
    \  let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let\
    \ mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut\
    \ current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39\
    \ = 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 =\
    \ 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n\
    \    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n  \
    \  let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let\
    \ mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut\
    \ current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52\
    \ = 0;\n    let mut current_note_oct53 = 0;\n    let mut current_note_\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyl45pi_p.rs:68:26\n   |\n\
    68 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n69 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyl45pi_p.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_note_length = 0;\n    let mut current_note_length_index\
    \ = 0;\n    for c in music_string.chars() {\n        if c.is_ascii() {\n     \
    \       if c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_length = 0;\n                current_note_length_index\
    \ = 0;\n            } else if c.to_ascii_lowercase() == 'o|' {\n             \
    \   beats.push(current_beat);\n                current_beat = 0;\n           \
    \     current_note = String::new();\n                current_note_length = 2;\n\
    \                current_note_length_index = 0;\n            } else if c.to_ascii_lowercase()\
    \ == '.|' {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n                current_note_length\
    \ = 1;\n                current_note_length_index = 0;\n            } else {\n\
    \                current_note.push(c);\n                current_note_length +=\
    \ 1;\n            }\n        } else {\n            if current_note_length_index\
    \ == 0 {\n                current_note.push(c);\n                current_note_length\
    \ += 1;\n            } else {\n                beats.push(current_beat);\n   \
    \             current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_length = 0;\n                current_note_length_index\
    \ = 0;\n            }\n        }\n        current_note_length_index += 1;\n  \
    \  }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpll52f7je.rs:24:52\n\
    \   |\n24 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_length = 0;\n                current_note_length_index\
    \ = 0;\n            } else if c.to_ascii_lowercase() == 'o|' {\n             \
    \   beats.push(current_beat);\n                current_beat = 0;\n           \
    \     current_note = String::new();\n                current_note_length = 2;\n\
    \                current_note_length_index = 0;\n            } else if c.to_ascii_lowercase()\
    \ == '.|' {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n                current_note_length\
    \ = 1;\n                current_note_length_index = 0;\n            } else {\n\
    \                current_note.push(c);\n                current_note_length +=\
    \ 1;\n            }\n        } else {\n            if current_note_length_index\
    \ == 0 {\n                current_note_length_index = 1;\n            } else {\n\
    \                current_note_length_index += 1;\n            }\n        }\n \
    \   }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmptivsa_vh.rs:24:52\n\
    \   |\n24 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, note)| note\
    \ != '|').collect::<Vec<_>>();\n    let mut current_note = 0;\n    let mut current_beat\
    \ = 0;\n    for note in notes {\n        if note == 'o' {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note++;\n        } else if\
    \ note == 'o|' {\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note += 2;\n        } else if note == '.|' {\n   \
    \         beats.push(current_beat);\n            current_beat = 0;\n         \
    \   current_note++;\n        } else {\n            current_beat += 1;\n      \
    \  }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpjg48g69e.rs:20:30\n\
    \   |\n20 |         } else if note == 'o|' {\n   |                           \
    \   ^^^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_to_beat:\
    \ Vec<isize> = vec![];\n    let mut current_note_length_to_beat_counter = 0;\n\
    \    let mut current_note_length_to_beat_counter_to_beat: Vec<isize> = vec![];\n\
    \    let mut current_note_length_to_beat_counter_to_beat_counter = 0;\n    let\
    \ mut current_note_length_to_beat_counter_to_beat_counter_to_beat: Vec<isize>\
    \ = vec![];\n    let mut current_note_length_to_beat_counter_to_beat_counter_to_beat_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_to_beat_counter_to_beat_counter_to_beat:\
    \ Vec<isize> = vec![];\n    let mut current_note_length_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter\
    \ = 0;\n    let mut current_note_length_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter_to_beat:\
    \ Vec<isize> = vec![];\n    let mut current_note_length_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter:\
    \ Vec<isize> = vec![];\n    let mut current_note_length_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter_to_beat:\
    \ Vec<isize> = vec![];\n    let mut current_note_length_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter:\
    \ Vec<isize> = vec![];\n    let mut current_note_length_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter_to_beat:\
    \ Vec<isize> = vec![];\n    let mut current_note_length_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter:\
    \ Vec<isize> = vec![];\n    let mut current_note_length_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter_to_beat_counter:\
    \ Vec<isize> = vec![];\n    let mut current_note_length_to_beat_counter\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpc0u24_l6.rs:30:48\n   |\n\
    30 |     let mut current_note_length_to_beat_counter\n   |                   \
    \                             ^ help: add `;` here\n31 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc0u24_l6.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_hsnybli.rs:63:32\n   |\n\
    63 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_hsnybli.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate();\n    let mut current_note\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_beats\
    \ = 0;\n    let mut last_beats_after_note = 0;\n    let mut last_beats_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_note = 0;\n    let mut last_beats_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp31mzqg_0.rs:36:118\n   |\n\
    36 |     let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\n\
    \   |                                                                        \
    \                                              ^ help: add `;` here\n37 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp31mzqg_0.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_octlen = 0;\n    let mut current_note_octoct = 0;\n    let mut\
    \ current_note_octoctlen = 0;\n    let mut current_note_octoctlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen = 0;\n    let\
    \ mut current_note_octlen = 0;\n    let mut current_note_octlen\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmptc8o6p79.rs:67:32\n   |\n\
    67 |     let mut current_note_octlen\n   |                                ^ help:\
    \ add `;` here\n68 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptc8o6p79.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    for c in music_string.chars() {\n        match c {\n            'o'\
    \ => current_note += 1,\n            'o|' => current_note += 2,\n            '.|'\
    \ => current_note += 4,\n            '.|' => current_note += 1,\n            _\
    \ => (),\n        }\n        if current_note == 4 {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = 0;\n            current_note_length\
    \ = 0;\n        }\n        current_beat += 1;\n        current_note_length +=\
    \ 1;\n    }\n    beats.push(current_beat);\n    current_beat = 0;\n    current_note\
    \ = 0;\n    current_note_length = 0;\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpxfxgg50h.rs:18:16\n\
    \   |\n18 |             'o|' => current_note += 2,\n   |                ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_note = String::new();\n    let mut current_beat\
    \ = 0;\n    let mut current_beats_length = 0;\n\n    for c in music_string {\n\
    \        if c == 'o' {\n            if current_note.is_empty() {\n           \
    \     println!(\"Invalid music string\");\n                return beats;\n   \
    \         }\n            beats.push(current_beats_length);\n            current_beats_length\
    \ = 0;\n            current_note = String::new();\n            current_beat =\
    \ 0;\n        } else if c == '|' {\n            if current_note.is_empty() {\n\
    \                println!(\"Invalid music string\");\n                return beats;\n\
    \            }\n            current_beats_length += 1;\n            current_note.push(c);\n\
    \        } else if c == '.' {\n            if current_note.is_empty() {\n    \
    \            println!(\"Invalid music string\");\n                return beats;\n\
    \            }\n            current_beats_length += 1;\n            current_note.push(c);\n\
    \        } else {\n            current_note.push(c);\n        }\n        current_beat\
    \ += 1;\n    }\n    beats.push(current_beats_length);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmperov658i.rs:16:14\n\
    \   |\n16 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4\
    \ = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n\
    \    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let\
    \ mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut\
    \ current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13\
    \ = 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 =\
    \ 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n\
    \    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n  \
    \  let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let\
    \ mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut\
    \ current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26\
    \ = 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 =\
    \ 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n\
    \    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n  \
    \  let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let\
    \ mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut\
    \ current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39\
    \ = 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 =\
    \ 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n\
    \    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n  \
    \  let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let\
    \ mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut\
    \ current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52\
    \ = 0;\n    let mut current_note_oct53 = 0;\n    let mut current_note_\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyl45pi_p.rs:68:26\n   |\n\
    68 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n69 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyl45pi_p.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, c)| c != '|');\n\
    \    let mut last_note = notes.next();\n    for note in notes {\n        if note.1\
    \ == last_note.1 {\n            beats.push(note.1 - last_note.1);\n        } else\
    \ {\n            beats.push(0);\n        }\n        last_note = note;\n    }\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzp2153ce.rs:12:72\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c != '|');\n   |                                                           \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0609]: no field `1` on type `Option<(usize,\
    \ char)>`\n  --> /tmp/tmpzp2153ce.rs:15:32\n   |\n15 |         if note.1 == last_note.1\
    \ {\n   |                                ^\n\nerror[E0609]: no field `1` on type\
    \ `Option<(usize, char)>`\n  --> /tmp/tmpzp2153ce.rs:16:43\n   |\n16 |       \
    \      beats.push(note.1 - last_note.1);\n   |                               \
    \            ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzp2153ce.rs:20:21\n\
    \   |\n13 |     let mut last_note = notes.next();\n   |                      \
    \   ------------ expected due to this value\n...\n20 |         last_note = note;\n\
    \   |                     ^^^^ expected enum `Option`, found tuple\n   |\n   =\
    \ note: expected enum `Option<(usize, char)>`\n             found tuple `(usize,\
    \ char)`\nhelp: try wrapping the expression in `Some`\n   |\n20 |         last_note\
    \ = Some(note);\n   |                     +++++    +\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0609.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.iter().next().unwrap();\n    let mut current_beat\
    \ = 0;\n    let mut current_note_count = 0;\n    for note in notes {\n       \
    \ if note != current_note {\n            beats.push(current_beat);\n         \
    \   current_note_count = 1;\n            current_note = note;\n            current_beat\
    \ = 0;\n        } else {\n            current_note_count += 1;\n            current_beat\
    \ += 1;\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpt2nilbv4.rs:17:17\n\
    \   |\n17 |         if note != current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt2nilbv4.rs:20:28\n   |\n13 |     let mut current_note\
    \ = notes.iter().next().unwrap();\n   |                            ----------------------------\
    \ expected due to this value\n...\n20 |             current_note = note;\n   |\
    \                            ^^^^ expected `&str`, found `str`\n   |\n   = note:\
    \ expected reference `&&str`\n              found reference `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp1856e9ui.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaf_v5be6.rs:63:26\n   |\n\
    63 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpaf_v5be6.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    for c in music_string {\n        if c.is_ascii() {\n            current_note\
    \ += c;\n        } else {\n            if current_note.len() > 0 {\n         \
    \       beats.push(current_beat);\n                current_beat = 0;\n       \
    \         current_note = String::new();\n            }\n            current_note\
    \ += c;\n        }\n        if c.is_ascii() || c.is_whitespace() {\n         \
    \   current_note_length += 1;\n            if current_note_length_index == current_note_length\
    \ {\n                current_note_length_index = 0;\n            }\n        }\
    \ else {\n            current_note_length_index += 1;\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmprglrgmqt.rs:16:14\n\
    \   |\n16 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == 'o|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else {\n                current_note += c.to_ascii_lowercase();\n\
    \            }\n        } else {\n            current_note += c.to_ascii_lowercase();\n\
    \        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpyf2qeh6h.rs:20:52\n\
    \   |\n20 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_hsnybli.rs:63:32\n   |\n\
    63 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_hsnybli.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat: isize = 0;\n    let mut current_note\
    \ = String::new();\n    let mut current_note_length: isize = 0;\n    let mut current_note_length_index:\
    \ usize = 0;\n    for c in music_string.chars() {\n        if c.is_ascii() {\n\
    \            current_note += c.to_string();\n            current_note_length +=\
    \ 1;\n            if current_note_length_index == 0 {\n                current_note_length_index\
    \ = 1;\n            } else {\n                current_note_length_index += 1;\n\
    \            }\n        } else {\n            if current_note != \"\" {\n    \
    \            beats.push(current_beat);\n                current_beat = 0;\n  \
    \              current_note = String::new();\n                current_note_length\
    \ = 0;\n                current_note_length_index = 0;\n            }\n      \
    \  }\n    }\n    beats.push(current_beat);\n    current_beat = 0;\n    current_note\
    \ = String::new();\n    current_note_length = 0;\n    current_note_length_index\
    \ = 0;\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpstpyhyj9.rs:18:29\n   |\n\
    18 |             current_note += c.to_string();\n   |                        \
    \     ^^^^^^^^^^^^^\n   |                             |\n   |                \
    \             expected `&str`, found struct `String`\n   |                   \
    \          help: consider borrowing here: `&c.to_string()`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    for c in music_string.chars() {\n   \
    \     if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n    \
    \            beats.push(current_beat);\n                current_beat = 0;\n  \
    \              current_note = String::new();\n                current_note_length\
    \ = 0;\n            } else if c.to_ascii_lowercase() == 'o|' {\n             \
    \   beats.push(current_beat);\n                current_beat = 0;\n           \
    \     current_note = String::new();\n                current_note_length = 1;\n\
    \            } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_length = 2;\n            } else {\n            \
    \    current_note.push(c);\n                current_note_length += 1;\n      \
    \      }\n        } else {\n            if current_note.is_empty() {\n       \
    \         println!(\"Invalid music string\");\n                return beats;\n\
    \            }\n            let note = current_note.chars().collect::<String>().parse().unwrap();\n\
    \            beats.push(current_beat + note);\n            current_beat = 0;\n\
    \            current_note = String::new();\n            current_note_length =\
    \ 0;\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmps76y7v6o.rs:22:52\n\
    \   |\n22 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp1856e9ui.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&'static str> = vec![];\n    let mut current_note\
    \ = String::new();\n    let mut current_beat = 0;\n    let mut current_length\
    \ = 0;\n    for c in music_string.chars() {\n        if c.is_ascii() {\n     \
    \       if c.to_ascii_lowercase() == 'o' {\n                notes.push(current_note);\n\
    \                current_note = String::new();\n                current_beat =\
    \ 0;\n                current_length = 0;\n            } else if c.to_ascii_lowercase()\
    \ == 'o|' {\n                notes.push(current_note);\n                current_note\
    \ = String::new();\n                current_beat = 0;\n                current_length\
    \ = 1;\n            } else if c.to_ascii_lowercase() == '.|' {\n             \
    \   notes.push(current_note);\n                current_note = String::new();\n\
    \                current_beat = 1;\n                current_length = 1;\n    \
    \        } else {\n                current_note.push(c);\n            }\n    \
    \    } else {\n            if current_note != String::new() {\n              \
    \  beats.push(current_beat);\n                current_beat = 0;\n            \
    \    current_length = 0;\n            }\n            current_note.clear();\n \
    \       }\n    }\n    if current_note != String::new() {\n        beats.push(current_beat);\n\
    \    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp8j6kgf29.rs:23:52\n\
    \   |\n23 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkunjr83j.rs:62:32\n   |\n\
    62 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkunjr83j.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|&(_, c)| c != '|');\n\
    \    for note in notes {\n        let beat = note.1.to_digit(10).unwrap();\n \
    \       beats.push(beat);\n    }\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbtwgeefq.rs:17:5\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |              \
    \                           ---------- expected `Vec<isize>` because of return\
    \ type\n...\n17 |     beats\n   |     ^^^^^ expected `isize`, found `u32`\n  \
    \ |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<u32>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate();\n    let mut current_note\
    \ = 0;\n    let mut current_beat = 0;\n    let mut current_note_len = 0;\n   \
    \ let mut current_beat_len = 0;\n    let mut current_note_char = 0;\n    let mut\
    \ current_beat_char = 0;\n    let mut current_note_char_count = 0;\n    let mut\
    \ current_beat_char_count = 0;\n    let mut current_note_char_is_octave = false;\n\
    \    let mut current_beat_char_is_octave = false;\n    let mut current_note_char_is_chord\
    \ = false;\n    let mut current_beat_char_is_chord = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let mut current_note_char_is_rest\
    \ = false;\n    let mut current_beat_char_is_rest = false;\n    let \n}\n\nfn\
    \ main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpu8fl5wi5.rs:62:1\n  \
    \ |\n62 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = \n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpabihjkv9.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c.to_ascii_lowercase() == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == 'o|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \            } else {\n                current_note += c.to_ascii_lowercase();\n\
    \            }\n        } else {\n            if current_note.is_empty() {\n \
    \               println!(\"Invalid music string\");\n                return beats;\n\
    \            }\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note = String::new();\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpvob5rtkv.rs:20:52\n\
    \   |\n20 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_len = 0;\n    for c in music_string {\n        if c\
    \ == 'o' {\n            if current_note_len > 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_len = 0;\n            }\n        } else if c ==\
    \ '|' {\n            current_note_len += 1;\n        } else if c == '.' {\n  \
    \          current_note_len = current_note_len - 1;\n        } else {\n      \
    \      current_note.push(c);\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpo9ejbtzm.rs:15:14\n\
    \   |\n15 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut note = music_string.chars().nth(1).unwrap();\n    let mut last_beat\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_note_count = 0;\n    let\
    \ mut last_note_duration = 0;\n    let mut last_note_duration_index = 0;\n   \
    \ let mut last_note_duration_index2 = 0;\n    let mut last_note_duration_index3\
    \ = 0;\n    let mut last_note_duration_index4 = 0;\n    let mut last_note_duration_index5\
    \ = 0;\n    let mut last_note_duration_index6 = 0;\n    let mut last_note_duration_index7\
    \ = 0;\n    let mut last_note_duration_index8 = 0;\n    let mut last_note_duration_index9\
    \ = 0;\n    let mut last_note_duration_index10 = 0;\n    let mut last_note_duration_index11\
    \ = 0;\n    let mut last_note_duration_index12 = 0;\n    let mut last_note_duration_index13\
    \ = 0;\n    let mut last_note_duration_index14 = 0;\n    let mut last_note_duration_index15\
    \ = 0;\n    let mut last_note_duration_index16 = 0;\n    let mut last_note_duration_index17\
    \ = 0;\n    let mut last_note_duration_index18 = 0;\n    let mut last_note_duration_index19\
    \ = 0;\n    let mut last_note_duration_index20 = 0;\n    let mut last_note_duration_index21\
    \ = 0;\n    let mut last_note_duration_index22 = 0;\n    let mut last_note_duration_index23\
    \ = 0;\n    let mut last_note_duration_index24 = 0;\n    let mut last_note_duration_index25\
    \ = 0;\n    let mut last_note_duration_index26 = 0;\n    let mut last_note_duration_index27\
    \ = 0;\n    let mut last_note_duration_index28 = 0;\n    let mut last_note_duration_index29\
    \ = 0;\n    let mut last_note_duration_index30 = 0;\n    let mut last_note_duration_index31\
    \ = 0;\n    let mut last_note_duration_index32 = 0;\n    let mut last_note_duration_index33\
    \ = 0;\n    let mut last_note_duration_index34 = 0;\n    let mut last_note_duration_index35\
    \ = 0;\n    let mut last_note_duration_index36 = 0;\n    let mut last_note_duration_index37\
    \ = 0;\n    let mut last_note_duration_index38 = 0;\n    let mut last_note_duration_index39\
    \ = 0;\n    let mut last_note_duration_index40 = 0;\n    let mut last_note_duration_index41\
    \ = 1;\n    let mut last_note_duration_index42 = 1;\n    let mut last_note_duration_index43\
    \ = 1;\n    let mut last_note_duration_index44 = 1;\n    let mut last_note_duration_index45\
    \ = 1;\n    let mut last_note_duration_index46 = 1;\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzaygloai.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.split_whitespace();\n    let mut current_beat\
    \ = 0;\n    let mut current_note = 0;\n    let mut current_note_length = 0;\n\
    \    for note in notes {\n        if note == \"o\" {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note++;\n            current_note_length\
    \ = 1;\n        } else if note == \"o|\" {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note++;\n            current_note_length\
    \ = 2;\n        } else if note == \".|\" {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note++;\n            current_note_length\
    \ = 1;\n        } else {\n            current_beat += 1;\n            current_note_length\
    \ += 1;\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpwsy3ck68.rs:20:25\n\
    \   |\n20 |             current_note++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n20 |         \
    \    { let tmp = current_note; current_note += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n20 -             current_note++;\n20\
    \ +             current_note += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpwsy3ck68.rs:25:25\n   |\n25 |             current_note++;\n\
    \   |                         ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n25 |             { let tmp = current_note; current_note\
    \ += 1; tmp };\n   |             +++++++++++             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    25 -             current_note++;\n25 +             current_note += 1;\n   | \n\
    \nerror: Rust has no postfix increment operator\n  --> /tmp/tmpwsy3ck68.rs:30:25\n\
    \   |\n30 |             current_note++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n30 |         \
    \    { let tmp = current_note; current_note += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n30 -             current_note++;\n30\
    \ +             current_note += 1;\n   | \n\nerror: aborting due to 3 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length_index48 = 0;\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj4kxmtfk.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_octave = 0;\n    let mut current_note_is_octave = false;\n\n\
    \    for c in music_string.chars() {\n        if c == 'o' {\n            if current_note_is_octave\
    \ {\n                beats.push(current_beat);\n                current_beat =\
    \ 0;\n                current_note_is_octave = false;\n            }\n       \
    \     current_note = String::new();\n            current_octave = 0;\n       \
    \     current_note_is_octave = true;\n        } else if c == '|' {\n         \
    \   current_note = current_note.push_str(\"|\");\n            current_note_is_octave\
    \ = false;\n        } else if c == '.' {\n            current_note = current_note.push_str(\"\
    . \");\n            current_note_is_octave = false;\n        } else {\n      \
    \      current_note = current_note.push_str(&c.to_string());\n        }\n    \
    \    current_beat += 1;\n    }\n    beats.push(current_beat);\n    beats\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj3o31d8s.rs:28:28\n   |\n\
    13 |     let mut current_note = String::new();\n   |                         \
    \   ------------- expected due to this value\n...\n28 |             current_note\
    \ = current_note.push_str(\"|\");\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmpj3o31d8s.rs:28:41\n   |\n28 |         \
    \    current_note = current_note.push_str(\"|\");\n   |                      \
    \      ------------ ^^^^^^^^ this call modifies `current_note` in-place\n   |\
    \                            |\n   |                            you probably want\
    \ to use this value after calling the method...\n   = note: ...instead of the\
    \ `()` output of method `push_str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj3o31d8s.rs:31:28\n\
    \   |\n13 |     let mut current_note = String::new();\n   |                  \
    \          ------------- expected due to this value\n...\n31 |             current_note\
    \ = current_note.push_str(\". \");\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmpj3o31d8s.rs:31:41\n   |\n31 |         \
    \    current_note = current_note.push_str(\". \");\n   |                     \
    \       ------------ ^^^^^^^^ this call modifies `current_note` in-place\n   |\
    \                            |\n   |                            you probably want\
    \ to use this value after calling the method...\n   = note: ...instead of the\
    \ `()` output of method `push_str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj3o31d8s.rs:34:28\n\
    \   |\n13 |     let mut current_note = String::new();\n   |                  \
    \          ------------- expected due to this value\n...\n34 |             current_note\
    \ = current_note.push_str(&c.to_string());\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmpj3o31d8s.rs"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_len = 0;\n    let mut current_note_char = 0;\n    let\
    \ mut current_note_char_len = 0;\n    let mut current_note_char_index = 0;\n \
    \   let mut current_note_char_index2 = 0;\n    let mut current_note_char_index3\
    \ = 0;\n    let mut current_note_char_index4 = 0;\n    let mut current_note_char_index5\
    \ = 0;\n    let mut current_note_char_index6 = 0;\n    let mut current_note_char_index7\
    \ = 0;\n    let mut current_note_char_index8 = 0;\n    let mut current_note_char_index9\
    \ = 0;\n    let mut current_note_char_index10 = 0;\n    let mut current_note_char_index11\
    \ = 0;\n    let mut current_note_char_index12 = 0;\n    let mut current_note_char_index13\
    \ = 0;\n    let mut current_note_char_index14 = 0;\n    let mut current_note_char_index15\
    \ = 0;\n    let mut current_note_char_index16 = 0;\n    let mut current_note_char_index17\
    \ = 0;\n    let mut current_note_char_index18 = 0;\n    let mut current_note_char_index19\
    \ = 0;\n    let mut current_note_char_index20 = 0;\n    let mut current_note_char_index21\
    \ = 0;\n    let mut current_note_char_index22 = 0;\n    let mut current_note_char_index23\
    \ = 0;\n    let mut current_note_char_index24 = 0;\n    let mut current_note_char_index25\
    \ = 0;\n    let mut current_note_char_index26 = 0;\n    let mut current_note_char_index27\
    \ = 0;\n    let mut current_note_char_index28 = 0;\n    let mut current_note_char_index29\
    \ = 0;\n    let mut current_note_char_index30 = 0;\n    let mut current_note_char_index31\
    \ = 0;\n    let mut current_note_char_index32 = 0;\n    let mut current_note_char_index33\
    \ = 0;\n    let mut current_note_char_index34 = 0;\n    let mut current_note_char_index35\
    \ = 0;\n    let mut current_note_char_index36 = 0;\n    let mut current_note_char_index37\
    \ = 0;\n    let mut current_note_char_index38 = 0;\n    let mut current_note_char_index39\
    \ = 0;\n    let mut current_note_char_index40 = 0;\n    let mut current_note_char_index41\
    \ = 0;\n    let mut current_note_char_index42 = 0;\n    let mut current_note_char_index43\
    \ = 0;\n    let mut current_note_char_index44 = 0;\n    let mut current_note_char_index45\
    \ = 0;\n    let mut current_note_char_index46 = 0;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4o_arvx7.rs:63:11\n   |\n\
    63 |     let mu\n   |           ^ help: add `;` here\n64 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4o_arvx7.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_index\
    \ = 0;\n    let mut current_note_length = 0;\n    let mut current_note_length_index\
    \ = 0;\n    let mut current_note_length_value = 0;\n    let mut current_note_length_value_index\
    \ = 0;\n    let mut current_note_length_value_value = 0;\n    let mut current_note_length_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_index = 0;\n    let\
    \ mut current_note_length_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_index\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_index = 0;\n    let mut current_note_length_value_value_value_value\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpspflq3aw.rs:56:26\n   |\n\
    56 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n57 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpspflq3aw.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_len = 0;\n    let mut last_note = String::new();\n \
    \   let mut last_note_len = 0;\n    for c in music_string.chars() {\n        if\
    \ c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n           \
    \     beats.push(current_beat);\n                current_beat = 0;\n         \
    \       current_note = String::new();\n                current_note_len = 0;\n\
    \            } else if c.to_ascii_lowercase() == 'o|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_len = 0;\n            } else if c.to_ascii_lowercase()\
    \ == '.' {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n                current_note_len\
    \ = 0;\n            } else {\n                current_note.push(c);\n        \
    \        current_note_len = c.len_utf8();\n            }\n        } else {\n \
    \           if current_note_len == 0 {\n                last_note.push(c);\n \
    \               last_note_len = c.len_utf8();\n            } else {\n        \
    \        if current_note_len == last_note_len {\n                    current_beat\
    \ += 1;\n                }\n                current_note.push(c);\n          \
    \      current_note_len = c.len_utf8();\n            }\n        }\n    }\n   \
    \ beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpq96q1bzk.rs:24:52\n\
    \   |\n24 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4\
    \ = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n\
    \    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let\
    \ mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut\
    \ current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13\
    \ = 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 =\
    \ 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n\
    \    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n  \
    \  let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let\
    \ mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut\
    \ current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26\
    \ = 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 =\
    \ 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n\
    \    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n  \
    \  let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let\
    \ mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut\
    \ current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39\
    \ = 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 =\
    \ 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n\
    \    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n  \
    \  let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let\
    \ mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut\
    \ current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52\
    \ = 0;\n    let mut current_note_oct53 = 0;\n    let mut current_note_\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyl45pi_p.rs:68:26\n   |\n\
    68 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n69 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyl45pi_p.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    for c in music_string.chars() {\n   \
    \     if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n    \
    \            beats.push(current_beat);\n                current_beat += 4;\n \
    \           } else if c.to_ascii_lowercase() == 'o|' {\n                beats.push(current_beat);\n\
    \                current_beat += 2;\n            } else if c.to_ascii_lowercase()\
    \ == '.|' {\n                beats.push(current_beat);\n                current_beat\
    \ += 1;\n            } else {\n                current_note += c.to_ascii_lowercase();\n\
    \                current_note_length += 1;\n            }\n        } else {\n\
    \            current_note += c.to_ascii_lowercase();\n            current_note_length\
    \ += 1;\n        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpwbsm9y48.rs:20:52\n\
    \   |\n20 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut last_note = String::from(\"\");\n    let mut last_beat: isize = 0;\n\
    \    let mut last_beats: isize = 0;\n    for note in notes {\n        if note\
    \ != \".\" {\n            if note == \"o\" {\n                beats.push(last_beat);\n\
    \                last_beat = 0;\n                last_beats += 1;\n          \
    \  } else if note == \"o|\" {\n                beats.push(last_beat);\n      \
    \          last_beat = 0;\n                last_beats += 2;\n            } else\
    \ if note == \".|\" {\n                beats.push(last_beat);\n              \
    \  last_beat = 0;\n                last_beats += 1;\n            } else {\n  \
    \              last_beats += 1;\n            }\n            last_note = note;\n\
    \        } else {\n            beats.push(last_beat);\n            last_beat =\
    \ 0;\n            last_beats += 1;\n        }\n    }\n    beats.push(last_beat);\n\
    \    last_beat = 0;\n    last_beats += 1;\n    beats\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaxb43fw9.rs:33:25\n   |\n\
    13 |     let mut last_note = String::from(\"\");\n   |                       \
    \  ---------------- expected due to this value\n...\n33 |             last_note\
    \ = note;\n   |                         ^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                         |\n   |                       \
    \  expected struct `String`, found `&str`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    for c in music_string.chars() {\n        if c == 'o' {\n\
    \            if current_beat == 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n            }\n            current_beat +=\
    \ 1;\n            current_note = String::new();\n        } else if c == '|' {\n\
    \            if current_beat == 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n            }\n            current_beat +=\
    \ 1;\n            current_note.push(c);\n        } else if c == '.' {\n      \
    \      if current_beat == 0 {\n                beats.push(current_beat);\n   \
    \             current_beat = 0;\n            }\n            current_beat += 1;\n\
    \            current_note.push(c);\n        } else {\n            current_note.push(c);\n\
    \        }\n    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmpoc4uxfrw.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let\
    \ mut current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut\
    \ current_note_oct4 = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6\
    \ = 0;\n    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n\
    \    let mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n   \
    \ let mut current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let\
    \ mut current_note_oct13 = 0;\n    let mut current_note_oct14 = 0;\n    let mut\
    \ current_note_oct15 = 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17\
    \ = 0;\n    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 =\
    \ 0;\n    let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n\
    \    let mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n  \
    \  let mut current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let\
    \ mut current_note_oct26 = 0;\n    let mut current_note_oct27 = 0;\n    let mut\
    \ current_note_oct28 = 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30\
    \ = 0;\n    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 =\
    \ 0;\n    let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n\
    \    let mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n  \
    \  let mut current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let\
    \ mut current_note_oct39 = 0;\n    let mut current_note_oct40 = 0;\n    let mut\
    \ current_note_oct41 = 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43\
    \ = 0;\n    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 =\
    \ 0;\n    let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n\
    \    let mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n  \
    \  let mut current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let\
    \ mut current_note_oct52 = 0;\n    let mut current_note_oct53\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp504k_35j.rs:67:31\n   |\n\
    67 |     let mut current_note_oct53\n   |                               ^ help:\
    \ add `;` here\n68 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp504k_35j.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_note_len = 0;\n    let mut current_note_oct\
    \ = 0;\n    let mut current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n\
    \    let mut current_note_oct4 = 0;\n    let mut current_note_oct5 = 0;\n    let\
    \ mut current_note_oct6 = 0;\n    let mut current_note_oct7 = 0;\n    let mut\
    \ current_note_oct8 = 0;\n    let mut current_note_oct9 = 0;\n    let mut current_note_oct10\
    \ = 0;\n    let mut current_note_oct11 = 0;\n    let mut current_note_oct12 =\
    \ 0;\n    let mut current_note_oct13 = 0;\n    let mut current_note_oct14 = 0;\n\
    \    let mut current_note_oct15 = 0;\n    let mut current_note_oct16 = 0;\n  \
    \  let mut current_note_oct17 = 0;\n    let mut current_note_oct18 = 0;\n    let\
    \ mut current_note_oct19 = 0;\n    let mut current_note_oct20 = 0;\n    let mut\
    \ current_note_oct21 = 0;\n    let mut current_note_oct22 = 0;\n    let mut current_note_oct23\
    \ = 0;\n    let mut current_note_oct24 = 0;\n    let mut current_note_oct25 =\
    \ 0;\n    let mut current_note_oct26 = 0;\n    let mut current_note_oct27 = 0;\n\
    \    let mut current_note_oct28 = 0;\n    let mut current_note_oct29 = 0;\n  \
    \  let mut current_note_oct30 = 0;\n    let mut current_note_oct31 = 0;\n    let\
    \ mut current_note_oct32 = 0;\n    let mut current_note_oct33 = 0;\n    let mut\
    \ current_note_oct34 = 0;\n    let mut current_note_oct35 = 0;\n    let mut current_note_oct36\
    \ = 0;\n    let mut current_note_oct37 = 0;\n    let mut current_note_oct38 =\
    \ 0;\n    let mut current_note_oct39 = 0;\n    let mut current_note_oct40 = 0;\n\
    \    let mut current_note_oct41 = 0;\n    let mut current_note_oct42 = 0;\n  \
    \  let mut current_note_oct43 = 0;\n    let mut current_note_oct44 = 0;\n    let\
    \ mut current_note_oct45 = 0;\n    let mut current_note_oct46 = 0;\n    let mut\
    \ current_note_oct47 = 0;\n    let mut current_note_oct48 = 0;\n    let mut current_note_oct49\
    \ = 0;\n    let mut current_note_oct50 = 0;\n    let mut current_note_oct51 =\
    \ 0;\n    let mut current_note_oct52 = 0;\n    let mut current_note_\n}\n\nfn\
    \ main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpahqm9vn3.rs:67:26\n   |\n\
    67 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n68 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpahqm9vn3.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate();\n    let mut last_note\
    \ = notes.next();\n    while let Some(note) = last_note {\n        let mut beat\
    \ = 0;\n        let mut last_beat = 0;\n        while let Some(note) = notes.next()\
    \ {\n            let note = note.0;\n            if note == 'o' {\n          \
    \      beat += 1;\n                last_beat = beat;\n            } else if note\
    \ == 'o|' {\n                beat += 2;\n                last_beat = beat;\n \
    \           } else if note == '.|' {\n                beat += 1;\n           \
    \     last_beat = beat;\n            } else {\n                break;\n      \
    \      }\n        }\n        beats.push(beat);\n        last_note = note;\n  \
    \  }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp5ndwlago.rs:22:34\n\
    \   |\n22 |             } else if note == 'o|' {\n   |                       \
    \           ^^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length\n}\n\nfn main() {\n    let candidate =\
    \ parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkunjr83j.rs:62:32\n   |\n\
    62 |     let mut current_note_length\n   |                                ^ help:\
    \ add `;` here\n63 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkunjr83j.rs:10:41\n   |\n10 | fn parse_music(music_string: String)\
    \ -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length_index48 = 0;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmphyjd3prq.rs:63:11\n   |\n\
    63 |     let mu\n   |           ^ help: add `;` here\n64 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphyjd3prq.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate();\n    let mut current_note\
    \ = 0;\n    let mut current_beat = 0;\n    let mut current_note_length = 0;\n\
    \    for note in notes {\n        let note_length = note.1.len_utf8();\n     \
    \   if note_length == 0 {\n            notes.remove(note);\n            continue;\n\
    \        }\n        if note.1.is_ascii() {\n            let note_char = note.1.to_ascii_lowercase();\n\
    \            if note_char == 'o' {\n                beats.push(current_beat);\n\
    \                current_beat += 4;\n            } else if note_char == 'o|' {\n\
    \                beats.push(current_beat);\n                current_beat += 2;\n\
    \            } else if note_char == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat += 1;\n            } else {\n                panic!(\"\
    Invalid note character in music string: {}\", note_char);\n            }\n   \
    \     } else {\n            panic!(\"Invalid note character in music string: {}\"\
    , note.1);\n        }\n        current_note_length += note_length;\n        if\
    \ current_note_length >= 4 {\n            current_note += 1;\n            current_beat\
    \ += 1;\n            current_note_length -= 4;\n        }\n    }\n    beats.push(current_beat);\n\
    \    current_beat += 1;\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmptt2xyjbm.rs:27:39\n\
    \   |\n27 |             } else if note_char == 'o|' {\n   |                  \
    \                     ^^^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaf_v5be6.rs:63:26\n   |\n\
    63 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpaf_v5be6.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = 0;\n  \
    \  let mut current_note_len = 0;\n    for c in music_string.chars() {\n      \
    \  if c == 'o' {\n            current_note_len = 4;\n            current_note\
    \ += 1;\n            current_beat += 1;\n        } else if c == '|' {\n      \
    \      current_note_len = 2;\n            current_note += 1;\n            current_beat\
    \ += 1;\n        } else if c == '.' {\n            current_note_len = 1;\n   \
    \         current_note += 1;\n            current_beat += 1;\n        } else {\n\
    \            current_note_len = 0;\n            current_note += 1;\n         \
    \   current_beat += 1;\n        }\n        beats.push(current_beat);\n    }\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 6, 7]`,\n right: `[4, 4, 4, 4]`', /tmp/tmpwo5dpuaw.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.first().unwrap();\n    let mut current_beat\
    \ = 0;\n    let mut current_note_count = 0;\n    let mut current_note_length =\
    \ 0;\n    for note in notes {\n        if note == current_note {\n           \
    \ current_note_count += 1;\n            current_note_length += 1;\n        } else\
    \ {\n            if current_note_count > 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note_count = 0;\n\
    \            }\n            current_note = note;\n            current_note_length\
    \ = 1;\n        }\n    }\n    if current_note_count > 0 {\n        beats.push(current_beat);\n\
    \    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmpzdvfxh85.rs:18:17\n\
    \   |\n18 |         if note == current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzdvfxh85.rs:27:28\n   |\n13 |     let mut current_note\
    \ = notes.first().unwrap();\n   |                            ----------------------\
    \ expected due to this value\n...\n27 |             current_note = note;\n   |\
    \                            ^^^^ expected `&str`, found `str`\n   |\n   = note:\
    \ expected reference `&&str`\n              found reference `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.first().unwrap();\n    let mut current_beat\
    \ = 0;\n    let mut current_note_count = 0;\n    let mut last_note_count = 0;\n\
    \    while current_note != \"\" {\n        if current_note == \"o\" {\n      \
    \      beats.push(current_beat);\n            current_beat = 0;\n            current_note_count\
    \ += 1;\n            last_note_count += 1;\n        } else if current_note ==\
    \ \"o|\" {\n            beats.push(current_beat);\n            current_beat =\
    \ 0;\n            current_note_count += 1;\n            last_note_count += 2;\n\
    \        } else if current_note == \".|\" {\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note_count += 1;\n       \
    \     last_note_count += 1;\n        } else {\n            current_beat += 1;\n\
    \        }\n        current_note = notes.remove(0);\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `str`\n  --> /tmp/tmptb09y2cb.rs:17:24\n\
    \   |\n17 |     while current_note != \"\" {\n   |                        ^^ no\
    \ implementation for `&str == str`\n   |\n   = help: the trait `PartialEq<str>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]: can't compare `&str`\
    \ with `str`\n  --> /tmp/tmptb09y2cb.rs:18:25\n   |\n18 |         if current_note\
    \ == \"o\" {\n   |                         ^^ no implementation for `&str == str`\n\
    \   |\n   = help: the trait `PartialEq<str>` is not implemented for `&str`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&str>` for `&&str`\n\nerror[E0277]:\
    \ can't compare `&str` with `str`\n  --> /tmp/tmptb09y2cb.rs:23:32\n   |\n23 |\
    \         } else if current_note == \"o|\" {\n   |                           \
    \     ^^ no implementation for `&str == str`\n   |\n   = help: the trait `PartialEq<str>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n   "
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|&(_, c)| c == 'o'\
    \ || c == '|' || c == '.').collect::<Vec<_>>();\n    for note in notes {\n   \
    \     if note.1 == notes.len() - 1 {\n            beats.push(4);\n        } else\
    \ {\n            beats.push(note.1 - notes.len() + 1);\n        }\n    }\n   \
    \ beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwq9ygrax.rs:14:22\n   |\n\
    14 |         if note.1 == notes.len() - 1 {\n   |                      ^^^^^^^^^^^^^^^\
    \ expected `char`, found `usize`\n\nerror[E0369]: cannot subtract `usize` from\
    \ `char`\n  --> /tmp/tmpwq9ygrax.rs:17:31\n   |\n17 |             beats.push(note.1\
    \ - notes.len() + 1);\n   |                        ------ ^ ----------- usize\n\
    \   |                        |\n   |                        char\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  for c in music_string.chars() {\n        if c.is_ascii() {\n            if\
    \ c == 'o' {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note = String::new();\n            } else {\n\
    \                current_note += c.to_string();\n            }\n        } else\
    \ {\n            if current_note.is_empty() {\n                println!(\"Invalid\
    \ music string\");\n                return beats;\n            }\n           \
    \ beats.push(current_beat);\n            current_beat = 0;\n            current_note\
    \ = String::new();\n        }\n    }\n    beats.push(current_beat);\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphyvv054_.rs:21:33\n   |\n\
    21 |                 current_note += c.to_string();\n   |                    \
    \             ^^^^^^^^^^^^^\n   |                                 |\n   |    \
    \                             expected `&str`, found struct `String`\n   |   \
    \                              help: consider borrowing here: `&c.to_string()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_value\
    \ = 0;\n    let mut current_note_length = 0;\n    let mut current_note_length_value\
    \ = 0;\n    let mut current_note_length_value_value = 0;\n    let mut current_note_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value = 0;\n    let\
    \ mut current_note_length_value_value_value_value_value = 0;\n    let mut current_note_length_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value\
    \ = 0;\n    let mut current_note_length_value_value_value_value_value_value_value_value_value_value_value_value_value_value\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkj2p9b07.rs:41:116\n   |\n\
    41 |     let mut current_note_length_value_value_value_value_value_value_value_value_value_value_value_value_value_value\n\
    \   |                                                                        \
    \                                            ^ help: add `;` here\n42 | }\n  \
    \ | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkj2p9b07.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_note_length = 0;\n    let mut current_note_length_index\
    \ = 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = parse_music;\n   \
    \ assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpz5rh2cyi.rs:63:1\n\
    \   |\n63 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().collect::<Vec<_>>();\n    let mut current_note\
    \ = notes.len() - 1;\n    let mut current_beat = 0;\n    let mut current_note_length\
    \ = notes[current_note].len_utf8();\n    let mut last_note = current_note;\n \
    \   while current_note > 0 {\n        let mut current_note_length = notes[current_note].len_utf8();\n\
    \        if current_note_length == 0 {\n            current_note -= 1;\n     \
    \       continue;\n        }\n        let mut current_beat = 0;\n        while\
    \ current_beat < current_note_length {\n            let mut current_beat_length\
    \ = notes[current_note].as_bytes()[current_beat].len_utf8();\n            if current_beat_length\
    \ == 0 {\n                current_beat += 1;\n                continue;\n    \
    \        }\n            beats.push(current_beat as isize);\n            current_beat\
    \ += 1;\n        }\n        last_note = current_note;\n        current_note -=\
    \ 1;\n    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n \
    \   assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_bytes` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp26jaxznm.rs:25:63\n   |\n25 |             let mut current_beat_length\
    \ = notes[current_note].as_bytes()[current_beat].len_utf8();\n   |           \
    \                                                    ^^^^^^^^ method not found\
    \ in `char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4\
    \ = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n\
    \    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let\
    \ mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut\
    \ current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13\
    \ = 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 =\
    \ 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n\
    \    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n  \
    \  let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let\
    \ mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut\
    \ current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26\
    \ = 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 =\
    \ 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n\
    \    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n  \
    \  let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let\
    \ mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut\
    \ current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39\
    \ = 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 =\
    \ 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n\
    \    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n  \
    \  let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let\
    \ mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut\
    \ current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52\
    \ = 0;\n    let mut current_note_oct53 = 0;\n    let mut current_note_\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyl45pi_p.rs:68:26\n   |\n\
    68 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n69 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyl45pi_p.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.clone();\n    let mut current_beat = 0;\n  \
    \  let mut current_note_len = 0;\n    let mut last_note_len = 0;\n    let mut\
    \ last_note = notes.clone();\n    while current_note.len() > 0 {\n        let\
    \ note = current_note.clone();\n        let note_len = note.len();\n        if\
    \ note_len == 0 {\n            notes.push(current_note.clone());\n           \
    \ current_note = notes.clone();\n            current_beat = 0;\n            current_note_len\
    \ = note_len;\n            last_note_len = 0;\n            last_note = notes.clone();\n\
    \            continue;\n        }\n        if note_len == last_note_len {\n  \
    \          notes.push(current_note.clone());\n            current_note = notes.clone();\n\
    \            current_beat = 0;\n            current_note_len = note_len;\n   \
    \         last_note_len = 0;\n            last_note = notes.clone();\n       \
    \     continue;\n        }\n        if note_len > last_note_len {\n          \
    \  notes.push(current_note.clone());\n            current_note = notes.clone();\n\
    \            current_beat = 0;\n            current_note_len = note_len;\n   \
    \         last_note = notes.clone();\n            continue;\n        }\n     \
    \   let mut beats_count = current_beat;\n        if note_len > 4 {\n         \
    \   beats_count += 1;\n        }\n        if note_len > 2 {\n            beats_count\
    \ += 1;\n        }\n        if note_len > 1 {\n            beats_count += 1;\n\
    \        }\n        beats.push(beats_count);\n        current_note = notes.clone();\n\
    \        current_beat = 0;\n        current_note_len = note_len;\n        last_note\
    \ = notes.clone();\n    }\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcfifjwv1.rs:22:24\n   |\n\
    22 |             notes.push(current_note.clone());\n   |                     \
    \   ^^^^^^^^^^^^^^^^^^^^ expected `&str`, found struct `Vec`\n   |\n   = note:\
    \ expected reference `&str`\n                 found struct `Vec<&str>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcfifjwv1.rs:31:24\n   |\n31 |             notes.push(current_note.clone());\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^ expected `&str`, found struct\
    \ `Vec`\n   |\n   = note: expected reference `&str`\n                 found struct\
    \ `Vec<&str>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcfifjwv1.rs:40:24\n\
    \   |\n40 |             notes.push(current_note.clone());\n   |              \
    \          ^^^^^^^^^^^^^^^^^^^^ expected `&str`, found struct `Vec`\n   |\n  \
    \ = note: expected reference `&str`\n                 found struct `Vec<&str>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|&(_, note)| note\
    \ != 'o');\n    for note in notes {\n        let mut beat = 0;\n        let mut\
    \ note = note.unwrap();\n        note.chars().for_each(|c| {\n            if c\
    \ == '|' {\n                beat += 1;\n            }\n            beat += 1;\n\
    \        });\n        beats.push(beat);\n    }\n    beats\n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for tuple `(usize, char)`\
    \ in the current scope\n  --> /tmp/tmpqyiyaaap.rs:15:29\n   |\n15 |         let\
    \ mut note = note.unwrap();\n   |                             ^^^^^^ method not\
    \ found in `(usize, char)`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_note = String::from(\"\");\n    let mut current_beat\
    \ = 0;\n    let mut current_length = 0;\n    for c in music_string.chars() {\n\
    \        match c {\n            'o' => current_note = String::from(\"\"),\n  \
    \          'o|' => current_note = String::from(\"\"),\n            '.|' => current_note\
    \ = String::from(\"\"),\n            'o' => beats.push(current_beat),\n      \
    \      'o|' => beats.push(current_beat),\n            '.|' => beats.push(current_beat),\n\
    \            '.' => current_beat = 1,\n            _ => current_note.push(c),\n\
    \        }\n        current_beat += 1;\n        current_length += 1;\n    }\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpbracd3zb.rs:18:16\n\
    \   |\n18 |             'o|' => current_note = String::from(\"\"),\n   |     \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate();\n    let mut current_note\
    \ = 0;\n    let mut current_beat = 0;\n    let mut current_note_index = 0;\n \
    \   let mut last_note_index = 0;\n    let mut last_beat_index = 0;\n    let mut\
    \ last_note = String::new();\n    let mut last_beat = String::new();\n    let\
    \ mut last_note_index = 0;\n    let mut last_beat_index = 0;\n    let mut last_note\
    \ = String::new();\n    let mut last_beat = String::new();\n    let mut last_note_index\
    \ = 0;\n    let mut last_beat_index = 0;\n    let mut last_note = String::new();\n\
    \    let mut last_beat = String::new();\n    let mut last_note_index = 0;\n  \
    \  let mut last_beat_index = 0;\n    let mut last_note = String::new();\n    let\
    \ mut last_beat = String::new();\n    let mut last_note_index = 0;\n    let mut\
    \ last_beat_index = 0;\n    let mut last_note = String::new();\n    let mut last_beat\
    \ = String::new();\n    let mut last_note_index = 0;\n    let mut last_beat_index\
    \ = 0;\n    let mut last_note = String::new();\n    let mut last_beat = String::new();\n\
    \    let mut last_note_index = 0;\n    let mut last_beat_index = 0;\n    let mut\
    \ last_note = String::new();\n    let mut last_beat = String::new();\n    let\
    \ mut last_note_index = 0;\n    let mut last_beat_index = 0;\n    let mut last_note\
    \ = String::new();\n    let mut last_beat = String::new();\n    let mut last_note_index\
    \ = 0;\n    let mut last_beat_index = 0;\n    let mut last_note = String::new();\n\
    \    let mut last_beat = String::new();\n    let mut last_note_index = 0;\n  \
    \  let mut last_beat_index = 0;\n    let mut last_note = String::new();\n    let\
    \ mut last_beat = String::new();\n    let mut last_note_index = 0;\n    let mut\
    \ last_beat_index = 0;\n    let mut last_note = String::new();\n    let mut last_beat\
    \ = String::new();\n    let mut last_note_index = 0;\n    let mut last_beat_index\
    \ = 0;\n    let mut last_note = String::new();\n    let mut last_beat = String::new();\n\
    \    let mut last_note_index = 0;\n    let mut last_\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxq7l7k8r.rs:65:18\n   |\n\
    65 |     let mut last_\n   |                  ^ help: add `;` here\n66 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxq7l7k8r.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 0;\n    let mut current_note_length_index42 = 0;\n    let mut current_note_length_index43\
    \ = 0;\n    let mut current_note_length_index44 = 0;\n    let mut current_note_length_index45\
    \ = 0;\n    let mut current_note_length_index46 = 0;\n    let mut current_note_length_index47\
    \ = 0;\n    let mut current_note_length_index48 = 0;\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj4kxmtfk.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, c)| c != '|').collect::<Vec<_>>();\n\
    \    let mut last_note = notes.len() - 1;\n    let mut last_beat = 0;\n    let\
    \ mut last_beats_length = 0;\n    let mut last_beats_length_to_beat = 0;\n   \
    \ let mut last_beats_length_to_note = 0;\n    let mut last_note_to_beat = 0;\n\
    \    let mut last_note_to_note = 0;\n    let mut last_note_to_length = 0;\n  \
    \  let mut last_note_to_length_to_beat = 0;\n    let mut last_note_to_length_to_note\
    \ = 0;\n    let mut last_note_to_length_to_length = 0;\n    let mut last_note_to_length_to_length_to_beat\
    \ = 0;\n    let mut last_note_to_length_to_length_to_note = 0;\n    let mut last_note_to_length_to_length_to_length\
    \ = 0;\n    let mut last_note_to_length_to_length_to_length_to_beat = 0;\n   \
    \ let mut last_note_to_length_to_length_to_length_to_note = 0;\n    let mut last_note_to_length_to_length_to_length_to_length\
    \ = 0;\n    let mut last_note_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut last_note_to_length_to_length_to_length_to_length_to_note\
    \ = 0;\n    let mut last_note_to_length_to_length_to_length_to_length_to_length\
    \ = 0;\n    let mut last_note_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut last_note_to_length_to_length_to_length_to_length_to_length_to_note\
    \ = 0;\n    let mut last_note_to_length_to_length_to_length_to_length_to_length_to_length\
    \ = 0;\n    let mut last_note_to_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut last_note_to_length_to_length_to_length_to_length_to_length_to_length_to_note\
    \ = 0;\n    let mut last_note_to_length_to_length_to_length_to_length_to_length_to_length_to_length\
    \ = 0;\n    let mut last_note_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut last_note_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_note\
    \ = 0;\n    let mut last_note_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_beat\
    \ = 0;\n    let mut last_note_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_length_to_note\
    \ = 0;\n    let mut last_note_to_length_to_length_to_length_to_\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpts3_f603.rs:43:56\n   |\n\
    43 |     let mut last_note_to_length_to_length_to_length_to_\n   |           \
    \                                             ^ help: add `;` here\n44 | }\n \
    \  | - unexpected token\n\nerror[E0277]: can't compare `&char` with `char`\n \
    \ --> /tmp/tmpts3_f603.rs:12:72\n   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_,\
    \ c)| c != '|').collect::<Vec<_>>();\n   |                                   \
    \                                     ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpts3_f603.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|(_, c)| c != '|');\n\
    \    for note in notes {\n        let mut beat = 0;\n        let mut note = note.1;\n\
    \        while note != 'o' {\n            beat += 1;\n            note += 1;\n\
    \        }\n        beats.push(beat);\n    }\n    beats\n}\n\nfn main() {\n  \
    \  let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgto3_lt2.rs:12:72\n\
    \   |\n12 |     let mut notes = music_string.chars().enumerate().filter(|(_, c)|\
    \ c != '|');\n   |                                                           \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0368]: binary assignment operation `+=`\
    \ cannot be applied to type `char`\n  --> /tmp/tmpgto3_lt2.rs:18:13\n   |\n18\
    \ |             note += 1;\n   |             ----^^^^^\n   |             |\n \
    \  |             cannot use `+=` on type `char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate().filter(|&(_, note)| note\
    \ != 'o');\n    let mut last_note = notes.next().unwrap().1;\n    for note in\
    \ notes {\n        if note != last_note {\n            beats.push(4);\n      \
    \  }\n        beats.push(note as isize);\n        last_note = note;\n    }\n \
    \   beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpar87ro8k.rs:15:20\n   |\n\
    15 |         if note != last_note {\n   |                    ^^^^^^^^^ expected\
    \ tuple, found `char`\n   |\n   = note: expected tuple `(usize, char)`\n     \
    \          found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpar87ro8k.rs:19:21\n\
    \   |\n13 |     let mut last_note = notes.next().unwrap().1;\n   |           \
    \              ----------------------- expected due to this value\n...\n19 | \
    \        last_note = note;\n   |                     ^^^^ expected `char`, found\
    \ tuple\n   |\n   = note: expected type `char`\n             found tuple `(usize,\
    \ char)`\n\nerror[E0605]: non-primitive cast: `(usize, char)` as `isize`\n  -->\
    \ /tmp/tmpar87ro8k.rs:18:20\n   |\n18 |         beats.push(note as isize);\n \
    \  |                    ^^^^^^^^^^^^^ an `as` expression can only be used to convert\
    \ between primitive types or to coerce to a specific trait object\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0605.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    for c in music_string {\n        if c.is_ascii() {\n            current_note\
    \ += c;\n            current_note_length += 1;\n            if current_note_length\
    \ == 4 {\n                beats.push(current_beat);\n                current_beat\
    \ += 1;\n                current_note_length = 0;\n                current_note_length_index\
    \ += 1;\n            }\n        } else {\n            if current_note_length_index\
    \ == 0 {\n                current_note += c;\n                current_note_length\
    \ += 1;\n            } else {\n                current_note += c;\n          \
    \      current_note_length += 1;\n            }\n        }\n    }\n    beats.push(current_beat);\n\
    \    current_beat += 1;\n    current_note_length = 0;\n    current_note_length_index\
    \ = 0;\n    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp64qqji71.rs:16:14\n\
    \   |\n16 |     for c in music_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_oct2 = 0;\n    for c in music_string.chars() {\n        if c ==\
    \ 'o' {\n            if current_note_len == 0 {\n                println!(\"Invalid\
    \ music string\");\n                break;\n            }\n            current_note\
    \ += c.to_string();\n            current_note_oct = c.to_digit(10).unwrap();\n\
    \            current_note_oct2 = current_note_oct / 2;\n            current_note_len\
    \ -= 1;\n            current_beat += 1;\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \          current_note_len = 0;\n            current_note_oct = 0;\n        \
    \    current_note_oct2 = 0;\n        } else if c == '|' {\n            if current_note_len\
    \ == 0 {\n                println!(\"Invalid music string\");\n              \
    \  break;\n            }\n            current_note += c.to_string();\n       \
    \     current_note_oct = c.to_digit(10).unwrap();\n            current_note_len\
    \ += 1;\n            current_beat += 1;\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \          current_note_len = 0;\n            current_note_oct = 0;\n        \
    \    current_note_oct2 = 0;\n        } else if c == '.' {\n            if current_note_len\
    \ == 0 {\n                println!(\"Invalid music string\");\n              \
    \  break;\n            }\n            current_note += c.to_string();\n       \
    \     current_note_oct = c.to_digit(10).unwrap();\n            current_note_len\
    \ += 1;\n            current_beat += 1;\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \          current_note_len = 0;\n            current_note_oct = 0;\n        \
    \    current_note_oct2 = 0;\n        } else {\n            current_note += c.to_string();\n\
    \            current_note_oct += c.to_digit(10).unwrap();\n            current_note_len\
    \ += 1;\n            current_beat += 1;\n            beats.push(current_beat);\n\
    \            current_beat = 0;\n            current_note = String::new();\n  \
    \          current_note_len = 0;\n            current_note_oct = 0;\n        \
    \    current_note_oct2 = 0;\n        }\n    }\n    beats\n}\n\nfn main() {\n \
    \   let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpio68it6l.rs:23:29\n   |\n\
    23 |             current_note += c.to_string();\n   |                        \
    \     ^^^^^^^^^^^^^\n   |                             |\n   |                \
    \             expected `&str`, found struct `String`\n   |                   \
    \          help: consider borrowing here: `&c.to_string()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpio68it6l.rs:39:29\n   |\n39 |             current_note\
    \ += c.to_string();\n   |                             ^^^^^^^^^^^^^\n   |    \
    \                         |\n   |                             expected `&str`,\
    \ found struct `String`\n   |                             help: consider borrowing\
    \ here: `&c.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpio68it6l.rs:54:29\n\
    \   |\n54 |             current_note += c.to_string();\n   |                 \
    \            ^^^^^^^^^^^^^\n   |                             |\n   |         \
    \                    expected `&str`, found struct `String`\n   |            \
    \                 help: consider borrowing here: `&c.to_string()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpio68it6l.rs:65:29\n   |\n65 |             current_note\
    \ += c.to_string();\n   |                             ^^^^^^^^^^^^^\n   |    \
    \                         |\n   |                             expected `&str`,\
    \ found struct `String`\n   |                             help: consider borrowing\
    \ here: `&c.to_string()`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut notes: Vec<&str> = music_string.split_whitespace().collect();\n\
    \    let mut current_note = notes.first().unwrap();\n    let mut current_beat\
    \ = 0;\n    let mut current_beats: isize = 0;\n    let mut current_notes: isize\
    \ = 0;\n    for note in notes {\n        if note == current_note {\n         \
    \   current_beats += 1;\n            current_beats += current_beats;\n       \
    \     current_beats += current_beats;\n            current_beats += current_beats;\n\
    \            current_notes += 1;\n        } else {\n            beats.push(current_beats);\n\
    \            current_beats = 0;\n            current_notes = 0;\n            current_note\
    \ = note;\n            current_beat = 1;\n        }\n    }\n    beats.push(current_beats);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `&str`\n  --> /tmp/tmp5enmu0yn.rs:18:17\n\
    \   |\n18 |         if note == current_note {\n   |                 ^^ no implementation\
    \ for `str == &str`\n   |\n   = help: the trait `PartialEq<&str>` is not implemented\
    \ for `str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&&str>` for `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5enmu0yn.rs:28:28\n   |\n13 |     let mut current_note\
    \ = notes.first().unwrap();\n   |                            ----------------------\
    \ expected due to this value\n...\n28 |             current_note = note;\n   |\
    \                            ^^^^ expected `&str`, found `str`\n   |\n   = note:\
    \ expected reference `&&str`\n              found reference `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat: isize = 0;\n    let mut current_note =\
    \ String::new();\n    let mut current_note_length = 0;\n    for c in music_string.chars()\
    \ {\n        if c.is_ascii() {\n            if c.to_ascii_lowercase() == 'o' {\n\
    \                beats.push(current_beat);\n                current_beat = 0;\n\
    \                current_note = String::new();\n                current_note_length\
    \ = 0;\n            } else if c.to_ascii_lowercase() == 'o|' {\n             \
    \   beats.push(current_beat);\n                current_beat = 0;\n           \
    \     current_note = String::new();\n                current_note_length = 1;\n\
    \            } else if c.to_ascii_lowercase() == '.|' {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_length = 2;\n            } else {\n            \
    \    let mut note = String::new();\n                note.push_str(&c.to_ascii_lowercase());\n\
    \                note.push_str(&c.to_ascii_lowercase());\n                note.push_str(&c.to_ascii_lowercase());\n\
    \                note.push_str(&c.to_ascii_lowercase());\n                note.push_str(&c.to_ascii_lowercase());\n\
    \                note.push_str(&c.to_ascii_lowercase());\n                note.push_str(&c.to_ascii_lowercase());\n\
    \                note.push_str(&c.to_ascii_lowercase());\n                note.push_str(&c.to_ascii_lowercase());\n\
    \                note.push_str(&c.to_ascii_lowercase());\n                note.push_str(&c.to_ascii_lowercase());\n\
    \                note.push_str(&c.to_ascii_lowercase());\n                note.push_str(&c.to_ascii_lowercase());\n\
    \                note.push_str(&c.to_ascii_lowercase());\n                note.push_str(&c.to_ascii_lowercase());\n\
    \                note.push_str(&c.to_ascii_lowercase());\n                note.push_str(&c.to_ascii_lowercase());\n\
    \                note.push_str(&c.to_ascii_lowercase());\n                note.push_str(&c.to_ascii_lowercase());\n\
    \                note.push_str(&c.to_ascii_lowercase());\n                note.push_str(&c.to_ascii_lowercase());\n\
    \                note.push_str(&c.to_ascii_lowercase());\n                note.push_str(&c.to_ascii_lowercase());\n\
    \                note.push_str(&c.to_ascii_lowercase());\n                note.push_str(&c.to_ascii_lowercase());\n\
    \                note.push_str(&c.to_ascii_lowercase());\n                note.push_str(&c.to_ascii_lowercase());\n\
    \                note.push_str(&c.to_ascii_lowercase\n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmp9cdlv0rr.rs:22:52\n\
    \   |\n22 |             } else if c.to_ascii_lowercase() == 'o|' {\n   |     \
    \                                               ^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_value = 0;\n    let mut current_note_length_value_length\
    \ = 0;\n    let mut current_note_length_value_length_index = 0;\n    let mut current_note_length_value_length_value\
    \ = 0;\n    let mut current_note_length_value_length_value_index = 0;\n    let\
    \ mut current_note_length_value_length_value_value = 0;\n    let mut current_note_length_value_length_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value = 0;\n    let\
    \ mut current_note_length_value_length_value_value_index = 0;\n    let mut current_note_length_value_length_value_value_value\
    \ = 0;\n    let mut current_note_length_value_length_value_value_index = 0;\n\
    \    let mut current_note_length_value_length_value_value_value\n}\n\nfn main()\
    \ {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0x6u8di1.rs:52:63\n   |\n\
    52 |     let mut current_note_length_value_length_value_value_value\n   |    \
    \                                                           ^ help: add `;` here\n\
    53 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0x6u8di1.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    let mut current_note_length_index = 0;\n\
    \    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let mut current_note_length_index46 = 1;\n    let mut current_note_length_index47\
    \ = 1;\n    let mut current_note_length_index48 = 1;\n\n}\n\nfn main() {\n   \
    \ let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3_wmrkhd.rs:10:41\n   |\n\
    10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = 0;\n\
    \    let mut current_note_length = 0;\n    for c in music_string.chars() {\n \
    \       if c == 'o' {\n            if current_note == 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = 1;\n      \
    \          current_note_length = 1;\n            } else {\n                current_note\
    \ += 1;\n                current_note_length += 1;\n            }\n        } else\
    \ if c == '|' {\n            if current_note == 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = 2;\n      \
    \          current_note_length = 1;\n            } else {\n                current_note\
    \ += 2;\n                current_note_length += 2;\n            }\n        } else\
    \ if c == '.' {\n            if current_note == 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = 3;\n      \
    \          current_note_length = 1;\n            } else {\n                current_note\
    \ += 3;\n                current_note_length += 3;\n            }\n        } else\
    \ {\n            if current_note == 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = 0;\n      \
    \          current_note_length = 1;\n            } else {\n                current_note\
    \ += 1;\n                current_note_length += 1;\n            }\n        }\n\
    \        current_beat += 1;\n    }\n    beats.push(current_beat);\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmpyx9jm34a.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    let mut current_note_length_index2 = 0;\n    let mut current_note_length_index3\
    \ = 0;\n    let mut current_note_length_index4 = 0;\n    let mut current_note_length_index5\
    \ = 0;\n    let mut current_note_length_index6 = 0;\n    let mut current_note_length_index7\
    \ = 0;\n    let mut current_note_length_index8 = 0;\n    let mut current_note_length_index9\
    \ = 0;\n    let mut current_note_length_index10 = 0;\n    let mut current_note_length_index11\
    \ = 0;\n    let mut current_note_length_index12 = 0;\n    let mut current_note_length_index13\
    \ = 0;\n    let mut current_note_length_index14 = 0;\n    let mut current_note_length_index15\
    \ = 0;\n    let mut current_note_length_index16 = 0;\n    let mut current_note_length_index17\
    \ = 0;\n    let mut current_note_length_index18 = 0;\n    let mut current_note_length_index19\
    \ = 0;\n    let mut current_note_length_index20 = 0;\n    let mut current_note_length_index21\
    \ = 0;\n    let mut current_note_length_index22 = 0;\n    let mut current_note_length_index23\
    \ = 0;\n    let mut current_note_length_index24 = 0;\n    let mut current_note_length_index25\
    \ = 0;\n    let mut current_note_length_index26 = 0;\n    let mut current_note_length_index27\
    \ = 0;\n    let mut current_note_length_index28 = 0;\n    let mut current_note_length_index29\
    \ = 0;\n    let mut current_note_length_index30 = 0;\n    let mut current_note_length_index31\
    \ = 0;\n    let mut current_note_length_index32 = 0;\n    let mut current_note_length_index33\
    \ = 0;\n    let mut current_note_length_index34 = 0;\n    let mut current_note_length_index35\
    \ = 0;\n    let mut current_note_length_index36 = 0;\n    let mut current_note_length_index37\
    \ = 0;\n    let mut current_note_length_index38 = 0;\n    let mut current_note_length_index39\
    \ = 0;\n    let mut current_note_length_index40 = 0;\n    let mut current_note_length_index41\
    \ = 1;\n    let mut current_note_length_index42 = 1;\n    let mut current_note_length_index43\
    \ = 1;\n    let mut current_note_length_index44 = 1;\n    let mut current_note_length_index45\
    \ = 1;\n    let mut current_note_length_index46 = 1;\n    let mut current_note_length_index47\
    \ = 1;\n    let mut current_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmh10knne.rs:62:21\n   |\n\
    62 |     let mut current_\n   |                     ^ help: add `;` here\n63 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmh10knne.rs:10:41\n\
    \   |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    for c in music_string.chars() {\n      \
    \  if c.is_whitespace() {\n            continue;\n        }\n        if c.is_ascii_digit()\
    \ {\n            current_note.push(c);\n            current_note_len = current_note.len();\n\
    \        } else {\n            if current_note_len == 0 {\n                continue;\n\
    \            }\n            if c.is_ascii_letter() {\n                let note\
    \ = current_note.to_string();\n                beats.push(current_beat + note.chars().filter(|c|\
    \ c.is_ascii_digit()).count());\n                current_beat = 0;\n         \
    \       current_note = String::new();\n                current_note_len = current_note.len();\n\
    \            } else {\n                current_note.push(c);\n               \
    \ current_note_len = current_note.len();\n            }\n        }\n    }\n  \
    \  beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmppwa4pkbe.rs:26:18\n   |\n26 |             if\
    \ c.is_ascii_letter() {\n   |                  ^^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppwa4pkbe.rs:38:5\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |                                         ----------\
    \ expected `Vec<isize>` because of return type\n...\n38 |     beats\n   |    \
    \ ^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<usize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut notes = music_string.chars().collect::<Vec<_>>();\n    let mut current_note\
    \ = notes.len() - 1;\n    let mut last_note = -1;\n    let mut last_beat = -1;\n\
    \    while current_note > -1 {\n        let note = notes[current_note];\n    \
    \    if note == 'o' {\n            if last_note == -1 {\n                last_note\
    \ = current_note;\n                last_beat = beats.len();\n            }\n \
    \           beats.push(beats.len());\n            current_note = -1;\n       \
    \ } else {\n            if note == '|' {\n                if last_note == -1 {\n\
    \                    last_note = current_note;\n                    last_beat\
    \ = beats.len();\n                }\n                beats.push(beats.len());\n\
    \                current_note = -1;\n            } else {\n                if\
    \ note == '.' {\n                    if last_note == -1 {\n                  \
    \      last_note = current_note;\n                        last_beat = beats.len();\n\
    \                    }\n                    beats.push(beats.len());\n       \
    \             current_note = -1;\n                } else {\n                 \
    \   current_note = -1;\n                }\n            }\n        }\n    }\n \
    \   beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmp0270rhf9.rs:16:26\n\
    \   |\n16 |     while current_note > -1 {\n   |                          ^^\n\
    \   |                          |\n   |                          cannot apply unary\
    \ operator `-`\n   |                          help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp0270rhf9.rs:14:25\n\
    \   |\n14 |     let mut last_note = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmp0270rhf9.rs:19:29\n   |\n19 | \
    \            if last_note == -1 {\n   |                             ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0277]: the trait bound\
    \ `usize: Neg` is not satisfied\n  --> /tmp/tmp0270rhf9.rs:15:25\n   |\n15 | \
    \    let mut last_beat = -1;\n   |                         ^^ the trait `Neg`\
    \ is not implemented for `usize`\n   |\n   = help: the following other types implement\
    \ trait `Neg`:\n             &f32\n             &f64\n             &i128\n   \
    \          &i16\n             &i32\n             &i64\n             &i8\n    \
    \         &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary\
    \ operator `-` to type `usize`\n  --> /tmp/tmp0270rhf9.rs:24:28\n   |\n24 |  \
    \           current_note = -1;\n   |                            ^^\n   |     \
    \                       |\n   |                            cannot apply unary\
    \ operator `-`\n   |                      "
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4\
    \ = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n\
    \    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let\
    \ mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut\
    \ current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13\
    \ = 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 =\
    \ 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n\
    \    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n  \
    \  let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let\
    \ mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut\
    \ current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26\
    \ = 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 =\
    \ 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n\
    \    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n  \
    \  let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let\
    \ mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut\
    \ current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39\
    \ = 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 =\
    \ 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n\
    \    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n  \
    \  let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let\
    \ mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut\
    \ current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52\
    \ = 0;\n    let mut current_note_oct53 = 0;\n    let mut current_note_\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyl45pi_p.rs:68:26\n   |\n\
    68 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n69 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyl45pi_p.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let mut current_note_length =\
    \ String::new();\n    let mut current_note_length = String::new();\n    let mut\
    \ current_note_length = String::new();\n    let mut current_note_length = String::new();\n\
    \    let mut current_note_length = String::new();\n    let mut current_note_length\
    \ = String::new();\n    let mut current_note_length = String::new();\n    let\
    \ mut current_note_length = String::new();\n    let \n}\n\nfn main() {\n    let\
    \ candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp1856e9ui.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = vec![];\n    let mut current_note\
    \ = String::new();\n    let mut current_beat = 0;\n    let mut current_note_index\
    \ = 0;\n    let mut current_note_length = 0;\n    let mut current_note_octave\
    \ = 0;\n    let mut current_note_octave_change = 0;\n    let mut current_note_octave_change_direction\
    \ = 0;\n    let mut current_note_octave_change_direction_change = 0;\n    let\
    \ mut current_note_octave_change_direction_change_direction = 0;\n    let mut\
    \ current_note_octave_change_direction_change_direction_change = 0;\n    let mut\
    \ current_note_octave_change_direction_change_direction_change_direction = 0;\n\
    \    let mut current_note_octave_change_direction_change_direction_change_direction_change\
    \ = 0;\n    let mut current_note_octave_change_direction_change_direction_change_direction_change_direction\
    \ = 0;\n    let mut current_note_octave_change_direction_change_direction_change_direction_change_direction_change\
    \ = 0;\n    let mut current_note_octave_change_direction_change_direction_change_direction_change_direction_change_direction\
    \ = 0;\n    let mut current_note_octave_change_direction_change_direction_change_direction_change_direction_change_direction\
    \ = 0;\n    let mut current_note_octave_change_direction_change_direction_change_direction_change_direction_change_direction\
    \ = 0;\n    let mut current_note_octave_change_direction_change_direction_change_direction_change_direction_change_direction_change\
    \ = 0;\n    let mut current_note_octave_change_direction_change_direction_change_direction_change_direction_change_direction_change_direction\
    \ = 0;\n    let mut current_note_octave_change_direction_change_direction_change_direction_change_direction_change_direction_change_direction\
    \ = 0;\n    let mut current_note_octave_change_direction_change_direction_change_direction_change_direction_change_direction_change_direction\
    \ = 0;\n    let mut current_note_octave_change_direction_change_direction_change_direction_change_direction_change_direction_change_direction_change\
    \ = 0;\n    let mut current_note_octave_change_direction_change_direction_change_direction_change_direction_change_direction_change_direction_change_direction\
    \ = 0;\n    let mut current_note_octave_change_direction_change_direction_change_direction_change_direction_change_direction_change_direction_change_direction\
    \ = 0;\n    let mut current_note_octave_change_direction_change_direction_change_direction_change_direction_\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx0imgax6.rs:37:101\n   |\n\
    37 |     let mut current_note_octave_change_direction_change_direction_change_direction_change_direction_\n\
    \   |                                                                        \
    \                             ^ help: add `;` here\n38 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx0imgax6.rs:10:41\n \
    \  |\n10 | fn parse_music(music_string: String) -> Vec<isize> {\n   |    -----------\
    \                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let\
    \ mut current_note_oct2 = 0;\n    for c in music_string.chars() {\n        if\
    \ c == 'o' {\n            if current_note_len == 0 {\n                println!(\"\
    Invalid music string\");\n                return beats;\n            }\n     \
    \       beats.push(current_beat);\n            current_beat = 0;\n           \
    \ current_note_len = 0;\n            current_note = String::new();\n         \
    \   current_note_oct = 0;\n            current_note_oct2 = 0;\n            current_note.push(c);\n\
    \        } else if c == '|' {\n            if current_note_len == 0 {\n      \
    \          println!(\"Invalid music string\");\n                return beats;\n\
    \            }\n            beats.push(current_beat);\n            current_beat\
    \ = 0;\n            current_note_len = 0;\n            current_note = String::new();\n\
    \            current_note_oct = 0;\n            current_note_oct2 = 0;\n     \
    \       current_note.push(c);\n        } else if c == '.' {\n            if current_note_len\
    \ == 0 {\n                println!(\"Invalid music string\");\n              \
    \  return beats;\n            }\n            beats.push(current_beat);\n     \
    \       current_beat = 0;\n            current_note_len = 0;\n            current_note\
    \ = String::new();\n            current_note_oct = 0;\n            current_note_oct2\
    \ = 0;\n            current_note.push(c);\n        } else if c == 'o' {\n    \
    \        current_note_oct += 1;\n        } else if c == '|' {\n            current_note_oct2\
    \ += 1;\n        } else if c == '.' {\n            current_note_oct += 1;\n  \
    \          current_note_oct2 += 1;\n        }\n        current_note_len = c.len_utf8();\n\
    \    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmp9nbt8gr_.rs:70:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011550
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    for c in music_string.chars() {\n      \
    \  if c == 'o' {\n            if current_note_len > 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_len = 0;\n            }\n        } else if c ==\
    \ '|' {\n            if current_note_len > 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_len = 0;\n            }\n        } else if c.is_whitespace()\
    \ {\n            continue;\n        } else {\n            current_note.push(c);\n\
    \            current_note_len = current_note.len();\n        }\n    }\n    if\
    \ current_note_len > 0 {\n        beats.push(current_beat);\n    }\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[4, 4, 4, 4]`', /tmp/tmp0pydi9q5.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011550
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    for\
    \ c in music_string.chars() {\n        if c.is_ascii() {\n            if c.is_ascii(10)\
    \ {\n                current_note = c.to_string();\n                current_note_len\
    \ = current_note.len();\n                current_note_oct = current_note.chars().next().unwrap();\n\
    \            } else {\n                let note = c.to_string();\n           \
    \     let note_len = note.len();\n                let note_oct = note.chars().next().unwrap();\n\
    \                if note_oct != current_note_oct {\n                    current_beat\
    \ = current_beat + 1;\n                    current_note = note.to_string();\n\
    \                    current_note_len = note_len;\n                    current_note_oct\
    \ = note_oct;\n                }\n            }\n        } else {\n          \
    \  if current_note_len == 0 {\n                beats.push(current_beat);\n   \
    \             current_beat = 0;\n                current_note = c.to_string();\n\
    \                current_note_len = current_note.len();\n                current_note_oct\
    \ = current_note.chars().next().unwrap();\n            } else {\n            \
    \    let note = c.to_string();\n                let note_len = note.len();\n \
    \               let note_oct = note.chars().next().unwrap();\n               \
    \ if note_oct != current_note_oct {\n                    current_beat = current_beat\
    \ + 1;\n                    current_note = note.to_string();\n               \
    \     current_note_len = note_len;\n                    current_note_oct = note_oct;\n\
    \                }\n            }\n        }\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpc5wd_jut.rs:18:18\n     |\n18   |             if c.is_ascii(10)\
    \ {\n     |                  ^^^^^^^^ -- supplied 1 argument\n     |         \
    \         |\n     |                  expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc5wd_jut.rs:21:36\n\
    \   |\n15 |     let mut current_note_oct = 0;\n   |                          \
    \      - expected due to this value\n...\n21 |                 current_note_oct\
    \ = current_note.chars().next().unwrap();\n   |                              \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpc5wd_jut.rs:26:32\n   |\n26 |  \
    \               if note_oct != current_note_oct {\n   |                      \
    \          ^^^^^^^^^^^^^^^^ expected `char`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc5wd_jut.rs:30:40\n   |\n15 |     let mut current_note_oct\
    \ = 0;\n   |                                - expected due to this value\n...\n\
    30 |                     current_note_oct = note_oct;\n   |                  \
    \                      ^^^^^^^^ expected integer, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc5wd_jut.rs:39:36\n   |\n15 |     let mut current_note_oct\
    \ = 0;\n   |                                - expected due to this value\n...\n\
    39 |                 current_note_oct = current_note.chars().next().unwrap();\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc5wd_jut.rs:44:32\n\
    \   |\n44 |                 if note_oct != current_note_oct {\n   |          \
    \                      ^^^^^^^^^^^^^^^^ expected `char`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc5wd_jut.rs:48:40\n   |\n15 |     let mut current_note_oct\
    \ = 0;\n   |                                - expected due to this value\n...\n\
    48 |                     current_note_oct = note_oct;\n   |                  \
    \           "
  stdout: ''
  timestamp: 1660011550
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut current_beat = 0;\n    let mut current_note = 0;\n    let mut current_note_length\
    \ = 0;\n    let mut current_note_length_index = 0;\n    let mut current_note_length_index2\
    \ = 0;\n    let mut current_note_length_index3 = 0;\n    let mut current_note_length_index4\
    \ = 0;\n    let mut current_note_length_index5 = 0;\n    let mut current_note_length_index6\
    \ = 0;\n    let mut current_note_length_index7 = 0;\n    let mut current_note_length_index8\
    \ = 0;\n    let mut current_note_length_index9 = 0;\n    let mut current_note_length_index10\
    \ = 0;\n    let mut current_note_length_index11 = 0;\n    let mut current_note_length_index12\
    \ = 0;\n    let mut current_note_length_index13 = 0;\n    let mut current_note_length_index14\
    \ = 0;\n    let mut current_note_length_index15 = 0;\n    let mut current_note_length_index16\
    \ = 0;\n    let mut current_note_length_index17 = 0;\n    let mut current_note_length_index18\
    \ = 0;\n    let mut current_note_length_index19 = 0;\n    let mut current_note_length_index20\
    \ = 0;\n    let mut current_note_length_index21 = 0;\n    let mut current_note_length_index22\
    \ = 0;\n    let mut current_note_length_index23 = 0;\n    let mut current_note_length_index24\
    \ = 0;\n    let mut current_note_length_index25 = 0;\n    let mut current_note_length_index26\
    \ = 0;\n    let mut current_note_length_index27 = 0;\n    let mut current_note_length_index28\
    \ = 0;\n    let mut current_note_length_index29 = 0;\n    let mut current_note_length_index30\
    \ = 0;\n    let mut current_note_length_index31 = 0;\n    let mut current_note_length_index32\
    \ = 0;\n    let mut current_note_length_index33 = 0;\n    let mut current_note_length_index34\
    \ = 0;\n    let mut current_note_length_index35 = 0;\n    let mut current_note_length_index36\
    \ = 0;\n    let mut current_note_length_index37 = 0;\n    let mut current_note_length_index38\
    \ = 0;\n    let mut current_note_length_index39 = 0;\n    let mut current_note_length_index40\
    \ = 0;\n    let mut current_note_length_index41 = 0;\n    let mut current_note_length_index42\
    \ = 0;\n    let mut current_note_length_index43 = 0;\n    let mut current_note_length_index44\
    \ = 0;\n    let mut current_note_length_index45 = 0;\n    let mut current_note_length_index46\
    \ = 0;\n    let mut current_note_length_index47 = 0;\n    let mut current_note_length_index48\
    \ = 0;\n    let mut current_note_\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaf_v5be6.rs:63:26\n   |\n\
    63 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpaf_v5be6.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = vec![];\n    let mut last_note = String::new();\n\
    \    let mut last_beat = 0;\n    let mut last_beat_index = 0;\n    let mut last_beat_length\
    \ = 0;\n    let mut last_beat_length_index = 0;\n    let mut last_beat_length_index2\
    \ = 0;\n    let mut last_beat_length_index3 = 0;\n    let mut last_beat_length_index4\
    \ = 0;\n    let mut last_beat_length_index5 = 0;\n    let mut last_beat_length_index6\
    \ = 0;\n    let mut last_beat_length_index7 = 0;\n    let mut last_beat_length_index8\
    \ = 0;\n    let mut last_beat_length_index9 = 0;\n    let mut last_beat_length_index10\
    \ = 0;\n    let mut last_beat_length_index11 = 0;\n    let mut last_beat_length_index12\
    \ = 0;\n    let mut last_beat_length_index13 = 0;\n    let mut last_beat_length_index14\
    \ = 0;\n    let mut last_beat_length_index15 = 0;\n    let mut last_beat_length_index16\
    \ = 0;\n    let mut last_beat_length_index17 = 0;\n    let mut last_beat_length_index18\
    \ = 0;\n    let mut last_beat_length_index19 = 0;\n    let mut last_beat_length_index20\
    \ = 0;\n    let mut last_beat_length_index21 = 0;\n    let mut last_beat_length_index22\
    \ = 0;\n    let mut last_beat_length_index23 = 0;\n    let mut last_beat_length_index24\
    \ = 0;\n    let mut last_beat_length_index25 = 0;\n    let mut last_beat_length_index26\
    \ = 0;\n    let mut last_beat_length_index27 = 0;\n    let mut last_beat_length_index28\
    \ = 0;\n    let mut last_beat_length_index29 = 0;\n    let mut last_beat_length_index30\
    \ = 0;\n    let mut last_beat_length_index31 = 0;\n    let mut last_beat_length_index32\
    \ = 0;\n    let mut last_beat_length_index33 = 0;\n    let mut last_beat_length_index34\
    \ = 0;\n    let mut last_beat_length_index35 = 0;\n    let mut last_beat_length_index36\
    \ = 0;\n    let mut last_beat_length_index37 = 0;\n    let mut last_beat_length_index38\
    \ = 0;\n    let mut last_beat_length_index39 = 0;\n    let mut last_beat_length_index40\
    \ = 0;\n    let mut last_beat_length_index41 = 0;\n    let \n}\n\nfn main() {\n\
    \    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\"\
    )), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\")),\
    \ vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\")),\
    \ vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o o\
    \ o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpjnglz0kj.rs:59:1\n  \
    \ |\n59 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut notes = music_string.chars().enumerate();\n    let mut current_note\
    \ = 0;\n    let mut last_note = 0;\n    let mut last_beat = 0;\n    let mut last_beats\
    \ = 0;\n    let mut last_beats_after_note = 0;\n    let mut last_beats_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_note = 0;\n    let mut last_beats_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_note = 0;\n    let\
    \ mut last_beats_after_notes_after_notes_after_notes = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_note\
    \ = 0;\n    let mut last_beats_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes_after_notes\
    \ = 0;\n    let mut last_beats_after_notes_after_\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjffs5ykd.rs:37:42\n   |\n\
    37 |     let mut last_beats_after_notes_after_\n   |                         \
    \                 ^ help: add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjffs5ykd.rs:10:41\n   |\n10 | fn parse_music(music_string:\
    \ String) -> Vec<isize> {\n   |    -----------                          ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = vec![];\n    let mut notes: Vec<&str> = vec![];\n    let mut last_note = String::from(\"\
    o\");\n    let mut last_beat = 0;\n    let mut last_beats: isize = 0;\n    let\
    \ mut last_beats_idx = 0;\n    let mut last_beats_idx2 = 0;\n    let mut last_beats_idx3\
    \ = 0;\n    let mut last_beats_idx4 = 0;\n    let mut last_beats_idx5 = 0;\n \
    \   let mut last_beats_idx6 = 0;\n    let mut last_beats_idx7 = 0;\n    let mut\
    \ last_beats_idx8 = 0;\n    let mut last_beats_idx9 = 0;\n    let mut last_beats_idx10\
    \ = 0;\n    let mut last_beats_idx11 = 0;\n    let mut last_beats_idx12 = 0;\n\
    \    let mut last_beats_idx13 = 0;\n    let mut last_beats_idx14 = 0;\n    let\
    \ mut last_beats_idx15 = 0;\n    let mut last_beats_idx16 = 0;\n    let mut last_beats_idx17\
    \ = 0;\n    let mut last_beats_idx18 = 0;\n    let mut last_beats_idx19 = 0;\n\
    \    let mut last_beats_idx20 = 0;\n    let mut last_beats_idx21 = 0;\n    let\
    \ mut last_beats_idx22 = 0;\n    let mut last_beats_idx23 = 0;\n    let mut last_beats_idx24\
    \ = 0;\n    let mut last_beats_idx25 = 0;\n    let mut last_beats_idx26 = 0;\n\
    \    let mut last_beats_idx27 = 0;\n    let mut last_beats_idx28 = 0;\n    let\
    \ mut last_beats_idx29 = 0;\n    let mut last_beats_idx30 = 0;\n    let mut last_beats_idx31\
    \ = 0;\n    let mut last_beats_idx32 = 0;\n    let mut last_beats_idx33 = 0;\n\
    \    let mut last_beats_idx34 = 0;\n    let mut last_beats_idx35 = 0;\n    let\
    \ mut last_beats_idx36 = 0;\n    let mut last_beats_idx37 = 0;\n    let mut last_beats_idx38\
    \ = 0;\n    let mut last_beats_idx39 = 0;\n    let mut last_beats_idx40 = 0;\n\
    \    let mut last_beats_idx41 = 0;\n    let mut last_beats_idx42 = 0;\n    let\
    \ mut last_beats_idx43 = 0;\n    let mut last_beats_idx44 = 0;\n    let mut last_beats_idx45\
    \ = 0;\n    let mut last_beats_idx\n}\n\nfn main() {\n    let candidate = parse_music;\n\
    \    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"\
    o o o o\")), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .|\
    \ .| .|\")), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o|\
    \ .| .| o o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv2fkps4z.rs:61:27\n   |\n\
    61 |     let mut last_beats_idx\n   |                           ^ help: add `;`\
    \ here\n62 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpv2fkps4z.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    for c in music_string.chars() {\n      \
    \  if c == 'o' {\n            if current_note_len > 0 {\n                beats.push(current_beat);\n\
    \                current_beat = 0;\n                current_note = String::new();\n\
    \                current_note_len = 0;\n            }\n        } else if c ==\
    \ '|' {\n            current_note_len = current_note.len() + 1;\n        } else\
    \ if c == '.' {\n            current_beat += 1;\n        }\n        current_note.push(c);\n\
    \    }\n    beats.push(current_beat);\n    beats\n}\n\nfn main() {\n    let candidate\
    \ = parse_music;\n    assert_eq!(candidate(String::from(\"\")), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(String::from(\"o o o o\")), vec![4, 4, 4, 4]);\n   \
    \ assert_eq!(candidate(String::from(\".| .| .| .|\")), vec![1, 1, 1, 1]);\n  \
    \  assert_eq!(candidate(String::from(\"o| o| .| .| o o o o\")), vec![2, 2, 1,\
    \ 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"o| .| o| .| o o| o\
    \ o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[]`', /tmp/tmppx6po5h4.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011550
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = Vec::new();\n\
    \    let mut notes = music_string.chars().collect::<Vec<_>>();\n    let mut current_note\
    \ = notes.len() - 1;\n    let mut last_note = notes.len() - 1;\n    let mut last_beat\
    \ = 0;\n    while current_note > 0 {\n        if notes[current_note] == '.' {\n\
    \            beats.push(last_beat);\n            last_beat = 0;\n            current_note--;\n\
    \            last_note = current_note;\n        } else {\n            last_beat\
    \ = last_beat + 1;\n            current_note--;\n        }\n    }\n    beats.push(last_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp8b_54w5g.rs:20:27\n\
    \   |\n20 |             current_note--;\n   |                           ^ expected\
    \ expression\n\nerror: expected expression, found `;`\n  --> /tmp/tmp8b_54w5g.rs:24:27\n\
    \   |\n24 |             current_note--;\n   |                           ^ expected\
    \ expression\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_len = 0;\n    let mut current_note_oct = 0;\n    let mut\
    \ current_note_oct2 = 0;\n    let mut current_note_oct3 = 0;\n    let mut current_note_oct4\
    \ = 0;\n    let mut current_note_oct5 = 0;\n    let mut current_note_oct6 = 0;\n\
    \    let mut current_note_oct7 = 0;\n    let mut current_note_oct8 = 0;\n    let\
    \ mut current_note_oct9 = 0;\n    let mut current_note_oct10 = 0;\n    let mut\
    \ current_note_oct11 = 0;\n    let mut current_note_oct12 = 0;\n    let mut current_note_oct13\
    \ = 0;\n    let mut current_note_oct14 = 0;\n    let mut current_note_oct15 =\
    \ 0;\n    let mut current_note_oct16 = 0;\n    let mut current_note_oct17 = 0;\n\
    \    let mut current_note_oct18 = 0;\n    let mut current_note_oct19 = 0;\n  \
    \  let mut current_note_oct20 = 0;\n    let mut current_note_oct21 = 0;\n    let\
    \ mut current_note_oct22 = 0;\n    let mut current_note_oct23 = 0;\n    let mut\
    \ current_note_oct24 = 0;\n    let mut current_note_oct25 = 0;\n    let mut current_note_oct26\
    \ = 0;\n    let mut current_note_oct27 = 0;\n    let mut current_note_oct28 =\
    \ 0;\n    let mut current_note_oct29 = 0;\n    let mut current_note_oct30 = 0;\n\
    \    let mut current_note_oct31 = 0;\n    let mut current_note_oct32 = 0;\n  \
    \  let mut current_note_oct33 = 0;\n    let mut current_note_oct34 = 0;\n    let\
    \ mut current_note_oct35 = 0;\n    let mut current_note_oct36 = 0;\n    let mut\
    \ current_note_oct37 = 0;\n    let mut current_note_oct38 = 0;\n    let mut current_note_oct39\
    \ = 0;\n    let mut current_note_oct40 = 0;\n    let mut current_note_oct41 =\
    \ 0;\n    let mut current_note_oct42 = 0;\n    let mut current_note_oct43 = 0;\n\
    \    let mut current_note_oct44 = 0;\n    let mut current_note_oct45 = 0;\n  \
    \  let mut current_note_oct46 = 0;\n    let mut current_note_oct47 = 0;\n    let\
    \ mut current_note_oct48 = 0;\n    let mut current_note_oct49 = 0;\n    let mut\
    \ current_note_oct50 = 0;\n    let mut current_note_oct51 = 0;\n    let mut current_note_oct52\
    \ = 0;\n    let mut current_note_oct53 = 0;\n    let mut current_note_\n}\n\n\
    fn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyl45pi_p.rs:68:26\n   |\n\
    68 |     let mut current_note_\n   |                          ^ help: add `;`\
    \ here\n69 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyl45pi_p.rs:10:41\n   |\n10 | fn parse_music(music_string: String) ->\
    \ Vec<isize> {\n   |    -----------                          ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011548
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats = vec![];\n\
    \    let mut current_beat = 0;\n    let mut current_note = String::new();\n  \
    \  let mut current_note_length = 0;\n    for c in music_string.chars() {\n   \
    \     if c.is_ascii() {\n            if c.is_ascii(8) {\n                if current_note.is_empty()\
    \ {\n                    current_note = c.to_string();\n                    current_note_length\
    \ = 1;\n                } else {\n                    current_note += c.to_string();\n\
    \                    current_note_length += 1\n                }\n           \
    \ } else {\n                if current_note.is_empty() {\n                   \
    \ current_note = c.to_string();\n                    current_note_length = 1;\n\
    \                } else {\n                    current_note += c.to_string();\n\
    \                    current_note_length += 1\n                }\n           \
    \ }\n        } else {\n            if current_note.is_empty() {\n            \
    \    current_note = c.to_string();\n                current_note_length = 1;\n\
    \            } else {\n                current_note += c.to_string();\n      \
    \          current_note_length += 1\n            }\n        }\n        if current_note_length\
    \ == 4 {\n            beats.push(current_beat);\n            current_beat = 0;\n\
    \            current_note_length = 0;\n            current_note = String::new();\n\
    \        }\n        current_beat += 1;\n    }\n    beats.push(current_beat);\n\
    \    beats\n}\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpt31gurpq.rs:17:18\n     |\n17   |             if c.is_ascii(8)\
    \ {\n     |                  ^^^^^^^^ - supplied 1 argument\n     |          \
    \        |\n     |                  expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt31gurpq.rs:22:37\n\
    \   |\n22 |                     current_note += c.to_string();\n   |         \
    \                            ^^^^^^^^^^^^^\n   |                             \
    \        |\n   |                                     expected `&str`, found struct\
    \ `String`\n   |                                     help: consider borrowing\
    \ here: `&c.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt31gurpq.rs:30:37\n\
    \   |\n30 |                     current_note += c.to_string();\n   |         \
    \                            ^^^^^^^^^^^^^\n   |                             \
    \        |\n   |                                     expected `&str`, found struct\
    \ `String`\n   |                                     help: consider borrowing\
    \ here: `&c.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt31gurpq.rs:39:33\n\
    \   |\n39 |                 current_note += c.to_string();\n   |             \
    \                    ^^^^^^^^^^^^^\n   |                                 |\n \
    \  |                                 expected `&str`, found struct `String`\n\
    \   |                                 help: consider borrowing here: `&c.to_string()`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// Input to this function is a string representing musical notes in a\
    \ special ASCII format.\n/// Your task is to parse this string and return list\
    \ of integers corresponding to how many beats does each\n/// not last.\n/// Here\
    \ is a legend:\n/// 'o' - whole note, lasts four beats\n/// 'o|' - half note,\
    \ lasts two beats\n/// '.|' - quater note, lasts one beat\n/// >>> parse_music(String::from(\"\
    o o| .| o| o| .| .| .| .| o o\"))\n/// vec![4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\
    fn parse_music(music_string: String) -> Vec<isize> {\n    let mut beats: Vec<isize>\
    \ = Vec::new();\n    let mut current_beat = 0;\n    let mut current_note = String::new();\n\
    \    let mut current_note_length = 0;\n    let mut current_note_length_index =\
    \ 0;\n    for c in music_string.chars() {\n        if c.is_ascii() {\n       \
    \     if current_note_length_index == 0 {\n                current_note += c;\n\
    \                current_note_length = 1;\n            } else {\n            \
    \    current_note += c;\n                current_note_length += 1;\n         \
    \   }\n            current_note_length_index += 1;\n        } else {\n       \
    \     if current_note_length_index == 0 {\n                current_note += c;\n\
    \                current_note_length = 1;\n            } else {\n            \
    \    current_note += c;\n                current_note_length += 1;\n         \
    \   }\n            current_note_length_index += 1;\n            if current_note_length_index\
    \ == 4 {\n                beats.push(current_beat);\n                current_beat\
    \ = 0;\n                current_note_length_index = 0;\n                current_note_length\
    \ = 1;\n            }\n        }\n    }\n    beats.push(current_beat);\n    beats\n\
    }\n\nfn main() {\n    let candidate = parse_music;\n    assert_eq!(candidate(String::from(\"\
    \")), Vec::<isize>::new());\n    assert_eq!(candidate(String::from(\"o o o o\"\
    )), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\".| .| .| .|\"\
    )), vec![1, 1, 1, 1]);\n    assert_eq!(candidate(String::from(\"o| o| .| .| o\
    \ o o o\")), vec![2, 2, 1, 1, 4, 4, 4, 4]);\n    assert_eq!(candidate(String::from(\"\
    o| .| o| .| o o| o o|\")), vec![2, 1, 2, 1, 4, 2, 4, 2]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn0wgusem.rs:19:33\n   |\n\
    19 |                 current_note += c;\n   |                                \
    \ ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn0wgusem.rs:22:33\n\
    \   |\n22 |                 current_note += c;\n   |                         \
    \        ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpn0wgusem.rs:28:33\n   |\n28 |                 current_note += c;\n\
    \   |                                 ^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn0wgusem.rs:31:33\n   |\n31 |              \
    \   current_note += c;\n   |                                 ^ expected `&str`,\
    \ found `char`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
