language: rs
name: HumanEval_25_factorize
results:
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n \
    \           factors.push(factor);\n            n /= factor;\n        }\n     \
    \   factor += 1;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp3ek8ue3e.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_counter = 1;\n    let mut factor\
    \ = 1;\n    let mut i = 1;\n    while i <= n {\n        if n % i == 0 {\n    \
    \        factors.push(factor);\n            factor = 1;\n            i += 1;\n\
    \        } else {\n            factor *= i;\n            primes.push(factor);\n\
    \            factor = 1;\n            i += 1;\n        }\n    }\n    factors.push(factor);\n\
    \    factors.push(prime_counter);\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1]`,\n right: `[2]`', /tmp/tmpsj58h_ek.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n            i += 1;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    factors.push(n);\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpoyd_euhh.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut factorization = Vec::new();\n    let mut factorization_primes = Vec::new();\n\
    \    let mut factorization_prime_factors = Vec::new();\n    let mut factorization_prime_factors_count\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max = Vec::new();\n\
    \    let mut factorization_prime_factors_count_max_index = Vec::new();\n    let\
    \ mut factorization_prime_factors_count_max_value = Vec::new();\n    let mut factorization_prime_factors_count_max_value_index\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime_index\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime_value\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime_value_index\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime_value_value\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime_value_value_index\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime_value_value_value\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime_value_value_index\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime_value_value_value\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime_value_value_index\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime_value_value_value\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime_value_value_index\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime_value_value_value\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime_value_value_index\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime_value_value_value\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime_value_value_index\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime_value_value_value\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime_value_value_index\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value_prime_value_value_value\
    \ = \n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp6ai960ui.rs:41:1\n\
    \   |\n41 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpduuwdehj.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpduuwdehj.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n    let\
    \ mut primes = vec![];\n    let mut primes_count = vec![];\n    let mut primes_count_max\
    \ = vec![];\n    let mut primes_count_max_index = vec![];\n    let mut primes_count_max_value\
    \ = vec![];\n    let mut primes_count_max_value_max = vec![];\n    let mut primes_count_max_value_max_index\
    \ = vec![];\n    let mut primes_count_max_value_max_value = vec![];\n    let mut\
    \ primes_count_max_value_max_value_index = vec![];\n    let mut primes_count_max_value_max_value_value\
    \ = vec![];\n    let mut primes_count_max_value_max_value_value_index = vec![];\n\
    \    let mut primes_count_max_value_max_value_value_value = vec![];\n    let mut\
    \ primes_count_max_value_max_value_value_value_index = vec![];\n    let mut primes_count_max_value_max_value_value_value_value\
    \ = vec![];\n    let mut primes_count_max_value_max_value_value_value_value_index\
    \ = vec![];\n    let mut primes_count_max_value_max_value_value_value_value_value\
    \ = vec![];\n    let mut primes_count_max_value_max_value_value_value_value_value_index\
    \ = vec![];\n    let mut primes_count_max_value_max_value_value_value_value_value_value\
    \ = vec![];\n    let mut primes_count_max_value_max_value_value_value_value_value_index\
    \ = vec![];\n    let mut primes_count_max_value_max_value_value_value_value_value_value\
    \ = vec![];\n    let mut primes_count_max_value_max_value_value_value_value_value_index\
    \ = vec![];\n    let mut primes_count_max_value_max_value_value_value_value_value_value\
    \ = vec![];\n    let mut primes_count_max_value_max_value_value_value_value_value_value_index\
    \ = vec![];\n    let mut primes_count_max_value_max_value_value_value_value_value_value_value\
    \ = vec![];\n    let mut primes_count_max_value_max_value_value_value_value_value_value_index\
    \ = vec![];\n    let mut primes_count_max_value_max_value_value_value_value_value_value_value\
    \ = vec![];\n    let mut primes_count_max_value_max_value_value_value_value_value_value_index\
    \ = vec![];\n    let mut primes_count_max_value_max_value_value_value_value_value_value_value\
    \ = vec![];\n    let mut primes_count_max_value_max_value_value_value_value_value_value_index\
    \ = vec![];\n    let mut primes_count_max_value_max_value_value_value_value_value_value_value\
    \ = vec![];\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n  \
    \  assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n\
    \    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3,\
    \ 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr3b141f8.rs:42:11\n   |\n\
    42 |     let mu\n   |           ^ help: add `;` here\n43 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr3b141f8.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        else {\n       \
    \     i += 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpa6kznut5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_index = Vec::new();\n    let mut prime_factors_count_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value_max\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_max = Vec::new();\n\
    \    let mut prime_factors_count_max_value_min = Vec::new();\n    let mut prime_factors_count_min_value_min\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_index = Vec::new();\n\
    \    let mut prime_factors_count_min_value_min_index = Vec::new();\n    let mut\
    \ prime_factors_count_max_value_min_value = Vec::new();\n    let mut prime_factors_count_min_value_min_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_value_max = Vec::new();\n\
    \    let mut prime_factors_count_min_value_min_value_max = Vec::new();\n    let\
    \ mut prime_factors_count_max_value_min_value_min = Vec::new();\n    let mut prime_factors_count_min_value_min_value_min\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_value_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_min_value_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_value_min_value\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_min_value_min_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_value_min_value_max\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_min_value_min_value_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_value_min_value_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_min_value_min_value_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_min_value_min_value_min_value\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_min_value_min_value_value\
    \ = Vec::new();\n    let mut prime_factors_\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsy159oof.rs:43:27\n   |\n\
    43 |     let mut prime_factors_\n   |                           ^ help: add `;`\
    \ here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpsy159oof.rs:10:27\n   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n\
    \   |    ---------              ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp5h6q1l78.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n    \
    \        factors.push(factor);\n            n /= factor;\n        } else {\n \
    \           factor *= factor;\n        }\n    }\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpsln1sf8i.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_counter = Vec::new();\n   \
    \ let mut prime_counter2 = Vec::new();\n    let mut prime_counter3 = Vec::new();\n\
    \    let mut prime_counter4 = Vec::new();\n    let mut prime_counter5 = Vec::new();\n\
    \    let mut prime_counter6 = Vec::new();\n    let mut prime_counter7 = Vec::new();\n\
    \    let mut prime_counter8 = Vec::new();\n    let mut prime_counter9 = Vec::new();\n\
    \    let mut prime_counter10 = Vec::new();\n    let mut prime_counter11 = Vec::new();\n\
    \    let mut prime_counter12 = Vec::new();\n    let mut prime_counter13 = Vec::new();\n\
    \    let mut prime_counter14 = Vec::new();\n    let mut prime_counter15 = Vec::new();\n\
    \    let mut prime_counter16 = Vec::new();\n    let mut prime_counter17 = Vec::new();\n\
    \    let mut prime_counter18 = Vec::new();\n    let mut prime_counter19 = Vec::new();\n\
    \    let mut prime_counter20 = Vec::new();\n    let mut prime_counter21 = Vec::new();\n\
    \    let mut prime_counter22 = Vec::new();\n    let mut prime_counter23 = Vec::new();\n\
    \    let mut prime_counter24 = Vec::new();\n    let mut prime_counter25 = Vec::new();\n\
    \    let mut prime_counter26 = Vec::new();\n    let mut prime_counter27 = Vec::new();\n\
    \    let mut prime_counter28 = Vec::new();\n    let mut prime_counter29 = Vec::new();\n\
    \    let mut prime_counter30 = Vec::new();\n    let mut prime_counter31 = Vec::new();\n\
    \    let mut prime_counter32 = Vec::new();\n    let mut prime_counter33 = Vec::new();\n\
    \    let mut prime_counter34 = Vec::new();\n    let mut prime_counter35 = Vec::new();\n\
    \    let mut prime_counter36 = Vec::new();\n    let mut prime_counter37 = Vec::new();\n\
    \    let mut prime_counter38 = Vec::new();\n    let mut prime_counter39 = Vec::\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1dlt87d1.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_min = Vec::new();\n    let mut prime_factors_count_max_min_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min = Vec::new();\n\
    \    let mut prime_factors_count_max_min_max_min_max = Vec::new();\n    let mut\
    \ prime_factors_count_max_min_max_min_max_min = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max_min\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max_min_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max_min_max_min\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min\
    \ = Vec::new();\n    let mut prime_factors_count_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max_min_max\
    \ = Vec::new();\n\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2xo4hzpz.rs:10:27\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n    let\
    \ mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            factors.push(i);\n\
    \            i += 1;\n        }\n        else {\n            i += 1;\n       \
    \ }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n  \
    \  assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n\
    \    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3,\
    \ 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpwut0n8xs.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpduuwdehj.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpduuwdehj.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n    let\
    \ mut primes = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size\
    \ = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n\
    \    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let\
    \ mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size\
    \ = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n\
    \    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let\
    \ mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size\
    \ = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n\
    \    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let\
    \ mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size\
    \ = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n\
    \    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let\
    \ mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size\
    \ = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n\
    \    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let\
    \ mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size\
    \ = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n\
    \    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let\
    \ mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size\
    \ = vec![];\n    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n\
    \    let mut primes_size = vec![];\n    let mut primes_size = vec![];\n    let\
    \ mut primes_size = vec![];\n    let mut prime\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxt1n421p.rs:62:18\n   |\n\
    62 |     let mut prime\n   |                  ^ help: add `;` here\n63 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxt1n421p.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n \
    \           factors.push(factor);\n            n /= factor;\n        }\n     \
    \   factor *= 2;\n    }\n    factors.push(1);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpf7t0nr19.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_counter = 1;\n    let mut i\
    \ = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            primes.push(i);\n\
    \            prime_counter *= i;\n        }\n        i += 1;\n    }\n    primes.sort_unstable();\n\
    \    for i in primes.rev() {\n        while n % i == 0 {\n            factors.push(i);\n\
    \            n /= i;\n        }\n    }\n    factors.push(prime_counter);\n   \
    \ factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpezzztrxn.rs:23:21\n\
    \    |\n23  |       for i in primes.rev() {\n    |                       ^^^ `Vec<isize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n    let\
    \ mut primes = vec![];\n    let mut prime_factors = vec![];\n    let mut prime_factors_count\
    \ = vec![];\n    let mut prime_factors_count_max = vec![];\n    let mut prime_factors_count_max_index\
    \ = vec![];\n    let mut prime_factors_count_max_value = vec![];\n    let mut\
    \ prime_factors_count_max_value_max = vec![];\n    let mut prime_factors_count_max_value_max_index\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_value = vec![];\n \
    \   let mut prime_factors_count_max_value_max_index = 0;\n    let mut prime_factors_count_max_value_max_value\
    \ = 0;\n    let mut prime_factors_count_max_value_max_index = 0;\n    let mut\
    \ prime_factors_count_max_value_max_value = 0;\n    let mut prime_factors_count_max_value_max_index\
    \ = 0;\n    let mut prime_factors_count_max_value_max_value = 0;\n    let mut\
    \ prime_factors_count_max_value_max_index = 0;\n    let mut prime_factors_count_max_value_max_value\
    \ = 0;\n    let mut prime_factors_count_max_value_max_index = 0;\n    let mut\
    \ prime_factors_count_max_value_max_value = 0;\n    let mut prime_factors_count_max_value_max_index\
    \ = 0;\n    let mut prime_factors_count_max_value_max_value = 0;\n    let mut\
    \ prime_factors_count_max_value_max_index = 0;\n    let mut prime_factors_count_max_value_max_value\
    \ = 0;\n    let mut prime_factors_count_max_value_max_index = 0;\n    let mut\
    \ prime_factors_count_max_value_max_value = 0;\n    let mut prime_factors_count_max_value_max_index\
    \ = 0;\n    let mut prime_factors_count_max_value_max_value = 0;\n    let mut\
    \ prime_factors_count_max_value_max_index = 0;\n    let mut prime_factors_count_max_value_max_value\
    \ = 0;\n    let mut prime_factors_count_max_value_max_index = 0;\n    let mut\
    \ prime_factors_count_max_value_max_value = 0;\n    let mut prime_factors_count_max_value_max_index\
    \ = 0;\n    let mut prime_factors_count_max_value_max_value = 0;\n    let mut\
    \ prime_factors_count_max_value_max_index = 0;\n    let mut prime_factors_count_max_value_max_value\
    \ = 0;\n    let mut prime_factors_count_max_value_max_index = 0;\n    let mut\
    \ prime_factors_count_max_value_max_value = 0;\n    let mut prime_factors_count_max_value_max_index\
    \ = 0;\n    let mut prime_factors_count_max_value_max_value = 0;\n    let \n}\n\
    \nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp4pbd8ndp.rs:52:1\n  \
    \ |\n52 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n \
    \           factors.push(factor);\n            n /= factor;\n        }\n     \
    \   factor *= 2;\n    }\n    factors.push(1);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpf7t0nr19.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_counter = 1;\n    let mut prime_factor\
    \ = 1;\n    let mut factor = 1;\n    let mut counter = 1;\n    let mut i = 2;\n\
    \    while i <= n {\n        if n % i == 0 {\n            primes.push(i);\n  \
    \          prime_counter *= i;\n            factors.push(factor);\n          \
    \  factor = 1;\n            i += 1;\n        } else {\n            factor += 1;\n\
    \        }\n        counter += 1;\n    }\n    factors.push(factor);\n    primes.push(prime_counter);\n\
    \    primes.push(prime_counter);\n    primes.push(prime_counter);\n    primes.push(prime_counter);\n\
    \    primes.push(prime_counter);\n    primes.push(prime_counter);\n    primes.push(prime_counter);\n\
    \    primes.push(prime_counter);\n    primes.push(prime_counter);\n    primes.push(prime_counter);\n\
    \    primes.push(prime_counter);\n    primes.push(prime_counter);\n    primes.push(prime_counter);\n\
    \    primes.push(prime_counter);\n    primes.push(prime_counter);\n    primes.push(prime_counter);\n\
    \    primes.push(prime_counter);\n    primes.push(prime_counter);\n    primes.push(prime_counter);\n\
    \    primes.push(prime_counter);\n    primes.push(prime_counter);\n    primes.push(prime_counter);\n\
    \    primes.push(prime_counter);\n    primes.push(prime_counter);\n    primes.push(prime_counter);\n\
    \    primes.push(prime_counter);\n    primes.push(prime_counter);\n    primes.push(prime_counter);\n\
    \    primes.push(prime_counter);\n    primes.push(prime_counter);\n    primes.push(prime_counter);\n\
    \    primes.push(prime_counter);\n    primes.push(prime_counter);\n    primes.push(prime_counter);\n\
    \    primes.push(prime_counter);\n    primes.push(prime_counter);\n    primes.push(prime_counter);\n\
    \    primes.push(prime_counter);\n    primes.push(prime_counter);\n    primes.push(prime_counter);\n\
    \    primes.push(prime_counter);\n    primes.push(prime_counter);\n    primes.push(prime_counter);\n\
    \    primes.push(prime_counter);\n    primes.push(prime_counter);\n    primes.push(prime_counter);\n\
    \    primes.push(prime_counter);\n    primes.push(prime_counter);\n    primes.push(prime_counter);\n\
    \    primes.push(prime_counter);\n    \n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp764pm32_.rs:10:27\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut i = 2;\n    while i <= n {\n    \
    \    if n % i == 0 {\n            factors.push(i);\n            primes.push(i);\n\
    \        }\n        i += 1;\n    }\n    factors.sort_unstable();\n    primes.sort_unstable();\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4]`,\n right: `[2, 2]`', /tmp/tmpzgmlnre7.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_counter = Vec::new();\n   \
    \ let mut prime_counter2 = Vec::new();\n    let mut prime_counter3 = Vec::new();\n\
    \    let mut prime_counter4 = Vec::new();\n    let mut prime_counter5 = Vec::new();\n\
    \    let mut prime_counter6 = Vec::new();\n    let mut prime_counter7 = Vec::new();\n\
    \    let mut prime_counter8 = Vec::new();\n    let mut prime_counter9 = Vec::new();\n\
    \    let mut prime_counter10 = Vec::new();\n    let mut prime_counter11 = Vec::new();\n\
    \    let mut prime_counter12 = Vec::new();\n    let mut prime_counter13 = Vec::new();\n\
    \    let mut prime_counter14 = Vec::new();\n    let mut prime_counter15 = Vec::new();\n\
    \    let mut prime_counter16 = Vec::new();\n    let mut prime_counter17 = Vec::new();\n\
    \    let mut prime_counter18 = Vec::new();\n    let mut prime_counter19 = Vec::new();\n\
    \    let mut prime_counter20 = Vec::new();\n    let mut prime_counter21 = Vec::new();\n\
    \    let mut prime_counter22 = Vec::new();\n    let mut prime_counter23 = Vec::new();\n\
    \    let mut prime_counter24 = Vec::new();\n    let mut prime_counter25 = Vec::new();\n\
    \    let mut prime_counter26 = Vec::new();\n    let mut prime_counter27 = Vec::new();\n\
    \    let mut prime_counter28 = Vec::new();\n    let mut prime_counter29 = Vec::new();\n\
    \    let mut prime_counter30 = Vec::new();\n    let mut prime_counter31 = Vec::new();\n\
    \    let mut prime_counter32 = Vec::new();\n    let mut prime_counter33 = Vec::new();\n\
    \    let mut prime_counter34 = Vec::new();\n    let mut prime_counter35 = Vec::new();\n\
    \    let mut prime_counter36 = Vec::new();\n    let mut prime_counter37 = Vec::new();\n\
    \    let mut prime_counter38 = Vec::new();\n    let mut prime_counter39 = Vec::\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1dlt87d1.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n    let\
    \ mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            factors.push(i);\n\
    \            n /= i;\n            i += 1;\n        }\n    }\n    if n > 1 {\n\
    \        factors.push(n);\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpnvtv3j3a.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_counter = Vec::new();\n   \
    \ let mut prime_counter2 = Vec::new();\n    let mut prime_counter3 = Vec::new();\n\
    \    let mut prime_counter4 = Vec::new();\n    let mut prime_counter5 = Vec::new();\n\
    \    let mut prime_counter6 = Vec::new();\n    let mut prime_counter7 = Vec::new();\n\
    \    let mut prime_counter8 = Vec::new();\n    let mut prime_counter9 = Vec::new();\n\
    \    let mut prime_counter10 = Vec::new();\n    let mut prime_counter11 = Vec::new();\n\
    \    let mut prime_counter12 = Vec::new();\n    let mut prime_counter13 = Vec::new();\n\
    \    let mut prime_counter14 = Vec::new();\n    let mut prime_counter15 = Vec::new();\n\
    \    let mut prime_counter16 = Vec::new();\n    let mut prime_counter17 = Vec::new();\n\
    \    let mut prime_counter18 = Vec::new();\n    let mut prime_counter19 = Vec::new();\n\
    \    let mut prime_counter20 = Vec::new();\n    let mut prime_counter21 = Vec::new();\n\
    \    let mut prime_counter22 = Vec::new();\n    let mut prime_counter23 = Vec::new();\n\
    \    let mut prime_counter24 = Vec::new();\n    let mut prime_counter25 = Vec::new();\n\
    \    let mut prime_counter26 = Vec::new();\n    let mut prime_counter27 = Vec::new();\n\
    \    let mut prime_counter28 = Vec::new();\n    let mut prime_counter29 = Vec::new();\n\
    \    let mut prime_counter30 = Vec::new();\n    let mut prime_counter31 = Vec::new();\n\
    \    let mut prime_counter32 = Vec::new();\n    let mut prime_counter33 = Vec::new();\n\
    \    let mut prime_counter34 = Vec::new();\n    let mut prime_counter35 = Vec::new();\n\
    \    let mut prime_counter36 = Vec::new();\n    let mut prime_counter37 = Vec::new();\n\
    \    let mut prime_counter38 = Vec::new();\n    let mut prime_counter39 = Vec::\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1dlt87d1.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n    \
    \        factors.push(factor);\n            n /= factor;\n        } else {\n \
    \           factor *= factor;\n        }\n    }\n    factors.push(factor);\n \
    \   factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpzzcrku80.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpduuwdehj.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpduuwdehj.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_counter = Vec::new();\n    let mut factorization = Vec::new();\n\
    \    let mut factorization_counter = Vec::new();\n    let mut factorization_counter2\
    \ = Vec::new();\n    let mut factorization_counter3 = Vec::new();\n    let mut\
    \ factorization_counter4 = Vec::new();\n    let mut factorization_counter5 = Vec::new();\n\
    \    let mut factorization_counter6 = Vec::new();\n    let mut factorization_counter7\
    \ = Vec::new();\n    let mut factorization_counter8 = Vec::new();\n    let mut\
    \ factorization_counter9 = Vec::new();\n    let mut factorization_counter10 =\
    \ Vec::new();\n    let mut factorization_counter11 = Vec::new();\n    let mut\
    \ factorization_counter12 = Vec::new();\n    let mut factorization_counter13 =\
    \ Vec::new();\n    let mut factorization_counter14 = Vec::new();\n    let mut\
    \ factorization_counter15 = Vec::new();\n    let mut factorization_counter16 =\
    \ Vec::new();\n    let mut factorization_counter17 = Vec::new();\n    let mut\
    \ factorization_counter18 = Vec::new();\n    let mut factorization_counter19 =\
    \ Vec::new();\n    let mut factorization_counter20 = Vec::new();\n    let mut\
    \ factorization_counter21 = Vec::new();\n    let mut factorization_counter22 =\
    \ Vec::new();\n    let mut factorization_counter23 = Vec::new();\n    let mut\
    \ factorization_counter24 = Vec::new();\n    let mut factorization_counter25 =\
    \ Vec::new();\n    let mut factorization_counter26 = Vec::new();\n    let mut\
    \ factorization_counter27 = Vec::new();\n    let mut factorization_counter28 =\
    \ Vec::new();\n    let mut factorization_counter29 = Vec::new();\n    let mut\
    \ factorization_counter30 = Vec::new();\n    let mut factorization_counter31 =\
    \ Vec::new();\n    let mut factorization_counter32 = Vec::new();\n    let mut\
    \ factorization_counter33 = Vec::new();\n    let mut factorization_counter34 =\
    \ Vec::new();\n    let mut factorization_counter35 = Vec::new();\n    let mut\
    \ factorization_counter36 = Vec::new();\n    let \n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp539soxz9.rs:53:1\n  \
    \ |\n53 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n    \
    \        factors.push(factor);\n            n /= factor;\n        } else {\n \
    \           factor *= factor;\n        }\n    }\n    factors.push(factor);\n \
    \   factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpzzcrku80.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = vec![true; n];\n    let mut prime_factors = Vec::new();\n\
    \    let mut prime_factors_count = vec![0; n];\n    let mut prime_factors_count_max\
    \ = vec![0; n];\n    let mut prime_factors_count_min = vec![0; n];\n    let mut\
    \ prime_factors_count_sum = vec![0; n];\n    let mut prime_factors_count_sum_max\
    \ = vec![0; n];\n    let mut prime_factors_count_sum_min = vec![0; n];\n    let\
    \ mut prime_factors_count_product = vec![0; n];\n    let mut prime_factors_count_product_max\
    \ = vec![0; n];\n    let mut prime_factors_count_product_min = vec![0; n];\n \
    \   let mut prime_factors_count_product_sum = vec![0; n];\n    let mut prime_factors_count_product_sum_max\
    \ = vec![0; n];\n    let mut prime_factors_count_product_sum_min = vec![0; n];\n\
    \    let mut prime_factors_count_product_product = vec![0; n];\n    let mut prime_factors_count_product_product_max\
    \ = vec![0; n];\n    let mut prime_factors_count_product_product_min = vec![0;\
    \ n];\n    let mut prime_factors_count_product_product_sum = vec![0; n];\n   \
    \ let mut prime_factors_count_product_product_sum_max = vec![0; n];\n    let mut\
    \ prime_factors_count_product_product_sum_min = vec![0; n];\n    let mut prime_factors_count_product_product_product\
    \ = vec![0; n];\n    let mut prime_factors_count_product_product_product_max =\
    \ vec![0; n];\n    let mut prime_factors_count_product_product_product_min = vec![0;\
    \ n];\n    let mut prime_factors_count_product_product_product_sum = vec![0; n];\n\
    \    let mut prime_factors_count_product_product_product_sum_max = vec![0; n];\n\
    \    let mut prime_factors_count_product_product_product_sum_min = vec![0; n];\n\
    \    let mut prime_factors_count_product_product_product_product = vec![0; n];\n\
    \    let mut prime_factors_count_product_product_product_product_max = vec![0;\
    \ n];\n    let mut prime_factors_count_product_product_product_product_min = vec![0;\
    \ n];\n    let mut prime_factors_count_product_product_product_product_sum = vec![0;\
    \ n];\n    let mut prime_factors_count_product_product_product_sum_max = vec![0;\
    \ n];\n    let mut prime_factors_count_product_product_product_\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppc45_g4u.rs:43:57\n   |\n\
    43 |     let mut prime_factors_count_product_product_product_\n   |          \
    \                                               ^ help: add `;` here\n44 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppc45_g4u.rs:12:33\n\
    \   |\n12 |     let mut primes = vec![true; n];\n   |                        \
    \         ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut primes = vec![true; n.try_into().unwrap()];\n   |                      \
    \            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppc45_g4u.rs:14:43\n\
    \   |\n14 |     let mut prime_factors_count = vec![0; n];\n   |              \
    \                             ^ expected `usize`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n14 |     let mut prime_factors_count = vec![0; n.try_into().unwrap()];\n\
    \   |                                            ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppc45_g4u.rs:15:47\n   |\n15 |     let mut prime_factors_count_max\
    \ = vec![0; n];\n   |                                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n15 |     let mut prime_factors_count_max\
    \ = vec![0; n.try_into().unwrap()];\n   |                                    \
    \            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppc45_g4u.rs:16:47\n\
    \   |\n16 |     let mut prime_factors_count_min = vec![0; n];\n   |          \
    \                                     ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n16 |     let mut prime_factors_count_min = vec![0; n.try_into().unwrap()];\n\
    \   |                                                ++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tm"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp5h6q1l78.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpduuwdehj.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpduuwdehj.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp5h6q1l78.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = vec![true; n + 1];\n    primes[0] = false;\n    for i in 1..=n\
    \ {\n        if primes[i] {\n            let mut j = 2;\n            while i *\
    \ j < n {\n                if n % i == 0 {\n                    factors.push(i);\n\
    \                    n /= i;\n                    break;\n                }\n\
    \                j +=1;\n            }\n        }\n    }\n    factors\n}\n\nfn\
    \ main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjd6el4dd.rs:12:33\n   |\n\
    12 |     let mut primes = vec![true; n + 1];\n   |                           \
    \      ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut primes = vec![true; (n + 1).try_into().unwrap()];\n   |                \
    \                 +     +++++++++++++++++++++\n\nerror[E0277]: the type `[bool]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpjd6el4dd.rs:15:12\n   |\n15 |  \
    \       if primes[i] {\n   |            ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n \
    \           factors.push(factor);\n            n /= factor;\n        }\n     \
    \   factor *= 2;\n    }\n    factors.push(factor);\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpekys9nb2.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpzzsjvzuv.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n            i += 1;\n        }\n  \
    \  }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpgrv5015d.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        else {\n       \
    \     i += 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpa6kznut5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut factorization = Vec::new();\n\
    \    let mut factorization_count = Vec::new();\n    let mut factorization_primes\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_prime\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpksrnp0lt.rs:51:32\n   |\n\
    51 |     let mut factorization_prime\n   |                                ^ help:\
    \ add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpksrnp0lt.rs:10:27\n   |\n10 | fn factorize(n: isize) -> Vec<isize>\
    \ {\n   |    ---------              ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_index = Vec::new();\n    let mut prime_factors_count_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value_pos\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_pos = Vec::new();\n\
    \    let mut prime_factors_count_max_value_neg = Vec::new();\n    let mut prime_factors_count_min_value_neg\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_pos_neg = Vec::new();\n\
    \    let mut prime_factors_count_min_value_pos_neg = Vec::new();\n    let mut\
    \ prime_factors_count_max_value_neg_pos = Vec::new();\n    let mut prime_factors_count_min_value_neg_pos\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_pos_neg_neg = Vec::new();\n\
    \    let mut prime_factors_count_min_value_pos_neg_neg = Vec::new();\n    let\
    \ mut prime_factors_count_max_value_neg_pos_pos = Vec::new();\n    let mut prime_factors_count_min_value_neg_pos_pos\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_pos_neg_neg = Vec::new();\n\
    \    let mut prime_factors_count_min_value_pos_neg_neg = Vec::new();\n    let\
    \ mut prime_factors_count_max_value_neg_pos_pos_pos = Vec::new();\n    let mut\
    \ prime_factors_count_min_value_neg_pos_pos_pos = Vec::new();\n    let mut prime_factors_count_max_value_neg_pos_neg_pos\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_neg_pos_neg_pos = Vec::new();\n\
    \    let mut prime_factors_count_max_value_neg_pos_pos_neg_pos = Vec::new();\n\
    \    let mut prime_factors_count_min_value_neg_pos_neg_pos_pos = Vec::new();\n\
    \    let mut prime_factors_count_max_value_neg_pos_pos_neg_pos = Vec::new();\n\
    \    let mut prime_factors_count_min_value_neg_pos_neg_pos_pos = Vec::new();\n\
    \    let mut prime_factors_count_max_value_neg_pos_pos_neg_\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplq10n0xa.rs:43:59\n   |\n\
    43 |     let mut prime_factors_count_max_value_neg_pos_pos_neg_\n   |        \
    \                                                   ^ help: add `;` here\n44 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplq10n0xa.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n        }\n        i += 1;\n    }\n\
    \    if n > 1 {\n        factors.push(n);\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmph_0k541y.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    if n > 1 {\n        factors.push(n);\n    }\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmphwn1t89z.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_count = Vec::new();\n    let mut primes_count_size = Vec::new();\n\
    \    let mut primes_count_size = Vec::new();\n    let mut primes_count_size =\
    \ Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp58k38grs.rs:54:11\n   |\n\
    54 |     let mu\n   |           ^ help: add `;` here\n55 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp58k38grs.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n \
    \           factors.push(factor);\n            n /= factor;\n        }\n     \
    \   factor *= 2;\n    }\n    factors.push(1);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpf7t0nr19.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    let mut prime_factor = 1;\n    let mut prime_divisor\
    \ = 1;\n    let mut prime_divisors = Vec::new();\n    let mut prime_divisors_counter\
    \ = 1;\n    let mut prime_divisors_counters = Vec::new();\n    let mut prime_divisors_counters_counter\
    \ = 1;\n    let mut prime_divisors_counters_counters = Vec::new();\n    let mut\
    \ prime_divisors_counters_counters_counter = 1;\n    let mut prime_divisors_counters_counters_counters\
    \ = Vec::new();\n    let mut prime_divisors_counters_counters_counters_counter\
    \ = 1;\n    let mut prime_divisors_counters_counters_counters_counters = Vec::new();\n\
    \    let mut prime_divisors_counters_counters_counters_counters_counter = 1;\n\
    \    let mut prime_divisors_counters_counters_counters_counters_counters = Vec::new();\n\
    \    let mut prime_divisors_counters_counters_counters_counters_counters_counter\
    \ = 1;\n    let mut prime_divisors_counters_counters_counters_counters_counters_counters\
    \ = Vec::new();\n    let mut prime_divisors_counters_counters_counters_counters_counters_counters_counter\
    \ = 1;\n    let mut prime_divisors_counters_counters_counters_counters_counters_counters_counters\
    \ = Vec::new();\n    let mut prime_divisors_counters_counters_counters_counters_counters_counters_counters_counter\
    \ = 1;\n    let mut prime_divisors_counters_counters_counters_counters_counters_counters_counters_counters\
    \ = Vec::new();\n    let mut prime_divisors_counters_counters_counters_counters_counters_counters_counters_counters_counter\
    \ = 1;\n    let mut prime_divisors_counters_counters_counters_counters_counters_counters_counters_counters_counters\
    \ = Vec::new();\n    let mut prime_divisors_counters_counters_counters_counters_counters_counters_counters_counters_counter\
    \ = 1;\n    let mut prime_divisors_counters_counters_counters_counters_counters_counters_counters_counters_counters\
    \ = Vec::new();\n    let mut prime_divisors_counters_counters_counters_counters_counters_counters_counters_counters_counters_counter\
    \ = 1;\n    let mut prime_divisors_counters_counters_counters_counters_counters_counters_counters_counters_counters_\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsdjia59w.rs:37:109\n   |\n\
    37 |     let mut prime_divisors_counters_counters_counters_counters_counters_counters_counters_counters_counters_\n\
    \   |                                                                        \
    \                                     ^ help: add `;` here\n38 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdjia59w.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n            i += 1;\n        }\n  \
    \      else {\n            i += 1;\n        }\n    }\n    factors.push(n);\n \
    \   factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpaxunri0a.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n          \
    \  factors.push(i);\n            primes.push(i);\n            prime_factors.push(1);\n\
    \        }\n        i += 1;\n    }\n    for i in factors.iter() {\n        for\
    \ j in prime_factors.iter() {\n            if j == i {\n                prime_factors.push(j\
    \ + 1);\n                break;\n            }\n        }\n    }\n    for i in\
    \ prime_factors.iter() {\n        if n % i == 0 {\n            factors.push(i);\n\
    \        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg1uuknnu.rs:33:26\n   |\n\
    33 |             factors.push(i);\n   |                          ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n33 |  \
    \           factors.push(*i);\n   |                          +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 0 {\n        if n % factor == 0 {\n    \
    \        factors.push(factor);\n            n /= factor;\n        } else {\n \
    \           factor *= factor;\n        }\n    }\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpe8f91h4t.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = vec![true; n];\n    let mut i = 1;\n    while i < n {\n  \
    \      if primes[i] == true {\n            factors.push(i);\n            while\
    \ i * i < n && primes[i * i] == true {\n                factors.push(i * i);\n\
    \                i += 1;\n            }\n        }\n        i += 1;\n    }\n \
    \   factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7sxlajum.rs:12:33\n   |\n\
    12 |     let mut primes = vec![true; n];\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ primes = vec![true; n.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[bool]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp7sxlajum.rs:15:12\n   |\n15 |         if primes[i]\
    \ == true {\n   |            ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be indexed by `isize`\n\
    \  --> /tmp/tmp7sxlajum.rs:17:32\n   |\n17 |             while i * i < n && primes[i\
    \ * i] == true {\n   |                                ^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n        }\n        i += 1;\n    }\n\
    \    factors.push(n);\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpdzsgsst7.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpwj5y7kfk.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    if n > 1 {\n        factors.push(n);\n    }\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmphwn1t89z.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n    let\
    \ mut primes = vec![];\n    let mut prime_factors = vec![];\n    let mut prime_factors_count\
    \ = vec![];\n    let mut prime_factors_count_max = vec![];\n    let mut prime_factors_count_max_index\
    \ = vec![];\n    let mut prime_factors_count_max_value = vec![];\n    let mut\
    \ prime_factors_count_max_value_max = vec![];\n    let mut prime_factors_count_max_value_max_index\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_value = vec![];\n \
    \   let mut prime_factors_count_max_value_max_index = vec![];\n    let mut prime_factors_count_max_value_max_value\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_index = vec![];\n \
    \   let mut prime_factors_count_max_value_max_value = vec![];\n    let mut prime_factors_count_max_value_max_index\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_value = vec![];\n \
    \   let mut prime_factors_count_max_value_max_index = vec![];\n    let mut prime_factors_count_max_value_max_value\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_index = vec![];\n \
    \   let mut prime_factors_count_max_value_max_value = vec![];\n    let mut prime_factors_count_max_value_max_index\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_value = vec![];\n \
    \   let mut prime_factors_count_max_value_max_index = vec![];\n    let mut prime_factors_count_max_value_max_value\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_index = vec![];\n \
    \   let mut prime_factors_count_max_value_max_value = vec![];\n    let mut prime_factors_count_max_value_max_index\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_value = vec![];\n \
    \   let mut prime_factors_count_max_value_max_index = vec![];\n    let mut prime_factors_count_max_value_max_value\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_index = vec![];\n \
    \   let mut prime_factors_count_max_value_max_value = vec![];\n    let mut prime_factors_count_max_value_max_index\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_value = vec![];\n \
    \   let mut prime_factors_count_max_value_max_index = vec![];\n    let mut prime_factors_count_max_value_max_value\
    \ = vec![];\n    let \n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpu3m28w_x.rs:48:1\n  \
    \ |\n48 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 0 {\n        if n % factor == 0 {\n    \
    \        factors.push(factor);\n            n /= factor;\n        } else {\n \
    \           factor *= factor;\n        }\n    }\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpe8f91h4t.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut factor = 1;\n    let mut i = 1;\n    while i <= n {\n        if n %\
    \ i == 0 {\n            factors.push(factor);\n            factor = 1;\n     \
    \       i += 1;\n        } else {\n            factor *= i;\n        }\n    }\n\
    \    factors.push(factor);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n    factors.push(1);\n\
    \    factors.push(1);\n    factors.push(1);\n    factors.push(\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n   --> /tmp/tmpgpf01kbd.rs:111:17\n\
    \    |\n10  | fn factorize(n: isize) -> Vec<isize> {\n    |                  \
    \                    - closing delimiter possibly meant for this\n...\n111 | \
    \    factors.push(\n    |                 ^ unclosed delimiter\n112 | }\n    |\
    \ ^ mismatched closing delimiter\n\nerror[E0061]: this function takes 1 argument\
    \ but 0 arguments were supplied\n    --> /tmp/tmpgpf01kbd.rs:111:13\n     |\n\
    111  |     factors.push(\n     |             ^^^^- supplied 0 arguments\n    \
    \ |             |\n     |             expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpgpf01kbd.rs:111:5\n\
    \    |\n10  |   fn factorize(n: isize) -> Vec<isize> {\n    |                \
    \             ---------- expected `Vec<isize>` because of return type\n...\n111\
    \ | /     factors.push(\n112 | | }\n    | |_^ expected struct `Vec`, found `()`\n\
    \    |\n    = note: expected struct `Vec<isize>`\n            found unit type\
    \ `()`\nnote: method `push` modifies its receiver in-place\n   --> /tmp/tmpgpf01kbd.rs:111:13\n\
    \    |\n111 |     factors.push(\n    |     ------- ^^^^ this call modifies `factors`\
    \ in-place\n    |     |\n    |     you probably want to use this value after calling\
    \ the method...\n    = note: ...instead of the `()` output of method `push`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        else {\n       \
    \     i += 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpa6kznut5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n    let\
    \ mut primes = vec![];\n    let mut prime_factors = vec![];\n    let mut prime_factors_count\
    \ = vec![];\n    let mut prime_factors_count_max = vec![];\n    let mut prime_factors_count_min\
    \ = vec![];\n    let mut prime_factors_count_sum = vec![];\n    let mut prime_factors_count_sum_max\
    \ = vec![];\n    let mut prime_factors_count_sum_min = vec![];\n    let mut prime_factors_count_product\
    \ = vec![];\n    let mut prime_factors_count_product_max = vec![];\n    let mut\
    \ prime_factors_count_product_min = vec![];\n    let mut prime_factors_count_product_sum\
    \ = vec![];\n    let mut prime_factors_count_product_sum_max = vec![];\n    let\
    \ mut prime_factors_count_product_sum_min = vec![];\n    let mut prime_factors_count_product_product\
    \ = vec![];\n    let mut prime_factors_count_product_product_max = vec![];\n \
    \   let mut prime_factors_count_product_product_min = vec![];\n    let mut prime_factors_count_product_product_sum\
    \ = vec![];\n    let mut prime_factors_count_product_product_sum_max = vec![];\n\
    \    let mut prime_factors_count_product_product_sum_min = vec![];\n    let mut\
    \ prime_factors_count_product_product_product = vec![];\n    let mut prime_factors_count_product_product_product_max\
    \ = vec![];\n    let mut prime_factors_count_product_product_product_min = vec![];\n\
    \    let mut prime_factors_count_product_product_product_sum = vec![];\n    let\
    \ mut prime_factors_count_product_product_product_sum_max = vec![];\n    let mut\
    \ prime_factors_count_product_product_product_sum_min = vec![];\n    let mut prime_factors_count_product_product_product_product\
    \ = vec![];\n    let mut prime_factors_count_product_product_product_product_max\
    \ = vec![];\n    let mut prime_factors_count_product_product_product_product_min\
    \ = vec![];\n    let mut prime_factors_count_product_product_product_product_sum\
    \ = vec![];\n    let mut prime_factors_count_product_product_product_product_sum_max\
    \ = vec![];\n    let mut prime_factors_count_product_product_product_product_sum_min\
    \ = vec![];\n    let mut prime_factors_count_product_product_product_product_product\
    \ = vec![];\n    let mut prime_factors_count_product_product_product_product_max\
    \ = vec![];\n    let mut prime_factors_count_product_product_product_product_min\
    \ = vec![];\n    let mut prime_factors_\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8ehjteby.rs:47:27\n   |\n\
    47 |     let mut prime_factors_\n   |                           ^ help: add `;`\
    \ here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp8ehjteby.rs:10:27\n   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n\
    \   |    ---------              ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n            i += 1;\n        }\n  \
    \  }\n    if n > 1 {\n        factors.push(n);\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpr97j6n60.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_sum = Vec::new();\n    let mut prime_factors_count_sum_max\
    \ = Vec::new();\n    let mut prime_factors_count_sum_min = Vec::new();\n    let\
    \ mut prime_factors_count_product = Vec::new();\n    let mut prime_factors_count_product_max\
    \ = Vec::new();\n    let mut prime_factors_count_product_min = Vec::new();\n \
    \   let mut prime_factors_count_product_sum = Vec::new();\n    let mut prime_factors_count_product_sum_max\
    \ = Vec::new();\n    let mut prime_factors_count_product_sum_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product = Vec::new();\n    let mut prime_factors_count_product_product_max\
    \ = Vec::new();\n    let mut prime_factors_count_product_product_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_sum = Vec::new();\n    let mut\
    \ prime_factors_count_product_product_sum_max = Vec::new();\n    let mut prime_factors_count_product_product_sum_min\
    \ = Vec::new();\n    let mut prime_factors_count_product_product_product = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_max = Vec::new();\n \
    \   let mut prime_factors_count_product_product_product_min = Vec::new();\n  \
    \  let mut prime_factors_count_product_product_product_sum = Vec::new();\n   \
    \ let mut prime_factors_count_product_product_product_sum_max = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_sum_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_max = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_sum = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_sum_max = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_sum_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_product = Vec::new();\n\
    \    let mut prime\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprnqbpub0.rs:45:18\n   |\n\
    45 |     let mut prime\n   |                  ^ help: add `;` here\n46 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprnqbpub0.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp5h6q1l78.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp5h6q1l78.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpduuwdehj.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpduuwdehj.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n    let\
    \ mut primes = vec![];\n    let mut prime_factors = vec![];\n    let mut prime_factors_count\
    \ = vec![];\n    let mut prime_factors_count_max = vec![];\n    let mut prime_factors_count_max_index\
    \ = vec![];\n    let mut prime_factors_count_min = vec![];\n    let mut prime_factors_count_min_index\
    \ = vec![];\n    let mut prime_factors_count_max_prime_factors = vec![];\n   \
    \ let mut prime_factors_count_min_prime_factors = vec![];\n    let mut prime_factors_count_max_prime_factors_index\
    \ = vec![];\n    let mut prime_factors_count_min_prime_factors_index = vec![];\n\
    \    let mut prime_factors_count_max_prime_factors_prime_factors = vec![];\n \
    \   let mut prime_factors_count_min_prime_factors_prime_factors = vec![];\n  \
    \  let mut prime_factors_count_max_prime_factors_prime_factors_index = vec![];\n\
    \    let mut prime_factors_count_min_prime_factors_prime_factors_index = vec![];\n\
    \    let mut prime_factors_count_max_prime_factors_prime_factors_prime_factors\
    \ = vec![];\n    let mut prime_factors_count_min_prime_factors_prime_factors_prime_factors\
    \ = vec![];\n    let mut prime_factors_count_max_prime_factors_prime_factors_prime_factors_index\
    \ = vec![];\n    let mut prime_factors_count_min_prime_factors_prime_factors_prime_factors_index\
    \ = vec![];\n    let mut prime_factors_count_max_prime_factors_prime_factors_prime_factors_prime_factors\
    \ = vec![];\n    let mut prime_factors_count_min_prime_factors_prime_factors_prime_factors_prime_factors\
    \ = vec![];\n    let mut prime_factors_count_max_prime_factors_prime_factors_prime_factors_prime_factors_index\
    \ = vec![];\n    let mut prime_factors_count_min_prime_factors_prime_factors_prime_factors_prime_factors_index\
    \ = vec![];\n    let mut prime_factors_count_max_prime_factors_prime_factors_prime_factors_prime_factors_prime_factors\
    \ = vec![];\n    let mut prime_factors_count_min_prime_factors_prime_factors_prime_factors_prime_factors_prime_factors\
    \ = vec![];\n    let mut prime_factors_count_max_prime_factors_prime_factors_prime_factors_prime_factors_prime_factors_index\
    \ = vec![];\n    let mut prime_factors_count_min_prime_factors_prime_factors_prime_factors_prime_factors_prime\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjo3ni4lq.rs:38:98\n   |\n\
    38 |     let mut prime_factors_count_min_prime_factors_prime_factors_prime_factors_prime_factors_prime\n\
    \   |                                                                        \
    \                          ^ help: add `;` here\n39 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjo3ni4lq.rs:10:27\n   |\n10 |\
    \ fn factorize(n: isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        else {\n       \
    \     i += 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpa6kznut5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_count = Vec::new();\n    let mut primes_count_size = Vec::new();\n\
    \    let mut primes_count_size = Vec::new();\n    let mut primes_count_size =\
    \ Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp58k38grs.rs:54:11\n   |\n\
    54 |     let mu\n   |           ^ help: add `;` here\n55 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp58k38grs.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_counter = Vec::new();\n   \
    \ let mut prime_counter2 = Vec::new();\n    let mut prime_counter3 = Vec::new();\n\
    \    let mut prime_counter4 = Vec::new();\n    let mut prime_counter5 = Vec::new();\n\
    \    let mut prime_counter6 = Vec::new();\n    let mut prime_counter7 = Vec::new();\n\
    \    let mut prime_counter8 = Vec::new();\n    let mut prime_counter9 = Vec::new();\n\
    \    let mut prime_counter10 = Vec::new();\n    let mut prime_counter11 = Vec::new();\n\
    \    let mut prime_counter12 = Vec::new();\n    let mut prime_counter13 = Vec::new();\n\
    \    let mut prime_counter14 = Vec::new();\n    let mut prime_counter15 = Vec::new();\n\
    \    let mut prime_counter16 = Vec::new();\n    let mut prime_counter17 = Vec::new();\n\
    \    let mut prime_counter18 = Vec::new();\n    let mut prime_counter19 = Vec::new();\n\
    \    let mut prime_counter20 = Vec::new();\n    let mut prime_counter21 = Vec::new();\n\
    \    let mut prime_counter22 = Vec::new();\n    let mut prime_counter23 = Vec::new();\n\
    \    let mut prime_counter24 = Vec::new();\n    let mut prime_counter25 = Vec::new();\n\
    \    let mut prime_counter26 = Vec::new();\n    let mut prime_counter27 = Vec::new();\n\
    \    let mut prime_counter28 = Vec::new();\n    let mut prime_counter29 = Vec::new();\n\
    \    let mut prime_counter30 = Vec::new();\n    let mut prime_counter31 = Vec::new();\n\
    \    let mut prime_counter32 = Vec::new();\n    let mut prime_counter33 = Vec::new();\n\
    \    let mut prime_counter34 = Vec::new();\n    let mut prime_counter35 = Vec::new();\n\
    \    let mut prime_counter36 = Vec::new();\n    let mut prime_counter37 = Vec::new();\n\
    \    let mut prime_counter38 = Vec::new();\n    let mut prime_counter39 = Vec::\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1dlt87d1.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut primes_size = primes.len();\n   \
    \ let mut primes_size = primes_size + 1;\n    let mut primes_size = primes_size\
    \ + 1;\n    let mut primes_size = primes_size + 1;\n    let mut primes_size =\
    \ primes_size + 1;\n    let mut primes_size = primes_size + 1;\n    let mut primes_size\
    \ = primes_size + 1;\n    let mut primes_size = primes_size + 1;\n    let mut\
    \ primes_size = primes_size + 1;\n    let mut primes_size = primes_size + 1;\n\
    \    let mut primes_size = primes_size + 1;\n    let mut primes_size = primes_size\
    \ + 1;\n    let mut primes_size = primes_size + 1;\n    let mut primes_size =\
    \ primes_size + 1;\n    let mut primes_size = primes_size + 1;\n    let mut primes_size\
    \ = primes_size + 1;\n    let mut primes_size = primes_size + 1;\n    let mut\
    \ primes_size = primes_size + 1;\n    let mut primes_size = primes_size + 1;\n\
    \    let mut primes_size = primes_size + 1;\n    let mut primes_size = primes_size\
    \ + 1;\n    let mut primes_size = primes_size + 1;\n    let mut primes_size =\
    \ primes_size + 1;\n    let mut primes_size = primes_size + 1;\n    let mut primes_size\
    \ = primes_size + 1;\n    let mut primes_size = primes_size + 1;\n    let mut\
    \ primes_size = primes_size + 1;\n    let mut primes_size = primes_size + 1;\n\
    \    let mut primes_size = primes_size + 1;\n    let mut primes_size = primes_size\
    \ + 1;\n    let mut primes_size = primes_size + 1;\n    let mut primes_size =\
    \ primes_size + 1;\n    let mut primes_size = primes_size + 1;\n    let mut primes_size\
    \ = primes_size + 1;\n    let mut primes_size = primes_size + 1;\n    let mut\
    \ primes_size = primes_size + 1;\n    let mut primes_size = primes_size + 1;\n\
    \    let mut primes_size = primes_size + 1;\n    let mut primes_size = primes_size\
    \ + 1;\n    let mut primes_size = primes_size + 1;\n    let mut primes_size =\
    \ primes_size + 1;\n    let mut primes_size = primes_size + 1;\n    let mut primes_size\
    \ = primes_size + 1;\n    let mut primes_size = primes_size + 1;\n    let mut\
    \ primes_size = primes_\n}\n\nfn main() {\n    let candidate = factorize;\n  \
    \  assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n\
    \    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3,\
    \ 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpcc2j9dk6.rs:57:34\n   |\n\
    57 |     let mut primes_size = primes_\n   |                                 \
    \ ^ help: add `;` here\n58 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `primes_` in this scope\n  --> /tmp/tmpcc2j9dk6.rs:57:27\n   |\n\
    57 |     let mut primes_size = primes_\n   |                           ^^^^^^^\
    \ help: a local variable with a similar name exists: `primes`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcc2j9dk6.rs:10:27\n   |\n10 | fn factorize(n:\
    \ isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n \
    \           factors.push(factor);\n            n /= factor;\n        }\n     \
    \   factor *= 2;\n    }\n    factors.push(1);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpf7t0nr19.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n    let\
    \ mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            factors.push(i);\n\
    \            i += 1;\n        }\n        i += 1;\n    }\n    factors\n}\n\nfn\
    \ main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpoowkefsz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpzzsjvzuv.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_max_index = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_max_value\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_max_value = Vec::new();\n    let mut prime_factors_count_max_\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa2qwe15v.rs:48:37\n   |\n\
    48 |     let mut prime_factors_count_max_\n   |                              \
    \       ^ help: add `;` here\n49 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa2qwe15v.rs:10:27\n   |\n10 | fn factorize(n:\
    \ isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp5h6q1l78.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_sum = Vec::new();\n    let mut prime_factors_count_sum_max\
    \ = Vec::new();\n    let mut prime_factors_count_sum_min = Vec::new();\n    let\
    \ mut prime_factors_count_product = Vec::new();\n    let mut prime_factors_count_product_max\
    \ = Vec::new();\n    let mut prime_factors_count_product_min = Vec::new();\n \
    \   let mut prime_factors_count_product_sum = Vec::new();\n    let mut prime_factors_count_product_sum_max\
    \ = Vec::new();\n    let mut prime_factors_count_product_sum_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product = Vec::new();\n    let mut prime_factors_count_product_product_max\
    \ = Vec::new();\n    let mut prime_factors_count_product_product_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_sum = Vec::new();\n    let mut\
    \ prime_factors_count_product_product_sum_max = Vec::new();\n    let mut prime_factors_count_product_product_sum_min\
    \ = Vec::new();\n    let mut prime_factors_count_product_product_product = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_max = Vec::new();\n \
    \   let mut prime_factors_count_product_product_product_min = Vec::new();\n  \
    \  let mut prime_factors_count_product_product_product_sum = Vec::new();\n   \
    \ let mut prime_factors_count_product_product_product_sum_max = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_sum_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_max = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_sum = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_sum_max = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_sum_min = Vec::new();\n\
    \    let mut prime_factors_count_product_product_product_product_product = Vec::new();\n\
    \    let mut prime\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmprnqbpub0.rs:45:18\n   |\n\
    45 |     let mut prime\n   |                  ^ help: add `;` here\n46 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprnqbpub0.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n            i += 1;\n        }\n  \
    \      i += 1;\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n \
    \   let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp2pwtd628.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n \
    \           factors.push(factor);\n            n /= factor;\n        }\n     \
    \   factor *= 2;\n    }\n    factors.push(1);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpf7t0nr19.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n    let\
    \ mut primes = vec![];\n    let mut prime_factors = vec![];\n    let mut prime_factors_count\
    \ = vec![];\n    let mut prime_factors_count_max = vec![];\n    let mut prime_factors_count_max_index\
    \ = vec![];\n    let mut prime_factors_count_max_value = vec![];\n    let mut\
    \ prime_factors_count_max_value_max = vec![];\n    let mut prime_factors_count_max_value_max_index\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_value = vec![];\n \
    \   let mut prime_factors_count_max_value_max_index = vec![];\n    let mut prime_factors_count_max_value_max_value\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_index = vec![];\n \
    \   let mut prime_factors_count_max_value_max_value = vec![];\n    let mut prime_factors_count_max_value_max_index\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_value = vec![];\n \
    \   let mut prime_factors_count_max_value_max_index = vec![];\n    let mut prime_factors_count_max_value_max_value\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_index = vec![];\n \
    \   let mut prime_factors_count_max_value_max_value = vec![];\n    let mut prime_factors_count_max_value_max_index\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_value = vec![];\n \
    \   let mut prime_factors_count_max_value_max_index = vec![];\n    let mut prime_factors_count_max_value_max_value\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_index = vec![];\n \
    \   let mut prime_factors_count_max_value_max_value = vec![];\n    let mut prime_factors_count_max_value_max_index\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_value = vec![];\n \
    \   let mut prime_factors_count_max_value_max_index = vec![];\n    let mut prime_factors_count_max_value_max_value\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_index = vec![];\n \
    \   let mut prime_factors_count_max_value_max_value = vec![];\n    let mut prime_factors_count_max_value_max_index\
    \ = vec![];\n    let mut prime_factors_count_max_value_max_value = vec![];\n \
    \   let mut prime_factors_count_max_value_max_index = vec![];\n    let mut prime_factors_count_max_value_max_value\
    \ = vec![];\n    let \n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpu3m28w_x.rs:48:1\n  \
    \ |\n48 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpduuwdehj.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpduuwdehj.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_counter = Vec::new();\n   \
    \ let mut prime_counter2 = Vec::new();\n    let mut prime_counter3 = Vec::new();\n\
    \    let mut prime_counter4 = Vec::new();\n    let mut prime_counter5 = Vec::new();\n\
    \    let mut prime_counter6 = Vec::new();\n    let mut prime_counter7 = Vec::new();\n\
    \    let mut prime_counter8 = Vec::new();\n    let mut prime_counter9 = Vec::new();\n\
    \    let mut prime_counter10 = Vec::new();\n    let mut prime_counter11 = Vec::new();\n\
    \    let mut prime_counter12 = Vec::new();\n    let mut prime_counter13 = Vec::new();\n\
    \    let mut prime_counter14 = Vec::new();\n    let mut prime_counter15 = Vec::new();\n\
    \    let mut prime_counter16 = Vec::new();\n    let mut prime_counter17 = Vec::new();\n\
    \    let mut prime_counter18 = Vec::new();\n    let mut prime_counter19 = Vec::new();\n\
    \    let mut prime_counter20 = Vec::new();\n    let mut prime_counter21 = Vec::new();\n\
    \    let mut prime_counter22 = Vec::new();\n    let mut prime_counter23 = Vec::new();\n\
    \    let mut prime_counter24 = Vec::new();\n    let mut prime_counter25 = Vec::new();\n\
    \    let mut prime_counter26 = Vec::new();\n    let mut prime_counter27 = Vec::new();\n\
    \    let mut prime_counter28 = Vec::new();\n    let mut prime_counter29 = Vec::new();\n\
    \    let mut prime_counter30 = Vec::new();\n    let mut prime_counter31 = Vec::new();\n\
    \    let mut prime_counter32 = Vec::new();\n    let mut prime_counter33 = Vec::new();\n\
    \    let mut prime_counter34 = Vec::new();\n    let mut prime_counter35 = Vec::new();\n\
    \    let mut prime_counter36 = Vec::new();\n    let mut prime_counter37 = Vec::new();\n\
    \    let mut prime_counter38 = Vec::new();\n    let mut prime_counter39 = Vec::\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1dlt87d1.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_counter = Vec::new();\n   \
    \ let mut prime_counter2 = Vec::new();\n    let mut prime_counter3 = Vec::new();\n\
    \    let mut prime_counter4 = Vec::new();\n    let mut prime_counter5 = Vec::new();\n\
    \    let mut prime_counter6 = Vec::new();\n    let mut prime_counter7 = Vec::new();\n\
    \    let mut prime_counter8 = Vec::new();\n    let mut prime_counter9 = Vec::new();\n\
    \    let mut prime_counter10 = Vec::new();\n    let mut prime_counter11 = Vec::new();\n\
    \    let mut prime_counter12 = Vec::new();\n    let mut prime_counter13 = Vec::new();\n\
    \    let mut prime_counter14 = Vec::new();\n    let mut prime_counter15 = Vec::new();\n\
    \    let mut prime_counter16 = Vec::new();\n    let mut prime_counter17 = Vec::new();\n\
    \    let mut prime_counter18 = Vec::new();\n    let mut prime_counter19 = Vec::new();\n\
    \    let mut prime_counter20 = Vec::new();\n    let mut prime_counter21 = Vec::new();\n\
    \    let mut prime_counter22 = Vec::new();\n    let mut prime_counter23 = Vec::new();\n\
    \    let mut prime_counter24 = Vec::new();\n    let mut prime_counter25 = Vec::new();\n\
    \    let mut prime_counter26 = Vec::new();\n    let mut prime_counter27 = Vec::new();\n\
    \    let mut prime_counter28 = Vec::new();\n    let mut prime_counter29 = Vec::new();\n\
    \    let mut prime_counter30 = Vec::new();\n    let mut prime_counter31 = Vec::new();\n\
    \    let mut prime_counter32 = Vec::new();\n    let mut prime_counter33 = Vec::new();\n\
    \    let mut prime_counter34 = Vec::new();\n    let mut prime_counter35 = Vec::new();\n\
    \    let mut prime_counter36 = Vec::new();\n    let mut prime_counter37 = Vec::new();\n\
    \    let mut prime_counter38 = Vec::new();\n    let mut prime_counter39 = Vec::\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1dlt87d1.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp5h6q1l78.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut primes_size = primes.len();\n   \
    \ let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzmjbacao.rs:10:27\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut primes_size = primes.len();\n   \
    \ let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.len();\n\
    \    let mut factors_size = factors.len();\n    let mut primes_size = primes.\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp_d9wqxx1.rs:58:1\n   |\n58\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp_d9wqxx1.rs:57:34\n\
    \   |\n57 |     let mut primes_size = primes.\n   |                          \
    \        ^ help: add `;` here\n58 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_d9wqxx1.rs:10:27\n   |\n10 | fn factorize(n:\
    \ isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n          \
    \  primes.push(i);\n            prime_factors.push(i);\n            while i *\
    \ i <= n && n % i == 0 {\n                factors.push(i);\n                i\
    \ += 1;\n            }\n        }\n        i += 1;\n    }\n    for i in prime_factors\
    \ {\n        factors.push(i);\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1]`,\n right: `[2]`', /tmp/tmpcdvnyq1h.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n            i += 1;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    factors.push(n);\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpoyd_euhh.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_counter = Vec::new();\n   \
    \ let mut prime_counter2 = Vec::new();\n    let mut prime_counter3 = Vec::new();\n\
    \    let mut prime_counter4 = Vec::new();\n    let mut prime_counter5 = Vec::new();\n\
    \    let mut prime_counter6 = Vec::new();\n    let mut prime_counter7 = Vec::new();\n\
    \    let mut prime_counter8 = Vec::new();\n    let mut prime_counter9 = Vec::new();\n\
    \    let mut prime_counter10 = Vec::new();\n    let mut prime_counter11 = Vec::new();\n\
    \    let mut prime_counter12 = Vec::new();\n    let mut prime_counter13 = Vec::new();\n\
    \    let mut prime_counter14 = Vec::new();\n    let mut prime_counter15 = Vec::new();\n\
    \    let mut prime_counter16 = Vec::new();\n    let mut prime_counter17 = Vec::new();\n\
    \    let mut prime_counter18 = Vec::new();\n    let mut prime_counter19 = Vec::new();\n\
    \    let mut prime_counter20 = Vec::new();\n    let mut prime_counter21 = Vec::new();\n\
    \    let mut prime_counter22 = Vec::new();\n    let mut prime_counter23 = Vec::new();\n\
    \    let mut prime_counter24 = Vec::new();\n    let mut prime_counter25 = Vec::new();\n\
    \    let mut prime_counter26 = Vec::new();\n    let mut prime_counter27 = Vec::new();\n\
    \    let mut prime_counter28 = Vec::new();\n    let mut prime_counter29 = Vec::new();\n\
    \    let mut prime_counter30 = Vec::new();\n    let mut prime_counter31 = Vec::new();\n\
    \    let mut prime_counter32 = Vec::new();\n    let mut prime_counter33 = Vec::new();\n\
    \    let mut prime_counter34 = Vec::new();\n    let mut prime_counter35 = Vec::new();\n\
    \    let mut prime_counter36 = Vec::new();\n    let mut prime_counter37 = Vec::new();\n\
    \    let mut prime_counter38 = Vec::new();\n    let mut prime_counter39 = Vec::\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1dlt87d1.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_counter = Vec::new();\n    let mut prime_factors_counter2\
    \ = Vec::new();\n    let mut prime_factors_counter3 = Vec::new();\n    let mut\
    \ prime_factors_counter4 = Vec::new();\n    let mut prime_factors_counter5 = Vec::new();\n\
    \    let mut prime_factors_counter6 = Vec::new();\n    let mut prime_factors_counter7\
    \ = Vec::new();\n    let mut prime_factors_counter8 = Vec::new();\n    let mut\
    \ prime_factors_counter9 = Vec::new();\n    let mut prime_factors_counter10 =\
    \ Vec::new();\n    let mut prime_factors_counter11 = Vec::new();\n    let mut\
    \ prime_factors_counter12 = Vec::new();\n    let mut prime_factors_counter13 =\
    \ Vec::new();\n    let mut prime_factors_counter14 = Vec::new();\n    let mut\
    \ prime_factors_counter15 = Vec::new();\n    let mut prime_factors_counter16 =\
    \ Vec::new();\n    let mut prime_factors_counter17 = Vec::new();\n    let mut\
    \ prime_factors_counter18 = Vec::new();\n    let mut prime_factors_counter19 =\
    \ Vec::new();\n    let mut prime_factors_counter20 = Vec::new();\n    let mut\
    \ prime_factors_counter21 = Vec::new();\n    let mut prime_factors_counter22 =\
    \ Vec::new();\n    let mut prime_factors_counter23 = Vec::new();\n    let mut\
    \ prime_factors_counter24 = Vec::new();\n    let mut prime_factors_counter25 =\
    \ Vec::new();\n    let mut prime_factors_counter26 = Vec::new();\n    let mut\
    \ prime_factors_counter27 = Vec::new();\n    let mut prime_factors_counter28 =\
    \ Vec::new();\n    let mut prime_factors_counter29 = Vec::new();\n    let mut\
    \ prime_factors_counter30 = Vec::new();\n    let mut prime_factors_counter31 =\
    \ Vec::new();\n    let mut prime_factors_counter32 = Vec::new();\n    let mut\
    \ prime_factors_counter33 = Vec::new();\n    let mut prime_factors_counter34 =\
    \ Vec::new();\n    let mut prime_factors_counter35 = Vec::new();\n    let mut\
    \ \n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpr_gshv60.rs:50:1\n\
    \   |\n50 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpduuwdehj.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpduuwdehj.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut i = 2;\n    while i * i <= n {\n\
    \        if n % i == 0 {\n            factors.push(i);\n            n /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    while n > 1 {\n\
    \        if n % 2 == 0 {\n            factors.push(2);\n            n /= 2;\n\
    \        } else {\n            let mut i = 2;\n            while i * i <= n {\n\
    \                if n % i == 0 {\n                    factors.push(i);\n     \
    \               n /= i;\n                    break;\n                }\n     \
    \           i += 1;\n            }\n        }\n    }\n    factors.push(1);\n \
    \   factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmplqm0_7c9.rs:12:22\n\
    \   |\n12 |     let mut primes = Vec::new();\n   |         ----------   ^^^^^^^^\
    \ cannot infer type for type parameter `T`\n   |         |\n   |         consider\
    \ giving `primes` the explicit type `Vec<T>`, where the type parameter `T` is\
    \ specified\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut i = 1;\n    while i <= n {\n        if n % i == 0 {\n            primes.push(i);\n\
    \            while primes.len() > 0 {\n                let mut j = primes.len()\
    \ - 1;\n                while j >= 0 && primes[j] <= i {\n                   \
    \ prime_factors.push(primes[j]);\n                    primes.remove(j);\n    \
    \                j -= 1;\n                }\n            }\n            i += 1;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    prime_factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpkt2v2uur.rs:11:23\n\
    \   |\n11 |     let mut factors = Vec::new();\n   |         -----------   ^^^^^^^^\
    \ cannot infer type for type parameter `T`\n   |         |\n   |         consider\
    \ giving `factors` the explicit type `Vec<T>`, where the type parameter `T` is\
    \ specified\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size_size = Vec::new();\n    let mut primes_size_primes = Vec::new();\n\
    \    let mut primes_size_primes_size = Vec::new();\n    let mut primes_size_primes_size_size\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes = Vec::new();\n\
    \    let mut primes_size_primes_size_size_primes_size = Vec::new();\n    let mut\
    \ primes_size_primes_size_size_primes_size_size = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes\
    \ = Vec::new();\n    let mut primes_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size_primes_size_size\
    \ = \n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpyzurk9id.rs:34:1\n\
    \   |\n34 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n            i += 1;\n        }\n  \
    \  }\n    if n > 1 {\n        factors.push(n);\n    }\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpr97j6n60.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_index = Vec::new();\n    let mut prime_factors_count_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value_2\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_2 = Vec::new();\n \
    \   let mut prime_factors_count_max_value_3 = Vec::new();\n    let mut prime_factors_count_min_value_3\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_4 = Vec::new();\n \
    \   let mut prime_factors_count_min_value_4 = Vec::new();\n    let mut prime_factors_count_max_value_5\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_5 = Vec::new();\n \
    \   let mut prime_factors_count_max_value_6 = Vec::new();\n    let mut prime_factors_count_min_value_6\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_7 = Vec::new();\n \
    \   let mut prime_factors_count_min_value_7 = Vec::new();\n    let mut prime_factors_count_max_value_8\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_8 = Vec::new();\n \
    \   let mut prime_factors_count_max_value_9 = Vec::new();\n    let mut prime_factors_count_min_value_9\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_10 = Vec::new();\n\
    \    let mut prime_factors_count_min_value_10 = Vec::new();\n    let mut prime_factors_count_max_value_11\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_11 = Vec::new();\n\
    \    let mut prime_factors_count_max_value_12 = Vec::new();\n    let mut prime_factors_count_min_value_12\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_13 = Vec::new();\n\
    \    let mut prime_factors_count_min_value_13 = Vec::new();\n    let mut prime_factors_count_max_value_14\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppiqncm3z.rs:46:43\n   |\n\
    46 |     let mut prime_factors_count_min_value_\n   |                        \
    \                   ^ help: add `;` here\n47 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmppiqncm3z.rs:10:27\n   |\n10 | fn\
    \ factorize(n: isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_counter = 1;\n    let mut prime_factor\
    \ = 1;\n    let mut factor = 1;\n    let mut i = 1;\n    while i < n {\n     \
    \   if n % i == 0 {\n            factors.push(factor);\n            factor = 1;\n\
    \            i += 1;\n        } else {\n            factor *= i;\n        }\n\
    \    }\n    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor);\n\
    \    factors.push(factor);\n    factors.push(factor);\n    factors.push(factor\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpuoves5vj.rs:97:17\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n97 |     factors.push(factor\n\
    \   |                 ^ unclosed delimiter\n98 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuoves5vj.rs:97:5\n\
    \   |\n10 |   fn factorize(n: isize) -> Vec<isize> {\n   |                   \
    \          ---------- expected `Vec<isize>` because of return type\n...\n97 |\
    \ /     factors.push(factor\n98 | | }\n   | |_^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    note: method `push` modifies its receiver in-place\n  --> /tmp/tmpuoves5vj.rs:97:13\n\
    \   |\n97 |     factors.push(factor\n   |     ------- ^^^^ this call modifies\
    \ `factors` in-place\n   |     |\n   |     you probably want to use this value\
    \ after calling the method...\n   = note: ...instead of the `()` output of method\
    \ `push`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut factorization = Vec::new();\n    let mut factorization_size = Vec::new();\n\
    \    let mut factorization_remainder = Vec::new();\n    let mut factorization_remainder_size\
    \ = Vec::new();\n\n    let mut prime_factors_size = prime_factors.len();\n\n \
    \   for i in 2..=n {\n        if n % i == 0 {\n            factors.push(i as isize);\n\
    \            primes.push(i);\n        }\n    }\n\n    for i in 2..=n {\n     \
    \   if prime_factors_size != prime_factors.len() {\n            factorization_remainder.push(i\
    \ as isize);\n            factorization_remainder_size.push(prime_factors_size);\n\
    \        }\n    }\n\n    for i in 2..=n {\n        if factorization_remainder_size.len()\
    \ != factorization_remainder.len() {\n            factorization.push(i as isize);\n\
    \            factorization_size.push(factorization_remainder_size.len());\n  \
    \      }\n    }\n\n    for i in 2..=n {\n        if factorization_size.len() !=\
    \ factorization.len() {\n            factorization.push(i as isize);\n       \
    \     factorization_size.push(factorization_remainder_size.len());\n        }\n\
    \    }\n\n    for i in 2..=n {\n        if factorization_size.len() != factorization.len()\
    \ {\n            factorization.push(i as isize);\n            factorization_size.push(factorization_remainder_size.len());\n\
    \        }\n    }\n\n    for i in 2..=n {\n        if factorization_size.len()\
    \ != factorization.len() {\n            factorization.push(i as isize);\n    \
    \        factorization_size.push(factorization_remainder_size.len());\n      \
    \  }\n    }\n\n    for i in 2..=n {\n        if factorization_size.len() != factorization.len()\
    \ {\n            factorization.push(i as isize);\n            factorization_size.push(factorization_remainder_size.len());\n\
    \        }\n    }\n\n    for i in 2..=n {\n        if factorization_size.len()\
    \ != factorization.len() {\n            factorization.push(i as isize);\n    \
    \        factorization_size.push(factorization_remainder_size.len());\n      \
    \  }\n    }\n\n    for i in 2..=n {\n        if factorization_size.len() != factorization.len()\
    \ {\n            factorization.push(i as isize);\n            factorization_size.push(factorization_remainder_size.len());\n\
    \        }\n    }\n\n    for i in 2..=n {\n        if \n}\n\nfn main() {\n   \
    \ let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmph6_jgwb9.rs:98:3\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |                     \
    \                 - unclosed delimiter\n...\n84 |     for i in 2..=n {\n   | \
    \                   - this delimiter might not be properly closed...\n85 |   \
    \      if \n86 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n98 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmph6_jgwb9.rs:86:1\n\
    \   |\n86 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmph6_jgwb9.rs:10:27\n   |\n10 | fn factorize(n: isize) -> Vec<isize>\
    \ {\n   |    ---------              ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n    let\
    \ mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            factors.push(i);\n\
    \            n /= i;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    factors.push(n as usize);\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7bd9b3gq.rs:21:18\n   |\n\
    21 |     factors.push(n as usize);\n   |                  ^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n21 |     factors.push((n\
    \ as usize).try_into().unwrap());\n   |                  +          +++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp5h6q1l78.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpduuwdehj.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpduuwdehj.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut factorization = Vec::new();\n\
    \    let mut factorization_count = Vec::new();\n    let mut factorization_primes\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_prime\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpksrnp0lt.rs:51:32\n   |\n\
    51 |     let mut factorization_prime\n   |                                ^ help:\
    \ add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpksrnp0lt.rs:10:27\n   |\n10 | fn factorize(n: isize) -> Vec<isize>\
    \ {\n   |    ---------              ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        else {\n       \
    \     i += 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpa6kznut5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut factorization = Vec::new();\n\
    \    let mut factorization_count = Vec::new();\n    let mut factorization_primes\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_prime\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpksrnp0lt.rs:51:32\n   |\n\
    51 |     let mut factorization_prime\n   |                                ^ help:\
    \ add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpksrnp0lt.rs:10:27\n   |\n10 | fn factorize(n: isize) -> Vec<isize>\
    \ {\n   |    ---------              ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n            i += 1;\n        }\n  \
    \      i += 1;\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n \
    \   let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp2pwtd628.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut i = 1;\n    while i * i <= n {\n\
    \        if n % i == 0 {\n            factors.push(i);\n            primes.push(i);\n\
    \        }\n        i += 1;\n    }\n    for i in factors.iter().rev() {\n    \
    \    primes.push(i);\n    }\n    primes.reverse();\n    factors\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq46xxbog.rs:22:21\n   |\n\
    22 |         primes.push(i);\n   |                     ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |        \
    \ primes.push(*i);\n   |                     +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpduuwdehj.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpduuwdehj.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut i = 1;\n    while i * i <= n {\n\
    \        if n % i == 0 {\n            factors.push(i);\n            i += 1;\n\
    \        } else {\n            primes.push(i);\n        }\n    }\n    factors.push(n\
    \ - 1);\n    primes.push(n - 1);\n    factors.sort_unstable();\n    primes.sort_unstable();\n\
    \    factors.into_iter().map(|&i| i as isize).collect()\n}\n\nfn main() {\n  \
    \  let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2oof52xc.rs:26:30\n   |\n\
    26 |     factors.into_iter().map(|&i| i as isize).collect()\n   |            \
    \                  ^--\n   |                              ||\n   |           \
    \                   |expected due to this\n   |                              expected\
    \ `isize`, found reference\n   |                              help: did you mean\
    \ `i`: `&isize`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut i = 2;\n    while i * i <= n {\n\
    \        if n % i == 0 {\n            factors.push(i);\n            n /= i;\n\
    \        }\n        else {\n            primes.push(i);\n            i += 1;\n\
    \        }\n    }\n    factors.push(n as isize);\n    primes.push(n as isize);\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp_ogi8xm5.rs:17:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n17 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_counter = 1;\n    let mut factor\
    \ = 1;\n    let mut prime_factor = 1;\n    let mut prime_factor_counter = 1;\n\
    \    let mut prime_factor_counter2 = 0;\n    let mut prime_factor_counter3 = 0;\n\
    \    let mut prime_factor_counter4 = 0;\n    let mut prime_factor_counter5 = 0;\n\
    \    let mut prime_factor_counter6 = 0;\n    let mut prime_factor_counter7 = 0;\n\
    \    let mut prime_factor_counter8 = 0;\n    let mut prime_factor_counter9 = 0;\n\
    \    let mut prime_factor_counter10 = 0;\n    let mut prime_factor_counter11 =\
    \ 0;\n    let mut prime_factor_counter12 = 0;\n    let mut prime_factor_counter13\
    \ = 0;\n    let mut prime_factor_counter14 = 0;\n    let mut prime_factor_counter15\
    \ = 0;\n    let mut prime_factor_counter16 = 0;\n    let mut prime_factor_counter17\
    \ = 0;\n    let mut prime_factor_counter18 = 0;\n    let mut prime_factor_counter19\
    \ = 0;\n    let mut prime_factor_counter20 = 0;\n    let mut prime_factor_counter21\
    \ = 0;\n    let mut prime_factor_counter22 = 0;\n    let mut prime_factor_counter23\
    \ = 0;\n    let mut prime_factor_counter24 = 0;\n    let mut prime_factor_counter25\
    \ = 0;\n    let mut prime_factor_counter26 = 0;\n    let mut prime_factor_counter27\
    \ = 0;\n    let mut prime_factor_counter28 = 0;\n    let mut prime_factor_counter29\
    \ = 0;\n    let mut prime_factor_counter30 = 0;\n    let mut prime_factor_counter31\
    \ = 0;\n    let mut prime_factor_counter32 = 0;\n    let mut prime_factor_counter33\
    \ = 0;\n    let mut prime_factor_counter34 = 0;\n    let mut prime_factor_counter35\
    \ = 0;\n    let mut prime_factor_counter36 = 0;\n    let mut prime_factor_counter37\
    \ = 0;\n    let mut prime_factor_counter38 = 0;\n    let mut prime_factor_counter39\
    \ = 0;\n    let mut prime_factor_counter40 = 0;\n    let mut prime_factor_counter41\
    \ = 0;\n    let mut prime_factor_counter42 = 0;\n    let mut prime_factor_counter43\
    \ = 0;\n    let mut prime_factor_counter44 = 0;\n    let mut prime_factor_counter45\
    \ = 0;\n    let mut prime_factor_counter46 = 0;\n    let mut prime_factor_counter47\
    \ = 0;\n    let mut prime_factor_\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp964k8hc7.rs:63:26\n   |\n\
    63 |     let mut prime_factor_\n   |                          ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp964k8hc7.rs:10:27\n   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n\
    \   |    ---------              ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n \
    \           factors.push(factor);\n            n /= factor;\n        }\n     \
    \   factor *= 2;\n    }\n    factors.push(1);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpf7t0nr19.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut factorization = Vec::new();\n\
    \    let mut factorization_count = Vec::new();\n    let mut factorization_primes\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_prime\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpksrnp0lt.rs:51:32\n   |\n\
    51 |     let mut factorization_prime\n   |                                ^ help:\
    \ add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpksrnp0lt.rs:10:27\n   |\n10 | fn factorize(n: isize) -> Vec<isize>\
    \ {\n   |    ---------              ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut i = 2;\n    while i * i <= n {\n\
    \        if n % i == 0 {\n            factors.push(i);\n            n /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    if n > 1 {\n   \
    \     factors.push(n);\n    }\n    for i in factors.iter() {\n        primes.push(i);\n\
    \    }\n    primes\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq4ohzsvz.rs:28:5\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |                           ----------\
    \ expected `Vec<isize>` because of return type\n...\n28 |     primes\n   |   \
    \  ^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut factorization = factorization(n);\n    let mut prime_factorization =\
    \ factorization(n);\n    let mut prime_factors_size = prime_factorization.len();\n\
    \    let mut factors_size = factorization.len();\n    let mut factors_size = factors_size\
    \ % prime_factors_size;\n    let mut prime_factors_size = prime_factors_size %\
    \ factors_size;\n    let mut factorization = factorization(n);\n    let mut factors_size\
    \ = factors_size % prime_factors_size;\n    let mut prime_factors_size = prime_factors_size\
    \ % factors_size;\n    let mut factorization = factorization(n);\n    let mut\
    \ factors_size = factors_size % prime_factors_size;\n    let mut prime_factors_size\
    \ = prime_factors_size % factors_size;\n    let mut factorization = factorization(n);\n\
    \    let mut factors_size = factors_size % prime_factors_size;\n    let mut prime_factors_size\
    \ = prime_factors_size % factors_size;\n    let mut factorization = factorization(n);\n\
    \    let mut factors_size = factors_size % prime_factors_size;\n    let mut prime_factors_size\
    \ = prime_factors_size % factors_size;\n    let mut factorization = factorization(n);\n\
    \    let mut factors_size = factors_size % prime_factors_size;\n    let mut prime_factors_size\
    \ = prime_factors_size % factors_size;\n    let mut factorization = factorization(n);\n\
    \    let mut factors_size = factors_size % prime_factors_size;\n    let mut prime_factors_size\
    \ = prime_factors_size % factors_size;\n    let mut factorization = factorization(n);\n\
    \    let mut factors_size = factors_size % prime_factors_size;\n    let mut prime_factors_size\
    \ = prime_factors_size % factors_size;\n    let mut factorization = factorization(n);\n\
    \    let mut factors_size = factors_size % prime_factors_size;\n    let mut prime_factors_size\
    \ = prime_factors_size % factors_size;\n    let mut factorization = factorization(n);\n\
    \    let mut factors_size = factors_size % prime_factors_size;\n    let mut prime_factors_size\
    \ = prime_factors_size % factors_size;\n    let mut factorization = factorization(n);\n\
    \    let mut factors_size = factors_size % prime_factors_size;\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factorization` in this scope\n  -->\
    \ /tmp/tmph5ndm2nh.rs:14:29\n   |\n14 |     let mut factorization = factorization(n);\n\
    \   |                             ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph5ndm2nh.rs:10:27\n   |\n10 | fn factorize(n:\
    \ isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpzzsjvzuv.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n            i += 1;\n        }\n  \
    \  }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpgrv5015d.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n        }\n        i += 1;\n    }\n\
    \    factors.push(n);\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpdzsgsst7.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = vec![true; n];\n    let mut i = 2;\n    while i < n {\n  \
    \      if primes[i] == true {\n            factors.push(i as isize);\n       \
    \     i += 1;\n        }\n        else {\n            i += 1;\n        }\n   \
    \ }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp9ohcrr4.rs:12:33\n   |\n\
    12 |     let mut primes = vec![true; n];\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ primes = vec![true; n.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[bool]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpp9ohcrr4.rs:15:12\n   |\n15 |         if primes[i]\
    \ == true {\n   |            ^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<bool>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_counter = Vec::new();\n   \
    \ let mut prime_counter2 = Vec::new();\n    let mut prime_counter3 = Vec::new();\n\
    \    let mut prime_counter4 = Vec::new();\n    let mut prime_counter5 = Vec::new();\n\
    \    let mut prime_counter6 = Vec::new();\n    let mut prime_counter7 = Vec::new();\n\
    \    let mut prime_counter8 = Vec::new();\n    let mut prime_counter9 = Vec::new();\n\
    \    let mut prime_counter10 = Vec::new();\n    let mut prime_counter11 = Vec::new();\n\
    \    let mut prime_counter12 = Vec::new();\n    let mut prime_counter13 = Vec::new();\n\
    \    let mut prime_counter14 = Vec::new();\n    let mut prime_counter15 = Vec::new();\n\
    \    let mut prime_counter16 = Vec::new();\n    let mut prime_counter17 = Vec::new();\n\
    \    let mut prime_counter18 = Vec::new();\n    let mut prime_counter19 = Vec::new();\n\
    \    let mut prime_counter20 = Vec::new();\n    let mut prime_counter21 = Vec::new();\n\
    \    let mut prime_counter22 = Vec::new();\n    let mut prime_counter23 = Vec::new();\n\
    \    let mut prime_counter24 = Vec::new();\n    let mut prime_counter25 = Vec::new();\n\
    \    let mut prime_counter26 = Vec::new();\n    let mut prime_counter27 = Vec::new();\n\
    \    let mut prime_counter28 = Vec::new();\n    let mut prime_counter29 = Vec::new();\n\
    \    let mut prime_counter30 = Vec::new();\n    let mut prime_counter31 = Vec::new();\n\
    \    let mut prime_counter32 = Vec::new();\n    let mut prime_counter33 = Vec::new();\n\
    \    let mut prime_counter34 = Vec::new();\n    let mut prime_counter35 = Vec::new();\n\
    \    let mut prime_counter36 = Vec::new();\n    let mut prime_counter37 = Vec::new();\n\
    \    let mut prime_counter38 = Vec::new();\n    let mut prime_counter39 = Vec::\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1dlt87d1.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size_reverse = Vec::new();\n    let mut primes_size_reverse_sorted\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse = Vec::new();\n\
    \    let mut primes_size_reverse_sorted_reverse2 = Vec::new();\n    let mut primes_size_reverse_sorted_reverse3\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse4 = Vec::new();\n\
    \    let mut primes_size_reverse_sorted_reverse5 = Vec::new();\n    let mut primes_size_reverse_sorted_reverse6\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse7 = Vec::new();\n\
    \    let mut primes_size_reverse_sorted_reverse8 = Vec::new();\n    let mut primes_size_reverse_sorted_reverse9\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse10 = Vec::new();\n\
    \    let mut primes_size_reverse_sorted_reverse11 = Vec::new();\n    let mut primes_size_reverse_sorted_reverse12\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse13 = Vec::new();\n\
    \    let mut primes_size_reverse_sorted_reverse14 = Vec::new();\n    let mut primes_size_reverse_sorted_reverse15\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse16 = Vec::new();\n\
    \    let mut primes_size_reverse_sorted_reverse17 = Vec::new();\n    let mut primes_size_reverse_sorted_reverse18\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse19 = Vec::new();\n\
    \    let mut primes_size_reverse_sorted_reverse20 = Vec::new();\n    let mut primes_size_reverse_sorted_reverse21\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse22 = Vec::new();\n\
    \    let mut primes_size_reverse_sorted_reverse23 = Vec::new();\n    let mut primes_size_reverse_sorted_reverse24\
    \ = Vec::new();\n    let mut primes_size_reverse_sorted_reverse25 = Vec::new();\n\
    \    let mut primes_size_reverse_sorted_reverse26 = Vec::new();\n    let mut primes_size_reverse_sorted_reverse27\
    \ = Vec::new();\n    let mut primes_\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmim9f6ns.rs:43:20\n   |\n\
    43 |     let mut primes_\n   |                    ^ help: add `;` here\n44 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmim9f6ns.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut primes_count = Vec::new();\n    let\
    \ mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let mut primes_count_max = Vec::new();\n    let mut primes_count_min = Vec::new();\n\
    \    let \n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp1ips3c7y.rs:55:1\n  \
    \ |\n55 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = vec![true; n];\n    let mut prime_factors = vec![0; n];\n\
    \    let mut prime_factors_count = vec![0; n];\n    let mut prime_factors_count_max\
    \ = vec![0; n];\n    let mut prime_factors_count_min = vec![0; n];\n    let mut\
    \ prime_factors_count_max_prime = vec![0; n];\n    let mut prime_factors_count_min_prime\
    \ = vec![0; n];\n    let mut prime_factors_count_max_prime_prime = vec![0; n];\n\
    \    let mut prime_factors_count_min_prime_prime = vec![0; n];\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = vec![0; n];\n    let mut prime_factors_count_min_prime_prime_prime = vec![0;\
    \ n];\n    let mut prime_factors_count_max_prime_prime_prime_prime = vec![0; n];\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime = vec![0; n];\n \
    \   let mut prime_factors_count_max_prime_prime_prime_prime_prime = vec![0; n];\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = vec![0; n];\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = vec![0;\
    \ n];\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime\
    \ = vec![0; n];\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = vec![0; n];\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = vec![0; n];\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = vec![0; n];\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = vec![0; n];\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = vec![0; n];\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = vec![0; n];\n    let mut prime_factors_count_\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpg5768u1v.rs:35:33\n   |\n\
    35 |     let mut prime_factors_count_\n   |                                 ^\
    \ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg5768u1v.rs:12:33\n   |\n12 |     let mut primes = vec![true;\
    \ n];\n   |                                 ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n12 |     let mut primes = vec![true; n.try_into().unwrap()];\n\
    \   |                                  ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg5768u1v.rs:13:37\n   |\n13 |     let mut prime_factors\
    \ = vec![0; n];\n   |                                     ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n13 |     let mut prime_factors = vec![0;\
    \ n.try_into().unwrap()];\n   |                                      ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpg5768u1v.rs:14:43\n   |\n14 |\
    \     let mut prime_factors_count = vec![0; n];\n   |                        \
    \                   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    14 |     let mut prime_factors_count = vec![0; n.try_into().unwrap()];\n   | \
    \                                           ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg5768u1v.rs:15:47\n   |\n15 |     let mut prime_factors_count_max\
    \ = vec![0; n];\n   |                                               ^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n15 |     let mut prime_factors_count_max\
    \ = vec![0; n.try_into().unwrap()];\n   |                                    \
    \            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg5768u1v.rs:16:47\n\
    \   |\n16 |     let mut prime_factors_count_min = vec![0; n];\n   |     "
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut factorization = Vec::new();\n\
    \    let mut factorization_count = Vec::new();\n    let mut factorization_prime\
    \ = Vec::new();\n    let mut factorization_prime_count = Vec::new();\n    let\
    \ mut factorization_prime_prime = Vec::new();\n    let mut factorization_prime_prime_count\
    \ = Vec::new();\n    let mut factorization_prime_prime_prime = Vec::new();\n \
    \   let mut factorization_prime_prime_prime_count = Vec::new();\n    let mut factorization_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_prime_prime_prime_count = Vec::new();\n\
    \    let mut factorization_prime_prime_prime_prime_prime = Vec::new();\n    let\
    \ mut factorization_prime_prime_prime_prime_prime_count = Vec::new();\n    let\
    \ mut factorization_prime_prime_prime_prime_prime_prime = Vec::new();\n    let\
    \ mut factorization_prime_prime_prime_prime_prime_count = Vec::new();\n    let\
    \ mut factorization_prime_prime_prime_prime_prime_prime = Vec::new();\n    let\
    \ mut factorization_prime_prime_prime_prime_prime_prime_count = Vec::new();\n\
    \    let mut factorization_prime_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut factorization_prime_prime_prime_prime_prime_prime_prime_count = Vec::new();\n\
    \    let mut factorization_prime_prime_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut factorization_prime_prime_prime_prime_prime_prime_prime_count = Vec::new();\n\
    \    let mut factorization_prime_prime_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut factorization_prime_prime_prime_prime_prime_prime_prime_prime_count\
    \ = Vec::new();\n    let mut factorization_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut factorization_prime_prime_prime_prime_prime_\n}\n\
    \nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa4wf3x2k.rs:38:57\n   |\n\
    38 |     let mut factorization_prime_prime_prime_prime_prime_\n   |          \
    \                                               ^ help: add `;` here\n39 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa4wf3x2k.rs:10:27\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------        \
    \      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n    \
    \        factors.push(factor);\n            n /= factor;\n        } else {\n \
    \           factor *= factor;\n        }\n    }\n    factors.push(factor);\n \
    \   factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpzzcrku80.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    let mut i = 1;\n    while i <= n {\n        if n %\
    \ i == 0 {\n            factors.push(factor);\n            factor = 1;\n     \
    \       i += 1;\n        } else {\n            factor *= i;\n        }\n    }\n\
    \    factors.push(factor);\n    factors\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1]`,\n right: `[2]`', /tmp/tmpib_m2nq7.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_count = Vec::new();\n    let mut primes_count_size = Vec::new();\n\
    \    let mut primes_count_size = Vec::new();\n    let mut primes_count_size =\
    \ Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mut primes_count_size = Vec::new();\n    let mut primes_count_size\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp58k38grs.rs:54:11\n   |\n\
    54 |     let mu\n   |           ^ help: add `;` here\n55 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp58k38grs.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = vec![true; n];\n    let mut prime_factors = vec![0; n];\n\
    \    let mut i = 1;\n    while i < n {\n        if primes[i] {\n            prime_factors[i]\
    \ = 1;\n            i += 1;\n        } else {\n            prime_factors[i] =\
    \ 0;\n            i += 2;\n        }\n    }\n    for i in 2..n {\n        if prime_factors[i]\
    \ == 0 {\n            continue;\n        }\n        let mut j = 1;\n        while\
    \ j < n {\n            if prime_factors[j] == 0 {\n                prime_factors[j]\
    \ = i;\n                j += 1;\n                break;\n            }\n     \
    \       j += 2;\n        }\n        if j == n {\n            factors.push(prime_factors[i]);\n\
    \        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmuan2ojo.rs:12:33\n   |\n\
    12 |     let mut primes = vec![true; n];\n   |                               \
    \  ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ primes = vec![true; n.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmuan2ojo.rs:13:37\n\
    \   |\n13 |     let mut prime_factors = vec![0; n];\n   |                    \
    \                 ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    13 |     let mut prime_factors = vec![0; n.try_into().unwrap()];\n   |       \
    \                               ++++++++++++++++++++\n\nerror[E0277]: the type\
    \ `[bool]` cannot be indexed by `isize`\n  --> /tmp/tmpmuan2ojo.rs:16:12\n   |\n\
    16 |         if primes[i] {\n   |            ^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpmuan2ojo.rs:17:13\n   |\n17 |         \
    \    prime_factors[i] = 1;\n   |             ^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpmuan2ojo.rs:20:13\n   |\n20 |  \
    \           prime_factors[i] = 0;\n   |             ^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>`\
    \ is not implemented "
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        else {\n       \
    \     i += 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpa6kznut5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n            i += 1;\n        }\n  \
    \  }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n    let candidate =\
    \ factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpgrv5015d.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpduuwdehj.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpduuwdehj.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_counter = Vec::new();\n   \
    \ let mut prime_counter2 = Vec::new();\n    let mut prime_counter3 = Vec::new();\n\
    \    let mut prime_counter4 = Vec::new();\n    let mut prime_counter5 = Vec::new();\n\
    \    let mut prime_counter6 = Vec::new();\n    let mut prime_counter7 = Vec::new();\n\
    \    let mut prime_counter8 = Vec::new();\n    let mut prime_counter9 = Vec::new();\n\
    \    let mut prime_counter10 = Vec::new();\n    let mut prime_counter11 = Vec::new();\n\
    \    let mut prime_counter12 = Vec::new();\n    let mut prime_counter13 = Vec::new();\n\
    \    let mut prime_counter14 = Vec::new();\n    let mut prime_counter15 = Vec::new();\n\
    \    let mut prime_counter16 = Vec::new();\n    let mut prime_counter17 = Vec::new();\n\
    \    let mut prime_counter18 = Vec::new();\n    let mut prime_counter19 = Vec::new();\n\
    \    let mut prime_counter20 = Vec::new();\n    let mut prime_counter21 = Vec::new();\n\
    \    let mut prime_counter22 = Vec::new();\n    let mut prime_counter23 = Vec::new();\n\
    \    let mut prime_counter24 = Vec::new();\n    let mut prime_counter25 = Vec::new();\n\
    \    let mut prime_counter26 = Vec::new();\n    let mut prime_counter27 = Vec::new();\n\
    \    let mut prime_counter28 = Vec::new();\n    let mut prime_counter29 = Vec::new();\n\
    \    let mut prime_counter30 = Vec::new();\n    let mut prime_counter31 = Vec::new();\n\
    \    let mut prime_counter32 = Vec::new();\n    let mut prime_counter33 = Vec::new();\n\
    \    let mut prime_counter34 = Vec::new();\n    let mut prime_counter35 = Vec::new();\n\
    \    let mut prime_counter36 = Vec::new();\n    let mut prime_counter37 = Vec::new();\n\
    \    let mut prime_counter38 = Vec::new();\n    let mut prime_counter39 = Vec::\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1dlt87d1.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        else {\n       \
    \     i += 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpa6kznut5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_counter = 1;\n    let mut prime_factor\
    \ = 1;\n    let mut factor = 1;\n    let mut counter = 1;\n    let mut factorization\
    \ = Vec::new();\n    let mut prime_factors = Vec::new();\n    let mut prime_factors_counter\
    \ = 1;\n    let mut prime_factors_factor = 1;\n    let mut prime_factors_counter_factor\
    \ = 1;\n    let mut prime_factors_factorization = Vec::new();\n    let mut prime_factors_factorization_counter\
    \ = 1;\n    let mut prime_factors_factorization_factor = 1;\n    let mut prime_factors_factorization_counter_factor\
    \ = 1;\n    let mut prime_factors_factorization_factorization = Vec::new();\n\
    \    let mut prime_factors_factorization_factorization_counter = 1;\n    let mut\
    \ prime_factors_factorization_factorization_factor = 1;\n    let mut prime_factors_factorization_factorization_counter_factor\
    \ = 1;\n    let mut prime_factors_factorization_factorization_factorization =\
    \ Vec::new();\n    let mut prime_factors_factorization_factorization_factorization_counter\
    \ = 1;\n    let mut prime_factors_factorization_factorization_factorization_factor\
    \ = 1;\n    let mut prime_factors_factorization_factorization_factorization_counter_factor\
    \ = 1;\n    let mut prime_factors_factorization_factorization_factorization_factorization\
    \ = Vec::new();\n    let mut prime_factors_factorization_factorization_factorization_factorization_counter\
    \ = 1;\n    let mut prime_factors_factorization_factorization_factorization_factorization_factor\
    \ = 1;\n    let mut prime_factors_factorization_factorization_factorization_factorization_counter_factor\
    \ = 1;\n    let mut prime_factors_factorization_factorization_factorization_factorization_factorization\
    \ = Vec::new();\n    let mut prime_factors_factorization_factorization_factorization_factorization_factorization_counter\
    \ = 1;\n    let mut prime_factors_factorization_factorization_factorization_factorization_factor\
    \ = 1;\n    let mut prime_factors_factorization_factorization_factorization_factorization_counter_factor\
    \ = 1;\n    let mut prime_factors_factorization_factorization_factorization_factorization_factorization\
    \ = Vec::new();\n    let mut prime_factors_factorization_factorization_factorization_factorization_factorization_counter\
    \ = 1;\n    let mut prime_factors_factorization_factorization_factorization_factorization_factor\
    \ = 1;\n    let mut prime_factors_factorization_factorization_factorization_factorization_factorization_counter_factor\
    \ = 1;\n    let mut prime_factors_factorization_factorization_factorization_factorization_factorization_factor\
    \ = 1;\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4s_hntus.rs:47:11\n   |\n\
    47 |     let mu\n   |           ^ help: add `;` here\n48 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4s_hntus.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_prime = Vec::new();\n    let mut prime_factors_count_min_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime = Vec::new();\n \
    \   let mut prime_factors_count_min_prime_prime_prime_prime = Vec::new();\n  \
    \  let mut prime_factors_count_max_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime = Vec::new();\n\
    \    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_min_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mut prime_factors_count_max_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = Vec::new();\n    let mu\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpduuwdehj.rs:36:11\n   |\n\
    36 |     let mu\n   |           ^ help: add `;` here\n37 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpduuwdehj.rs:10:27\n \
    \  |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------         \
    \     ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpwj5y7kfk.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp5h6q1l78.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut factorization = Vec::new();\n    let mut factorization_primes = Vec::new();\n\
    \    let mut factorization_prime_factors = Vec::new();\n    let mut factorization_prime_factors_count\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max = Vec::new();\n\
    \    let mut factorization_prime_factors_count_max_index = Vec::new();\n    let\
    \ mut factorization_prime_factors_count_max_value = Vec::new();\n    let mut factorization_prime_factors_count_max_value\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value = Vec::new();\n\
    \    let mut factorization_prime_factors_count_max_value = Vec::new();\n    let\
    \ mut factorization_prime_factors_count_max_value = Vec::new();\n    let mut factorization_prime_factors_count_max_value\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value = Vec::new();\n\
    \    let mut factorization_prime_factors_count_max_value = Vec::new();\n    let\
    \ mut factorization_prime_factors_count_max_value = Vec::new();\n    let mut factorization_prime_factors_count_max_value\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value = Vec::new();\n\
    \    let mut factorization_prime_factors_count_max_value = Vec::new();\n    let\
    \ mut factorization_prime_factors_count_max_value = Vec::new();\n    let mut factorization_prime_factors_count_max_value\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value = Vec::new();\n\
    \    let mut factorization_prime_factors_count_max_value = Vec::new();\n    let\
    \ mut factorization_prime_factors_count_max_value = Vec::new();\n    let mut factorization_prime_factors_count_max_value\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value = Vec::new();\n\
    \    let mut factorization_prime_factors_count_max_value = Vec::new();\n    let\
    \ mut factorization_prime_factors_count_max_value = Vec::new();\n    let mut factorization_prime_factors_count_max_value\
    \ = Vec::new();\n    let mut factorization_prime_factors_count_max_value = Vec::new();\n\
    \    let mut factorization_prime_factors_count_max_value = Vec::new();\n    let\
    \ mut factorization_prime_factors_count_max_value = Vec::new();\n\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfym25n4p.rs:10:27\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut i = 2;\n    while i * i <= n {\n\
    \        if n % i == 0 {\n            factors.push(i);\n            n /= i;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    while n != 1 {\n\
    \        factors.push(n);\n        n /= 2;\n    }\n    for i in factors.iter()\
    \ {\n        primes.push(i);\n    }\n    primes\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4b37z3qr.rs:29:5\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |                           ----------\
    \ expected `Vec<isize>` because of return type\n...\n29 |     primes\n   |   \
    \  ^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_counter = Vec::new();\n   \
    \ let mut prime_factors = Vec::new();\n    let mut factorization = Vec::new();\n\
    \    let mut factorization_counter = Vec::new();\n    let mut factorization_prime\
    \ = Vec::new();\n    let mut factorization_prime_counter = Vec::new();\n    let\
    \ mut factorization_prime_factors = Vec::new();\n    let mut factorization_prime_factors_counter\
    \ = Vec::new();\n    let mut factorization_prime_factors_counter2 = Vec::new();\n\
    \    let mut factorization_prime_factors_counter3 = Vec::new();\n    let mut factorization_prime_factors_counter4\
    \ = Vec::new();\n    let mut factorization_prime_factors_counter5 = Vec::new();\n\
    \    let mut factorization_prime_factors_counter6 = Vec::new();\n    let mut factorization_prime_factors_counter7\
    \ = Vec::new();\n    let mut factorization_prime_factors_counter8 = Vec::new();\n\
    \    let mut factorization_prime_factors_counter9 = Vec::new();\n    let mut factorization_prime_factors_counter10\
    \ = Vec::new();\n    let mut factorization_prime_factors_counter11 = Vec::new();\n\
    \    let mut factorization_prime_factors_counter12 = Vec::new();\n    let mut\
    \ factorization_prime_factors_counter13 = Vec::new();\n    let mut factorization_prime_factors_counter14\
    \ = Vec::new();\n    let mut factorization_prime_factors_counter15 = Vec::new();\n\
    \    let mut factorization_prime_factors_counter16 = Vec::new();\n    let mut\
    \ factorization_prime_factors_counter17 = Vec::new();\n    let mut factorization_prime_factors_counter18\
    \ = Vec::new();\n    let mut factorization_prime_factors_counter19 = Vec::new();\n\
    \    let mut factorization_prime_factors_counter20 = Vec::new();\n    let mut\
    \ factorization_prime_factors_counter21 = Vec::new();\n    let mut factorization_prime_factors_counter22\
    \ = Vec::new();\n    let mut factorization_prime_factors_counter23 = Vec::new();\n\
    \    let mut factorization_prime_factors_counter24 = Vec::new();\n    let mut\
    \ factorization_prime_factors_counter25 = Vec::new();\n    let mut factorization_prime_factors_counter26\
    \ = Vec::new();\n    let mut \n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpwyinlnlp.rs:47:1\n\
    \   |\n47 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpwj5y7kfk.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n          \
    \  factors.push(i);\n            n /= i;\n        }\n        else {\n        \
    \    primes.push(i);\n        }\n        i += 1;\n    }\n    for i in primes {\n\
    \        prime_factors.push(factors.iter().filter(|&x| x == i).count());\n   \
    \ }\n    prime_factors\n}\n\nfn main() {\n    let candidate = factorize;\n   \
    \ assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n\
    \    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3,\
    \ 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmphqu4wvfk.rs:26:57\n\
    \   |\n26 |         prime_factors.push(factors.iter().filter(|&x| x == i).count());\n\
    \   |                                                         ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmphqu4wvfk.rs:28:5\n   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n\
    \   |                           ---------- expected `Vec<isize>` because of return\
    \ type\n...\n28 |     prime_factors\n   |     ^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<usize>`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpwj5y7kfk.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut factorization = Vec::new();\n    let mut factorization_size = Vec::new();\n\
    \    let mut factorization_repeat = Vec::new();\n    let mut factorization_repeat_count\
    \ = Vec::new();\n    let mut factorization_repeat_count_max = Vec::new();\n  \
    \  let mut factorization_repeat_count_max_index = Vec::new();\n    let mut factorization_repeat_count_min\
    \ = Vec::new();\n    let mut factorization_repeat_count_min_index = Vec::new();\n\
    \    let mut factorization_repeat_count_sum = Vec::new();\n    let mut factorization_repeat_count_sum_index\
    \ = Vec::new();\n    let mut factorization_repeat_count_product = Vec::new();\n\
    \    let mut factorization_repeat_count_product_index = Vec::new();\n    let mut\
    \ factorization_repeat_count_product2 = Vec::new();\n    let mut factorization_repeat_count_product2_index\
    \ = Vec::new();\n    let mut factorization_repeat_count_product3 = Vec::new();\n\
    \    let mut factorization_repeat_count_product3_index = Vec::new();\n    let\
    \ mut factorization_repeat_count_product4 = Vec::new();\n    let mut factorization_repeat_count_product4_index\
    \ = Vec::new();\n    let mut factorization_repeat_count_product5 = Vec::new();\n\
    \    let mut factorization_repeat_count_product5_index = Vec::new();\n    let\
    \ mut factorization_repeat_count_product6 = Vec::new();\n    let mut factorization_repeat_count_product6_index\
    \ = Vec::new();\n    let mut factorization_repeat_count_product7 = Vec::new();\n\
    \    let mut factorization_repeat_count_product7_index = Vec::new();\n    let\
    \ mut factorization_repeat_count_product8 = Vec::new();\n    let mut factorization_repeat_count_product8_index\
    \ = Vec::new();\n    let mut factorization_repeat_count_product9 = Vec::new();\n\
    \    let mut factorization_repeat_count_product9_index = Vec::new();\n    let\
    \ mut factorization_repeat_count_product10 = Vec::new();\n    let mut factorization_repeat_count_product10_index\
    \ = Vec::new();\n    let mut factorization_repeat_count_product\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpj20t4cu1.rs:44:47\n   |\n\
    44 |     let mut factorization_repeat_count_product\n   |                    \
    \                           ^ help: add `;` here\n45 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpj20t4cu1.rs:10:27\n   |\n10 |\
    \ fn factorize(n: isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        else {\n       \
    \     i += 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpa6kznut5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n    let\
    \ mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            factors.push(i);\n\
    \            i += 1;\n        }\n        i += 1;\n    }\n    factors\n}\n\nfn\
    \ main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpoowkefsz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut factorization = Vec::new();\n\
    \n    let mut factorization_size = factorization.len();\n\n    for i in 2..n {\n\
    \        if n % i == 0 {\n            factors.push(i as isize);\n            factorization_size++;\n\
    \        }\n    }\n\n    for i in 2..n {\n        if n % i == 0 {\n          \
    \  let mut factorization = factorization.clone();\n            let mut factorization_size\
    \ = factorization.len();\n            for j in 2..i {\n                if n %\
    \ j == 0 {\n                    factorization.push(j as isize);\n            \
    \        factorization_size++;\n                }\n            }\n           \
    \ factors.push(factorization);\n            factorization_size++;\n        }\n\
    \    }\n\n    for i in 2..n {\n        if n % i == 0 {\n            let mut factorization\
    \ = factorization.clone();\n            let mut factorization_size = factorization.len();\n\
    \            for j in 2..i {\n                if n % j == 0 {\n              \
    \      factorization.push(j as isize);\n                    factorization_size++;\n\
    \                }\n            }\n            factors.push(factorization);\n\
    \            factorization_size++;\n        }\n    }\n\n    for i in 2..n {\n\
    \        if n % i == 0 {\n            let mut factorization = factorization.clone();\n\
    \            let mut factorization_size = factorization.len();\n            for\
    \ j in 2..i {\n                if n % j == 0 {\n                    factorization.push(j\
    \ as isize);\n                    factorization_size++;\n                }\n \
    \           }\n            factors.push(factorization);\n            factorization_size++;\n\
    \        }\n    }\n\n    for i in 2..n {\n        if n % i == 0 {\n          \
    \  let mut factorization = factorization.clone();\n            let mut factorization_size\
    \ = factorization.len();\n            for j in 2..i {\n                if n %\
    \ j == 0 {\n                    factorization.push(j as isize);\n            \
    \        factorization_size++;\n                }\n            }\n           \
    \ factors.push(factorization);\n            factorization_size++;\n        }\n\
    \    }\n\n    for i in 2..n {\n        if n % i == 0 {\n            let mut factorization\
    \ = factorization.clone();\n            let mut factorization_size = factorization.len();\n\
    \            for j in 2..i {\n                if n % j == 0 {\n              \
    \      factorization.push(j as isize);\n                    factorization_size++;\n\
    \                }\n            }\n            factors.push(factorization);\n\
    \            factorization_size++;\n        }\n    }\n\n    for i in 2..n {\n\
    \        if n % i == 0 {\n            let mu\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp5es_5cdz.rs:116:3\n\
    \    |\n10  | fn factorize(n: isize) -> Vec<isize> {\n    |                  \
    \                    - unclosed delimiter\n...\n101 |     for i in 2..n {\n  \
    \  |                   - unclosed delimiter\n102 |         if n % i == 0 {\n \
    \   |                       - this delimiter might not be properly closed...\n\
    103 |             let mu\n104 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n116 | }\n    |   ^\n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmp5es_5cdz.rs:22:31\n   |\n22 |             factorization_size++;\n\
    \   |                               ^^ not a valid postfix operator\n   |\nhelp:\
    \ use `+= 1` instead\n   |\n22 |             { let tmp = factorization_size; factorization_size\
    \ += 1; tmp };\n   |             +++++++++++                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    22 -             factorization_size++;\n22 +             factorization_size +=\
    \ 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmp5es_5cdz.rs:33:39\n\
    \   |\n33 |                     factorization_size++;\n   |                  \
    \                     ^^ not a valid postfix operator\n   |\nhelp: use `+= 1`\
    \ instead\n   |\n33 |                     { let tmp = factorization_size; factorization_size\
    \ += 1; tmp };\n   |                     +++++++++++                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    33 -                     factorization_size++;\n33 +                     factorization_size\
    \ += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmp5es_5cdz.rs:37:31\n\
    \   |\n37 |             factorization_size++;\n   |                          \
    \     ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    37 |             { let tmp = factorization_size; factorization_size += 1; tmp\
    \ };\n   |             +++++++++++                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    37 -             factorization_size++;\n37 +             factorization_size +=\
    \ 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmp5es_5cdz.rs:48:39\n\
    \   |\n4"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n    \
    \        factors.push(factor);\n            n /= factor;\n        } else {\n \
    \           factor *= factor;\n        }\n    }\n    factors.push(factor);\n \
    \   factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpzzcrku80.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::new();\n    let\
    \ mut primes_size = Vec::new();\n    let mut primes_size = Vec::\n}\n\nfn main()\
    \ {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpwj5y7kfk.rs:58:1\n\
    \   |\n58 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    factors.push(n);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp5h6q1l78.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut prime_factors_count_max\
    \ = Vec::new();\n    let mut prime_factors_count_min = Vec::new();\n    let mut\
    \ prime_factors_count_max_index = Vec::new();\n    let mut prime_factors_count_min_index\
    \ = Vec::new();\n    let mut prime_factors_count_max_value = Vec::new();\n   \
    \ let mut prime_factors_count_min_value = Vec::new();\n    let mut prime_factors_count_max_value_2\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_2 = Vec::new();\n \
    \   let mut prime_factors_count_max_value_3 = Vec::new();\n    let mut prime_factors_count_min_value_3\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_4 = Vec::new();\n \
    \   let mut prime_factors_count_min_value_4 = Vec::new();\n    let mut prime_factors_count_max_value_5\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_5 = Vec::new();\n \
    \   let mut prime_factors_count_max_value_6 = Vec::new();\n    let mut prime_factors_count_min_value_6\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_7 = Vec::new();\n \
    \   let mut prime_factors_count_min_value_7 = Vec::new();\n    let mut prime_factors_count_max_value_8\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_8 = Vec::new();\n \
    \   let mut prime_factors_count_max_value_9 = Vec::new();\n    let mut prime_factors_count_min_value_9\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_10 = Vec::new();\n\
    \    let mut prime_factors_count_min_value_10 = Vec::new();\n    let mut prime_factors_count_max_value_11\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_11 = Vec::new();\n\
    \    let mut prime_factors_count_max_value_12 = Vec::new();\n    let mut prime_factors_count_min_value_12\
    \ = Vec::new();\n    let mut prime_factors_count_max_value_13 = Vec::new();\n\
    \    let mut prime_factors_count_min_value_13 = Vec::new();\n    let mut prime_factors_count_max_value_14\
    \ = Vec::new();\n    let mut prime_factors_count_min_value_\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmppiqncm3z.rs:46:43\n   |\n\
    46 |     let mut prime_factors_count_min_value_\n   |                        \
    \                   ^ help: add `;` here\n47 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmppiqncm3z.rs:10:27\n   |\n10 | fn\
    \ factorize(n: isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n    \
    \        factors.push(factor);\n            n /= factor;\n        } else {\n \
    \           factor *= factor;\n        }\n    }\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpsln1sf8i.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: -1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut i = 1;\n    let mut j = 1;\n    let mut k = n;\n    while i <= k {\n\
    \        if n % i == 0 {\n            primes.push(i);\n            prime_factors.push(i);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    while k > 1 {\n        if prime_factors.len() == 0 {\n            factors.push(1);\n\
    \            prime_factors.push(1);\n        } else {\n            let mut j =\
    \ 1;\n            while j < prime_factors.len() {\n                let mut k =\
    \ prime_factors[j];\n                while k > 1 {\n                    if n %\
    \ k == 0 {\n                        factors.push(k);\n                       \
    \ prime_factors.push(k);\n                        break;\n                   \
    \ } else {\n                        k += 1;\n                    }\n         \
    \       }\n                j += 1;\n            }\n        }\n        k -= 1;\n\
    \    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660010991
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n \
    \           factors.push(factor);\n            n /= factor;\n        }\n     \
    \   factor *= 2;\n    }\n    factors.push(1);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpf7t0nr19.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut prime_factors = Vec::new();\n   \
    \ let mut prime_factors_count = Vec::new();\n    let mut factorization = Vec::new();\n\
    \    let mut factorization_count = Vec::new();\n    let mut factorization_primes\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_primes_count = Vec::new();\n    let\
    \ mut factorization_primes_count = Vec::new();\n    let mut factorization_primes_count\
    \ = Vec::new();\n    let mut factorization_prime\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpksrnp0lt.rs:51:32\n   |\n\
    51 |     let mut factorization_prime\n   |                                ^ help:\
    \ add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpksrnp0lt.rs:10:27\n   |\n10 | fn factorize(n: isize) -> Vec<isize>\
    \ {\n   |    ---------              ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = vec![true; n + 1];\n    let mut i = 2;\n    while i < n {\n\
    \        if primes[i] {\n            factors.push(i as isize);\n            primes[i]\
    \ = false;\n        }\n        while i * i < n && !primes[i * i] {\n         \
    \   i += 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsxp0r8z9.rs:12:33\n   |\n\
    12 |     let mut primes = vec![true; n + 1];\n   |                           \
    \      ^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut primes = vec![true; (n + 1).try_into().unwrap()];\n   |                \
    \                 +     +++++++++++++++++++++\n\nerror[E0277]: the type `[bool]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpsxp0r8z9.rs:15:12\n   |\n15 |  \
    \       if primes[i] {\n   |            ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpsxp0r8z9.rs:17:13\n   |\n17 |            \
    \ primes[i] = false;\n   |             ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[bool]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<bool>`\n\nerror[E0277]: the type `[bool]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpsxp0r8z9.rs:19:29\n   |\n19 |         while\
    \ i * i < n && !primes[i * i] {\n   |                             ^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[bool]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<bool>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut primes = Vec::new();\n    let mut primes_size = primes.len();\n   \
    \ let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n    let mut primes_size = primes_size as usize;\n    let mut primes_size\
    \ = primes_size as usize;\n    let mut primes_size = primes_size as usize;\n \
    \   let mut primes_size = primes_size as usize;\n    let mut primes_size = primes_size\
    \ as usize;\n\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzmjbacao.rs:10:27\n   |\n\
    10 | fn factorize(n: isize) -> Vec<isize> {\n   |    ---------              ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = vec![];\n    let\
    \ mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n            factors.push(i);\n\
    \            i += 1;\n        }\n        i += 1;\n    }\n    factors\n}\n\nfn\
    \ main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n\
    \    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2,\
    \ 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpoowkefsz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n            i += 1;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    if n > 1 {\n        factors.push(n);\n\
    \    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpt3yhti4q.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n \
    \           factors.push(factor);\n            n /= factor;\n        }\n     \
    \   factor += 1;\n    }\n    factors\n}\n\nfn main() {\n    let candidate = factorize;\n\
    \    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2,\
    \ 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmp3ek8ue3e.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        else {\n       \
    \     i += 1;\n        }\n    }\n    factors\n}\n\nfn main() {\n    let candidate\
    \ = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpa6kznut5.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 101
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            i += 1;\n        }\n        i += 1;\n    }\n\
    \    factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1]`,\n right: `[2]`', /tmp/tmpq27y03uz.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010986
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   factors.push(i);\n            n /= i;\n            i += 1;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    factors.push(n);\n    factors\n\
    }\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpoyd_euhh.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= i;\n\
    \   |             ^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n \
    \           factors.push(factor);\n            n /= factor;\n        }\n     \
    \   factor *= 2;\n    }\n    factors.push(1);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpf7t0nr19.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        while n % factor == 0 {\n \
    \           factors.push(factor);\n            n /= factor;\n        }\n     \
    \   factor *= 2;\n    }\n    factors.push(1);\n    factors\n}\n\nfn main() {\n\
    \    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4),\
    \ vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57),\
    \ vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193),\
    \ vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpf7t0nr19.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
- exit_code: 1
  program: "/// Return list of prime factors of given integer in the order from smallest\
    \ to largest.\n/// Each of the factors should be listed number of times corresponding\
    \ to how many times it appeares in factorization.\n/// Input number should be\
    \ equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n\
    /// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\n\
    fn factorize(n: isize) -> Vec<isize> {\n    let mut factors = Vec::new();\n  \
    \  let mut factor = 1;\n    while n > 1 {\n        if n % factor == 0 {\n    \
    \        factors.push(factor);\n            n /= factor;\n        } else {\n \
    \           factor *= factor;\n        }\n    }\n    factors.push(factor);\n \
    \   factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2),\
    \ vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8),\
    \ vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249),\
    \ vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19,\
    \ 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18),\
    \ vec![2, 3, 3]);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpzzcrku80.rs:16:13\n\
    \   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help:\
    \ consider making this binding mutable: `mut n`\n...\n16 |             n /= factor;\n\
    \   |             ^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660010985
