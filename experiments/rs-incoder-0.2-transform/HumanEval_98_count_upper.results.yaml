language: rs
name: HumanEval_98_count_upper
results:
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6abq85q.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count() as isize\n}\n\nfn\
    \ main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp__s_jq2n.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count() as isize\n   |   \
    \                                                      ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjbsrldsr.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_lowercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii_uppercase()).count()\n}\n\n\
    fn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo_xth5he.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii_uppercase()).count()\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \                                    ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E').count() as isize\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpne96gdf2.rs:10:48\n   |\n\
    10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'A' && c != 'e' && c != 'E').count() as ...\n   |     \
    \                                           ^^^\n   |                        \
    \                        |\n   |                                             \
    \   expected `&char`, found `char`\n   |                                     \
    \           help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpne96gdf2.rs:10:60\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E').count() as ...\n   |                                             \
    \               ^^^\n   |                                                    \
    \        |\n   |                                                            expected\
    \ `&char`, found `char`\n   |                                                \
    \            help: consider borrowing here: `&'Z'`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpne96gdf2.rs:10:83\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E').count() as ...\n   |                                             \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpne96gdf2.rs:10:95\n   |\n10 |   \
    \  s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_, c)|\
    \ c != 'a' && c != 'A' && c != 'e' && c != 'E').count() as ...\n   |         \
    \                                                                            \
    \          ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerro"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjbsrldsr.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_lowercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6abq85q.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').count()\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdht7128s.rs:10:48\n   |\n\
    10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').count()\n\
    \   |                                                ^^^\n   |               \
    \                                 |\n   |                                    \
    \            expected `&char`, found `char`\n   |                            \
    \                    help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdht7128s.rs:10:60\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').count()\n   |                                    \
    \                        ^^^\n   |                                           \
    \                 |\n   |                                                    \
    \        expected `&char`, found `char`\n   |                                \
    \                            help: consider borrowing here: `&'Z'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdht7128s.rs:10:5\n   |\n9  | fn count_upper(s:\
    \ String) -> isize {\n   |                              ----- expected `isize`\
    \ because of return type\n10 |     s.chars().enumerate().filter(|(_, c)| c >=\
    \ 'A' && c <= 'Z').count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').count().try_into().unwrap()\n   |                \
    \                                                        ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6abq85q.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6abq85q.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6abq85q.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjbsrldsr.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_lowercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjbsrldsr.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_lowercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| {\n        c.is_ascii_letter() || c.is_ascii_digit()\n\
    \    }).count()\n}\n\nfn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpwr60tx8a.rs:11:11\n   |\n11 |         c.is_ascii_letter()\
    \ || c.is_ascii_digit()\n   |           ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwr60tx8a.rs:10:5\n   |\n9  |   fn count_upper(s: String) -> isize\
    \ {\n   |                                ----- expected `isize` because of return\
    \ type\n10 | /     s.chars().enumerate().filter(|(_, c)| c.is_uppercase()).filter(|(_,\
    \ c)| {\n11 | |         c.is_ascii_letter() || c.is_ascii_digit()\n12 | |    \
    \ }).count()\n   | |______________^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n12 |     }).count().try_into().unwrap()\n   |               ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).count()\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc4pvdzuy.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).count().try_into().unwrap()\n   |                    \
    \                                                ++++++++++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6abq85q.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjbsrldsr.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_lowercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjbsrldsr.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_lowercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjbsrldsr.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_lowercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6abq85q.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6abq85q.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count() / 2\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpz9kysyo_.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count() / 2\n   |        \
    \                                                 ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz9kysyo_.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\
    \ / 2\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count() / 2).try_into().unwrap()\n\
    \   |     +                                                                  \
    \                +++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count() % 2 == 0\n}\n\nfn\
    \ main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpmkzyzi0y.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count() % 2 == 0\n   |   \
    \                                                      ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmkzyzi0y.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\
    \ % 2 == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6abq85q.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6abq85q.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjbsrldsr.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_lowercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6abq85q.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjbsrldsr.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_lowercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E').count() as isize\n}\n\nfn main() {\n    let candidate = count_upper;\n\
    \    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"\
    abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpne96gdf2.rs:10:48\n   |\n\
    10 |     s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_,\
    \ c)| c != 'a' && c != 'A' && c != 'e' && c != 'E').count() as ...\n   |     \
    \                                           ^^^\n   |                        \
    \                        |\n   |                                             \
    \   expected `&char`, found `char`\n   |                                     \
    \           help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpne96gdf2.rs:10:60\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E').count() as ...\n   |                                             \
    \               ^^^\n   |                                                    \
    \        |\n   |                                                            expected\
    \ `&char`, found `char`\n   |                                                \
    \            help: consider borrowing here: `&'Z'`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpne96gdf2.rs:10:83\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c >= 'A' && c <= 'Z').filter(|(_, c)| c != 'a' && c != 'A' && c != 'e' &&\
    \ c != 'E').count() as ...\n   |                                             \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpne96gdf2.rs:10:95\n   |\n10 |   \
    \  s.chars().enumerate().filter(|(_, c)| c >= 'A' && c <= 'Z').filter(|(_, c)|\
    \ c != 'a' && c != 'A' && c != 'e' && c != 'E').count() as ...\n   |         \
    \                                                                            \
    \          ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerro"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjbsrldsr.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_lowercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii_letter()).count()\n}\n\nfn\
    \ main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpvm5bcbei.rs:10:79\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii_letter()).count()\n   |   \
    \                                                                            ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvm5bcbei.rs:10:5\n   |\n9  | fn count_upper(s:\
    \ String) -> isize {\n   |                              ----- expected `isize`\
    \ because of return type\n10 |     s.chars().enumerate().filter(|(_, c)| c.is_uppercase()).filter(|(_,\
    \ c)| c.is_ascii_letter()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \                                 ++++++++++++++++++++\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6abq85q.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjbsrldsr.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_lowercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6abq85q.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3a9ckaqc.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').count() as isize\n   |   \
    \                            ^^^\n   |                               |\n   | \
    \                              expected `&char`, found `char`\n   |          \
    \                     help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3a9ckaqc.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() as isize\n   |                               \
    \            ^^^\n   |                                           |\n   |     \
    \                                      expected `&char`, found `char`\n   |  \
    \                                         help: consider borrowing here: `&'Z'`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii_uppercase()).count()\n}\n\n\
    fn main() {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo_xth5he.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii_uppercase()).count()\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \                                    ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6abq85q.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")), 1);\n  \
    \  assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3a9ckaqc.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').count() as isize\n   |   \
    \                            ^^^\n   |                               |\n   | \
    \                              expected `&char`, found `char`\n   |          \
    \                     help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3a9ckaqc.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').count() as isize\n   |                               \
    \            ^^^\n   |                                           |\n   |     \
    \                                      expected `&char`, found `char`\n   |  \
    \                                         help: consider borrowing here: `&'Z'`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6abq85q.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|&(i,\
    \ c)| {\n        c >= 'A' && c <= 'Z' && i % 2 == 0\n    }).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_rzhcalq.rs:10:5\n   |\n\
    9  |   fn count_upper(s: String) -> isize {\n   |                            \
    \    ----- expected `isize` because of return type\n10 | /     s.chars().enumerate().filter(|&(i,\
    \ c)| {\n11 | |         c >= 'A' && c <= 'Z' && i % 2 == 0\n12 | |     }).count()\n\
    \   | |______________^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    12 |     }).count().try_into().unwrap()\n   |               ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwvjmktjn.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().enumerate().filter(|(_,\
    \ c)| c.is_uppercase()).filter(|(_, c)| c.is_ascii()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \                          ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjbsrldsr.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_lowercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjbsrldsr.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_lowercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_lowercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count()\n}\n\nfn main()\
    \ {\n    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"\
    aBCdEf\")), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"\
    B\")), 0);\n    assert_eq!(candidate(String::from(\"U\")), 1);\n    assert_eq!(candidate(String::from(\"\
    \")), 0);\n    assert_eq!(candidate(String::from(\"EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphrsibx3n.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii_uppercase()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_uppercase()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \              ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmp669j99c8.rs:10:57\n\
    \   |\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c % 2 == 0).count()\n\
    \   |                                                       - ^ - {integer}\n\
    \   |                                                       |\n   |          \
    \                                             &char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp669j99c8.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c % 2 == 0).count().try_into().unwrap()\n   | \
    \                                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n}\n\nfn main() {\n   \
    \ let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:31\n   |\n\
    10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'A'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:43\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count()\n   |                 \
    \                          ^^^\n   |                                         \
    \  |\n   |                                           expected `&char`, found `char`\n\
    \   |                                           help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0369]: cannot mod `&char` by `{integer}`\n  --> /tmp/tmpykx_lyb9.rs:10:61\n\
    \   |\n10 |     s.chars().filter(|c| c >= 'A' && c <= 'Z').filter(|c| c % 2 ==\
    \ 0).count()\n   |                                                           -\
    \ ^ - {integer}\n   |                                                        \
    \   |\n   |                                                           &char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpykx_lyb9.rs:10:5\n   |\n9  | fn\
    \ count_upper(s: String) -> isize {\n   |                              ----- expected\
    \ `isize` because of return type\n10 |     s.chars().filter(|c| c >= 'A' && c\
    \ <= 'Z').filter(|c| c % 2 == 0).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c >= 'A' && c <= 'Z').filter(|c| c % 2 == 0).count().try_into().unwrap()\n \
    \  |                                                                         \
    \     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n}\n\nfn main() {\n\
    \    let candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpbwgyuvcp.rs:10:57\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n   |            \
    \                                             ^^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `is_ascii`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbwgyuvcp.rs:10:5\n   |\n9  | fn count_upper(s: String)\
    \ -> isize {\n   |                              ----- expected `isize` because\
    \ of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c.is_ascii_letter()).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii_letter()).count().try_into().unwrap()\n\
    \   |                                                                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
- exit_code: 1
  program: "/// Given a string s, count the number of uppercase vowels in even indices.\n\
    /// For example:\n/// >>> count_upper(String::from(\"aBCdEf\"))\n/// 1\n/// >>>\
    \ count_upper(String::from(\"abcdefg\"))\n/// 0\n/// >>> count_upper(String::from(\"\
    dBBE\"))\n/// 0\nfn count_upper(s: String) -> isize {\n    s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count()\n}\n\nfn main() {\n    let\
    \ candidate = count_upper;\n    assert_eq!(candidate(String::from(\"aBCdEf\")),\
    \ 1);\n    assert_eq!(candidate(String::from(\"abcdefg\")), 0);\n    assert_eq!(candidate(String::from(\"\
    dBBE\")), 0);\n    assert_eq!(candidate(String::from(\"B\")), 0);\n    assert_eq!(candidate(String::from(\"\
    U\")), 1);\n    assert_eq!(candidate(String::from(\"\")), 0);\n    assert_eq!(candidate(String::from(\"\
    EEEE\")), 2);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz6abq85q.rs:10:5\n   |\n\
    9  | fn count_upper(s: String) -> isize {\n   |                              -----\
    \ expected `isize` because of return type\n10 |     s.chars().filter(|c| c.is_uppercase()).filter(|c|\
    \ c.is_ascii()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     s.chars().filter(|c|\
    \ c.is_uppercase()).filter(|c| c.is_ascii()).count().try_into().unwrap()\n   |\
    \                                                                            ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009034
