language: rs
name: HumanEval_149_sorted_list_sum
results:
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        let len = word.len();\n        if len % 2 == 1\
    \ {\n            sorted_list.push(word);\n        } else {\n            let mut\
    \ i = 0;\n            while i < sorted_list.len() && sorted_list[i].len() < len\
    \ {\n                i += 1;\n            }\n            res.push(sorted_list[i]);\n\
    \            sorted_list.splice(i, 1);\n        }\n    }\n    res.sort_by(|a,\
    \ b| a.len().cmp(b.len()));\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: RangeBounds<usize>` is not satisfied\n\
    \    --> /tmp/tmprc3z2vbc.rs:29:32\n     |\n29   |             sorted_list.splice(i,\
    \ 1);\n     |                         ------ ^ the trait `RangeBounds<usize>`\
    \ is not implemented for `usize`\n     |                         |\n     |   \
    \                      required by a bound introduced by this call\n     |\n \
    \    = help: the following other types implement trait `RangeBounds<T>`:\n   \
    \            (Bound<&'a T>, Bound<&'a T>)\n               (Bound<T>, Bound<T>)\n\
    \               RangeFrom<&T>\n               RangeFrom<T>\n               RangeFull\n\
    \               RangeInclusive<&T>\n               RangeInclusive<T>\n       \
    \        RangeTo<&T>\n             and 5 others\nnote: required by a bound in\
    \ `Vec::<T, A>::splice`\n\nerror[E0277]: `{integer}` is not an iterator\n  -->\
    \ /tmp/tmprc3z2vbc.rs:29:35\n   |\n29 |             sorted_list.splice(i, 1);\n\
    \   |                         ------    ^ `{integer}` is not an iterator\n   |\
    \                         |\n   |                         required by a bound\
    \ introduced by this call\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `{integer}`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\nnote: required by a bound in `Splice`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprc3z2vbc.rs:32:36\n   |\n32 |     res.sort_by(|a, b| a.len().cmp(b.len()));\n\
    \   |                                    ^^^^^^^\n   |                       \
    \             |\n   |                                    expected `&usize`, found\
    \ `usize`\n   |                                    help: consider borrowing here:\
    \ `&b.len()`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[0].len() < word.len() {\n      \
    \          sorted_list.push(word);\n            } else {\n                let\
    \ mut i = 0;\n                while i < sorted_list.len() {\n                \
    \    if sorted_list[i].len() < word.len() {\n                        sorted_list.swap(i,\
    \ i);\n                        break;\n                    }\n               \
    \     i += 1;\n                }\n                sorted_list.push(word);\n  \
    \          }\n        }\n    }\n    for word in sorted_list {\n        res.push(word);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp5a35rhgi.rs:46:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut seen = HashSet::new();\n\
    \    for s in lst {\n        if seen.contains(&s) {\n            continue;\n \
    \       }\n        seen.insert(s);\n        res.push(s);\n    }\n    res.sort_by(|a,\
    \ b| a.len() < b.len());\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpao2igahx.rs:18:20\n   |\n18 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpao2igahx.rs:26:24\n   |\n26 |     res.sort_by(|a,\
    \ b| a.len() < b.len());\n   |                        ^^^^^^^^^^^^^^^^^ expected\
    \ enum `std::cmp::Ordering`, found `bool`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for word in lst {\n       \
    \ if res.len() == 0 {\n            res.push(word);\n        } else {\n       \
    \     let mut cur = res.last().unwrap();\n            if cur.len() < word.len()\
    \ {\n                res.push(word);\n            } else {\n                let\
    \ mut cur = res.last().unwrap();\n                while cur.len() < word.len()\
    \ {\n                    cur = cur.to_owned() + word.to_owned();\n           \
    \     }\n                res.push(cur);\n            }\n        }\n    }\n   \
    \ res.sort_by_key(|x| x.len());\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnpgqr5xx.rs:28:44\n   |\n\
    28 |                     cur = cur.to_owned() + word.to_owned();\n   |       \
    \                                     ^^^^^^^^^^^^^^^\n   |                  \
    \                          |\n   |                                           \
    \ expected `&str`, found struct `String`\n   |                               \
    \             help: consider borrowing here: `&word.to_owned()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnpgqr5xx.rs:28:27\n   |\n26 |              \
    \   let mut cur = res.last().unwrap();\n   |                               -------------------\
    \ expected due to this value\n27 |                 while cur.len() < word.len()\
    \ {\n28 |                     cur = cur.to_owned() + word.to_owned();\n   |  \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |             \
    \              |\n   |                           expected `&String`, found struct\
    \ `String`\n   |                           help: consider borrowing here: `&(cur.to_owned()\
    \ + word.to_owned())`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnpgqr5xx.rs:30:26\n\
    \   |\n30 |                 res.push(cur);\n   |                          ^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \        |\n   |                          expected struct `String`, found `&String`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2_tmier.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            let mut found = false;\n            for item in\
    \ sorted_list {\n                if item.len() == word.len() {\n             \
    \       if item < word {\n                        sorted_list.push(item);\n  \
    \                      found = true;\n                    }\n                }\
    \ else {\n                    if item == word {\n                        found\
    \ = true;\n                    }\n                }\n            }\n         \
    \   if !found {\n                sorted_list.push(word);\n            }\n    \
    \    }\n    }\n    for word in sorted_list {\n        res.push(word);\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `sorted_list`\n   --> /tmp/tmpgybu0nm_.rs:20:12\n\
    \    |\n18  |     let mut sorted_list = vec![];\n    |         ---------------\
    \ move occurs because `sorted_list` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n19  |     for word in lst {\n20  |         if sorted_list.len()\
    \ == 0 {\n    |            ^^^^^^^^^^^^^^^^^ value borrowed here after move\n\
    ...\n24  |             for item in sorted_list {\n    |                      \
    \   ----------- `sorted_list` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `sorted_list`\nhelp: consider iterating over\
    \ a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \    |\n24  |             for item in &sorted_list {\n    |                  \
    \       +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for elem in lst {\n        sorted_list_len.push(elem.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for elem in sorted_list_len\
    \ {\n        let mut new_list = vec![];\n        for elem in lst {\n         \
    \   if elem.len() == elem {\n                new_list.push(elem);\n          \
    \  }\n        }\n        sorted_list = sorted_list.push(new_list);\n    }\n  \
    \  sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxuvkmwf5.rs:26:30\n   |\n\
    26 |             if elem.len() == elem {\n   |                              ^^^^\
    \ expected `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxuvkmwf5.rs:30:23\n   |\n17 |     let mut sorted_list = vec![];\n\
    \   |                           ------ expected due to this value\n...\n30 | \
    \        sorted_list = sorted_list.push(new_list);\n   |                     \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<Vec<String>>`\n           found unit type `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxuvkmwf5.rs:33:5\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                                        \
    \ ----------- expected `Vec<String>` because of return type\n...\n33 |     sorted_list\n\
    \   |     ^^^^^^^^^^^ expected struct `String`, found struct `Vec`\n   |\n   =\
    \ note: expected struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2_tmier.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[0].length() == word.length() {\n\
    \                sorted_list.sort_by(|a, b| a.cmp(b));\n                sorted_list.push(word);\n\
    \            } else {\n                sorted_list.sort_by(|a, b| a.cmp(b).reverse());\n\
    \                sorted_list.push(word);\n            }\n        }\n    }\n  \
    \  for word in sorted_list {\n        res.push(word);\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpl19zowcj.rs:23:31\n   |\n23 |             if sorted_list[0].length()\
    \ == word.length() {\n   |                               ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpl19zowcj.rs:23:48\n\
    \   |\n23 |             if sorted_list[0].length() == word.length() {\n   |  \
    \                                              ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for elem in lst.iter() {\n        if elem.len() % 2 == 1 {\n            sorted_list.push(elem);\n\
    \        } else {\n            res.push(elem);\n        }\n    }\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    res.extend(sorted_list);\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwocpftsv.rs:26:32\n   |\n\
    26 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwocpftsv.rs:28:5\n   |\n16 | fn\
    \ sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n28 |     res\n   |     ^^^ expected struct `String`, found `&String`\n  \
    \ |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&String>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for word in lst {\n       \
    \ if res.len() == 0 {\n            res.push(word);\n        } else {\n       \
    \     let mut found = false;\n            for w in res {\n                if w.len()\
    \ == word.len() {\n                    if w < word {\n                       \
    \ found = true;\n                        break;\n                    }\n     \
    \           } else {\n                    found = true;\n                    break;\n\
    \                }\n            }\n            if !found {\n                res.push(word);\n\
    \            }\n        }\n    }\n    res.sort_by_key(|w| w.len());\n    res\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `res`\n   --> /tmp/tmpcl2jmdx0.rs:19:12\n\
    \    |\n17  |     let mut res = vec![];\n    |         ------- move occurs because\
    \ `res` has type `Vec<String>`, which does not implement the `Copy` trait\n18\
    \  |     for word in lst {\n19  |         if res.len() == 0 {\n    |         \
    \   ^^^^^^^^^ value borrowed here after move\n...\n23  |             for w in\
    \ res {\n    |                      --- `res` moved due to this implicit call\
    \ to `.into_iter()`, in previous iteration of loop\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `res`\nhelp: consider iterating\
    \ over a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \    |\n23  |             for w in &res {\n    |                      +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    for word in lst {\n      \
    \  if word.len() % 2 == 1 {\n            sorted_list.push(word);\n        }\n\
    \    }\n    for word in sorted_list {\n        if word.len() > sorted_list.len()\
    \ {\n            sorted_list = sorted_list.clone();\n        }\n    }\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx7r7tc2r.rs:30:32\n   |\n\
    30 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for s in lst {\n        if s.len() % 2 != 0 {\n            sorted_list.push(s);\n\
    \        } else {\n            let mut i = 0;\n            while i < s.len() {\n\
    \                if s[i] != s[i + 1] {\n                    break;\n         \
    \       }\n                i += 1;\n            }\n            sorted_list.push(s.to_string());\n\
    \        }\n    }\n    for s in sorted_list {\n        res.push(s);\n    }\n \
    \   res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpdo_7v7u5.rs:25:20\n\
    \   |\n25 |                 if s[i] != s[i + 1] {\n   |                    ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpdo_7v7u5.rs:25:28\n   |\n25 |                 if s[i] != s[i +\
    \ 1] {\n   |                            ^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut counter = 0;\n\
    \    for word in lst {\n        if counter % 2 == 0 {\n            sorted_list.push(word);\n\
    \        }\n        counter += 1;\n    }\n    sorted_list.sort_by_key(|word| word.len());\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpebj190st.rs:31:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if sorted_list.iter().all(|&x| x.len() == word.len()) {\n           \
    \ sorted_list.push(word);\n        } else {\n            if sorted_list.iter().all(|&x|\
    \ x.len() < word.len()) {\n                sorted_list.push(word);\n         \
    \   }\n        }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmpdyw5gykj.rs:19:36\n\
    \   |\n19 |         if sorted_list.iter().all(|&x| x.len() == word.len()) {\n\
    \   |                                    ^^ consider giving this closure parameter\
    \ the explicit type `&T`, with the type parameters specified\n   |\n   = note:\
    \ type must be known at this point\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    for ele in lst {\n    \
    \    if res.len() == 0 {\n            res.push(ele);\n        } else if ele.len()\
    \ < res[0].len() {\n            res.insert(0, ele);\n        } else {\n      \
    \      res.push(ele);\n        }\n    }\n    res.sort_by(|a, b| a.len() < b.len());\n\
    \    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwz03cmdk.rs:27:24\n   |\n\
    27 |     res.sort_by(|a, b| a.len() < b.len());\n   |                        ^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list.last().unwrap().len() < word.len()\
    \ {\n                sorted_list.push(word);\n            } else {\n         \
    \       sorted_list.sort_by(|a, b| a.len() < b.len());\n                sorted_list.push(sorted_list.last().unwrap());\n\
    \                sorted_list.push(word);\n            }\n        }\n    }\n  \
    \  for word in sorted_list {\n        res.push(word);\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu707hqjc.rs:26:44\n   |\n\
    26 |                 sorted_list.sort_by(|a, b| a.len() < b.len());\n   |    \
    \                                        ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu707hqjc.rs:27:34\n\
    \   |\n27 |                 sorted_list.push(sorted_list.last().unwrap());\n \
    \  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                                  |\n\
    \   |                                  expected struct `String`, found `&String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 == 1 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppkdp47zc.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2_tmier.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[0].len() < word.len() {\n      \
    \          sorted_list.push(word);\n            } else {\n                let\
    \ mut i = 0;\n                while i < sorted_list.len() {\n                \
    \    if sorted_list[i].len() < word.len() {\n                        break;\n\
    \                    }\n                    i += 1;\n                }\n     \
    \           sorted_list.insert(i, word);\n            }\n        }\n    }\n  \
    \  for word in sorted_list {\n        res.push(word);\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp7vub5f4n.rs:45:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list.last().unwrap().len() > word.len()\
    \ {\n                sorted_list.push(word);\n            } else {\n         \
    \       if sorted_list.last().unwrap().len() == word.len() {\n               \
    \     sorted_list.push(word);\n                } else {\n                    if\
    \ sorted_list.last().unwrap().len() < word.len() {\n                        sorted_list.push(word);\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   for word in sorted_list {\n        res.push(word);\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpflosw4zh.rs:44:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if word.len() % 2 == 1 {\n            sorted_list.push(word);\n     \
    \   }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7i8r_xls.rs:23:32\n   |\n\
    23 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for elem in lst {\n        if elem.len() % 2 == 1 {\n            sorted_list.push(elem);\n\
    \        } else {\n            let mut sorted_list = vec![];\n            for\
    \ elem in sorted_list {\n                let mut sorted_list = vec![];\n     \
    \           for elem in sorted_list {\n                    if elem.len() > elem.len()\
    \ {\n                        sorted_list.push(elem);\n                    }\n\
    \                }\n            }\n            res.push(sorted_list.clone());\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpp4h4dnna.rs:27:24\n\
    \   |\n25 |                 let mut sorted_list = vec![];\n   |              \
    \       --------------- consider giving `sorted_list` a type\n26 |           \
    \      for elem in sorted_list {\n27 |                     if elem.len() > elem.len()\
    \ {\n   |                        ^^^^ cannot infer type\n   |\n   = note: type\
    \ must be known at this point\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp4h4dnna.rs:35:5\n\
    \   |\n16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n35 |     res\n   |     ^^^ expected struct `String`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Vec<Vec<_>>`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0282, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.len()\
    \ == 1 {\n                sorted_list.push(word);\n            } else {\n    \
    \            if sorted_list[0].length() == word.length() {\n                 \
    \   if sorted_list[0].cmp(&word) == cmp::Ordering::Less {\n                  \
    \      sorted_list.push(word);\n                    } else {\n               \
    \         sorted_list.sort_by(|a, b| a.cmp(&b));\n                        sorted_list.push(word);\n\
    \                    }\n                } else {\n                    sorted_list.sort_by(|a,\
    \ b| a.cmp(&b));\n                    sorted_list.push(word);\n              \
    \  }\n            }\n        }\n    }\n    sorted_list\n}\n\nfn main() {\n   \
    \ let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpz9ql3tr7.rs:27:53\n   |\n27 |                     if sorted_list[0].cmp(&word)\
    \ == cmp::Ordering::Less {\n   |                                             \
    \        ^^^ use of undeclared crate or module `cmp`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpz9ql3tr7.rs:26:35\n\
    \   |\n26 |                 if sorted_list[0].length() == word.length() {\n  \
    \ |                                   ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0599]: no method named `length` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpz9ql3tr7.rs:26:52\n   |\n\
    26 |                 if sorted_list[0].length() == word.length() {\n   |     \
    \                                               ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        let len = word.len();\n        if\
    \ len % 2 != 0 {\n            sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbe_ircrq.rs:25:32\n   |\n\
    25 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            let mut is_sorted = false;\n            for s in\
    \ sorted_list {\n                if word.len() < s.len() {\n                 \
    \   is_sorted = true;\n                    break;\n                }\n       \
    \     }\n            if is_sorted {\n                sorted_list.push(word);\n\
    \            } else {\n                res.push(sorted_list);\n              \
    \  sorted_list = vec![word];\n            }\n        }\n    }\n    res.push(sorted_list);\n\
    \    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyv68iidb.rs:39:5\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |             \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n39 |     res\n   |     ^^^ expected struct `String`, found struct\
    \ `Vec`\n   |\n   = note: expected struct `Vec<String>`\n              found struct\
    \ `Vec<Vec<String>>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for word in lst {\n       \
    \ if word.length() % 2 != 0 {\n            res.push(word);\n        }\n    }\n\
    \    res.sort_by(|a, b| a.cmp(b));\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpygm2v_jg.rs:19:17\n   |\n19 |         if word.length()\
    \ % 2 != 0 {\n   |                 ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for s in lst {\n        if\
    \ s.len() % 2 != 0 {\n            res.push(s);\n        }\n    }\n    res.sort_by_key(|s|\
    \ s.len());\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp17fj5af4.rs:29:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        for word in lst {\n            if word.len() == word {\n        \
    \        sorted_list.push(word);\n            }\n        }\n    }\n    sorted_list.sort_unstable();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0n6x65e2.rs:25:30\n   |\n\
    25 |             if word.len() == word {\n   |                              ^^^^\
    \ expected `usize`, found struct `String`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[0].len() < word.len() {\n      \
    \          sorted_list.push(word);\n            } else {\n                sorted_list.sort();\n\
    \                res.push(sorted_list[0]);\n                sorted_list.shift();\n\
    \            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `shift` found for struct `Vec<String>` in\
    \ the current scope\n  --> /tmp/tmpe306i5f7.rs:28:29\n   |\n28 |             \
    \    sorted_list.shift();\n   |                             ^^^^^ method not found\
    \ in `Vec<String>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in lst {\n        if\
    \ sorted_list_len.contains(&word.len()) {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmprz_jja5q.rs:23:17\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for word in lst {\n    |\
    \                 --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for word in lst {\n    |                 ^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `lst`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n19  |     for word in &lst {\n \
    \   |                 +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut seen = HashSet::new();\n\
    \    for s in lst {\n        if !seen.insert(s).unwrap() {\n            seen.insert(s);\n\
    \            res.push(s);\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmphce757zi.rs:18:20\n   |\n18 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        let mut sorted_list_word = vec![];\n        for word in lst {\n \
    \           if word.len() == word {\n                sorted_list_word.push(word);\n\
    \            }\n        }\n        sorted_list.push(sorted_list_word);\n    }\n\
    \    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbvf2f5uk.rs:26:30\n   |\n\
    26 |             if word.len() == word {\n   |                              ^^^^\
    \ expected `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbvf2f5uk.rs:33:5\n   |\n16 | fn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n33 |     sorted_list\n   |     ^^^^^^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.contains(&word.len())\
    \ {\n            sorted_list_len.push(word.len());\n            sorted_list.push(word);\n\
    \        } else {\n            sorted_list_len.push(word.len());\n           \
    \ sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by_key(|word|\
    \ word.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpo4kj_nss.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = sorted_list.len();\n    for word in lst {\n        if sorted_list_len == sorted_list.len()\
    \ {\n            sorted_list_len += 1;\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[sorted_list_len - 1].len() < word.len()\
    \ {\n                sorted_list_len += 1;\n                sorted_list.push(word);\n\
    \            }\n        }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpurgsu6fc.rs:30:32\n   |\n\
    30 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[0].len() == word.len() {\n     \
    \           sorted_list.sort_by(|a, b| a.cmp(b));\n                sorted_list.push(word);\n\
    \            } else {\n                sorted_list.sort_by(|a, b| a.cmp(b));\n\
    \                sorted_list.push(sorted_list[0]);\n                sorted_list.push(word);\n\
    \            }\n        }\n    }\n    for word in sorted_list {\n        res.push(word);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpmacuvj_u.rs:28:34\n\
    \   |\n28 |                 sorted_list.push(sorted_list[0]);\n   |          \
    \                        ^^^^^^^^^^^^^^ move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for elem in lst {\n        sorted_list_len.push(elem.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for elem in sorted_list_len\
    \ {\n        sorted_list.push(vec![]);\n    }\n    for elem in lst {\n       \
    \ let mut i = 0;\n        for elem2 in sorted_list {\n            if elem.len()\
    \ == elem2.len() {\n                sorted_list[i].push(elem);\n             \
    \   i += 1;\n            }\n        }\n    }\n    sorted_list.sort_unstable();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3vr4t6ai.rs:36:5\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |             \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n36 |     sorted_list\n   |     ^^^^^^^^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `Vec<String>`\n       \
    \       found struct `Vec<Vec<String>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut len = lst.len();\n\
    \    while len > 0 {\n        let mut cur = vec![];\n        for s in lst {\n\
    \            if s.len() % 2 == 1 {\n                cur.push(s);\n           \
    \ }\n        }\n        res.push(cur);\n        len -= 1;\n    }\n    res.sort_by_key(|x|\
    \ x.len());\n    res.sort_by_key(|x| x.to_lowercase());\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_lowercase` found for reference `&Vec<String>`\
    \ in the current scope\n  --> /tmp/tmpy3cs0hsu.rs:30:27\n   |\n30 |     res.sort_by_key(|x|\
    \ x.to_lowercase());\n   |                           ^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_vec`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpy3cs0hsu.rs:31:5\n   |\n16 | fn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n31 |     res\n   |     ^^^ expected\
    \ struct `String`, found struct `Vec`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<Vec<String>>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for s in lst {\n        if\
    \ s.len() % 2 != 0 {\n            res.push(s);\n        }\n    }\n    res.sort_by_key(|s|\
    \ s.len());\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp17fj5af4.rs:29:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort();\n   \
    \ sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpa9gjxqdy.rs:17:27\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         ---------------  \
    \ ^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |      \
    \   consider giving `sorted_list` the explicit type `Vec<T>`, where the type parameter\
    \ `T` is specified\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for s in lst {\n        if s.len() % 2 != 0 {\n            sorted_list.push(s);\n\
    \        } else {\n            let mut i = 0;\n            for c in s.chars()\
    \ {\n                if i == 0 {\n                    i += 1;\n              \
    \      continue;\n                }\n                if c != s.chars().nth(i)\
    \ {\n                    break;\n                }\n                i += 1;\n\
    \            }\n            sorted_list.push(s);\n        }\n    }\n    for i\
    \ in sorted_list.len() {\n        let mut j = 0;\n        for c in sorted_list.chars()\
    \ {\n            if j == i {\n                continue;\n            }\n     \
    \       if c != sorted_list.chars().nth(j) {\n                break;\n       \
    \     }\n            j += 1;\n        }\n        res.push(sorted_list[j]);\n \
    \   }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd9xs3bq_.rs:29:25\n   |\n\
    29 |                 if c != s.chars().nth(i) {\n   |                        \
    \ ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Option<char>`\n\nerror[E0277]: `usize`\
    \ is not an iterator\n  --> /tmp/tmpd9xs3bq_.rs:37:14\n   |\n37 |     for i in\
    \ sorted_list.len() {\n   |              ^^^^^^^^^^^^^^^^^ `usize` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `usize`\n   = note:\
    \ if you want to iterate between `start` until a value `end`, use the exclusive\
    \ range syntax `start..end` or the inclusive range syntax `start..=end`\n   =\
    \ note: required because of the requirements on the impl of `IntoIterator` for\
    \ `usize`\n\nerror[E0599]: no method named `chars` found for struct `Vec<String>`\
    \ in the current scope\n  --> /tmp/tmpd9xs3bq_.rs:39:30\n   |\n39 |         for\
    \ c in sorted_list.chars() {\n   |                              ^^^^^ method not\
    \ found in `Vec<String>`\n\nerror[E0599]: no method named `chars` found for struct\
    \ `Vec<String>` in the current scope\n  --> /tmp/tmpd9xs3bq_.rs:43:33\n   |\n\
    43 |             if c != sorted_list.chars().nth(j) {\n   |                  \
    \               ^^^^^ method not found in `Vec<String>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for word in lst {\n       \
    \ if res.len() > 0 {\n            if word.len() > res[0].len() {\n           \
    \     res.sort_by(|a, b| a.len() < b.len());\n            } else {\n         \
    \       res.sort_by(|a, b| a.len() == b.len());\n            }\n        }\n  \
    \      res.push(word);\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpsllhjhfj.rs:20:29\n\
    \   |\n17 |     let mut res = vec![];\n   |         ------- consider giving `res`\
    \ the explicit type `Vec<T>`, with the type parameters specified\n...\n20 |  \
    \           if word.len() > res[0].len() {\n   |                             ^^^^^^\
    \ cannot infer type\n   |\n   = note: type must be known at this point\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for s in lst {\n        if s.len() % 2 != 0 {\n            sorted_list.push(s);\n\
    \        } else {\n            let mut i = 0;\n            for c in s.chars()\
    \ {\n                if i % 2 == 0 {\n                    sorted_list.push(c);\n\
    \                }\n                i += 1;\n            }\n        }\n    }\n\
    \    for s in sorted_list {\n        res.push(s);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_5x20ptr.rs:26:38\n   |\n\
    26 |                     sorted_list.push(c);\n   |                          \
    \            ^- help: try using a conversion method: `.to_string()`\n   |    \
    \                                  |\n   |                                   \
    \   expected struct `String`, found `char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for s in lst {\n        if s.len() % 2 != 0 {\n            sorted_list.push(s);\n\
    \        } else {\n            let mut i = 0;\n            while i < sorted_list.len()\
    \ {\n                if sorted_list[i].len() < s.len() {\n                   \
    \ i += 1;\n                } else {\n                    break;\n            \
    \    }\n            }\n            sorted_list.insert(i, s);\n        }\n    }\n\
    \    for s in sorted_list {\n        res.push(s);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpsve2luj2.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in lst {\n        if\
    \ sorted_list_len.contains(&word.len()) {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmprz_jja5q.rs:23:17\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for word in lst {\n    |\
    \                 --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for word in lst {\n    |                 ^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `lst`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n19  |     for word in &lst {\n \
    \   |                 +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for word in lst {\n       \
    \ if res.len() == 0 {\n            res.push(word);\n        } else {\n       \
    \     let mut found = false;\n            for item in &res {\n               \
    \ if item.len() == word.len() {\n                    if item.cmp(&word) == cmp::Ordering::Less\
    \ {\n                        found = true;\n                        break;\n \
    \                   }\n                }\n            }\n            if !found\
    \ {\n                res.push(word);\n            }\n        }\n    }\n    res.sort_by(|a,\
    \ b| a.len() < b.len());\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmphc0pdq3o.rs:25:43\n   |\n25 |                     if item.cmp(&word)\
    \ == cmp::Ordering::Less {\n   |                                           ^^^\
    \ use of undeclared crate or module `cmp`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphc0pdq3o.rs:36:24\n   |\n36 |     res.sort_by(|a, b| a.len() <\
    \ b.len());\n   |                        ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.contains(&word.len())\
    \ {\n            sorted_list_len.push(word.len());\n            sorted_list.push(word);\n\
    \        } else {\n            sorted_list_len.push(word.len());\n           \
    \ sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b| b.cmp(a));\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaa\", \"aa\", \"a\"]`,\n right: `[\"aa\"]`', /tmp/tmp69dnyzrh.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            let mut found = false;\n            for s in sorted_list\
    \ {\n                if word.len() < s.len() {\n                    found = true;\n\
    \                    break;\n                }\n            }\n            if\
    \ !found {\n                sorted_list.push(word);\n            }\n        }\n\
    \    }\n    for s in sorted_list {\n        res.push(s);\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `sorted_list`\n   --> /tmp/tmp9ochj2y6.rs:20:12\n\
    \    |\n18  |     let mut sorted_list = vec![];\n    |         ---------------\
    \ move occurs because `sorted_list` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n19  |     for word in lst {\n20  |         if sorted_list.len()\
    \ == 0 {\n    |            ^^^^^^^^^^^^^^^^^ value borrowed here after move\n\
    ...\n24  |             for s in sorted_list {\n    |                      -----------\
    \ `sorted_list` moved due to this implicit call to `.into_iter()`, in previous\
    \ iteration of loop\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `sorted_list`\nhelp: consider iterating over a slice of\
    \ the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n24 \
    \ |             for s in &sorted_list {\n    |                      +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2_tmier.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.last().unwrap().len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                sorted_list.sort_by(|a, b| a.len() < b.len());\n        \
    \        sorted_list.push(sorted_list.last().unwrap());\n            }\n     \
    \   }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd3tpy6v1.rs:26:44\n   |\n\
    26 |                 sorted_list.sort_by(|a, b| a.len() < b.len());\n   |    \
    \                                        ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd3tpy6v1.rs:27:34\n\
    \   |\n27 |                 sorted_list.push(sorted_list.last().unwrap());\n \
    \  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                                  |\n\
    \   |                                  expected struct `String`, found `&String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[0].length() == word.length() {\n\
    \                sorted_list.sort_by(|a, b| a.cmp(b));\n                sorted_list.push(word);\n\
    \            } else {\n                sorted_list.sort_by(|a, b| a.cmp(b).reverse());\n\
    \                sorted_list.push(word);\n            }\n        }\n    }\n  \
    \  for word in sorted_list {\n        res.push(word);\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpl19zowcj.rs:23:31\n   |\n23 |             if sorted_list[0].length()\
    \ == word.length() {\n   |                               ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpl19zowcj.rs:23:48\n\
    \   |\n23 |             if sorted_list[0].length() == word.length() {\n   |  \
    \                                              ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list[0].length()\
    \ == word.length() {\n                sorted_list.sort_by(|a, b| a.cmp(b));\n\
    \                sorted_list.push(word);\n            } else {\n             \
    \   sorted_list.sort_by(|a, b| a.cmp(b));\n                sorted_list.push(word);\n\
    \                sorted_list.push(sorted_list[0]);\n            }\n        }\n\
    \    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpterv5muq.rs:23:31\n   |\n23 |             if sorted_list[0].length()\
    \ == word.length() {\n   |                               ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpterv5muq.rs:23:48\n\
    \   |\n23 |             if sorted_list[0].length() == word.length() {\n   |  \
    \                                              ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 == 1 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppkdp47zc.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for s in lst {\n        if s.len() % 2 != 0 {\n            sorted_list.push(s);\n\
    \        } else {\n            let mut i = 0;\n            for c in s.chars()\
    \ {\n                if i % 2 == 0 {\n                    i += 1;\n          \
    \      } else {\n                    i += 2;\n                }\n            }\n\
    \            sorted_list.push(s);\n        }\n    }\n    for i in sorted_list.iter().cloned()\
    \ {\n        res.push(i);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpb8ib9sd3.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 == 1 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppkdp47zc.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in lst {\n        if\
    \ sorted_list_len.iter().position(|x| x == word.len()).is_some() {\n         \
    \   sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_unstable();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&usize` with `usize`\n  --> /tmp/tmp938pnjkd.rs:24:50\n\
    \   |\n24 |         if sorted_list_len.iter().position(|x| x == word.len()).is_some()\
    \ {\n   |                                                  ^^ no implementation\
    \ for `&usize == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not\
    \ implemented for `&usize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 == 1 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort();\n   \
    \ sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmphup00e6h.rs:17:27\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         ---------------  \
    \ ^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |      \
    \   consider giving `sorted_list` the explicit type `Vec<T>`, where the type parameter\
    \ `T` is specified\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for s in lst {\n        if\
    \ s.len() % 2 != 0 {\n            res.push(s);\n        }\n    }\n    res.sort_by_key(|s|\
    \ s.len());\n    res.sort_by_key(|s| s.to_lowercase());\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpauxwi8nw.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.len()\
    \ == 1 {\n                sorted_list.push(word);\n            } else {\n    \
    \            if sorted_list[0].length() == word.length() {\n                 \
    \   sorted_list.push(word);\n                } else {\n                    if\
    \ sorted_list[0].length() < word.length() {\n                        sorted_list.push(word);\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpr9yre0gc.rs:26:35\n   |\n26 |                 if\
    \ sorted_list[0].length() == word.length() {\n   |                           \
    \        ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0599]: no method named `length` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpr9yre0gc.rs:26:52\n   |\n26 |                 if sorted_list[0].length()\
    \ == word.length() {\n   |                                                   \
    \ ^^^^^^ help: there is an associated function with a similar name: `len`\n\n\
    error[E0599]: no method named `length` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpr9yre0gc.rs:29:39\n   |\n29 |                     if sorted_list[0].length()\
    \ < word.length() {\n   |                                       ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpr9yre0gc.rs:29:55\n\
    \   |\n29 |                     if sorted_list[0].length() < word.length() {\n\
    \   |                                                       ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for s in lst {\n        if\
    \ s.len() % 2 != 0 {\n            res.push(s);\n        }\n    }\n    res.sort_by(|a,\
    \ b| a.len() < b.len());\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpebwjieg0.rs:23:24\n   |\n\
    23 |     res.sort_by(|a, b| a.len() < b.len());\n   |                        ^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2_tmier.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    for word in sorted_list {\n\
    \        sorted_list.sort_by(|a, b| a.cmp(b));\n    }\n    sorted_list\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpmq8nkp0q.rs:17:27\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         ---------------  \
    \ ^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |      \
    \   consider giving `sorted_list` the explicit type `Vec<T>`, where the type parameter\
    \ `T` is specified\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.last().unwrap().len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                if sorted_list.last().unwrap().len() == word.len() {\n  \
    \                  sorted_list.last().unwrap().push(word);\n                }\n\
    \            }\n        }\n    }\n    sorted_list.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2q2wq3vd.rs:27:54\n   |\n\
    27 |                     sorted_list.last().unwrap().push(word);\n   |       \
    \                                               ^^^^ expected `char`, found struct\
    \ `String`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        } else {\n            sorted_list.sort_by(|a,\
    \ b| a.cmp(b));\n        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmp1kmh9i1z.rs:17:27\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         ---------------  \
    \ ^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |      \
    \   consider giving `sorted_list` the explicit type `Vec<T>`, where the type parameter\
    \ `T` is specified\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list.last().unwrap().len() < word.len()\
    \ {\n                sorted_list.push(word);\n            } else {\n         \
    \       let mut i = 0;\n                while i < sorted_list.len() {\n      \
    \              if sorted_list[i].len() < word.len() {\n                      \
    \  break;\n                    }\n                    i += 1;\n              \
    \  }\n                sorted_list.insert(i, word);\n            }\n        }\n\
    \    }\n    for word in sorted_list {\n        res.push(word);\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp0mqskknz.rs:45:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2_tmier.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[0].len() < word.len() {\n      \
    \          sorted_list.push(word);\n            } else {\n                let\
    \ mut i = 0;\n                while sorted_list[i].len() < word.len() {\n    \
    \                i += 1;\n                }\n                sorted_list.swap(i,\
    \ 0);\n                sorted_list.push(word);\n            }\n        }\n   \
    \ }\n    for word in sorted_list {\n        res.push(word);\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpmvg3t5hn.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list.last().unwrap().len() < word.len()\
    \ {\n                sorted_list.push(word);\n            } else {\n         \
    \       sorted_list.sort();\n                sorted_list.push(sorted_list.last().unwrap());\n\
    \                sorted_list.push(word);\n            }\n        }\n    }\n  \
    \  sorted_list.sort();\n    res.push(sorted_list.last().unwrap());\n    res\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx6m5svwe.rs:27:34\n   |\n\
    27 |                 sorted_list.push(sorted_list.last().unwrap());\n   |    \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                                  |\n\
    \   |                                  expected struct `String`, found `&String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpx6m5svwe.rs:34:5\n   |\n16 | fn\
    \ sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n34 |     res\n   |     ^^^ expected struct `String`, found `&String`\n  \
    \ |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&String>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut counter = vec![];\n\
    \    for s in lst {\n        if !counter.contains(&s.len()) {\n            counter.push(s.len());\n\
    \            res.push(s);\n        }\n    }\n    counter.sort_unstable();\n  \
    \  for s in counter {\n        for r in res {\n            if r == s {\n     \
    \           res.remove(r);\n                break;\n            }\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpagishfok.rs:29:28\n   |\n\
    29 |                 res.remove(r);\n   |                            ^ expected\
    \ `usize`, found struct `String`\n\nerror[E0277]: can't compare `String` with\
    \ `usize`\n  --> /tmp/tmpagishfok.rs:28:18\n   |\n28 |             if r == s {\n\
    \   |                  ^^ no implementation for `String == usize`\n   |\n   =\
    \ help: the trait `PartialEq<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <&'a\
    \ str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n \
    \            <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list.last().unwrap().len() < word.len()\
    \ {\n                sorted_list.push(word);\n            } else {\n         \
    \       sorted_list.sort_by(|a, b| a.len() < b.len());\n                sorted_list.push(sorted_list.last().unwrap());\n\
    \            }\n        }\n    }\n    for word in sorted_list {\n        res.push(word);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7nb6kncg.rs:26:44\n   |\n\
    26 |                 sorted_list.sort_by(|a, b| a.len() < b.len());\n   |    \
    \                                        ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7nb6kncg.rs:27:34\n\
    \   |\n27 |                 sorted_list.push(sorted_list.last().unwrap());\n \
    \  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                                  |\n\
    \   |                                  expected struct `String`, found `&String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in lst {\n        if\
    \ sorted_list_len.contains(&word.len()) {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmprz_jja5q.rs:23:17\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for word in lst {\n    |\
    \                 --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for word in lst {\n    |                 ^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `lst`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n19  |     for word in &lst {\n \
    \   |                 +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        let len = word.len();\n        if\
    \ len % 2 == 1 {\n            sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb2rbqp50.rs:25:32\n   |\n\
    25 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[0].len() < word.len() {\n      \
    \          sorted_list.push(word);\n            } else {\n                let\
    \ mut i = 0;\n                while i < sorted_list.len() {\n                \
    \    if sorted_list[i].len() < word.len() {\n                        sorted_list.swap(i,\
    \ 0);\n                        break;\n                    }\n               \
    \     i += 1;\n                }\n                sorted_list.push(word);\n  \
    \          }\n        }\n    }\n    for word in sorted_list {\n        res.push(word);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpvfbech4y.rs:46:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for s in lst {\n        if\
    \ s.len() % 2 != 0 {\n            res.push(s);\n        }\n    }\n    res.sort_by_key(|s|\
    \ s.len());\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp17fj5af4.rs:29:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[0].len() < word.len() {\n      \
    \          sorted_list.push(word);\n            } else {\n                sorted_list.sort();\n\
    \                res.push(sorted_list[0]);\n                sorted_list.clear();\n\
    \            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpwilww_km.rs:27:26\n\
    \   |\n27 |                 res.push(sorted_list[0]);\n   |                  \
    \        ^^^^^^^^^^^^^^ move occurs because value has type `String`, which does\
    \ not implement the `Copy` trait\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for s in lst {\n        if s.len() % 2 != 0 {\n            sorted_list.push(s);\n\
    \        } else {\n            let mut i = 0;\n            let mut j = s.len()\
    \ - 1;\n            while i < j {\n                if s[i].len() > s[j].len()\
    \ {\n                    res.push(sorted_list[i]);\n                    i += 1;\n\
    \                } else {\n                    j -= 1;\n                }\n  \
    \          }\n            res.push(sorted_list[i]);\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7wcn_h7q.rs:26:20\n\
    \   |\n26 |                 if s[i].len() > s[j].len() {\n   |               \
    \     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7wcn_h7q.rs:26:33\n   |\n26 |                 if s[i].len() > s[j].len()\
    \ {\n   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if word.len() % 2 != 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            let mut i = 0;\n            while i < sorted_list.len()\
    \ {\n                if sorted_list[i].len() < word.len() {\n                \
    \    i += 1;\n                } else {\n                    break;\n         \
    \       }\n            }\n            res.push(sorted_list[i]);\n            sorted_list.splice(i,\
    \ 1);\n        }\n    }\n    res.sort_by(|a, b| a.len() < b.len());\n    res\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: RangeBounds<usize>` is not satisfied\n\
    \    --> /tmp/tmpt2qomj4r.rs:32:32\n     |\n32   |             sorted_list.splice(i,\
    \ 1);\n     |                         ------ ^ the trait `RangeBounds<usize>`\
    \ is not implemented for `usize`\n     |                         |\n     |   \
    \                      required by a bound introduced by this call\n     |\n \
    \    = help: the following other types implement trait `RangeBounds<T>`:\n   \
    \            (Bound<&'a T>, Bound<&'a T>)\n               (Bound<T>, Bound<T>)\n\
    \               RangeFrom<&T>\n               RangeFrom<T>\n               RangeFull\n\
    \               RangeInclusive<&T>\n               RangeInclusive<T>\n       \
    \        RangeTo<&T>\n             and 5 others\nnote: required by a bound in\
    \ `Vec::<T, A>::splice`\n\nerror[E0277]: `{integer}` is not an iterator\n  -->\
    \ /tmp/tmpt2qomj4r.rs:32:35\n   |\n32 |             sorted_list.splice(i, 1);\n\
    \   |                         ------    ^ `{integer}` is not an iterator\n   |\
    \                         |\n   |                         required by a bound\
    \ introduced by this call\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `{integer}`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\nnote: required by a bound in `Splice`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt2qomj4r.rs:35:24\n   |\n35 |     res.sort_by(|a, b| a.len()\
    \ < b.len());\n   |                        ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in lst {\n        if\
    \ sorted_list_len.iter().find(|&x| x == word.len()).is_some() {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&usize` with `usize`\n  --> /tmp/tmpus32qysj.rs:24:47\n\
    \   |\n24 |         if sorted_list_len.iter().find(|&x| x == word.len()).is_some()\
    \ {\n   |                                               ^^ no implementation for\
    \ `&usize == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not implemented\
    \ for `&usize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.contains(&word.len())\
    \ {\n            sorted_list_len.push(word.len());\n            sorted_list.push(word);\n\
    \        } else {\n            sorted_list_len.push(word.len());\n           \
    \ sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by_key(|word|\
    \ word.len());\n    sorted_list.sort_by_key(|word| word.to_lowercase());\n   \
    \ sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp_mor2eor.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        for index in 0..word.len() {\n            if index != word.len()\
    \ - 1 {\n                if sorted_list.is_empty() {\n                    sorted_list.push(word.clone());\n\
    \                } else {\n                    let mut current_word = sorted_list.last().unwrap();\n\
    \                    if current_word.len() > word.len() {\n                  \
    \      sorted_list.push(word.clone());\n                    } else if current_word.len()\
    \ < word.len() {\n                        let mut current_len = current_word.len();\n\
    \                        let mut current_word = current_word.clone();\n      \
    \                  while current_len < word.len() {\n                        \
    \    current_word.push(0);\n                            current_len += 1;\n  \
    \                      }\n                        sorted_list.push(current_word);\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp_4r0otvi.rs:24:30\n   |\n24 |         for index in 0..word.len()\
    \ {\n   |                              ^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `len` found for type `usize` in the current scope\n  --> /tmp/tmp_4r0otvi.rs:25:30\n\
    \   |\n25 |             if index != word.len() - 1 {\n   |                   \
    \           ^^^ method not found in `usize`\n\nerror[E0599]: no method named `len`\
    \ found for reference `&usize` in the current scope\n  --> /tmp/tmp_4r0otvi.rs:30:37\n\
    \   |\n30 |                     if current_word.len() > word.len() {\n   |   \
    \                                  ^^^ method not found in `&usize`\n\nerror[E0599]:\
    \ no method named `len` found for type `usize` in the current scope\n  --> /tmp/tmp_4r0otvi.rs:30:50\n\
    \   |\n30 |                     if current_word.len() > word.len() {\n   |   \
    \                                               ^^^ method not found in `usize`\n\
    \nerror[E0599]: no method named `len` found for reference `&usize` in the current\
    \ scope\n  --> /tmp/tmp_4r0otvi.rs:32:44\n   |\n32 |                     } else\
    \ if current_word.len() < word.len() {\n   |                                 \
    \           ^^^ method not found in `&usize`\n\nerror[E0599]: no method named\
    \ `len` found for type `usize` in the current scope\n  --> /tmp/tmp_4r0otvi.rs:32:57\n\
    \   |\n32 |                     } else if current_word.len() < word.len() {\n\
    \   |                                                         ^^^ method not found\
    \ in `usize`\n\nerror[E0599]: no method named `len` found for reference `&usize`\
    \ in the current scope\n  --> /tmp/tmp_4r0otvi.rs:33:60\n   |\n33 |          \
    \               let mut current_len = current_word.len();\n   |              \
    \                                              ^^^ method not found in `&usize`\n\
    \nerror[E0599]: no method named `len` found for type `usize` in the current scope\n\
    \  --> /tmp/tmp_4r0otvi.rs:35:50\n   |\n35 |                         while current_len\
    \ < word.len() {\n   |                                     "
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2_tmier.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for elem in lst.iter() {\n        if elem.len() % 2 == 1 {\n            sorted_list.push(elem);\n\
    \        } else {\n            let mut new_elem = vec![];\n            for elem\
    \ in sorted_list.iter() {\n                new_elem.push(elem);\n            }\n\
    \            new_elem.push(elem);\n            sorted_list = new_elem;\n     \
    \   }\n    }\n    for elem in sorted_list.iter() {\n        res.push(elem);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxaoefbdh.rs:27:27\n   |\n\
    27 |             new_elem.push(elem);\n   |                           ^^^^ expected\
    \ `&String`, found struct `String`\n   |\n   = note: expected reference `&&String`\n\
    \              found reference `&String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpxaoefbdh.rs:28:27\n   |\n18 |     let mut sorted_list = vec![];\n\
    \   |                           ------ expected due to this value\n...\n28 | \
    \            sorted_list = new_elem;\n   |                           ^^^^^^^^\
    \ expected struct `String`, found `&String`\n   |\n   = note: expected struct\
    \ `Vec<&String>`\n              found struct `Vec<&&String>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxaoefbdh.rs:34:5\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                                        \
    \ ----------- expected `Vec<String>` because of return type\n...\n34 |     res\n\
    \   |     ^^^ expected struct `String`, found `&&String`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `Vec<&&String>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if word.len() % 2 == 1 {\n            sorted_list.push(word);\n     \
    \   }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7i8r_xls.rs:23:32\n   |\n\
    23 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.len()\
    \ == 1 {\n                sorted_list.push(word);\n            } else {\n    \
    \            if sorted_list[0].length() == word.length() {\n                 \
    \   sorted_list.push(word);\n                } else {\n                    if\
    \ sorted_list[0].length() < word.length() {\n                        sorted_list.push(word);\n\
    \                    } else {\n                        sorted_list.sort_by(|a,\
    \ b| a.cmp(b));\n                        sorted_list.push(word);\n           \
    \         }\n                }\n            }\n        }\n    }\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpbalfp980.rs:26:35\n   |\n26 |                 if\
    \ sorted_list[0].length() == word.length() {\n   |                           \
    \        ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0599]: no method named `length` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpbalfp980.rs:26:52\n   |\n26 |                 if sorted_list[0].length()\
    \ == word.length() {\n   |                                                   \
    \ ^^^^^^ help: there is an associated function with a similar name: `len`\n\n\
    error[E0599]: no method named `length` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpbalfp980.rs:29:39\n   |\n29 |                     if sorted_list[0].length()\
    \ < word.length() {\n   |                                       ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpbalfp980.rs:29:55\n\
    \   |\n29 |                     if sorted_list[0].length() < word.length() {\n\
    \   |                                                       ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2_tmier.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        let mut new_list = vec![];\n        for word in lst {\n         \
    \   if word.len() == word {\n                new_list.push(word);\n          \
    \  }\n        }\n        sorted_list = sorted_list.push(new_list);\n    }\n  \
    \  sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp150bkp_s.rs:26:30\n   |\n\
    26 |             if word.len() == word {\n   |                              ^^^^\
    \ expected `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp150bkp_s.rs:30:23\n   |\n17 |     let mut sorted_list = vec![];\n\
    \   |                           ------ expected due to this value\n...\n30 | \
    \        sorted_list = sorted_list.push(new_list);\n   |                     \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<Vec<String>>`\n           found unit type `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp150bkp_s.rs:33:5\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                                        \
    \ ----------- expected `Vec<String>` because of return type\n...\n33 |     sorted_list\n\
    \   |     ^^^^^^^^^^^ expected struct `String`, found struct `Vec`\n   |\n   =\
    \ note: expected struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut len = lst.len();\n\
    \    let mut i = 0;\n    while i < len {\n        let mut j = i;\n        while\
    \ j < len && lst[j].len() < len {\n            j += 1\n        }\n        if j\
    \ == i {\n            res.push(lst[i]);\n            i += 1;\n        } else {\n\
    \            res.push(lst[j]);\n            len = j;\n        }\n    }\n    res.sort();\n\
    \    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpy68r_8sv.rs:26:22\n\
    \   |\n26 |             res.push(lst[i]);\n   |                      ^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpy68r_8sv.rs:29:22\n\
    \   |\n29 |             res.push(lst[j]);\n   |                      ^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2_tmier.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7pj9o9ys.rs:16:41\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    ---------------\
    \                      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |   \
    \ |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut sorted_list = Vec::new();\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            let mut found = false;\n            for s in sorted_list\
    \ {\n                if s.len() == word.len() {\n                    if s.cmp(&word)\
    \ == cmp::Ordering::Equal {\n                        found = true;\n         \
    \               break;\n                    }\n                }\n           \
    \ }\n            if !found {\n                sorted_list.push(word);\n      \
    \      }\n        }\n    }\n    for s in sorted_list {\n        res.push(s);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpw857n_ht.rs:26:40\n   |\n26 |                     if s.cmp(&word)\
    \ == cmp::Ordering::Equal {\n   |                                        ^^^ use\
    \ of undeclared crate or module `cmp`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by_key(|x| x.len());\n\
    \    sorted_list.sort_by_key(|x| x.to_lowercase());\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmplkeo9auv.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmplkeo9auv.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut sorted_list = Vec::new();\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            let mut found = false;\n            for item in\
    \ sorted_list {\n                if item.len() == word.len() {\n             \
    \       if item < word {\n                        sorted_list.push(item);\n  \
    \                  } else {\n                        sorted_list.push(word);\n\
    \                        found = true;\n                    }\n              \
    \      break;\n                }\n            }\n            if !found {\n   \
    \             sorted_list.push(word);\n            }\n        }\n    }\n    for\
    \ word in sorted_list {\n        res.push(word);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `sorted_list`\n   --> /tmp/tmpmxxafgt1.rs:20:12\n\
    \    |\n18  |     let mut sorted_list = Vec::new();\n    |         ---------------\
    \ move occurs because `sorted_list` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n19  |     for word in lst {\n20  |         if sorted_list.len()\
    \ == 0 {\n    |            ^^^^^^^^^^^^^^^^^ value borrowed here after move\n\
    ...\n24  |             for item in sorted_list {\n    |                      \
    \   ----------- `sorted_list` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `sorted_list`\nhelp: consider iterating over\
    \ a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \    |\n24  |             for item in &sorted_list {\n    |                  \
    \       +\n\nerror[E0382]: use of moved value: `word`\n  --> /tmp/tmpmxxafgt1.rs:36:34\n\
    \   |\n19 |     for word in lst {\n   |         ----\n   |         |\n   |   \
    \      this reinitialization might get skipped\n   |         move occurs because\
    \ `word` has type `String`, which does not implement the `Copy` trait\n...\n29\
    \ |                         sorted_list.push(word);\n   |                    \
    \                      ---- value moved here\n...\n36 |                 sorted_list.push(word);\n\
    \   |                                  ^^^^ value used here after move\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[0].len() < word.len() {\n      \
    \          sorted_list.push(word);\n            } else {\n                let\
    \ mut i = 0;\n                while i < sorted_list.len() && sorted_list[i].len()\
    \ < word.len() {\n                    i += 1;\n                }\n           \
    \     sorted_list.insert(i, word);\n            }\n        }\n    }\n    for word\
    \ in sorted_list {\n        res.push(word);\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpbyxqe9bn.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2_tmier.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for s in lst {\n        if\
    \ res.len() > 0 {\n            if s.len() > res.len() {\n                res.push(s);\n\
    \            } else {\n                if s.len() < res[0].len() {\n         \
    \           res.swap(0, res.len());\n                }\n            }\n      \
    \  } else {\n            res.push(s);\n        }\n    }\n    res.sort_by(|a, b|\
    \ a.len() < b.len());\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3zxavene.rs:31:24\n   |\n\
    31 |     res.sort_by(|a, b| a.len() < b.len());\n   |                        ^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in lst {\n        if\
    \ sorted_list_len.contains(&word.len()) {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmprz_jja5q.rs:23:17\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for word in lst {\n    |\
    \                 --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for word in lst {\n    |                 ^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `lst`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n19  |     for word in &lst {\n \
    \   |                 +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for s in lst {\n        if s.len() % 2 == 1 {\n            sorted_list.push(s);\n\
    \        } else {\n            let mut i = 0;\n            let mut j = 0;\n  \
    \          while i < s.len() && j < sorted_list.len() {\n                if s[i].len()\
    \ < sorted_list[j].len() {\n                    i += 1;\n                } else\
    \ {\n                    j += 1;\n                }\n            }\n         \
    \   res.push(sorted_list[j]);\n            sorted_list.splice(j, 1);\n       \
    \ }\n    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptd5x6xyh.rs:26:20\n\
    \   |\n26 |                 if s[i].len() < sorted_list[j].len() {\n   |     \
    \               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the trait bound `usize: RangeBounds<usize>` is not\
    \ satisfied\n    --> /tmp/tmptd5x6xyh.rs:33:32\n     |\n33   |             sorted_list.splice(j,\
    \ 1);\n     |                         ------ ^ the trait `RangeBounds<usize>`\
    \ is not implemented for `usize`\n     |                         |\n     |   \
    \                      required by a bound introduced by this call\n     |\n \
    \    = help: the following other types implement trait `RangeBounds<T>`:\n   \
    \            (Bound<&'a T>, Bound<&'a T>)\n               (Bound<T>, Bound<T>)\n\
    \               RangeFrom<&T>\n               RangeFrom<T>\n               RangeFull\n\
    \               RangeInclusive<&T>\n               RangeInclusive<T>\n       \
    \        RangeTo<&T>\n             and 5 others\nnote: required by a bound in\
    \ `Vec::<T, A>::splice`\n\nerror[E0277]: `{integer}` is not an iterator\n  -->\
    \ /tmp/tmptd5x6xyh.rs:33:35\n   |\n33 |             sorted_list.splice(j, 1);\n\
    \   |                         ------    ^ `{integer}` is not an iterator\n   |\
    \                         |\n   |                         required by a bound\
    \ introduced by this call\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `{integer}`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\nnote: required by a bound in `S"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by_key(|word|\
    \ word.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpskclfirt.rs:17:27\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         ---------------  \
    \ ^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |      \
    \   consider giving `sorted_list` the explicit type `Vec<T>`, where the type parameter\
    \ `T` is specified\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for elem in lst {\n        if elem.len() % 2 != 0 {\n            sorted_list.push(elem);\n\
    \        } else {\n            let mut i = 0;\n            let mut j = i;\n  \
    \          while j < sorted_list.len() {\n                if sorted_list[j].len()\
    \ < elem.len() {\n                    i += 1;\n                } else {\n    \
    \                j += 1;\n                }\n            }\n            sorted_list.swap(i,\
    \ j);\n        }\n    }\n    for i in 0..sorted_list.len() {\n        res.push(sorted_list[i]);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmp2pie5cna.rs:36:18\n\
    \   |\n36 |         res.push(sorted_list[i]);\n   |                  ^^^^^^^^^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for s in lst {\n        if s.len() % 2 == 1 {\n            sorted_list.push(s);\n\
    \        } else {\n            let mut i = 0;\n            let mut j = s.len()\
    \ - 1;\n            while i < j {\n                if s[i] != s[j] {\n       \
    \             res.push(s[i]);\n                    i += 1;\n                }\
    \ else {\n                    j -= 1;\n                }\n            }\n    \
    \    }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    res.sort_by(|a,\
    \ b| a.len() < b.len());\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmgk6xcu5.rs:26:20\n\
    \   |\n26 |                 if s[i] != s[j] {\n   |                    ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmgk6xcu5.rs:26:28\n   |\n26 |                 if s[i] != s[j] {\n\
    \   |                            ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmgk6xcu5.rs:27:30\n   |\n27 |                     res.push(s[i]);\n\
    \   |                              ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ In"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[0].len() < word.len() {\n      \
    \          sorted_list.push(word);\n            } else {\n                let\
    \ mut i = 0;\n                while i < sorted_list.len() {\n                \
    \    if sorted_list[i].len() < word.len() {\n                        break;\n\
    \                    }\n                    i += 1;\n                }\n     \
    \           sorted_list.insert(i, word);\n            }\n        }\n    }\n  \
    \  for word in sorted_list {\n        res.push(word);\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp7vub5f4n.rs:45:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list[0].length()\
    \ == word.length() {\n                sorted_list.sort_by(|a, b| a.cmp(b));\n\
    \                sorted_list.push(word);\n            } else {\n             \
    \   sorted_list.sort_by(|a, b| a.cmp(b));\n                sorted_list.push(word);\n\
    \            }\n        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpttzy6at5.rs:23:31\n   |\n23 |             if sorted_list[0].length()\
    \ == word.length() {\n   |                               ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpttzy6at5.rs:23:48\n\
    \   |\n23 |             if sorted_list[0].length() == word.length() {\n   |  \
    \                                              ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in lst {\n        if\
    \ sorted_list_len.iter().any(|&x| x == word.len()) {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp_evk1ar3.rs:23:17\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for word in lst {\n    |\
    \                 --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for word in lst {\n    |                 ^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `lst`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n19  |     for word in &lst {\n \
    \   |                 +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    for word in lst {\n      \
    \  if sorted_list.len() == 0 {\n            sorted_list.push(word);\n        }\
    \ else {\n            if sorted_list.len() == 1 {\n                sorted_list.push(word);\n\
    \            } else {\n                if sorted_list[0].length() == word.length()\
    \ {\n                    sorted_list.sort_by(|a, b| a.cmp(b));\n             \
    \   } else {\n                    sorted_list.sort_by(|a, b| a.cmp(b).reverse());\n\
    \                }\n            }\n        }\n    }\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpvwef_e6e.rs:27:35\n   |\n27 |                 if\
    \ sorted_list[0].length() == word.length() {\n   |                           \
    \        ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0599]: no method named `length` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpvwef_e6e.rs:27:52\n   |\n27 |                 if sorted_list[0].length()\
    \ == word.length() {\n   |                                                   \
    \ ^^^^^^ help: there is an associated function with a similar name: `len`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        } else {\n            sorted_list.sort_by(|a,\
    \ b| a.cmp(b));\n        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmp1kmh9i1z.rs:17:27\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         ---------------  \
    \ ^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |      \
    \   consider giving `sorted_list` the explicit type `Vec<T>`, where the type parameter\
    \ `T` is specified\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list.last().unwrap().len() < word.len()\
    \ {\n                sorted_list.push(word);\n            } else {\n         \
    \       sorted_list.sort();\n                res.push(sorted_list.last().unwrap());\n\
    \                sorted_list.clear();\n            }\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfuvn48z_.rs:32:5\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |             \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n32 |     res\n   |     ^^^ expected struct `String`, found `&String`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&String>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for s in lst {\n        if\
    \ res.len() > 0 {\n            if s.len() > res.last().unwrap().len() {\n    \
    \            res.push(s);\n            } else {\n                res.sort_by(|a,\
    \ b| a.len() < b.len());\n                res.push(s);\n            }\n      \
    \  } else {\n            res.push(s);\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmp_x3bj51v.rs:20:30\n\
    \   |\n17 |     let mut res = vec![];\n   |         ------- consider giving `res`\
    \ the explicit type `Vec<T>`, where the type parameter `T` is specified\n...\n\
    20 |             if s.len() > res.last().unwrap().len() {\n   |              \
    \                ^^^^ cannot infer type for type parameter `T`\n   |\n   = note:\
    \ type must be known at this point\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.len()\
    \ == 1 {\n                sorted_list.push(word);\n            } else {\n    \
    \            if sorted_list[0].length() == word.length() {\n                 \
    \   if sorted_list[0].cmp(&word) == Ordering::Less {\n                       \
    \ sorted_list.push(word);\n                    }\n                } else {\n \
    \                   if sorted_list[0].length() < word.length() {\n           \
    \             sorted_list.push(word);\n                    }\n               \
    \ }\n            }\n        }\n    }\n    sorted_list.sort_by(|a, b| a.cmp(&b));\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmphmks7a7o.rs:27:53\n   |\n27 |                     if sorted_list[0].cmp(&word)\
    \ == Ordering::Less {\n   |                                                  \
    \   ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0599]: no method named\
    \ `length` found for struct `String` in the current scope\n  --> /tmp/tmphmks7a7o.rs:26:35\n\
    \   |\n26 |                 if sorted_list[0].length() == word.length() {\n  \
    \ |                                   ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0599]: no method named `length` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmphmks7a7o.rs:26:52\n   |\n\
    26 |                 if sorted_list[0].length() == word.length() {\n   |     \
    \                                               ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmphmks7a7o.rs:31:39\n\
    \   |\n31 |                     if sorted_list[0].length() < word.length() {\n\
    \   |                                       ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0599]: no method named `length`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmphmks7a7o.rs:31:55\n\
    \   |\n31 |                     if sorted_list[0].length() < word.length() {\n\
    \   |                                                       ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0433, E0599.\n\
    For more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for elem in lst {\n        let len = elem.len();\n        if len % 2 == 1\
    \ {\n            sorted_list.push(elem);\n        } else {\n            let mut\
    \ i = 0;\n            while i < len {\n                if sorted_list[i].len()\
    \ > len {\n                    sorted_list.swap(i, i);\n                    break;\n\
    \                }\n                i += 1;\n            }\n        }\n    }\n\
    \    for elem in sorted_list {\n        res.push(elem);\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpm6uk3y_n.rs:26:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut sorted_list = vec![];\n\
    \    for s in lst {\n        if s.len() % 2 != 0 {\n            sorted_list.push(s);\n\
    \        }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    for\
    \ s in sorted_list {\n        res.push(s);\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpedv5crqb.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if word.len()\
    \ > sorted_list[0].len() {\n                sorted_list.push(word);\n        \
    \    } else {\n                if word.len() < sorted_list[0].len() {\n      \
    \              sorted_list = sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \                }\n            }\n        }\n    }\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprhea89_2.rs:27:62\n   |\n\
    27 |                     sorted_list = sorted_list.sort_by(|a, b| a.len() < b.len());\n\
    \   |                                                              ^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprhea89_2.rs:27:35\n   |\n18 |     let mut sorted_list =\
    \ vec![];\n   |                           ------ expected due to this value\n\
    ...\n27 |                     sorted_list = sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.last().unwrap().len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                if sorted_list.last().unwrap().len() == word.len() {\n  \
    \                  sorted_list.push(word);\n                }\n            }\n\
    \        }\n    }\n    sorted_list.sort_by_key(|x| x.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpa4k_23en.rs:17:27\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         ---------------  \
    \ ^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |      \
    \   consider giving `sorted_list` the explicit type `Vec<T>`, where the type parameter\
    \ `T` is specified\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 == 1 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppkdp47zc.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut counter = vec![];\n\
    \    for word in lst {\n        if counter.contains(&word) {\n            sorted_list.push(word);\n\
    \        } else {\n            sorted_list.push(word);\n            counter.push(word);\n\
    \        }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmfoxqzg5.rs:27:32\n   |\n\
    27 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for ele in lst {\n        if\
    \ res.len() > 0 {\n            if res.last().len() < ele.len() {\n           \
    \     res.push(ele);\n            } else {\n                res.sort_by(|a, b|\
    \ a.len() < b.len());\n                res.push(ele);\n            }\n       \
    \ } else {\n            res.push(ele);\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp_57mq171.rs:20:27\n   |\n20 |             if res.last().len()\
    \ < ele.len() {\n   |                           ^^^ method not found in `Option<&_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_57mq171.rs:23:36\n   |\n23 |\
    \                 res.sort_by(|a, b| a.len() < b.len());\n   |               \
    \                     ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found\
    \ `bool`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        let len = word.len();\n        if len % 2 == 1\
    \ {\n            sorted_list.push(word);\n        } else {\n            let mut\
    \ i = 0;\n            while i < sorted_list.len() {\n                if sorted_list[i].len()\
    \ > len {\n                    res.push(sorted_list[i]);\n                   \
    \ sorted_list.pop();\n                } else {\n                    i += 1;\n\
    \                }\n            }\n            res.push(word);\n        }\n  \
    \  }\n    res.sort_by(|a, b| a.len() < b.len());\n    res\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp46_gdz3x.rs:36:24\n   |\n\
    36 |     res.sort_by(|a, b| a.len() < b.len());\n   |                        ^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            let mut i = 0;\n            let mut j = 0;\n  \
    \          while i < sorted_list.len() && j < word.len() {\n                if\
    \ sorted_list[i].len() < word[j].len() {\n                    i += 1;\n      \
    \          } else if sorted_list[i].len() > word[j].len() {\n                \
    \    j += 1;\n                } else {\n                    sorted_list.swap(i,\
    \ j);\n                    i += 1;\n                    j += 1;\n            \
    \    }\n            }\n            sorted_list.push(word);\n        }\n    }\n\
    \    for word in sorted_list {\n        res.push(word);\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgmnc1l3t.rs:26:43\n\
    \   |\n26 |                 if sorted_list[i].len() < word[j].len() {\n   |  \
    \                                         ^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgmnc1l3t.rs:28:50\n   |\n28 |                 } else if sorted_list[i].len()\
    \ > word[j].len() {\n   |                                                  ^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.contains(&word.len())\
    \ {\n            sorted_list_len[sorted_list_len.iter().position(|&x| x == word.len()).unwrap()]\
    \ += 1;\n        } else {\n            sorted_list_len.push(word.len());\n   \
    \     }\n    }\n    for word in sorted_list_len.iter() {\n        sorted_list.push(String::from(\"\
    \"));\n    }\n    for word in lst {\n        if sorted_list_len.contains(&word.len())\
    \ {\n            sorted_list_len[sorted_list_len.iter().position(|&x| x == word.len()).unwrap()]\
    \ += 1;\n        } else {\n            sorted_list_len.push(word.len());\n   \
    \     }\n    }\n    for word in sorted_list_len.iter() {\n        sorted_list.push(String::from(\"\
    \"));\n    }\n    for word in lst {\n        if sorted_list_len.contains(&word.len())\
    \ {\n            sorted_list_len[sorted_list_len.iter().position(|&x| x == word.len()).unwrap()]\
    \ += 1;\n        } else {\n            sorted_list_len.push(word.len());\n   \
    \     }\n    }\n    for word in sorted_list_len.iter() {\n        sorted_list.push(String::from(\"\
    \"));\n    }\n    for word in lst {\n        if sorted_list_len.contains(&word.len())\
    \ {\n            sorted_list_len[sorted_list_len.iter().position(|&x| x == word.len()).unwrap()]\
    \ += 1;\n        } else {\n            sorted_list_len.push(word.len());\n   \
    \     }\n    }\n    for word in sorted_list_len.iter() {\n        sorted_list.push(String::from(\"\
    \"));\n    }\n    for word in lst {\n        if sorted_list_len.contains(&word.len())\
    \ {\n            sorted_list_len[sorted_list_len.iter().position(|&x| x == word.len()).unwrap()]\
    \ += 1;\n        } else {\n            sorted_list_len.push(word.len());\n   \
    \     }\n    }\n    for word in sorted_list_len.iter() {\n        sorted_list.push(String::from(\"\
    \"));\n    }\n    for word in lst {\n        if sorted_list_len.contains(&word.len())\
    \ {\n            sorted_list_len[sorted_list_len.iter().position(|&x| x == word.len()).unwrap()]\
    \ += 1;\n        } else {\n            sorted_list_len.push(word.len());\n   \
    \     }\n    }\n    for word in sorted_list_len.iter() {\n        sorted_list.push(String::from(\"\
    \"));\n    }\n    for word in lst {\n        if sorted_list_len.contains(&word.len())\
    \ {\n            sorted_\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmppf3zgjnh.rs:93:3\n\
    \   |\n16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n79\
    \ |     for word in lst {\n   |                     - unclosed delimiter\n80 |\
    \         if sorted_list_len.contains(&word.len()) {\n   |                   \
    \                               - this delimiter might not be properly closed...\n\
    81 |             sorted_\n82 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n93 | }\n   |   ^\n\nerror[E0425]: cannot find value `sorted_`\
    \ in this scope\n  --> /tmp/tmppf3zgjnh.rs:81:13\n   |\n81 |             sorted_\n\
    \   |             ^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppf3zgjnh.rs:79:5\n   |\n16 |   fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                                        \
    \   ----------- expected `Vec<String>` because of return type\n...\n79 | /   \
    \  for word in lst {\n80 | |         if sorted_list_len.contains(&word.len())\
    \ {\n81 | |             sorted_\n82 | | }\n...  |\n92 | |     assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc...\n93 | | }\n   | |__^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<String>`\n           found unit\
    \ type `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 == 1 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppkdp47zc.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in lst {\n        if\
    \ sorted_list_len.contains(&word.len()) {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmprz_jja5q.rs:23:17\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for word in lst {\n    |\
    \                 --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for word in lst {\n    |                 ^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `lst`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n19  |     for word in &lst {\n \
    \   |                 +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2_tmier.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut sorted_list = Vec::new();\n\
    \    for elem in lst.iter() {\n        if elem.len() % 2 == 1 {\n            sorted_list.push(elem);\n\
    \        } else {\n            let mut i = 0;\n            for j in sorted_list.iter()\
    \ {\n                if j == elem {\n                    i += 1;\n           \
    \     } else {\n                    break;\n                }\n            }\n\
    \            if i == sorted_list.len() {\n                sorted_list.push(elem);\n\
    \            }\n        }\n    }\n    for elem in sorted_list.iter() {\n     \
    \   res.push(elem);\n    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmpoft7xb50.rs:25:22\n\
    \   |\n25 |                 if j == elem {\n   |                      ^^ no implementation\
    \ for `&String == String`\n   |\n   = help: the trait `PartialEq<String>` is not\
    \ implemented for `&String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&String>` for `&&String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpoft7xb50.rs:39:5\n   |\n16 | fn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n39 |     res\n   |     ^^^ expected\
    \ struct `String`, found `&&String`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&&String>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for s in lst {\n        let len = s.len();\n        if len % 2 == 1 {\n \
    \           sorted_list.push(s);\n        } else {\n            let mut i = 0;\n\
    \            while i < len {\n                if i % 2 == 1 {\n              \
    \      sorted_list.push(s);\n                    break;\n                }\n \
    \               i += 1;\n            }\n        }\n    }\n    for s in sorted_list\
    \ {\n        res.push(s);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpcwt3tu1s.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008841
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for word in lst {\n       \
    \ if res.len() == 0 {\n            res.push(word);\n        } else {\n       \
    \     let mut cur = res.iter().next();\n            if cur.len() < word.len()\
    \ {\n                res.push(word);\n            } else {\n                while\
    \ cur.len() < word.len() {\n                    res.push(cur.clone());\n     \
    \               cur = res.iter().next();\n                }\n            }\n \
    \       }\n    }\n    res.sort_by_key(|x| x.len());\n    res\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmprh8ozzvr.rs:23:20\n   |\n23 |             if cur.len()\
    \ < word.len() {\n   |                    ^^^ method not found in `Option<&String>`\n\
    \nerror[E0599]: no method named `len` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmprh8ozzvr.rs:26:27\n   |\n26 |                 while cur.len() <\
    \ word.len() {\n   |                           ^^^ method not found in `Option<&String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprh8ozzvr.rs:27:30\n   |\n27 |\
    \                     res.push(cur.clone());\n   |                           \
    \   ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<&String>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.contains(&word)\
    \ {\n            sorted_list_len.push(word);\n        } else {\n            sorted_list.push(word);\n\
    \            sorted_list_len.push(word.len());\n        }\n    }\n    sorted_list.sort_by(|a,\
    \ b| a.cmp(b));\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv5n5hp5v.rs:24:34\n   |\n\
    24 |             sorted_list_len.push(word.len());\n   |                     \
    \             ^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                  |\n   |                               \
    \   expected struct `String`, found `usize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for ele in lst {\n        if\
    \ res.iter().any(|&x| x.len() < ele.len()) {\n            res.push(ele);\n   \
    \     } else {\n            let mut i = 0;\n            while i < res.len() &&\
    \ res[i].len() < ele.len() {\n                i += 1;\n            }\n       \
    \     res.swap(i, res.len() - 1);\n        }\n    }\n    res.sort_by(|a, b| a.len()\
    \ < b.len());\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmpth9vxxyw.rs:19:28\n\
    \   |\n19 |         if res.iter().any(|&x| x.len() < ele.len()) {\n   |      \
    \                      ^^ consider giving this closure parameter the explicit\
    \ type `&T`, with the type parameters specified\n   |\n   = note: type must be\
    \ known at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for s in lst {\n        if s.len() % 2 == 1 {\n            sorted_list.push(s);\n\
    \        } else {\n            let mut i = 0;\n            for c in s.chars()\
    \ {\n                i += 1;\n                if i % 2 == 0 {\n              \
    \      sorted_list.push(c);\n                }\n            }\n        }\n   \
    \ }\n    for s in sorted_list {\n        res.push(s);\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp09wou1d4.rs:27:38\n   |\n\
    27 |                     sorted_list.push(c);\n   |                          \
    \            ^- help: try using a conversion method: `.to_string()`\n   |    \
    \                                  |\n   |                                   \
    \   expected struct `String`, found `char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut len = lst.len();\n\
    \    while len > 0 {\n        let mut i = 0;\n        let mut j = 0;\n       \
    \ while i < len && j < len {\n            if lst[i].len() > lst[j].len() {\n \
    \               res.push(lst[j]);\n                j += 1;\n            } else\
    \ {\n                i += 1;\n            }\n        }\n        res.push(lst[j]);\n\
    \        len -= 1;\n    }\n    res.sort();\n    res\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmperbv91o9.rs:24:26\n\
    \   |\n24 |                 res.push(lst[j]);\n   |                          ^^^^^^\
    \ move occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmperbv91o9.rs:30:18\n\
    \   |\n30 |         res.push(lst[j]);\n   |                  ^^^^^^ move occurs\
    \ because value has type `String`, which does not implement the `Copy` trait\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        let mut new_list = vec![];\n        for word in lst {\n         \
    \   if word.len() == word {\n                new_list.push(word);\n          \
    \  }\n        }\n        sorted_list.push(new_list);\n    }\n    sorted_list.sort_unstable();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp277632ky.rs:26:30\n   |\n\
    26 |             if word.len() == word {\n   |                              ^^^^\
    \ expected `usize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp277632ky.rs:33:5\n   |\n16 | fn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n33 |     sorted_list\n   |     ^^^^^^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for s in lst {\n        if\
    \ res.iter().any(|&x| x.len() == s.len()) {\n            res.sort_unstable_by_key(|&x|\
    \ x.len());\n        } else {\n            res.push(s);\n        }\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmp2uj6qgpo.rs:19:28\n\
    \   |\n19 |         if res.iter().any(|&x| x.len() == s.len()) {\n   |       \
    \                     ^^ consider giving this closure parameter the explicit type\
    \ `&T`, with the type parameters specified\n   |\n   = note: type must be known\
    \ at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for elem in lst {\n        let len = elem.len();\n        sorted_list_len.push(len);\n\
    \        sorted_list.push(elem);\n    }\n    sorted_list_len.sort_unstable();\n\
    \    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpomzca0tn.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008841
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        for word in lst {\n            if word.len() == word {\n        \
    \        sorted_list.push(word);\n                break;\n            }\n    \
    \    }\n    }\n    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy0ruw8e8.rs:25:30\n   |\n\
    25 |             if word.len() == word {\n   |                              ^^^^\
    \ expected `usize`, found struct `String`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[0].len() < word.len() {\n      \
    \          sorted_list.push(word);\n            } else {\n                sorted_list.sort();\n\
    \                res.push(sorted_list[0]);\n                sorted_list.pop();\n\
    \            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmppxr3knok.rs:27:26\n\
    \   |\n27 |                 res.push(sorted_list[0]);\n   |                  \
    \        ^^^^^^^^^^^^^^ move occurs because value has type `String`, which does\
    \ not implement the `Copy` trait\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut counter = vec![];\n\
    \    for word in lst {\n        if counter.contains(&word) {\n            sorted_list.push(word);\n\
    \        } else {\n            sorted_list.push(word);\n            counter.push(word);\n\
    \        }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmfoxqzg5.rs:27:32\n   |\n\
    27 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for elem in lst {\n        sorted_list_len.push(elem.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for elem in sorted_list_len\
    \ {\n        let mut sorted_list_elem = vec![];\n        for elem2 in lst {\n\
    \            if elem2.len() == elem {\n                sorted_list_elem.push(elem2);\n\
    \            }\n        }\n        sorted_list.push(sorted_list_elem);\n    }\n\
    \    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpncg9d6lt.rs:33:5\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |             \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n33 |     sorted_list\n   |     ^^^^^^^^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `Vec<String>`\n       \
    \       found struct `Vec<Vec<String>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut len = lst.len();\n\
    \    while len > 0 {\n        let mut cur = vec![];\n        for s in lst {\n\
    \            if s.len() % 2 == 1 {\n                cur.push(s);\n           \
    \ }\n        }\n        res.push(cur);\n        len -= cur.len();\n    }\n   \
    \ res.sort_by_key(|x| x.iter().map(|s| s.len()).sum());\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc9qjkl95.rs:30:5\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |             \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n30 |     res\n   |     ^^^ expected struct `String`, found struct\
    \ `Vec`\n   |\n   = note: expected struct `Vec<String>`\n              found struct\
    \ `Vec<Vec<String>>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in lst {\n        if\
    \ sorted_list_len.iter().position(|&x| x == word.len()).is_some() {\n        \
    \    sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_unstable();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp_12l_zi6.rs:23:17\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for word in lst {\n    |\
    \                 --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for word in lst {\n    |                 ^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `lst`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n19  |     for word in &lst {\n \
    \   |                 +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for s in lst {\n        if s.len() % 2 != 0 {\n            sorted_list.push(s);\n\
    \        } else {\n            let mut i = 0;\n            for c in s.chars()\
    \ {\n                if i % 2 == 0 {\n                    i += 1;\n          \
    \      } else {\n                    i += 1;\n                }\n            }\n\
    \            sorted_list.push(s);\n        }\n    }\n    for i in sorted_list.len()\
    \ {\n        for j in sorted_list.len() {\n            if i != j {\n         \
    \       if sorted_list[j].len() < sorted_list[i].len() {\n                   \
    \ let mut temp = sorted_list[i];\n                    sorted_list[i] = sorted_list[j];\n\
    \                    sorted_list[j] = temp;\n                }\n            }\n\
    \        }\n    }\n    for i in sorted_list.len() {\n        for j in sorted_list.len()\
    \ {\n            if i != j {\n                if sorted_list[j].len() > sorted_list[i].len()\
    \ {\n                    let mut temp = sorted_list[i];\n                    sorted_list[i]\
    \ = sorted_list[j];\n                    sorted_list[j] = temp;\n            \
    \    }\n            }\n        }\n    }\n    for i in sorted_list.len() {\n  \
    \      for j in sorted_list.len() {\n            if i != j {\n               \
    \ if sorted_list[j].len() == sorted_list[i].len() {\n                    let mut\
    \ temp = sorted_list[i];\n                    sorted_list[i] = sorted_list[j];\n\
    \                    sorted_list[j] = temp;\n                }\n            }\n\
    \        }\n    }\n    for i in sorted_list.len() {\n        for j in sorted_list.len()\
    \ {\n            if i != j {\n                if sorted_list[j].len() < sorted_list[i].len()\
    \ {\n                    let mut temp = sorted_list[i];\n                    sorted_list[i]\
    \ = sorted_list[j];\n                    sorted_list[j] = temp;\n            \
    \    }\n            }\n        }\n    }\n    for i in sorted_list.len() {\n  \
    \      for j in sorted_list.len() {\n            if i != j {\n               \
    \ if sorted_list[j].len() > sorted_list[i].len() {\n                    let mut\
    \ temp = sorted_list[i];\n                    sorted_list[i] = sorted_list[j];\n\
    \                    sorted_list[j] = temp;\n                }\n            }\n\
    \        }\n    }\n    for i in sorted_list.len() {\n        for j in sorted_list.len()\
    \ {\n            if i != j {\n                if sorted_list[j].len() == sorted_list[i].len()\
    \ {\n                    let mut temp = sorted_list[i];\n                    sorted_list[i]\
    \ = sorted_list[j];\n                    sorted_list[j] = temp;\n            \
    \    }\n            }\n        }\n    }\n    for i in sorted_list.len() {\n  \
    \      for j in sorted_list.len() {\n            if i != j {\n               \
    \ if sorted_list[j].len() < sorted_list[i].len() {\n                    let mut\
    \ temp = sorted_list[i];\n                    sorted_list[i] = sorted_list[j];\n\
    \n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpakmyeo9p.rs:118:3\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                                                  - unclosed delimiter\n...\n\
    100 |     for i in sorted_list.len() {\n    |                                -\
    \ unclosed delimiter\n101 |         for j in sorted_list.len() {\n    |      \
    \                              - unclosed delimiter\n102 |             if i !=\
    \ j {\n    |                       - unclosed delimiter\n103 |               \
    \  if sorted_list[j].len() < sorted_list[i].len() {\n    |                   \
    \                                             - this delimiter might not be properly\
    \ closed...\n...\n107 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n118 | }\n    |   ^\n\nerror[E0277]: `usize` is not an iterator\n\
    \  --> /tmp/tmpakmyeo9p.rs:34:14\n   |\n34 |     for i in sorted_list.len() {\n\
    \   |              ^^^^^^^^^^^^^^^^^ `usize` is not an iterator\n   |\n   = help:\
    \ the trait `Iterator` is not implemented for `usize`\n   = note: if you want\
    \ to iterate between `start` until a value `end`, use the exclusive range syntax\
    \ `start..end` or the inclusive range syntax `start..=end`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `usize`\n\nerror[E0277]:\
    \ `usize` is not an iterator\n  --> /tmp/tmpakmyeo9p.rs:35:18\n   |\n35 |    \
    \     for j in sorted_list.len() {\n   |                  ^^^^^^^^^^^^^^^^^ `usize`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `usize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `usize`\n\nerror[E0277]: `usize` is not an iterator\n  -->\
    \ /tmp/tmpakmyeo9p.rs:45:14\n   |\n45 |     for i in sorted_list.len() {\n   |\
    \              ^^^^^^^^^^^^^^^^^ `usize` is not an iterator\n   |\n   = help:\
    \ the trait `Iterator` is not implemented for `usize`\n "
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if word.len() % 2 == 1 {\n            sorted_list.push(word);\n     \
    \   }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7i8r_xls.rs:23:32\n   |\n\
    23 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in sorted_list_len\
    \ {\n        sorted_list.push(word.to_string());\n    }\n    sorted_list.sort_unstable();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"1\", \"2\", \"3\"]`,\n right: `[\"aa\"]`', /tmp/tmp7gybrhtb.rs:32:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008841
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut sorted_list = vec![];\n\
    \    for s in lst {\n        if s.len() % 2 != 0 {\n            sorted_list.push(s);\n\
    \        }\n    }\n    sorted_list.sort_by_key(|s| s.len());\n    for s in sorted_list\
    \ {\n        res.push(s);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpbo03qyho.rs:33:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008841
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list[0].length()\
    \ == word.length() {\n                sorted_list.sort_by(|a, b| a.cmp(b));\n\
    \                sorted_list.push(word);\n            } else {\n             \
    \   sorted_list.sort_by(|a, b| a.cmp(b));\n                sorted_list.push(word);\n\
    \                sorted_list.push(sorted_list[0]);\n            }\n        }\n\
    \    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpterv5muq.rs:23:31\n   |\n23 |             if sorted_list[0].length()\
    \ == word.length() {\n   |                               ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpterv5muq.rs:23:48\n\
    \   |\n23 |             if sorted_list[0].length() == word.length() {\n   |  \
    \                                              ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 == 1 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by_key(|x|\
    \ x.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmptd8gs35i.rs:17:27\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         ---------------  \
    \ ^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |      \
    \   consider giving `sorted_list` the explicit type `Vec<T>`, where the type parameter\
    \ `T` is specified\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list[0].len() < word.len() {\n      \
    \          sorted_list.push(word);\n            } else {\n                let\
    \ mut i = 0;\n                while i < sorted_list.len() {\n                \
    \    if sorted_list[i].len() < word.len() {\n                        break;\n\
    \                    }\n                    i += 1;\n                }\n     \
    \           sorted_list.insert(i, word);\n            }\n        }\n    }\n  \
    \  for word in sorted_list {\n        res.push(word);\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp7vub5f4n.rs:45:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by_key(|x| x.len());\n\
    \    sorted_list.sort_by_key(|x| x.to_lowercase());\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmplkeo9auv.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmplkeo9auv.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        if sorted_list.iter().any(|&x| x.len() < word.len()) {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_by(|a, b| a.len() < b.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmpydax8vvi.rs:19:36\n\
    \   |\n19 |         if sorted_list.iter().any(|&x| x.len() < word.len()) {\n \
    \  |                                    ^^ consider giving this closure parameter\
    \ the explicit type `&T`, with the type parameters specified\n   |\n   = note:\
    \ type must be known at this point\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for word in lst {\n       \
    \ let len = word.len();\n        if len % 2 == 1 {\n            res.push(word);\n\
    \        } else {\n            let mut i = 0;\n            let mut j = 0;\n  \
    \          while i < len && j < len {\n                if word[j] < word[i] {\n\
    \                    i += 1;\n                } else {\n                    j\
    \ += 1;\n                }\n            }\n            if i == len {\n       \
    \         res.push(word);\n            } else {\n                res.push(word[j]);\n\
    \            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1dfggxfj.rs:26:20\n\
    \   |\n26 |                 if word[j] < word[i] {\n   |                    ^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1dfggxfj.rs:26:30\n   |\n26 |                 if word[j] < word[i]\
    \ {\n   |                              ^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1dfggxfj.rs:35:26\n   |\n35 |                 res.push(word[j]);\n\
    \   |                          ^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n       "
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            let mut found = false;\n            for item in\
    \ sorted_list {\n                if item.len() == word.len() {\n             \
    \       if item < word {\n                        sorted_list.push(item);\n  \
    \                  } else {\n                        sorted_list.push(word);\n\
    \                        found = true;\n                    }\n              \
    \  }\n            }\n            if !found {\n                sorted_list.push(word);\n\
    \            }\n        }\n    }\n    for word in sorted_list {\n        res.push(word);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `sorted_list`\n   --> /tmp/tmpz2aftnsi.rs:20:12\n\
    \    |\n18  |     let mut sorted_list = vec![];\n    |         ---------------\
    \ move occurs because `sorted_list` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n19  |     for word in lst {\n20  |         if sorted_list.len()\
    \ == 0 {\n    |            ^^^^^^^^^^^^^^^^^ value borrowed here after move\n\
    ...\n24  |             for item in sorted_list {\n    |                      \
    \   ----------- `sorted_list` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `sorted_list`\nhelp: consider iterating over\
    \ a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \    |\n24  |             for item in &sorted_list {\n    |                  \
    \       +\n\nerror[E0382]: borrow of moved value: `word`\n  --> /tmp/tmpz2aftnsi.rs:25:34\n\
    \   |\n19 |     for word in lst {\n   |         ----\n   |         |\n   |   \
    \      this reinitialization might get skipped\n   |         move occurs because\
    \ `word` has type `String`, which does not implement the `Copy` trait\n...\n25\
    \ |                 if item.len() == word.len() {\n   |                      \
    \            ^^^^^^^^^^ value borrowed here after move\n...\n29 |            \
    \             sorted_list.push(word);\n   |                                  \
    \        ---- value moved here, in previous iteration of loop\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for word in lst {\n       \
    \ if res.len() > 0 {\n            if word.len() > res[0].len() {\n           \
    \     res.sort();\n            }\n        }\n        res.push(word);\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpjmsvs_dv.rs:20:29\n\
    \   |\n17 |     let mut res = vec![];\n   |         ------- consider giving `res`\
    \ the explicit type `Vec<T>`, with the type parameters specified\n...\n20 |  \
    \           if word.len() > res[0].len() {\n   |                             ^^^^^^\
    \ cannot infer type\n   |\n   = note: type must be known at this point\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            let mut found = false;\n            for item in\
    \ sorted_list {\n                if item.len() == word.len() {\n             \
    \       if item < word {\n                        sorted_list.push(item);\n  \
    \                      found = true;\n                    }\n                }\
    \ else {\n                    if item == word {\n                        found\
    \ = true;\n                    }\n                }\n            }\n         \
    \   if !found {\n                sorted_list.push(word);\n            }\n    \
    \    }\n    }\n    for word in sorted_list {\n        res.push(word);\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `sorted_list`\n   --> /tmp/tmpgybu0nm_.rs:20:12\n\
    \    |\n18  |     let mut sorted_list = vec![];\n    |         ---------------\
    \ move occurs because `sorted_list` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n19  |     for word in lst {\n20  |         if sorted_list.len()\
    \ == 0 {\n    |            ^^^^^^^^^^^^^^^^^ value borrowed here after move\n\
    ...\n24  |             for item in sorted_list {\n    |                      \
    \   ----------- `sorted_list` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `sorted_list`\nhelp: consider iterating over\
    \ a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \    |\n24  |             for item in &sorted_list {\n    |                  \
    \       +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        let len = word.len();\n        if len % 2 == 1\
    \ {\n            sorted_list.push(word);\n        } else {\n            let mut\
    \ i = 0;\n            while i < sorted_list.len() {\n                if sorted_list[i].len()\
    \ < len {\n                    i += 1;\n                } else {\n           \
    \         break;\n                }\n            }\n            sorted_list.insert(i,\
    \ word);\n        }\n    }\n    for word in sorted_list {\n        res.push(word);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp3sg9gxyp.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008841
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            let mut found = false;\n            for s in sorted_list\
    \ {\n                if word.len() < s.len() {\n                    found = true;\n\
    \                    break;\n                }\n            }\n            if\
    \ !found {\n                sorted_list.push(word);\n            }\n        }\n\
    \    }\n    for s in sorted_list {\n        res.push(s);\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `sorted_list`\n   --> /tmp/tmp9ochj2y6.rs:20:12\n\
    \    |\n18  |     let mut sorted_list = vec![];\n    |         ---------------\
    \ move occurs because `sorted_list` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n19  |     for word in lst {\n20  |         if sorted_list.len()\
    \ == 0 {\n    |            ^^^^^^^^^^^^^^^^^ value borrowed here after move\n\
    ...\n24  |             for s in sorted_list {\n    |                      -----------\
    \ `sorted_list` moved due to this implicit call to `.into_iter()`, in previous\
    \ iteration of loop\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `sorted_list`\nhelp: consider iterating over a slice of\
    \ the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n24 \
    \ |             for s in &sorted_list {\n    |                      +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for elem in lst {\n        if elem.len() % 2 != 0 {\n            sorted_list.push(elem);\n\
    \        } else {\n            let mut i = 0;\n            for j in sorted_list.iter().rev()\
    \ {\n                if j == elem {\n                    i += 1;\n           \
    \         break;\n                }\n            }\n            if i == 0 {\n\
    \                sorted_list.push(elem);\n            }\n        }\n    }\n  \
    \  for elem in sorted_list {\n        res.push(elem);\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmpqy42mze7.rs:25:22\n\
    \   |\n25 |                 if j == elem {\n   |                      ^^ no implementation\
    \ for `&String == String`\n   |\n   = help: the trait `PartialEq<String>` is not\
    \ implemented for `&String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for s in lst {\n        if\
    \ s.len() % 2 != 0 {\n            res.push(s);\n        }\n    }\n    res.sort_by(|a,\
    \ b| a.len() < b.len());\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpebwjieg0.rs:23:24\n   |\n\
    23 |     res.sort_by(|a, b| a.len() < b.len());\n   |                        ^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for word in lst {\n       \
    \ if res.len() > 0 {\n            if word.len() > res[0].len() {\n           \
    \     res.sort();\n            }\n        }\n        res.push(word);\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpjmsvs_dv.rs:20:29\n\
    \   |\n17 |     let mut res = vec![];\n   |         ------- consider giving `res`\
    \ the explicit type `Vec<T>`, with the type parameters specified\n...\n20 |  \
    \           if word.len() > res[0].len() {\n   |                             ^^^^^^\
    \ cannot infer type\n   |\n   = note: type must be known at this point\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            let mut is_sorted = false;\n            for s in\
    \ sorted_list {\n                if word.len() < s.len() {\n                 \
    \   is_sorted = true;\n                    break;\n                }\n       \
    \     }\n            if is_sorted {\n                sorted_list.push(word);\n\
    \            } else {\n                res.push(sorted_list);\n              \
    \  sorted_list = vec![word];\n            }\n        }\n    }\n    res.push(sorted_list);\n\
    \    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyv68iidb.rs:39:5\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |             \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n39 |     res\n   |     ^^^ expected struct `String`, found struct\
    \ `Vec`\n   |\n   = note: expected struct `Vec<String>`\n              found struct\
    \ `Vec<Vec<String>>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        let len = word.len();\n        if len % 2 == 1\
    \ {\n            sorted_list.push(word);\n        } else {\n            let mut\
    \ i = 0;\n            while i < sorted_list.len() {\n                if sorted_list[i].len()\
    \ < len {\n                    i += 1;\n                } else {\n           \
    \         break;\n                }\n            }\n            sorted_list.insert(i,\
    \ word);\n        }\n    }\n    for word in sorted_list {\n        res.push(word);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpzum716ep.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008841
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for elem in lst {\n        let len = elem.len();\n        if len % 2 == 1\
    \ {\n            sorted_list.push(elem);\n        } else {\n            let mut\
    \ i = 0;\n            while i < sorted_list.len() {\n                if sorted_list[i].len()\
    \ < len {\n                    i += 1;\n                } else {\n           \
    \         break;\n                }\n            }\n            sorted_list.insert(i,\
    \ elem);\n        }\n    }\n    for elem in sorted_list {\n        res.push(elem);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmps9znn0xi.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008841
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpdwr18936.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpdwr18936.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut sorted_list = vec![];\n\
    \    for elem in lst.iter() {\n        if elem.len() % 2 != 0 {\n            sorted_list.push(elem);\n\
    \        } else {\n            let mut new_elem = vec![];\n            for elem2\
    \ in sorted_list.iter() {\n                if elem2.len() < elem.len() {\n   \
    \                 new_elem.push(elem2);\n                }\n            }\n  \
    \          sorted_list = new_elem;\n            sorted_list.push(elem);\n    \
    \    }\n    }\n    for elem in sorted_list.iter() {\n        res.push(elem);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyf5l38jy.rs:29:27\n   |\n\
    18 |     let mut sorted_list = vec![];\n   |                           ------\
    \ expected due to this value\n...\n29 |             sorted_list = new_elem;\n\
    \   |                           ^^^^^^^^ expected struct `String`, found `&String`\n\
    \   |\n   = note: expected struct `Vec<&String>`\n              found struct `Vec<&&String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyf5l38jy.rs:36:5\n   |\n16 | fn\
    \ sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n36 |     res\n   |     ^^^ expected struct `String`, found `&&String`\n \
    \  |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&&String>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            let mut found = false;\n            for s in sorted_list\
    \ {\n                if word.len() < s.len() {\n                    found = true;\n\
    \                    break;\n                }\n            }\n            if\
    \ !found {\n                sorted_list.push(word);\n            }\n        }\n\
    \    }\n    for s in sorted_list {\n        res.push(s);\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `sorted_list`\n   --> /tmp/tmp9ochj2y6.rs:20:12\n\
    \    |\n18  |     let mut sorted_list = vec![];\n    |         ---------------\
    \ move occurs because `sorted_list` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n19  |     for word in lst {\n20  |         if sorted_list.len()\
    \ == 0 {\n    |            ^^^^^^^^^^^^^^^^^ value borrowed here after move\n\
    ...\n24  |             for s in sorted_list {\n    |                      -----------\
    \ `sorted_list` moved due to this implicit call to `.into_iter()`, in previous\
    \ iteration of loop\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `sorted_list`\nhelp: consider iterating over a slice of\
    \ the `Vec<String>`'s content to avoid moving into the `for` loop\n    |\n24 \
    \ |             for s in &sorted_list {\n    |                      +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n    sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpdwr18936.rs:18:43\n     |\n18   |     let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n     |                              \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpdwr18936.rs:18:52\n   |\n18 |       let mut sorted_list\
    \ = lst.into_iter().cloned().collect();\n   |                                \
    \                      ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in lst {\n        if\
    \ sorted_list_len.iter().find(|&x| x == word.len()).is_some() {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&usize` with `usize`\n  --> /tmp/tmpus32qysj.rs:24:47\n\
    \   |\n24 |         if sorted_list_len.iter().find(|&x| x == word.len()).is_some()\
    \ {\n   |                                               ^^ no implementation for\
    \ `&usize == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not implemented\
    \ for `&usize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by_key(|x|\
    \ x.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpyv68j4bq.rs:17:27\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         ---------------  \
    \ ^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |      \
    \   consider giving `sorted_list` the explicit type `Vec<T>`, where the type parameter\
    \ `T` is specified\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2_tmier.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        let len = word.len();\n        if len % 2 == 1\
    \ {\n            sorted_list.push(word);\n        } else {\n            let mut\
    \ i = 0;\n            for _ in 0..len {\n                i += 1;\n           \
    \ }\n            sorted_list.push(word.to_owned());\n            i += 1;\n   \
    \     }\n    }\n    sorted_list.sort_by_key(|x| x.len());\n    for word in sorted_list\
    \ {\n        res.push(word);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp69_1h_zx.rs:41:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008841
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for elem in lst.iter() {\n        if elem.len() % 2 != 0 {\n            sorted_list.push(elem);\n\
    \        } else {\n            let mut i = 0;\n            for j in sorted_list.iter()\
    \ {\n                if j == elem {\n                    i += 1;\n           \
    \     } else {\n                    break;\n                }\n            }\n\
    \            if i == sorted_list.len() {\n                sorted_list.push(elem);\n\
    \            }\n        }\n    }\n    for elem in sorted_list.iter() {\n     \
    \   res.push(elem);\n    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmpzt06f744.rs:25:22\n\
    \   |\n25 |                 if j == elem {\n   |                      ^^ no implementation\
    \ for `&String == String`\n   |\n   = help: the trait `PartialEq<String>` is not\
    \ implemented for `&String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&String>` for `&&String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzt06f744.rs:39:5\n   |\n16 | fn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n39 |     res\n   |     ^^^ expected\
    \ struct `String`, found `&&String`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&&String>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut len = lst.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if len % 2 == 0 {\n        \
    \    res.push(lst[i]);\n            i += 1;\n        } else {\n            i +=\
    \ 1;\n        }\n        len -= 1;\n    }\n    res.sort();\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmphj8jth64.rs:22:22\n\
    \   |\n22 |             res.push(lst[i]);\n   |                      ^^^^^^ move\
    \ occurs because value has type `String`, which does not implement the `Copy`\
    \ trait\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2_tmier.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for s in lst {\n        if\
    \ s.len() % 2 != 0 {\n            res.push(s);\n        }\n    }\n    res.sort_by_key(|s|\
    \ s.len());\n    res.sort_by_key(|s| s.to_lowercase());\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpauxwi8nw.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2_tmier.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for s in lst {\n        if\
    \ res.len() > 0 {\n            if s.len() > res.len() {\n                res.push(s);\n\
    \            } else {\n                let mut i = 0;\n                while i\
    \ < res.len() && s.len() > res[i].len() {\n                    i += 1;\n     \
    \           }\n                res.swap(i, res.len() - 1);\n            }\n  \
    \      } else {\n            res.push(s);\n        }\n    }\n    res.sort_by_key(|s|\
    \ s.len());\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `res` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp94nb3e5e.rs:27:29\n   |\n27 |                 res.swap(i,\
    \ res.len() - 1);\n   |                 ------------^^^^^^^^^-----\n   |     \
    \            |   |       |\n   |                 |   |       immutable borrow\
    \ occurs here\n   |                 |   mutable borrow later used by call\n  \
    \ |                 mutable borrow occurs here\n   |\nhelp: try adding a local\
    \ storing this argument...\n  --> /tmp/tmp94nb3e5e.rs:27:29\n   |\n27 |      \
    \           res.swap(i, res.len() - 1);\n   |                             ^^^^^^^^^\n\
    help: ...and then using that local as the argument to this call\n  --> /tmp/tmp94nb3e5e.rs:27:17\n\
    \   |\n27 |                 res.swap(i, res.len() - 1);\n   |                \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.last().unwrap().len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                if sorted_list.last().unwrap().len() == word.len() {\n  \
    \                  sorted_list.push(word);\n                } else {\n       \
    \             if sorted_list.last().unwrap().len() > word.len() {\n          \
    \              sorted_list.push(word);\n                    }\n              \
    \  }\n            }\n        }\n    }\n    sorted_list.sort_by(|a, b| a.len()\
    \ < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0vquxhk3.rs:36:32\n   |\n\
    36 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 == 1 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppkdp47zc.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n\
    \    let mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n    let\
    \ mut sorted_list = vec![];\n    let mut sorted_list = vec![];\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7pj9o9ys.rs:16:41\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    ---------------\
    \                      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |   \
    \ |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        } else {\n            sorted_list.sort_by(|a,\
    \ b| a.cmp(b));\n        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmp1kmh9i1z.rs:17:27\n\
    \   |\n17 |     let mut sorted_list = vec![];\n   |         ---------------  \
    \ ^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |      \
    \   consider giving `sorted_list` the explicit type `Vec<T>`, where the type parameter\
    \ `T` is specified\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.len()\
    \ == 1 {\n                sorted_list.push(word);\n            } else {\n    \
    \            if sorted_list[0].length() == word.length() {\n                 \
    \   if sorted_list[0].len() > word.length() {\n                        sorted_list.push(word);\n\
    \                    } else {\n                        sorted_list.push(sorted_list[0]);\n\
    \                    }\n                } else {\n                    if sorted_list[0].length()\
    \ < word.length() {\n                        sorted_list.push(word);\n       \
    \             } else {\n                        sorted_list.push(sorted_list[0]);\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   sorted_list.sort_by_key(|x| x.len());\n    sorted_list\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp8dk80pqh.rs:26:35\n   |\n26 |                 if\
    \ sorted_list[0].length() == word.length() {\n   |                           \
    \        ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0599]: no method named `length` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp8dk80pqh.rs:26:52\n   |\n26 |                 if sorted_list[0].length()\
    \ == word.length() {\n   |                                                   \
    \ ^^^^^^ help: there is an associated function with a similar name: `len`\n\n\
    error[E0599]: no method named `length` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp8dk80pqh.rs:27:52\n   |\n27 |                     if sorted_list[0].len()\
    \ > word.length() {\n   |                                                    ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp8dk80pqh.rs:33:39\n   |\n33 |                     if sorted_list[0].length()\
    \ < word.length() {\n   |                                       ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmp8dk80pqh.rs:33:55\n\
    \   |\n33 |                     if sorted_list[0].length() < word.length() {\n\
    \   |                                                       ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror: aborting due\
    \ to 5 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for word in lst {\n       \
    \ if res.len() == 0 {\n            res.push(word);\n        } else if word.len()\
    \ > res[0].len() {\n            res.sort();\n            res.insert(0, word);\n\
    \        } else {\n            res.insert(0, word);\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaa\", \"a\", \"aa\"]`,\n right: `[\"aa\"]`', /tmp/tmp99ouyyue.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008841
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        let len = word.len();\n        sorted_list_len.push(len);\n\
    \        sorted_list.push(word);\n    }\n    sorted_list.sort_by(|a, b| {\n  \
    \      if a.len() < b.len() {\n            -1\n        } else {\n            1\n\
    \        }\n    });\n    sorted_list.sort_by(|a, b| {\n        if a.len() == b.len()\
    \ {\n            a.cmp(&b)\n        } else {\n            a.len() - b.len()\n\
    \        }\n    });\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiq87ymum.rs:26:13\n   |\n\
    26 |             -1\n   |             ^^ expected enum `std::cmp::Ordering`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiq87ymum.rs:28:13\n\
    \   |\n28 |             1\n   |             ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiq87ymum.rs:35:13\n\
    \   |\n35 |             a.len() - b.len()\n   |             ^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `usize`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for s in lst {\n        if s.len() % 2 != 0 {\n            sorted_list.push(s);\n\
    \        } else {\n            let mut i = 0;\n            for c in s.chars()\
    \ {\n                if i == 0 {\n                    i += 1;\n              \
    \  } else {\n                    i += 1;\n                }\n            }\n \
    \           sorted_list.push(s);\n        }\n    }\n    for s in sorted_list {\n\
    \        res.push(s);\n    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp8fn21qqf.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008841
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for s in lst {\n        if\
    \ s.len() % 2 != 0 {\n            res.push(s);\n        }\n    }\n    res.sort_by_key(|s|\
    \ s.len());\n    res.sort_by_key(|s| s.to_lowercase());\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpauxwi8nw.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            if sorted_list.last().unwrap().len() < word.len()\
    \ {\n                sorted_list.push(word);\n            } else {\n         \
    \       sorted_list.sort_by(|a, b| a.len() < b.len());\n                sorted_list.push(sorted_list.last().unwrap());\n\
    \            }\n        }\n    }\n    for word in sorted_list {\n        res.push(word);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7nb6kncg.rs:26:44\n   |\n\
    26 |                 sorted_list.sort_by(|a, b| a.len() < b.len());\n   |    \
    \                                        ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7nb6kncg.rs:27:34\n\
    \   |\n27 |                 sorted_list.push(sorted_list.last().unwrap());\n \
    \  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                                  |\n\
    \   |                                  expected struct `String`, found `&String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for elem in lst {\n        sorted_list_len.push(elem.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for elem in sorted_list_len\
    \ {\n        for elem2 in lst {\n            if elem.0 == elem2.0 {\n        \
    \        sorted_list.push(elem2);\n            }\n        }\n    }\n    sorted_list.sort_unstable();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpi_kz751g.rs:25:21\n   |\n25 |             if elem.0 == elem2.0\
    \ {\n   |                     ^\n\nerror[E0609]: no field `0` on type `String`\n\
    \  --> /tmp/tmpi_kz751g.rs:25:32\n   |\n25 |             if elem.0 == elem2.0\
    \ {\n   |                                ^ unknown field\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0609, E0610.\n\
    For more information about an error, try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.len()\
    \ == 1 {\n                sorted_list.push(word);\n            } else {\n    \
    \            if sorted_list[0].len() < word.len() {\n                    sorted_list.push(word);\n\
    \                } else {\n                    sorted_list.push(sorted_list[0]);\n\
    \                }\n            }\n        }\n    }\n    sorted_list.sort_by(|a,\
    \ b| a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcicfjh5l.rs:34:32\n   |\n\
    34 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            let mut found = false;\n            for item in\
    \ sorted_list {\n                if item.len() == word.len() {\n             \
    \       if item < word {\n                        sorted_list.push(item);\n  \
    \                      found = true;\n                    }\n                }\n\
    \            }\n            if !found {\n                sorted_list.push(word);\n\
    \            }\n        }\n    }\n    for word in sorted_list {\n        res.push(word);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `sorted_list`\n   --> /tmp/tmpvn94jiq3.rs:20:12\n\
    \    |\n18  |     let mut sorted_list = vec![];\n    |         ---------------\
    \ move occurs because `sorted_list` has type `Vec<String>`, which does not implement\
    \ the `Copy` trait\n19  |     for word in lst {\n20  |         if sorted_list.len()\
    \ == 0 {\n    |            ^^^^^^^^^^^^^^^^^ value borrowed here after move\n\
    ...\n24  |             for item in sorted_list {\n    |                      \
    \   ----------- `sorted_list` moved due to this implicit call to `.into_iter()`,\
    \ in previous iteration of loop\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `sorted_list`\nhelp: consider iterating over\
    \ a slice of the `Vec<String>`'s content to avoid moving into the `for` loop\n\
    \    |\n24  |             for item in &sorted_list {\n    |                  \
    \       +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        if sorted_list_len.contains(&word.len())\
    \ {\n            sorted_list_len.insert(word.len(), 1);\n        } else {\n  \
    \          sorted_list_len.insert(word.len(), 0);\n        }\n    }\n    sorted_list_len.sort_unstable();\n\
    \    for word in sorted_list_len {\n        for index in 0..word.0 {\n       \
    \     sorted_list.push(lst[index]);\n        }\n    }\n    sorted_list.sort_unstable();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp36tbgzue.rs:28:30\n   |\n28 |         for index in 0..word.0 {\n\
    \   |                              ^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0610`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2_tmier.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for s in lst {\n        if\
    \ s.len() % 2 != 0 {\n            res.push(s);\n        }\n    }\n    res.sort_by(|a,\
    \ b| a.len() < b.len());\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpebwjieg0.rs:23:24\n   |\n\
    23 |     res.sort_by(|a, b| a.len() < b.len());\n   |                        ^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut sorted_list = vec![];\n\
    \    for elem in lst {\n        let len = elem.len();\n        if len % 2 == 1\
    \ {\n            sorted_list.push(elem);\n        } else {\n            let mut\
    \ i = 0;\n            for j in 0..len {\n                if j % 2 == 0 {\n   \
    \                 i += 1;\n                }\n            }\n            sorted_list.push(sorted_list[i].to_owned());\n\
    \        }\n    }\n    for elem in sorted_list {\n        res.push(elem);\n  \
    \  }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 1'', /tmp/tmp2ln07slz.rs:30:30

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660008841
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        let mut sorted_list = vec![];\n  \
    \      let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mut sorted_list = vec![];\n\
    \        let mut sorted_list = vec![];\n        let mu\n}\n\nfn main() {\n   \
    \ let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp6i9o0mbk.rs:86:3\n\
    \   |\n16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |      \
    \                                               - unclosed delimiter\n...\n19\
    \ |     for word in lst {\n   |                     - this delimiter might not\
    \ be properly closed...\n...\n75 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n86 | }\n   |   ^\n\nerror: expected `;`, found `}`\n\
    \  --> /tmp/tmp6i9o0mbk.rs:74:15\n   |\n74 |         let mu\n   |            \
    \   ^ help: add `;` here\n75 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6i9o0mbk.rs:16:41\n   |\n16 | fn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n   |    ---------------                      ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in lst {\n        if\
    \ sorted_list_len.contains(&word.len()) {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmprz_jja5q.rs:23:17\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for word in lst {\n    |\
    \                 --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for word in lst {\n    |                 ^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `lst`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n19  |     for word in &lst {\n \
    \   |                 +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut sorted_list = vec![];\n\
    \    for elem in lst {\n        if elem.len() % 2 == 1 {\n            sorted_list.push(elem);\n\
    \        } else {\n            let mut new_list = sorted_list;\n            new_list.sort_by(|a,\
    \ b| a.len() < b.len());\n            new_list.push(elem);\n            sorted_list\
    \ = new_list;\n        }\n    }\n    for elem in sorted_list {\n        res.push(elem);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjgvwajia.rs:24:37\n   |\n\
    24 |             new_list.sort_by(|a, b| a.len() < b.len());\n   |           \
    \                          ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if sorted_list.len() == 0 {\n    \
    \        sorted_list.push(word);\n        } else {\n            if sorted_list.last().unwrap().len()\
    \ < word.len() {\n                sorted_list.push(word);\n            } else\
    \ {\n                sorted_list.sort_by(|a, b| a.len() < b.len());\n        \
    \        sorted_list.push(sorted_list.last().unwrap());\n            }\n     \
    \   }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd3tpy6v1.rs:26:44\n   |\n\
    26 |                 sorted_list.sort_by(|a, b| a.len() < b.len());\n   |    \
    \                                        ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd3tpy6v1.rs:27:34\n\
    \   |\n27 |                 sorted_list.push(sorted_list.last().unwrap());\n \
    \  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                                  |\n\
    \   |                                  expected struct `String`, found `&String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2_tmier.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 == 1 {\n       \
    \     sorted_list.push(word);\n        } else {\n            let mut i = 0;\n\
    \            let mut j = 0;\n            while i < word.len() && j < sorted_list.len()\
    \ {\n                if word[i].len() < sorted_list[j].len() {\n             \
    \       sorted_list.push(word[i]);\n                    i += 1;\n            \
    \    } else {\n                    sorted_list.push(sorted_list[j]);\n       \
    \             j += 1;\n                }\n            }\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_by_key(|x| x.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvcg6h3ph.rs:26:20\n\
    \   |\n26 |                 if word[i].len() < sorted_list[j].len() {\n   |  \
    \                  ^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvcg6h3ph.rs:27:38\n   |\n27 |                     sorted_list.push(word[i]);\n\
    \   |                                      ^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2_tmier.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 101
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        let len = word.len();\n        if len % 2 != 0 {\n            sorted_list.push(word);\n\
    \        }\n    }\n    sorted_list.sort_by_key(|x| x.len());\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp4z9oawmv.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660008841
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_len\
    \ = vec![];\n    for word in lst {\n        sorted_list_len.push(word.len());\n\
    \    }\n    sorted_list_len.sort_unstable();\n    for word in lst {\n        if\
    \ sorted_list_len.iter().position(|&x| x == word.len()).is_some() {\n        \
    \    sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_unstable();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmp_12l_zi6.rs:23:17\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for word in lst {\n    |\
    \                 --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n23  |     for word in lst {\n    |                 ^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `lst`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n19  |     for word in &lst {\n \
    \   |                 +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660008840
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut len = lst.len();\n\
    \    while len > 0 {\n        let mut cur = lst.len();\n        while cur > 0\
    \ {\n            if lst[cur - 1].len() < lst[cur].len() {\n                res.push(&lst[cur\
    \ - 1]);\n                cur -= 1;\n            } else {\n                res.push(&lst[cur]);\n\
    \                cur -= 1;\n            }\n        }\n        len -= 1;\n    }\n\
    \    res.sort();\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj2ci9f1w.rs:33:5\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |             \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n33 |     res\n   |     ^^^ expected struct `String`, found `&String`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&String>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008841
- exit_code: 1
  program: "/// Write a function that accepts a list of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ list with a sorted order,\n/// The list is always a list of strings and never\
    \ an array of numbers,\n/// and it may contain duplicates.\n/// The order of the\
    \ list should be ascending by length of each word, and you\n/// should return\
    \ the list sorted by that rule.\n/// If two words have the same length, sort the\
    \ list alphabetically.\n/// The function should return a list of strings in sorted\
    \ order.\n/// You may assume that all words will have the same length.\n/// For\
    \ example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"a\"),\
    \ String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list\
    \ = vec![];\n    for word in lst {\n        if word.len() % 2 != 0 {\n       \
    \     sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|a, b|\
    \ a.len() < b.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2_tmier.rs:24:32\n   |\n\
    24 |     sorted_list.sort_by(|a, b| a.len() < b.len());\n   |                \
    \                ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660008840
