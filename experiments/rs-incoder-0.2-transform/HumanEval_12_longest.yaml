name: HumanEval_12_longest
language: rs
prompt: "/// Out of list of strings, return the longest one. Return the first one\
  \ in case of multiple\n/// strings of the same length. Return None in case the input\
  \ list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
  a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"))\n\
  /// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
  ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) -> Option<String>\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!(candidate(Vec::<String>::new()),\
  \ None);\n    assert_eq!(candidate(vec![String::from(\"x\"), String::from(\"y\"\
  ), String::from(\"z\")]), Some(String::from(\"x\")));\n    assert_eq!(candidate(vec![String::from(\"\
  x\"), String::from(\"yyy\"), String::from(\"zzzz\"), String::from(\"www\"), String::from(\"\
  kkkk\"), String::from(\"abc\")]), Some(String::from(\"zzzz\")));\n}\n"
completions: ["    let mut longest = String::new();\n    let mut longestlen = String::new();\n\
    \    for s in strings {\n        if longestlen.len() < s.len() {\n           \
    \ longest = s;\n            longestlen = s.len();\n        }\n    }\n    longest.cloned()",
  '    strings.iter().max_by_key(|s| s.len())', "    if strings.is_empty() {\n   \
    \     return None;\n    }\n\n    let mut longest_len = String::new();\n    let\
    \ mut longest_len = longest_len.chars().max().unwrap();\n    let mut longest_str\
    \ = String::new();\n    let mut longest_str = longest_str.chars().max().unwrap();\n\
    \n    for s in strings {\n        if longest_len.len() < s.len() {\n         \
    \   longest_len = s.len();\n            longest_str = s;\n        }\n    }\n\n\
    \    Some(longest_str)", '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', "    if strings.is_empty() {\n        return None;\n    }\n\n    let\
    \ mut max_len = String::new();\n    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n\
    \    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let\
    \ mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len\
    \ = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s|\
    \ s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n\
    \    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let\
    \ mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len\
    \ = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s|\
    \ s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n\
    \    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let\
    \ mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len\
    \ = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s|\
    \ s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n\
    \    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let\
    \ mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len\
    \ = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s|\
    \ s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n\
    \    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let\
    \ mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len\
    \ = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s",
  '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', "    strings.iter().fold(None, |mut acc, string| {\n        if acc.is_none()\
    \ {\n            acc = Some(string);\n        } else if acc.unwrap().len() < string.len()\
    \ {\n            acc = Some(string);\n        }\n        acc\n    })", "    if\
    \ strings.is_empty() {\n        return None;\n    }\n    let mut longest = strings[0];\n\
    \    for s in strings.iter().rev() {\n        if s.len() > longest.len() {\n \
    \           longest = s;\n        }\n    }\n    Some(longest)", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut max_len = String::new();\n   \
    \ let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut\
    \ max_index = -1;\n\n    for index in strings.iter().rev().skip(1) {\n       \
    \ if strings[index].len() > max_len {\n            max_len = strings[index].len();\n\
    \            max_index = index;\n        }\n    }\n\n    Some(strings[max_index])",
  "    strings\n        .iter()\n        .fold(None, |mut acc, s| {\n            if\
    \ acc.is_none() {\n                Some(s.clone())\n            } else {\n   \
    \             let mut len = s.len();\n                let mut max_len = acc.unwrap().len();\n\
    \                if len > max_len {\n                    Some(s.clone())\n   \
    \             } else {\n                    Some(acc.unwrap().clone())\n     \
    \           }\n            }\n        })", "    let mut max_len = std::cmp::max::<usize>(\n\
    \        strings.iter().map(|s| s.len()).sum(),\n        strings.len(),\n    );\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n        }\n    }\n    if max_len == 0 {\n        return None;\n  \
    \  }\n    strings.iter().max_by(|a, b| a.len() < b.len()).map(|s| s[0])", "  \
    \  strings.iter().fold(None, |mut acc, s| {\n        if acc.is_none() {\n    \
    \        acc = Some(s);\n        } else if acc.as_ref().unwrap().len() < s.len()\
    \ {\n            acc = Some(s);\n        }\n        acc\n    })", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut max_len = String::new();\n   \
    \ let mut max_idx = -1;\n    for &s in strings {\n        if s.len() > max_len.len()\
    \ {\n            max_len = s;\n            max_idx = strings.iter().position(|&s|\
    \ s.len() == max_len.len()).unwrap();\n        }\n    }\n\n    Some(strings[max_idx])",
  '    strings.iter().max_by_key(|s| s.len()).cloned()', '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut max_len = String::new();\n   \
    \ let mut max_index = -1;\n    for &s in strings {\n        let len = s.len();\n\
    \        if max_len.len() < len {\n            max_len = s;\n            max_index\
    \ = len;\n        }\n    }\n\n    Some(max_len.to_string())", "    let mut max_len\
    \ = String::new();\n    let mut max_index = -1;\n    for s in strings {\n    \
    \    let len = s.len();\n        if max_len.len() < len {\n            max_len\
    \ = s;\n            max_index = len;\n        }\n    }\n    if max_len.len() ==\
    \ 0 {\n        return None;\n    }\n    Some(max_len.clone())", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut longest = strings[0];\n    let\
    \ mut len = strings.len();\n    while len > 1 {\n        let mut cur = longest;\n\
    \        longest = strings[len - 1];\n        len -= 1;\n        if cur == longest\
    \ {\n            break;\n        }\n    }\n    Some(longest)", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut max_len = String::new();\n   \
    \ let mut max_index = -1;\n    for &s in strings {\n        let len = s.len();\n\
    \        if max_len.len() < len {\n            max_len = s;\n            max_index\
    \ = len;\n        }\n    }\n\n    Some(max_len.to_owned())", '    strings.iter().max_by_key(|s|
    s.len())', "    let mut longest_len = std::cmp::max::<usize>(\n        strings.iter().map(|s|\
    \ s.len()).sum(),\n        strings.len(),\n    );\n    let mut longest_str = String::new();\n\
    \    for s in strings {\n        if s.len() > longest_len {\n            longest_len\
    \ = s.len();\n            longest_str = s;\n        }\n    }\n    Some(longest_str)",
  '    strings.iter().max_by_key(|s| s.len()).cloned()', "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut longest = strings[0];\n    for\
    \ s in strings {\n        if s.len() > longest.len() {\n            longest =\
    \ s;\n        }\n    }\n\n    Some(longest)", "    if strings.is_empty() {\n \
    \       return None;\n    }\n\n    let mut longest_len = std::cmp::max::<usize>(\n\
    \        strings.iter().map(|s| s.len()).sum(),\n        strings.len(),\n    );\n\
    \n    for s in strings {\n        if s.len() > longest_len {\n            longest_len\
    \ = s.len();\n        }\n    }\n\n    strings.iter().max_by(|a, b| a.len() < b.len()).map(|s|\
    \ s).ok()", "    if strings.is_empty() {\n        return None;\n    }\n\n    let\
    \ mut longest = strings[0];\n    for s in strings {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n\n    Some(longest)", '    strings.iter().max_by_key(|s|
    s.len())', "    if strings.is_empty() {\n        return None;\n    }\n\n    let\
    \ mut max_len = String::new();\n    let mut max_index = -1;\n    for (i, s) in\
    \ strings.iter().enumerate() {\n        if s.len() > max_len.len() {\n       \
    \     max_len = s;\n            max_index = i;\n        }\n    }\n\n    Some(strings[max_index])",
  "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n     \
    \   .cloned()\n        .or_else(|| strings.first().cloned())", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut longest_len = String::new();\n \
    \   let mut longest_str = String::new();\n    for s in strings {\n        let\
    \ len = s.len();\n        if len > longest_len.len() {\n            longest_len\
    \ = len;\n            longest_str = s;\n        }\n    }\n    Some(longest_str)",
  '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', "    strings.iter().fold(None,\
    \ |mut acc, s| {\n        if let Some(mut len) = acc.len() {\n            if len\
    \ > s.len() {\n                acc = s;\n            }\n        }\n        Some(acc)\n\
    \    })", "    if strings.is_empty() {\n        return None;\n    }\n    let mut\
    \ max_len = String::new();\n    let mut max_index = -1;\n    for &s in strings\
    \ {\n        if s.len() > max_len.len() {\n            max_len = s;\n        \
    \    max_index = strings.iter().position(|s| s == max_len).unwrap();\n       \
    \ }\n    }\n    Some(max_len)", "    strings\n        .iter()\n        .fold(None,\
    \ |mut acc, s| {\n            match acc.len() {\n                0 => Some(s),\n\
    \                n => {\n                    if s.len() < n {\n              \
    \          Some(s)\n                    } else {\n                        None\n\
    \                    }\n                }\n            }\n        })", '    strings.iter().max_by(|a,
    b| a.len() < b.len()).cloned()', '    strings.iter().map(|s| s.len()).max().map(|s|
    s.to_string()).ok()', "    if strings.is_empty() {\n        return None;\n   \
    \ }\n\n    let mut longest_len = std::cmp::max::<usize>(\n        strings.iter().map(|s|\
    \ s.len()).sum(),\n        strings.len(),\n    );\n\n    for s in strings {\n\
    \        if s.len() > longest_len {\n            longest_len = s.len();\n    \
    \    }\n    }\n\n    strings.iter().max_by_key(|s| s.len() as usize).map(|s| s)",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len =\
    \ String::new();\n    let mut max_index = -1;\n    for index in 0..strings.len()\
    \ {\n        let len = strings[index].len();\n        if max_len.len() < len {\n\
    \            max_len = strings[index];\n            max_index = index;\n     \
    \   }\n    }\n    Some(max_len.clone())", '    strings.iter().max_by_key(|s| s.len())',
  "    let mut max_len = std::cmp::max::<usize>(\n        strings.len(),\n       \
    \ strings.iter().map(|s| s.len()).sum(),\n    );\n    for s in strings {\n   \
    \     if max_len < s.len() {\n            max_len = s.len();\n        }\n    }\n\
    \    if max_len == 0 {\n        return None;\n    }\n    strings.iter().max_by(|a,\
    \ b| a.len() < b.len()).map(|s| s[0])", "    if strings.is_empty() {\n       \
    \ return None;\n    }\n\n    let mut longest_len = std::cmp::max::<usize>(\n \
    \       strings.iter().map(|s| s.len()).sum(),\n        strings.len(),\n    );\n\
    \n    for s in strings {\n        if s.len() > longest_len {\n            longest_len\
    \ = s.len();\n        }\n    }\n\n    strings.iter().find(|s| s.len() == longest_len).cloned()",
  '    strings.iter().max_by_key(|s| s.len())', "    if strings.is_empty() {\n   \
    \     return None;\n    }\n    let mut max_len = String::new();\n    let mut max_index\
    \ = -1;\n    for &s in strings {\n        if s.len() > max_len.len() {\n     \
    \       max_len = s;\n            max_index = strings.iter().position(|s| s ==\
    \ max_len).unwrap();\n        }\n    }\n    Some(max_len.to_owned())", '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().map(|s| s.len()).max()', "    let mut max_len =\
    \ std::cmp::max::<usize>(\n        strings.iter().map(|s| s.len()).sum(),\n  \
    \      strings.len(),\n    );\n    strings.iter().for_each(|s| {\n        if s.len()\
    \ > max_len {\n            max_len = s.len();\n        }\n    });\n    strings.iter().find(|s|\
    \ s.len() == max_len).cloned()", '    strings.iter().max_by_key(|s| s.len())',
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len =\
    \ String::new();\n    let mut max_index = -1;\n    for &s in strings {\n     \
    \   let len = s.len();\n        if max_len.len() < len {\n            max_len\
    \ = s;\n            max_index = len;\n        }\n    }\n    Some(max_len.clone())",
  "    strings.iter().fold(None, |mut acc, s| {\n        if acc.is_none() {\n    \
    \        Some(s.len())\n        } else {\n            match s.len() {\n      \
    \          1 => Some(s),\n                2 => Some(s),\n                3 =>\
    \ Some(s),\n                _ => None,\n            }\n        }\n    })", '    strings.iter().max_by(|a,
    b| a.len() < b.len()).cloned()', "    if strings.is_empty() {\n        return\
    \ None;\n    }\n    let mut max_len = String::new();\n    let mut max_index =\
    \ -1;\n    for &s in strings {\n        let len = s.len();\n        if max_len.len()\
    \ < len {\n            max_len = s;\n            max_index = len;\n        }\n\
    \    }\n    if max_len.len() == 0 {\n        return None;\n    }\n    Some(max_len.to_owned())",
  '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n\
    \        .cloned()\n        .or_else(|| strings.first().cloned())", "    let mut\
    \ longest = String::new();\n    for s in strings {\n        if longest != s.len()\
    \ {\n            longest = s;\n        }\n    }\n    longest_match(&longest, strings)",
  "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n     \
    \   .cloned()\n        .or_else(|| strings.first().cloned())", "    strings.iter().fold(None,\
    \ |mut acc, s| {\n        if acc.is_none() {\n            Some(s.len())\n    \
    \    } else {\n            if s.len() > acc.unwrap().len() {\n               \
    \ Some(s)\n            } else {\n                acc\n            }\n        }\n\
    \    })", "    if strings.is_empty() {\n        return None;\n    }\n\n    let\
    \ mut longest = strings[0];\n    for s in strings.iter().rev() {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n\n    Some(longest)",
  '    strings.iter().max_by_key(|s| s.len())', "    let mut longest_len = std::cmp::max::<usize>(\n\
    \        strings.iter().map(|s| s.len()).sum(),\n        strings.len(),\n    );\n\
    \    let mut longest_str = String::new();\n    for s in strings {\n        if\
    \ s.len() > longest_len {\n            longest_len = s.len();\n            longest_str\
    \ = s;\n        }\n    }\n    longest_str.ok()", '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by(|a,
    b| a.len() < b.len()).cloned()', "    strings\n        .iter()\n        .fold(None,\
    \ |mut acc, s| {\n            if acc.is_none() {\n                Some(s)\n  \
    \          } else {\n                if acc.len() < s.len() {\n              \
    \      Some(acc)\n                } else {\n                    Some(s)\n    \
    \            }\n            }\n        })", "    let mut longest_len = std::cmp::max::<usize>(\n\
    \        strings.len(),\n        strings.iter().map(|s| s.len()).sum::<usize>(),\n\
    \    );\n    let mut longest_string = None;\n    for s in strings {\n        if\
    \ s.len() > longest_len {\n            longest_len = s.len();\n            longest_string\
    \ = Some(s);\n        }\n    }\n    longest_string", '    strings.iter().max_by_key(|s|
    s.len())', "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n\
    \        .cloned()\n        .or_else(|| strings.first().cloned())", '    strings.iter().max_by_key(|s|
    s.len())', "    if strings.is_empty() {\n        return None;\n    }\n    let\
    \ mut longest_len = std::cmp::max::<usize>(\n        strings.iter().map(|s| s.len()).sum(),\n\
    \        strings.len(),\n    );\n    let mut longest_str = String::new();\n  \
    \  for s in strings {\n        if s.len() > longest_len {\n            longest_len\
    \ = s.len();\n            longest_str = s;\n        }\n    }\n    Some(longest_str)",
  '    strings.iter().max_by_key(|s| s.len()).cloned()', "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut longest = strings[0];\n    for s\
    \ in strings {\n        if s.len() > longest.len() {\n            longest = s;\n\
    \        }\n    }\n    Some(longest)", "    strings.iter().fold(None, |mut max,\
    \ string| {\n        if max.is_none() {\n            max = Some(string);\n   \
    \     } else if string.length() > max.unwrap().length() {\n            max = Some(string);\n\
    \        }\n        max\n    })", "    strings.iter().fold(None, |mut acc, s|\
    \ {\n        if acc.is_none() {\n            Some(s.len())\n        } else {\n\
    \            if s.len() > acc.unwrap().len() {\n                Some(s)\n    \
    \        } else {\n                acc\n            }\n        }\n    })", " \
    \   if strings.is_empty() {\n        return None;\n    }\n    let mut max_len\
    \ = String::new();\n    let mut max_index = -1;\n    for index in 0..strings.len()\
    \ {\n        let len = strings[index].len();\n        if max_len.len() < len {\n\
    \            max_len = strings[index];\n            max_index = index;\n     \
    \   }\n    }\n    Some(max_len.to_string())", "    strings.iter().fold(None, |mut\
    \ max, s| {\n        if max != None {\n            if s.len() > max.len() {\n\
    \                max = Some(s);\n            }\n        } else {\n           \
    \ max = Some(s);\n        }\n        max\n    })", "    strings\n        .iter()\n\
    \        .map(|s| s.len())\n        .max()\n        .cloned()\n        .or_else(||\
    \ strings.first().cloned())", "    if strings.is_empty() {\n        return None;\n\
    \    }\n    let mut longest_len = std::cmp::max::<usize>(\n        strings.iter().map(|s|\
    \ s.len()).sum(),\n        strings.len(),\n    );\n    let mut longest_str = None;\n\
    \    for s in strings {\n        if s.len() > longest_len {\n            longest_len\
    \ = s.len();\n            longest_str = Some(s);\n        }\n    }\n    longest_str",
  '    strings.iter().max_by_key(|s| s.len())', "    if strings.is_empty() {\n   \
    \     return None;\n    }\n\n    let mut longest_len = std::cmp::max::<usize>(\n\
    \        strings.iter().map(|s| s.len()).sum(),\n        strings.len(),\n    );\n\
    \n    for s in strings {\n        if s.len() > longest_len {\n            longest_len\
    \ = s.len();\n        }\n    }\n\n    strings.iter().max_by_key(|s| s.len() as\
    \ usize).map(|s| s)", "    strings\n        .iter()\n        .map(|s| s.len())\n\
    \        .max()\n        .cloned()\n        .or_else(|| strings.first().cloned())",
  "    strings.iter().fold(None, |max, &str| {\n        match str.length() {\n   \
    \         0 => Some(max),\n            max if max > str.length() => Some(str),\n\
    \            _ => max,\n        }\n    })", '    strings.iter().max_by_key(|s|
    s.len())', "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n\
    \        .cloned()\n        .or_else(|| strings.first().cloned())", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut max_len = String::new();\n    let\
    \ mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    for s in\
    \ strings {\n        if s.len() > max_len {\n            max_len = s.len();\n\
    \        }\n    }\n    Some(max_len)", '    strings.iter().max_by_key(|s| s.len()).map(|s|
    s)', "    if strings.is_empty() {\n        return None;\n    }\n\n    let mut\
    \ longest_len = std::cmp::Ordering::default();\n    let mut longest_str = String::from(\"\
    \");\n    for s in strings {\n        let len = s.len();\n        if len > longest_len\
    \ {\n            longest_len = len;\n            longest_str = s;\n        }\n\
    \    }\n\n    Some(longest_str)", "    strings.iter().fold(None, |mut acc, s|\
    \ {\n        if acc.is_none() {\n            Some(s.len())\n        } else {\n\
    \            if s.len() > acc.unwrap().len() {\n                Some(s)\n    \
    \        } else {\n                acc\n            }\n        }\n    })", '    strings.iter().max_by_key(|s|
    s.len())', "    strings.iter().fold(None, |mut acc, s| {\n        if acc.is_none()\
    \ {\n            Some(s)\n        } else {\n            if acc.len() < s.len()\
    \ {\n                Some(acc)\n            } else {\n                Some(s)\n\
    \            }\n        }\n    })", '    strings.iter().max_by_key(|s| s.len()).cloned()',
  "    strings.iter().fold(None, |mut acc, s| {\n        if acc.is_none() {\n    \
    \        Some(s)\n        } else {\n            match s.len() {\n            \
    \    1 => Some(s),\n                2 => Some(s),\n                _ => Some(acc.unwrap().clone()),\n\
    \            }\n        }\n    })", "    strings.iter().fold(None, |mut acc, s|\
    \ {\n        let mut len = s.len();\n        if len > acc.len() {\n          \
    \  acc = Some(s);\n        }\n        Some(acc)\n    })", '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', "    let mut longest_len = std::collections::HashMap::new();\n    for\
    \ s in strings {\n        let len = s.len();\n        if !longest_len.contains_key(&len)\
    \ {\n            longest_len.insert(len, s);\n        }\n    }\n    longest_len.iter().max_by_key(|len|\
    \ len).map(|len| longest_len.get(&len).unwrap())", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut longest_len = String::new();\n\
    \    let mut longest_string = String::new();\n\n    for s in strings {\n     \
    \   if s.len() > longest_len.len() {\n            longest_len = s.len();\n   \
    \         longest_string = s;\n        }\n    }\n\n    Some(longest_string)",
  '    strings.iter().map(|s| s.len()).max()', "    if strings.is_empty() {\n    \
    \    return None;\n    }\n\n    let mut longest_len = String::new();\n    let\
    \ mut longest_str = String::new();\n\n    for s in strings {\n        if s.len()\
    \ > longest_len.len() {\n            longest_len = s.len();\n            longest_str\
    \ = s;\n        }\n    }\n\n    Some(longest_str)", '    strings.iter().map(|s|
    s.len()).max()', '    strings.iter().max_by_key(|s| s.len())', "    strings.iter().fold(None,\
    \ |mut acc, s| {\n        let len = s.len();\n        if len > acc.len() {\n \
    \           Some(s.clone())\n        } else {\n            acc\n        }\n  \
    \  })", '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n\
    \        .cloned()\n        .or_else(|| strings.first().cloned())", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut max_len = String::new();\n   \
    \ let mut max_len = strings[0].len();\n    for s in strings {\n        if s.len()\
    \ > max_len {\n            max_len = s.len();\n        }\n    }\n\n    for s in\
    \ strings {\n        if s.len() == max_len {\n            return Some(s);\n  \
    \      }\n    }\n\n    None", "    let mut max_len = std::cmp::max::<usize>(strings.len(),\
    \ 1);\n    let mut max_string = None;\n    for s in strings {\n        if s.len()\
    \ == max_len {\n            max_string = Some(s);\n        }\n        max_len\
    \ = std::cmp::max::<usize>(s.len(), max_len);\n    }\n    max_string", '    strings.iter().max_by_key(|s|
    s.len())', "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n\
    \        .cloned()\n        .or_else(|| strings.first().cloned())", '    strings.iter().max_by_key(|s|
    s.len()).cloned()', "    if strings.is_empty() {\n        return None;\n    }\n\
    \n    let mut longest = strings[0];\n    for s in strings.iter().rev() {\n   \
    \     if s.len() > longest.len() {\n            longest = s;\n        }\n    }\n\
    \    Some(longest)", '    strings.iter().max_by_key(|s| s.len()).cloned()', " \
    \   strings.iter().fold(None, |max, s| if max.is_none() || s.length() > s.length()\
    \ {\n        Some(s)\n    } else {\n        max\n    })", '    strings.iter().max_by_key(|s|
    s.len()).cloned()', "    strings.iter().fold(None, |mut acc, s| {\n        if\
    \ acc.is_none() {\n            Some(s.len())\n        } else {\n            if\
    \ s.len() > acc.unwrap().unwrap() {\n                Some(s)\n            } else\
    \ {\n                None\n            }\n        }\n    })", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut max_len = String::new();\n    let\
    \ mut max_index = -1;\n    for &s in strings {\n        let len = s.len();\n \
    \       if max_len.len() < len {\n            max_len = s;\n            max_index\
    \ = len;\n        }\n    }\n    Some(max_len.to_string())", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut longest_len = std::cmp::max::<usize>(\n\
    \        strings.iter().map(|s| s.len()).sum(),\n        strings.len(),\n    );\n\
    \n    for s in strings {\n        if s.len() > longest_len {\n            longest_len\
    \ = s.len();\n        }\n    }\n\n    strings.iter().find(|s| s.len() == longest_len).cloned()",
  "    strings.iter().fold(None, |max, s| {\n        if let Some(len) = s.len() {\n\
    \            if len > max {\n                Some(s)\n            } else {\n \
    \               None\n            }\n        } else {\n            None\n    \
    \    }\n    })", "    strings.iter().fold(None, |mut acc, s| {\n        if acc.is_none()\
    \ {\n            Some(s)\n        } else {\n            if acc.len() < s.len()\
    \ {\n                Some(acc)\n            } else {\n                Some(s)\n\
    \            }\n        }\n    })", "    strings.iter().fold(None, |mut acc, s|\
    \ {\n        if acc.is_none() {\n            Some(s)\n        } else {\n     \
    \       if acc.len() < s.len() {\n                Some(acc)\n            } else\
    \ {\n                Some(s)\n            }\n        }\n    })", '    strings.iter().max_by_key(|s|
    s.len())', "    let mut max_len = std::cmp::max::<usize>(\n        strings.iter().map(|s|\
    \ s.len()).sum(),\n        strings.len(),\n    );\n    for s in strings {\n  \
    \      if max_len < s.len() {\n            max_len = s.len();\n        }\n   \
    \ }\n    if max_len == 0 {\n        return None;\n    }\n    Some(strings[strings.iter().position(|s|\
    \ max_len == s.len()).unwrap()])", "    if strings.is_empty() {\n        return\
    \ None;\n    }\n    let mut longest_len = String::new();\n    let mut longest_str\
    \ = String::new();\n    for s in strings {\n        if s.len() > longest_len.len()\
    \ {\n            longest_len = s.len();\n            longest_str = s;\n      \
    \  }\n    }\n    Some(longest_str)", "    let mut max_len = std::cmp::max::<usize>(\n\
    \        strings.iter().map(|s| s.len()).sum(),\n        strings.len(),\n    );\n\
    \    for s in strings {\n        if max_len < s.len() {\n            max_len =\
    \ s.len();\n        }\n    }\n    if max_len == 0 {\n        return None;\n  \
    \  }\n    strings.iter().max_by(|a, b| a.len() < b.len()).map(|s| s[0])", "  \
    \  let mut max_len = std::cmp::max::<usize>(\n        strings.iter().map(|s| s.len()).sum(),\n\
    \        strings.len(),\n    );\n    strings.iter().for_each(|s| {\n        if\
    \ s.len() > max_len {\n            max_len = s.len();\n        }\n    });\n  \
    \  if max_len == 0 {\n        return None;\n    }\n    strings.iter().find(|s|\
    \ s.len() == max_len).cloned()", "    let mut longest = strings[0];\n    for s\
    \ in strings.iter().rev() {\n        if s.len() > longest.len() {\n          \
    \  longest = s;\n        }\n    }\n    longest", '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', "    strings.iter().fold(None,\
    \ |mut acc, s| {\n        let len = s.len();\n        if len > acc.len() {\n \
    \           Some(s.clone())\n        } else {\n            acc\n        }\n  \
    \  })", "    let mut longest_len = std::cmp::max::<usize>(\n        strings.len(),\n\
    \        strings.iter().map(|s| s.len()).sum::<usize>(),\n    );\n    let mut\
    \ longest_string = None;\n    for s in strings {\n        if s.len() > longest_len\
    \ {\n            longest_len = s.len();\n            longest_string = Some(s);\n\
    \        }\n    }\n    longest_string", "    strings.iter().fold(None, |mut acc,\
    \ s| {\n        if acc.is_none() {\n            Some(s)\n        } else {\n  \
    \          if s.len() > acc.unwrap().len() {\n                Some(s)\n      \
    \      } else {\n                acc\n            }\n        }\n    })", '    strings.iter().max_by_key(|s|
    s.len())', "    strings\n        .iter()\n        .map(|s| s.chars().count())\n\
    \        .max()\n        .cloned()\n        .map(|c| String::from_utf8(c.to_string()).unwrap())",
  "    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0];\n    for s in strings {\n        if s.len() > longest.len() {\n\
    \            longest = s;\n        }\n    }\n\n    Some(longest)", "    let mut\
    \ longest_len = std::cmp::max::<usize>(\n        strings.len(),\n        strings.iter().map(|s|\
    \ s.len()).sum(),\n    );\n    let mut longest_str = None;\n    for s in strings\
    \ {\n        if s.len() > longest_len {\n            longest_len = s.len();\n\
    \            longest_str = Some(s);\n        }\n    }\n    longest_str", "   \
    \ strings.iter().fold(None, |max, s| {\n        if let Some(len) = s.len() {\n\
    \            if len > max {\n                Some(s)\n            } else {\n \
    \               None\n            }\n        } else {\n            None\n    \
    \    }\n    })", "    if strings.is_empty() {\n        return None;\n    }\n \
    \   let mut longest_len = String::new();\n    let mut longest_str = String::new();\n\
    \    for s in strings {\n        if s.len() > longest_len.len() {\n          \
    \  longest_len = s.len();\n            longest_str = s;\n        }\n    }\n  \
    \  Some(longest_str)", '    strings.iter().max_by_key(|s| s.len())', "    let\
    \ mut longest_len = String::new();\n    let mut longest_str = String::new();\n\
    \    for s in strings {\n        if s.len() > longest_len.len() {\n          \
    \  longest_len = s.len();\n            longest_str = s;\n        }\n    }\n  \
    \  Some(longest_str)", "    strings.iter().fold(None, |mut acc, s| {\n       \
    \ if acc.is_none() {\n            Some(s.len())\n        } else {\n          \
    \  match s.len() {\n                1 => Some(s),\n                2 => Some(s),\n\
    \                _ => Some(s),\n            }\n        }\n    })", "    strings\n\
    \        .iter()\n        .fold(None, |mut acc, s| {\n            match acc.len().cmp(&s.len())\
    \ {\n                Ordering::Less => Some(s),\n                Ordering::Greater\
    \ => None,\n                Ordering::Equal => Some(s),\n            }\n     \
    \   })", "    strings.iter().fold(None, |mut acc, string| {\n        let len =\
    \ string.len();\n        if len > acc.len() {\n            Some(string)\n    \
    \    } else {\n            acc\n        }\n    })", "    let mut max_len = std::cmp::max::<usize>(\n\
    \        strings.iter().map(|s| s.len()).sum(),\n        strings.len(),\n    );\n\
    \    for s in strings {\n        if max_len < s.len() {\n            max_len =\
    \ s.len();\n        }\n    }\n    if max_len == 0 {\n        return None;\n  \
    \  }\n    Some(strings[strings.iter().position(|s| max_len == s.len()).unwrap()])",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len =\
    \ String::new();\n    let mut max_index = -1;\n    for &s in strings {\n     \
    \   let len = s.len();\n        if max_len.len() < len {\n            max_len\
    \ = s;\n            max_index = len;\n        }\n    }\n    Some(max_len.to_string())",
  "    strings.iter().fold(None, |mut acc, s| {\n        if acc.is_none() {\n    \
    \        acc = Some(s);\n        } else if acc.as_ref().unwrap().len() < s.len()\
    \ {\n            acc = Some(s);\n        }\n        acc\n    })", "    strings\n\
    \        .iter()\n        .fold(None, |mut acc, s| {\n            let len = s.len();\n\
    \            if len > acc.len() {\n                Some(s.clone())\n         \
    \   } else {\n                acc\n            }\n        })", '    strings.iter().max_by_key(|s|
    s.len())', "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n\
    \        .cloned()\n        .or_else(|| strings.first().cloned())", '    strings.iter().map(|s|
    s.len()).max()', '    strings.iter().max_by_key(|s| s.len()).cloned()', '    strings.iter().max_by_key(|s|
    s.len())', "    let mut max_len = String::new();\n    let mut max_index = -1;\n\
    \    for s in strings {\n        let len = s.len();\n        if max_len.len()\
    \ < len {\n            max_len = s;\n            max_index = len;\n        }\n\
    \    }\n    if max_len.len() == 0 {\n        return None;\n    }\n    Some(strings[max_index])",
  "    strings\n        .iter()\n        .map(|s| s.len())\n        .max()\n     \
    \   .cloned()\n        .or_else(|| strings.first().cloned())", "    strings\n\
    \        .iter()\n        .map(|s| s.len())\n        .max()\n        .cloned()\n\
    \        .or_else(|| strings.first().cloned())", '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().map(|s|
    s.len()).max()', '    strings.iter().max_by_key(|s| s.len()).cloned()', '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len()).cloned()', "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut max_len = String::new();\n   \
    \ let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut\
    \ max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len\
    \ = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s|\
    \ s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n\
    \    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let\
    \ mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len\
    \ = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s|\
    \ s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n\
    \    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let\
    \ mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len\
    \ = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s|\
    \ s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n\
    \    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let\
    \ mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len\
    \ = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s|\
    \ s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n\
    \    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let\
    \ mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len\
    \ = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s|\
    \ s.len()).max().unwrap();\n    let mut max_len = strings.iter().map(|s", '    strings.iter().max_by_key(|s|
    s.len()).cloned()', "    if strings.is_empty() {\n        return None;\n    }\n\
    \n    let mut max_len = String::new();\n    let mut max_index = -1;\n    for &s\
    \ in strings {\n        let len = s.len();\n        if max_len.len() < len {\n\
    \            max_len = s;\n            max_index = len;\n        }\n    }\n  \
    \  Some(max_len.to_string())", '    strings.iter().max_by_key(|s| s.len())', " \
    \   if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_len\
    \ = std::cmp::max::<usize>(\n        strings.iter().map(|s| s.len()).sum(),\n\
    \        strings.len(),\n    );\n\n    let mut longest_string = None;\n    for\
    \ s in strings {\n        if s.len() > longest_len {\n            longest_len\
    \ = s.len();\n            longest_string = Some(s);\n        }\n    }\n\n    longest_string",
  "    strings.iter().fold(None, |mut acc, s| {\n        if acc.is_none() {\n    \
    \        Some(s.len())\n        } else {\n            match s.len() {\n      \
    \          1 => Some(s),\n                2 => Some(s),\n                3 | 4\
    \ | 5 => Some(s),\n                _ => None,\n            }\n        }\n    })",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut longest =\
    \ strings[0];\n    for s in strings.iter().rev() {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest)", "    strings.iter().fold(None,\
    \ |max, &str| {\n        if max.is_none() || str.length() > max.unwrap().length()\
    \ {\n            Some(str)\n        } else {\n            None\n        }\n  \
    \  })", "    let mut max_len = std::cmp::max::<usize>(\n        strings.iter().map(|s|\
    \ s.len()).sum(),\n        strings.len(),\n    );\n    for s in strings {\n  \
    \      if s.len() > max_len {\n            max_len = s.len();\n        }\n   \
    \ }\n    if max_len == 0 {\n        return None;\n    }\n    strings.iter().max_by(|a,\
    \ b| a.len() < b.len()).map(|s| s)", "    let mut max_len = String::new();\n \
    \   let mut max_index = -1;\n    for &s in strings {\n        let len = s.len();\n\
    \        if max_len.len() < len {\n            max_len = s;\n            max_index\
    \ = len;\n        }\n    }\n    Some(max_len.to_string())", '    strings.iter().max_by_key(|s|
    s.len())', "    if strings.is_empty() {\n        return None;\n    }\n    let\
    \ mut longest = strings[0];\n    for s in strings.iter().rev() {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n    Some(longest)",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len =\
    \ String::new();\n    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n        }\n    }\n    Some(max_len)", '    strings.iter().max_by_key(|s|
    s.len()).cloned()', '    strings.iter().max_by_key(|s| s.len())', "    strings.iter().fold(None,\
    \ |mut acc, s| {\n        if acc.is_none() {\n            Some(s)\n        } else\
    \ {\n            match s.len() {\n                1 => Some(s),\n            \
    \    2 => Some(s),\n                _ => acc,\n            }\n        }\n    })",
  "    strings.iter().fold(None, |max, s| {\n        if let Some(len) = s.len() {\n\
    \            if len > max {\n                Some(s)\n            } else {\n \
    \               None\n            }\n        } else {\n            None\n    \
    \    }\n    })", '    strings.iter().max_by_key(|s| s.len())', "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut max_len = String::new();\n   \
    \ let mut max_len = strings[0].len();\n    for s in strings {\n        if s.len()\
    \ > max_len {\n            max_len = s.len();\n        }\n    }\n\n    for s in\
    \ strings {\n        if s.len() == max_len {\n            return Some(s);\n  \
    \      }\n    }\n\n    None", '    strings.iter().max_by_key(|s| s.len())', " \
    \   if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0];\n    for s in strings.iter().rev() {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest)", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n    let mut longest = strings[0];\n    for s\
    \ in strings {\n        if s.len() > longest.len() {\n            longest = s;\n\
    \        }\n    }\n    Some(longest)", "    strings.iter().fold(None, |mut acc,\
    \ s| {\n        let len = s.len();\n        if len > acc.len() {\n           \
    \ Some(s.clone())\n        } else {\n            Some(acc.clone())\n        }\n\
    \    })", "    strings\n        .iter()\n        .fold(None, |mut acc, str| {\n\
    \            let len = str.len();\n            if len > acc.as_ref().unwrap().len()\
    \ {\n                Some(str)\n            } else {\n                acc\n  \
    \          }\n        })", "    strings\n        .iter()\n        .map(|s| s.len())\n\
    \        .max()\n        .cloned()\n        .or_else(|| strings.first().cloned())",
  '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', "    strings.iter().fold(None,\
    \ |mut max, &str| {\n        if max != None {\n            if str.length() > max.len()\
    \ {\n                max = Some(str);\n            }\n        } else {\n     \
    \       max = Some(str);\n        }\n        max\n    })", '    strings.iter().max_by_key(|s|
    s.len())', "    let mut max_len = std::cmp::max::<usize>(\n        strings.iter().map(|s|\
    \ s.len()).sum(),\n        strings.len(),\n    );\n    let mut max_string = None;\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n            max_string = Some(s);\n        }\n    }\n    max_string",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len =\
    \ String::new();\n    let mut max_index = -1;\n    for &s in strings {\n     \
    \   let len = s.len();\n        if max_len.len() < len {\n            max_len\
    \ = s;\n            max_index = len;\n        }\n    }\n    Some(max_len.clone())"]
stop_tokens:
- "\n}"
