name: HumanEval_12_longest
language: rs
prompt: "/// Out of list of strings, return the longest one. Return the first one\
  \ in case of multiple\n/// strings of the same length. Return None in case the input\
  \ list is empty.\n/// >>> longest(vec![])\n/// None\n/// >>> longest(vec![String::from(\"\
  a\"), String::from(\"b\"), String::from(\"c\")])\n/// Some(String::from(\"a\"))\n\
  /// >>> longest(vec![String::from(\"a\"), String::from(\"bb\"), String::from(\"\
  ccc\")])\n/// Some(String::from(\"ccc\"))\nfn longest(strings: Vec<String>) -> Option<String>\
  \ {\n"
tests: "}\n\nfn main() {\n    let candidate = longest;\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
completions: ['    strings.iter().max_by_key(|s| s.len())', "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut longest = strings[0];\n    for\
    \ s in strings.iter().rev() {\n        if s.len() > longest.len() {\n        \
    \    longest = s;\n        }\n    }\n\n    Some(longest)", '    strings.iter().max_by_key(|s|
    s.len())', "    if strings.is_empty() {\n        return None;\n    }\n\n    let\
    \ mut max_len = String::new();\n    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n\
    \    let mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let\
    \ mut max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_len\
    \ = strings.iter().map(|s| s.len()).max().unwrap();\n\n    for s in strings {\n\
    \        if s.len() > max_len {\n            max_len = s.len();\n        }\n \
    \   }\n\n    Some(String::from(max_len))", '    strings.iter().max_by_key(|s|
    s.len())', "    strings.iter().fold(None, |mut max, string| {\n        if max.is_none()\
    \ {\n            max = Some(string);\n        } else if string.length() > max.unwrap().length()\
    \ {\n            max = Some(string);\n        }\n        max\n    })", "    strings\n\
    \        .iter()\n        .map(|s| s.len())\n        .max()\n        .cloned()\n\
    \        .or_else(|| strings.first().cloned())", "    strings.iter().fold(None,\
    \ |mut acc, s| {\n        if acc.is_none() {\n            Some(s.len())\n    \
    \    } else {\n            match s.len() {\n                1 => Some(s),\n  \
    \              2 => Some(s),\n                3 => Some(s),\n                4\
    \ => Some(s),\n                5 => Some(s),\n                6 => Some(s),\n\
    \                7 => Some(s),\n                8 => Some(s),\n              \
    \  9 => Some(s),\n                10 => Some(s),\n                11 => Some(s),\n\
    \                12 => Some(s),\n                13 => Some(s),\n            \
    \    14 => Some(s),\n                15 => Some(s),\n                16 => Some(s),\n\
    \                17 => Some(s),\n                18 => Some(s),\n            \
    \    19 => Some(s),\n                20 => Some(s),\n                21 => Some(s),\n\
    \                22 => Some(s),\n                23 => Some(s),\n            \
    \    24 => Some(s),\n                25 => Some(s),\n                26 => Some(s),\n\
    \                27 => Some(s),\n                28 => Some(s),\n            \
    \    29 => Some(s),\n                30 => Some(s),\n                31 => Some(s),\n\
    \                32 => Some(s),\n                33 => Some(s),\n            \
    \    34 => Some(s),\n                35 => Some(s),\n                36 => Some(s),\n\
    \                37 => Some(s),\n                38 => Some(s),\n            \
    \    39 => Some(s),\n                40 => Some(s),\n                41 => Some(s),\n\
    \                42 => Some(s),\n                43 => Some(s),\n            \
    \    44 => Some(s),\n                45 => Some(s),\n                46 => Some(s),\n\
    \                47 => Some(s),\n                48 => Some(s),\n            \
    \    49 => Some(s),\n                50 => Some(s),\n                51 => Some(s),\n\
    \                52 => Some(s),\n                53 => Some(s),\n            \
    \    54 => Some(s),\n                55 => Some(s),\n                56 => Some(s),\n\
    \                57 => Some(s),\n                58 => Some(s),\n            \
    \    59 => Some(s),\n                60 => Some(s),\n                61 => Some(s),\n\
    \                62 => Some(s),\n                63 => Some(s),\n            \
    \    64 => Some(s),\n                65 => Some(", "    let mut max_len = String::new();\n\
    \    for s in strings {\n        let len = s.len();\n        if max_len.len()\
    \ < len {\n            max_len = s;\n        }\n    }\n    Some(max_len)", '    strings.iter().max_by_key(|s|
    s.len()).cloned()', '    strings.iter().max_by_key(|s| s.len()).cloned()', " \
    \   strings.iter().fold(None, |mut acc, s| {\n        if let Some(mut len) = acc.len()\
    \ {\n            if len > s.len() {\n                acc = Some(s);\n        \
    \    }\n        }\n        acc\n    })", "    if strings.is_empty() {\n      \
    \  return None;\n    }\n\n    let mut max_len = String::new();\n    let mut max_index\
    \ = -1;\n\n    for &s in strings {\n        let len = s.len();\n        if max_len.len()\
    \ < len {\n            max_len = s;\n            max_index = len;\n        }\n\
    \    }\n\n    if max_len.len() == 0 {\n        return None;\n    }\n\n    Some(max_len.to_owned())",
  "    if strings.is_empty() {\n        return None;\n    }\n    let mut max_len =\
    \ String::new();\n    let mut max_index = -1;\n    for &s in strings {\n     \
    \   let len = s.len();\n        if max_len.len() < len {\n            max_len\
    \ = s;\n            max_index = len;\n        }\n    }\n    Some(max_len.to_string())",
  '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', "    strings.iter().fold(None,\
    \ |mut acc, s| {\n        let len = s.len();\n        if len > acc.len() {\n \
    \           Some(s.clone())\n        } else {\n            acc\n        }\n  \
    \  })", "    strings.iter().fold(None, |mut acc, s| {\n        let len = s.len();\n\
    \        if len > acc.len() {\n            Some(s)\n        } else {\n       \
    \     None\n        }\n    })", "    if strings.is_empty() {\n        return None;\n\
    \    }\n    let mut longest_len = std::cmp::max::<usize>(\n        strings.iter().map(|s|\
    \ s.len()).sum(),\n        strings.len(),\n    );\n    let mut longest_string\
    \ = None;\n    for s in strings {\n        if s.len() == longest_len {\n     \
    \       longest_string = Some(s);\n        }\n        if s.len() > longest_len\
    \ {\n            longest_len = s.len();\n        }\n    }\n    longest_string",
  "    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest\
    \ = strings[0];\n    for s in strings.iter().rev() {\n        if s.len() > longest.len()\
    \ {\n            longest = s;\n        }\n    }\n    Some(longest)", "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut longest = strings[0];\n    let\
    \ mut longest_len = strings[0].len();\n\n    for s in strings.iter().rev() {\n\
    \        if s.len() > longest_len {\n            longest = s;\n            longest_len\
    \ = s.len();\n        }\n    }\n\n    Some(longest)", "    strings.iter().fold(None,\
    \ |mut acc, s| {\n        if acc.is_none() {\n            Some(s.len())\n    \
    \    } else {\n            if acc.unwrap().len() < s.len() {\n               \
    \ Some(acc.unwrap())\n            } else {\n                Some(s)\n        \
    \    }\n        }\n    })", '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', "    if strings.is_empty() {\n        return None;\n    }\n\n    let\
    \ mut longest = strings[0];\n    for s in strings.iter().rev() {\n        if s.len()\
    \ > longest.len() {\n            longest = s;\n        }\n    }\n\n    Some(longest)",
  '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', "    if strings.is_empty() {\n        return None;\n    }\n\n    let\
    \ mut longest_len = std::cmp::max::<usize>(\n        strings.iter().map(|s| s.len()).sum(),\n\
    \        strings.len(),\n    );\n\n    let mut longest_str = String::new();\n\
    \    for s in strings {\n        if s.len() > longest_len {\n            longest_len\
    \ = s.len();\n            longest_str = s;\n        }\n    }\n\n    Some(longest_str)",
  "    if strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_len\
    \ = std::cmp::max::<usize>(\n        strings.iter().map(|s| s.len()).sum(),\n\
    \        strings.len(),\n    );\n\n    for s in strings {\n        if s.len()\
    \ > longest_len {\n            longest_len = s.len();\n        }\n    }\n\n  \
    \  strings.iter().max_by_key(|s| s.len() as usize).map(|s| s.to_string()).ok()",
  '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len())', '    strings.iter().max_by_key(|s| s.len())', '    strings.iter().max_by_key(|s|
    s.len()).cloned()', '    strings.iter().map(|s| s.len()).max()', '    strings.iter().max_by(|a,
    b| a.len() < b.len())', '    strings.iter().max_by_key(|s| s.len())', "    if\
    \ strings.is_empty() {\n        return None;\n    }\n\n    let mut longest_len\
    \ = String::new();\n    let mut longest_str = String::new();\n\n    for s in strings\
    \ {\n        if s.len() > longest_len.len() {\n            longest_len = s.len();\n\
    \            longest_str = s;\n        }\n    }\n\n    Some(longest_str)", " \
    \   if strings.is_empty() {\n        return None;\n    }\n    let mut max_len\
    \ = String::new();\n    let mut max_index = -1;\n    for &s in strings {\n   \
    \     let len = s.len();\n        if max_len.len() < len {\n            max_len\
    \ = s;\n            max_index = len;\n        }\n    }\n    Some(max_len.to_string())",
  "    let mut max_len = String::new();\n    let mut max_len = strings[0].len();\n\
    \    for s in strings {\n        if s.len() > max_len {\n            max_len =\
    \ s.len();\n        }\n    }\n    if max_len == strings[0].len() {\n        return\
    \ None;\n    }\n    Some(strings[strings.iter().position(|s| s.len() == max_len).unwrap()])",
  '    strings.iter().max_by_key(|s| s.len())', "    if strings.is_empty() {\n   \
    \     return None;\n    }\n\n    let mut max_len = String::new();\n    let mut\
    \ max_len = strings.iter().map(|s| s.len()).max().unwrap();\n    let mut max_index\
    \ = -1;\n    for &s in strings {\n        if s.len() > max_len {\n           \
    \ max_len = s.len();\n            max_index = strings.iter().position(|&s| s.len()\
    \ == max_len).unwrap();\n        }\n    }\n\n    if max_index == -1 {\n      \
    \  return None;\n    }\n\n    Some(strings[max_index])", '    strings.iter().max_by_key(|s|
    s.len())', "    let mut longest = String::new();\n    for s in strings {\n   \
    \     if longest.len() < s.len() {\n            longest = s;\n        }\n    }\n\
    \    longest.ok()", '    strings.iter().max_by_key(|s| s.len())', "    if strings.is_empty()\
    \ {\n        return None;\n    }\n\n    let mut max_len = std::cmp::max::<usize>(\n\
    \        strings.iter().map(|s| s.len()).sum(),\n        strings.len(),\n    );\n\
    \    let mut longest = String::new();\n    for s in strings {\n        if s.len()\
    \ > max_len {\n            max_len = s.len();\n            longest = s;\n    \
    \    }\n    }\n    Some(longest)", "    strings.iter().fold(None, |mut max, string|\
    \ {\n        let len = string.len();\n        if len > max {\n            max\
    \ = len;\n        }\n        max\n    })", '    strings.iter().max_by_key(|s|
    s.len())']
stop_tokens:
- "\n}"
