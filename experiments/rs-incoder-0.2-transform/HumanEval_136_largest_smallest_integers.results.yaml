language: rs
name: HumanEval_136_largest_smallest_integers
results:
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, Some(min_val));\n    (None, None) if max_val == std::i32::MIN => (None,\
    \ None);\n    (Some(max_val), Some(min_val)) if min_val == max_val => (Some(max_val),\
    \ Some(min_val));\n    (Some(max_val), None) if max_val == std::i32::MIN => (Some(max_val),\
    \ None);\n    (None, None)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmp4di7nxic.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, Some(min_val));\n   |                \
    \           ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4di7nxic.rs:16:16\n   |\n16 |         if x <\
    \ min_val {\n   |                ^^^^^^^ expected `isize`, found `i32`\n   |\n\
    help: you can convert an `i32` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n   | \
    \                      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4di7nxic.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4di7nxic.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4di7nxic.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == i32::MAX =>\
    \ (None, None)\n    (None, Some(max_val)) if max_val == i32::MIN => (None, None)\n\
    \    (Some(min_val), Some(max_val)) => (Some(min_val), Some(max_val))\n}\n\nfn\
    \ main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpr03qdtny.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == i32::MAX => (None, None)\n   |                           ^^ expected\
    \ one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpr03qdtny.rs:16:16\n   |\n16 |         if x < min_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    16 |         if x < min_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr03qdtny.rs:17:23\n\
    \   |\n13 |     let mut min_val = i32::MAX;\n   |                       --------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpr03qdtny.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr03qdtny.rs:20:23\n\
    \   |\n14 |     let mut max_val = i32::MIN;\n   |                       --------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for x in lst {\n        if x < 0 {\n      \
    \      if smallest == None {\n                smallest = Some(x);\n          \
    \  } else {\n                let mut tmp = smallest;\n                smallest\
    \ = Some(x);\n                largest = Some(tmp.max());\n            }\n    \
    \    } else {\n            if largest == None {\n                largest = Some(x);\n\
    \            } else {\n                let mut tmp = largest;\n              \
    \  largest = Some(x);\n                smallest = Some(tmp.min());\n         \
    \   }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmp862ie2mn.rs:22:36\n    |\n22  |                 largest = Some(tmp.max());\n\
    \    |                                    ^^^- supplied 0 arguments\n    |   \
    \                                 |\n    |                                   \
    \ expected 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp862ie2mn.rs:26:32\n   |\n26 |              \
    \   largest = Some(x);\n   |                                ^ expected enum `Option`,\
    \ found `isize`\n   |\n   = note: expected enum `Option<isize>`\n            \
    \  found type `isize`\nhelp: try wrapping the expression in `Some`\n   |\n26 |\
    \                 largest = Some(Some(x));\n   |                             \
    \   +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp862ie2mn.rs:29:32\n\
    \   |\n29 |                 largest = Some(x);\n   |                         \
    \       ^ expected enum `Option`, found `isize`\n   |\n   = note: expected enum\
    \ `Option<isize>`\n              found type `isize`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n29 |                 largest = Some(Some(x));\n   |       \
    \                         +++++ +\n\nerror[E0061]: this function takes 1 argument\
    \ but 0 arguments were supplied\n   --> /tmp/tmp862ie2mn.rs:30:37\n    |\n30 \
    \ |                 smallest = Some(tmp.min());\n    |                       \
    \              ^^^- supplied 0 arguments\n    |                              \
    \       |\n    |                                     expected 1 argument\n   \
    \ |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp862ie2mn.rs:30:33\n   |\n30 |                 smallest = Some(tmp.min());\n\
    \   |                                 ^^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<Option<isize>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp862ie2mn.rs:34:6\n   |\n34 | \
    \    (largest, smallest)\n   |      ^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected enum `Optio"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for v in lst {\n        if v < min_val\
    \ {\n            min_val = v;\n        }\n        if v > max_val {\n         \
    \   max_val = v;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcgurpxh2.rs:16:16\n   |\n\
    16 |         if v < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if v < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcgurpxh2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcgurpxh2.rs:19:16\n\
    \   |\n19 |         if v > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if v > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcgurpxh2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcgurpxh2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcgurpxh2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for x in lst {\n        if x < 0 {\n      \
    \      if smallest == None {\n                smallest = Some(x);\n          \
    \  } else {\n                largest = Some(x);\n            }\n        } else\
    \ {\n            if largest == None {\n                largest = Some(x);\n  \
    \          } else {\n                if x > largest {\n                    largest\
    \ = Some(x);\n                }\n                if x < smallest {\n         \
    \           smallest = Some(x);\n                }\n            }\n        }\n\
    \    }\n    (largest, smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3tpwayfw.rs:26:24\n   |\n\
    26 |                 if x > largest {\n   |                        ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp3tpwayfw.rs:29:24\n   |\n29 |                 if x < smallest {\n  \
    \ |                        ^^^^^^^^ expected `isize`, found enum `Option`\n  \
    \ |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for elt in lst {\n        if elt <\
    \ min_val {\n            min_val = elt;\n        }\n        if elt > max_val {\n\
    \            max_val = elt;\n        }\n    }\n    (None, Some(min_val)) if min_val\
    \ == std::i32::MAX => (None, None)\n    (None, Some(max_val)) if max_val == std::i32::MIN\
    \ => (None, None)\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpuq14kzjt.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuq14kzjt.rs:16:18\n   |\n16 |         if elt < min_val\
    \ {\n   |                  ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp:\
    \ you can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n16 |         if elt < min_val.try_into().unwrap() {\n   |       \
    \                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpuq14kzjt.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuq14kzjt.rs:19:18\n\
    \   |\n19 |         if elt > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n19 |         if elt > max_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpuq14kzjt.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (Some(max_val), None) if max_val == std::i32::MIN => (None,\
    \ None)\n    (None, None)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpc3fq4qrl.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc3fq4qrl.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc3fq4qrl.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(std::cmp::max(max_negative.unwrap(),\
    \ x));\n            }\n        } else {\n            if min_positive.is_none()\
    \ {\n                min_positive = Some(x);\n            } else {\n         \
    \       min_positive = Some(std::cmp::min(min_positive.unwrap(), x));\n      \
    \      }\n        }\n    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpj07877ac.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_val = std::i32::MAX;\n\
    \    let mut min_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if max_val == std::i32::MAX\
    \ => (None, None)\n    else if min_val == std::i32::MIN => (None, None)\n    else\
    \ if max_val < min_val => (Some(max_val), Some(min_val))\n    else if max_val\
    \ > min_val => (Some(max_val), None)\n    else (None, None)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmp3cc0fm4b.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if max_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3cc0fm4b.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3cc0fm4b.rs:17:23\n\
    \   |\n14 |     let mut min_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3cc0fm4b.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3cc0fm4b.rs:20:23\n\
    \   |\n13 |     let mut max_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for x in lst {\n        if x < 0 {\n      \
    \      if smallest == None {\n                smallest = Some(x);\n          \
    \  } else {\n                smallest = Some(std::cmp::min(smallest, Some(x)));\n\
    \            }\n        } else {\n            if largest == None {\n         \
    \       largest = Some(x);\n            } else {\n                largest = Some(std::cmp::max(largest,\
    \ Some(x)));\n            }\n        }\n    }\n    (largest, smallest)\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5moh54lo.rs:20:47\n   |\n\
    20 |                 smallest = Some(std::cmp::min(smallest, Some(x)));\n   |\
    \                                               ^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5moh54lo.rs:20:57\n\
    \   |\n20 |                 smallest = Some(std::cmp::min(smallest, Some(x)));\n\
    \   |                                                         ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5moh54lo.rs:26:46\n   |\n26 |                 largest = Some(std::cmp::max(largest,\
    \ Some(x)));\n   |                                              ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5moh54lo.rs:26:55\n   |\n26 |                 largest = Some(std::cmp::max(largest,\
    \ Some(x)));\n   |                                                       ^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8h3f5n9a.rs:17:16\n   |\n\
    17 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8h3f5n9a.rs:18:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n18\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8h3f5n9a.rs:20:16\n\
    \   |\n20 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8h3f5n9a.rs:21:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n21\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8h3f5n9a.rs:24:11\n\
    \   |\n24 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n24 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8h3f5n9a.rs:24:26\n   |\n24 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n24 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(std::cmp::max(max_negative.unwrap(),\
    \ x));\n            }\n        } else {\n            if min_positive.is_none()\
    \ {\n                min_positive = Some(x);\n            } else {\n         \
    \       min_positive = Some(std::cmp::min(min_positive.unwrap(), x));\n      \
    \      }\n        }\n    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpj07877ac.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_val = lst.iter().max().unwrap();\n\
    \    let mut min_val = lst.iter().min().unwrap();\n    if max_val < min_val {\n\
    \        (None, Some(min_val))\n    } else {\n        (Some(max_val), None)\n\
    \    }\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n   \
    \ assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiaqfrwoz.rs:16:21\n   |\n\
    16 |         (None, Some(min_val))\n   |                     ^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    16 |         (None, Some(*min_val))\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpiaqfrwoz.rs:18:15\n   |\n18 |         (Some(max_val),\
    \ None)\n   |               ^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n18 |         (Some(*max_val), None)\n\
    \   |               +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(std::cmp::max(max_negative.unwrap(),\
    \ x));\n            }\n        } else {\n            if min_positive.is_none()\
    \ {\n                min_positive = Some(x);\n            } else {\n         \
    \       min_positive = Some(std::cmp::min(min_positive.unwrap(), x));\n      \
    \      }\n        }\n    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpj07877ac.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = Some(std::i32::MAX);\n\
    \    let mut largest = Some(std::i32::MIN);\n    for x in lst {\n        if x\
    \ < smallest {\n            smallest = Some(x);\n        }\n        if x > largest\
    \ {\n            largest = Some(x);\n        }\n    }\n    (largest, smallest)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8j8hbile.rs:16:16\n   |\n\
    16 |         if x < smallest {\n   |                ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8j8hbile.rs:17:29\n\
    \   |\n17 |             smallest = Some(x);\n   |                            \
    \ ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n17 |             smallest\
    \ = Some(x.try_into().unwrap());\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8j8hbile.rs:19:16\n   |\n19 |\
    \         if x > largest {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8j8hbile.rs:20:28\n\
    \   |\n20 |             largest = Some(x);\n   |                            ^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n20 |             largest\
    \ = Some(x.try_into().unwrap());\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8j8hbile.rs:23:6\n   |\n23 | \
    \    (largest, smallest)\n   |      ^^^^^^^ expected `isize`, found `i32`\n  \
    \ |\n   = note: expected enum `Option<isize>`\n              found enum `Option<i32>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8j8hbile.rs:23:15\n   |\n23 |\
    \     (largest, smallest)\n   |               ^^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\n   = note: expected enum `Option<isize>`\n              found enum\
    \ `Option<i32>`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = Some(std::i32::MAX);\n\
    \    let mut largest = Some(std::i32::MIN);\n    for x in lst {\n        if x\
    \ < smallest {\n            smallest = Some(x);\n        }\n        if x > largest\
    \ {\n            largest = Some(x);\n        }\n    }\n    (smallest, largest)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:16:16\n   |\n\
    16 |         if x < smallest {\n   |                ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:17:29\n\
    \   |\n17 |             smallest = Some(x);\n   |                            \
    \ ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n17 |             smallest\
    \ = Some(x.try_into().unwrap());\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:19:16\n   |\n19 |\
    \         if x > largest {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:20:28\n\
    \   |\n20 |             largest = Some(x);\n   |                            ^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n20 |             largest\
    \ = Some(x.try_into().unwrap());\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:23:6\n   |\n23 | \
    \    (smallest, largest)\n   |      ^^^^^^^^ expected `isize`, found `i32`\n \
    \  |\n   = note: expected enum `Option<isize>`\n              found enum `Option<i32>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:23:16\n   |\n23 |\
    \     (smallest, largest)\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\n   = note: expected enum `Option<isize>`\n              found enum\
    \ `Option<i32>`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(std::cmp::max(max_negative.unwrap(),\
    \ x));\n            }\n        } else {\n            if min_positive.is_none()\
    \ {\n                min_positive = Some(x);\n            } else {\n         \
    \       min_positive = Some(std::cmp::min(min_positive.unwrap(), x));\n      \
    \      }\n        }\n    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpj07877ac.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for v in lst {\n        if v < min_val\
    \ {\n            min_val = v;\n        }\n        if v > max_val {\n         \
    \   max_val = v;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (None, Some(max_val)) if max_val == std::i32::MIN => (None,\
    \ None)\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpue0ysy3i.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpue0ysy3i.rs:16:16\n   |\n16 |         if v < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if v < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpue0ysy3i.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = v;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpue0ysy3i.rs:19:16\n   |\n19 |         if v > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if v > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpue0ysy3i.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = v;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_int = isize::MAX;\n\
    \    let mut min_int = isize::MIN;\n    for x in lst {\n        if x < min_int\
    \ {\n            min_int = x;\n        }\n        if x > max_int {\n         \
    \   max_int = x;\n        }\n    }\n    (None, Some(min_int))\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(-9223372036854775808))`,\n right: `(None, Some(1))`', /tmp/tmpsc6kmeom.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(max_negative.max());\n\
    \            }\n        } else {\n            if min_positive.is_none() {\n  \
    \              min_positive = Some(x);\n            } else {\n               \
    \ min_positive = Some(min_positive.min());\n            }\n        }\n    }\n\
    \    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpah0a0c2b.rs:20:50\n    |\n20  |                 max_negative =\
    \ Some(max_negative.max());\n    |                                           \
    \       ^^^- supplied 0 arguments\n    |                                     \
    \             |\n    |                                                  expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpah0a0c2b.rs:20:37\n   |\n20 |                 max_negative\
    \ = Some(max_negative.max());\n   |                                     ^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n   --> /tmp/tmpah0a0c2b.rs:26:50\n\
    \    |\n26  |                 min_positive = Some(min_positive.min());\n    |\
    \                                                  ^^^- supplied 0 arguments\n\
    \    |                                                  |\n    |             \
    \                                     expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpah0a0c2b.rs:26:37\n\
    \   |\n26 |                 min_positive = Some(min_positive.min());\n   |   \
    \                                  ^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = Some(std::i32::MAX);\n\
    \    let mut largest = Some(std::i32::MIN);\n    for x in lst {\n        if x\
    \ < smallest {\n            smallest = Some(x);\n        }\n        if x > largest\
    \ {\n            largest = Some(x);\n        }\n    }\n    (smallest, largest)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:16:16\n   |\n\
    16 |         if x < smallest {\n   |                ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:17:29\n\
    \   |\n17 |             smallest = Some(x);\n   |                            \
    \ ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n17 |             smallest\
    \ = Some(x.try_into().unwrap());\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:19:16\n   |\n19 |\
    \         if x > largest {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:20:28\n\
    \   |\n20 |             largest = Some(x);\n   |                            ^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n20 |             largest\
    \ = Some(x.try_into().unwrap());\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:23:6\n   |\n23 | \
    \    (smallest, largest)\n   |      ^^^^^^^^ expected `isize`, found `i32`\n \
    \  |\n   = note: expected enum `Option<isize>`\n              found enum `Option<i32>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:23:16\n   |\n23 |\
    \     (smallest, largest)\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\n   = note: expected enum `Option<isize>`\n              found enum\
    \ `Option<i32>`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (None, Some(max_val)) if max_val == std::i32::MIN => (None,\
    \ None)\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpvp6ek5i9.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvp6ek5i9.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvp6ek5i9.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvp6ek5i9.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvp6ek5i9.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for v in lst {\n        if v < min_val\
    \ {\n            min_val = v;\n        }\n        if v > max_val {\n         \
    \   max_val = v;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcgurpxh2.rs:16:16\n   |\n\
    16 |         if v < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if v < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcgurpxh2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcgurpxh2.rs:19:16\n\
    \   |\n19 |         if v > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if v > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcgurpxh2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcgurpxh2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcgurpxh2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = Some(None);\n\
    \    let mut smallest = Some(None);\n    for x in lst {\n        if x < 0 {\n\
    \            largest = Some(x);\n        } else {\n            smallest = Some(x);\n\
    \        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbeic9diw.rs:17:28\n   |\n\
    17 |             largest = Some(x);\n   |                            ^ expected\
    \ enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<_>`\n \
    \             found type `isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n17 |             largest = Some(Some(x));\n   |                       \
    \     +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbeic9diw.rs:19:29\n\
    \   |\n19 |             smallest = Some(x);\n   |                            \
    \ ^ expected enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n19 |             smallest = Some(Some(x));\n   |                      \
    \       +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbeic9diw.rs:22:6\n\
    \   |\n22 |     (largest, smallest)\n   |      ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected enum `Option<isize>`\n            \
    \  found enum `Option<Option<_>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbeic9diw.rs:22:15\n\
    \   |\n22 |     (largest, smallest)\n   |               ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected enum `Option<isize>`\n      \
    \        found enum `Option<Option<_>>`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == i32::MAX =>\
    \ (None, Some(min_val));\n    (None, None) if max_val == i32::MIN => (None, None);\n\
    \    (Some(max_val), None) if max_val == i32::MIN => (Some(max_val), None);\n\
    \    (Some(max_val), Some(min_val)) if min_val == max_val => (Some(max_val), Some(min_val));\n\
    \    (Some(max_val), Some(min_val)) if min_val < max_val => (Some(max_val), Some(min_val));\n\
    \    (Some(max_val), Some(min_val)) if min_val > max_val => (Some(max_val), Some(min_val));\n\
    \    (Some(max_val), Some(min_val)) if min_val == i32::MIN - 1 => (Some(max_val),\
    \ Some(min_val));\n    (Some(max_val), Some(min_val)) if min_val == i32::MAX +\
    \ 1 => (Some(max_val), Some(min_val));\n    (Some(max_val), Some(min_val)) if\
    \ min_val == i32::MAX - 1 => (Some(max_val), Some(min_val));\n    (Some(max_val),\
    \ Some(min_val)) if min_val == i32::MIN + 1 => (Some(max_val), Some(min_val));\n\
    \    (Some(max_val), Some(min_val)) if min_val == i32::MAX - 1 => (Some(max_val),\
    \ Some(min_val));\n    (Some(max_val), Some(min_val)) if min_val == i32::MAX +\
    \ 1 => (Some(max_val), Some(min_val));\n    (Some(max_val), Some(min_val)) if\
    \ min_val == i32::MAX - 1 => (Some(max_val), Some(min_val));\n    (Some(max_val),\
    \ Some(min_val)) if min_val == i32::MIN - 1 => (Some(max_val), Some(min_val));\n\
    \    (Some(max_val), Some(min_val)) if min_val == i32::MIN + 1 => (Some(max_val),\
    \ Some(min_val));\n    (Some(max_val), Some(min_val)) if min_val == i32::MIN +\
    \ 1 => (Some\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmp8wqb32pf.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == i32::MAX => (None, Some(min_val));\n   |                     \
    \      ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: mismatched\
    \ closing delimiter: `}`\n  --> /tmp/tmp8wqb32pf.rs:38:66\n   |\n12 | fn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n   |                      \
    \                                                           - closing delimiter\
    \ possibly meant for this\n...\n38 |     (Some(max_val), Some(min_val)) if min_val\
    \ == i32::MIN + 1 => (Some\n   |                                             \
    \                     ^ unclosed delimiter\n39 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8wqb32pf.rs:16:16\n\
    \   |\n16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8wqb32pf.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8wqb32pf.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8wqb32pf.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror: aborting due to 6"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(std::cmp::max(max_negative.unwrap(),\
    \ x));\n            }\n        } else {\n            if min_positive.is_none()\
    \ {\n                min_positive = Some(x);\n            } else {\n         \
    \       min_positive = Some(std::cmp::min(min_positive.unwrap(), x));\n      \
    \      }\n        }\n    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpj07877ac.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for x in lst {\n        if x < 0 {\n      \
    \      if smallest == None {\n                smallest = Some(x);\n          \
    \  } else {\n                largest = Some(x);\n            }\n        } else\
    \ {\n            if largest == None {\n                largest = Some(x);\n  \
    \          } else {\n                if x > largest {\n                    largest\
    \ = Some(x);\n                }\n            }\n        }\n    }\n    (largest,\
    \ smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm76wi8hk.rs:26:24\n   |\n\
    26 |                 if x > largest {\n   |                        ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == i32::MAX =>\
    \ (None, None)\n    (Some(max_val), None) if max_val == i32::MIN => (None, None)\n\
    \    (None, None)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpughhz76j.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == i32::MAX => (None, None)\n   |                           ^^ expected\
    \ one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpughhz76j.rs:16:16\n   |\n16 |         if x < min_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    16 |         if x < min_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpughhz76j.rs:17:23\n\
    \   |\n13 |     let mut min_val = i32::MAX;\n   |                       --------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpughhz76j.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpughhz76j.rs:20:23\n\
    \   |\n14 |     let mut max_val = i32::MIN;\n   |                       --------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = isize::MAX;\n\
    \    let mut largest = isize::MIN;\n    for x in lst {\n        if x < smallest\
    \ {\n            smallest = x;\n        }\n        if x > largest {\n        \
    \    largest = x;\n        }\n    }\n    (None, Some(largest))\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp9kxnjvff.rs:28:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, Some(min_val));\n    (None, Some(max_val)) if max_val == std::i32::MIN\
    \ => (None, Some(max_val));\n    (Some(min_val), Some(max_val)) if min_val > max_val\
    \ => (Some(min_val), Some(max_val));\n    (Some(min_val), None) if min_val ==\
    \ std::i32::MIN => (Some(min_val), None);\n    (None, Some(max_val)) if max_val\
    \ == std::i32::MAX => (None, Some(max_val));\n    (Some(min_val), Some(max_val))\
    \ if min_val < max_val => (Some(min_val), Some(max_val));\n    (Some(min_val),\
    \ None) if min_val == std::i32::MIN => (Some(min_val), None);\n    (None, Some(max_val))\
    \ if max_val == std::i32::MAX => (None, Some(max_val));\n    (Some(min_val), Some(max_val))\
    \ if min_val > max_val => (Some(min_val), Some(max_val));\n    (Some(min_val),\
    \ None) if min_val == std::i32::MIN => (Some(min_val), None);\n    (None, Some(max_val))\
    \ if max_val == std::i32::MAX => (None, Some(max_val));\n    (Some(min_val), Some(max_val))\
    \ if min_val < max_val => (Some(min_val), Some(max_val));\n    (Some(min_val),\
    \ None) if min_val == std::i32::MIN => (Some(min_val), None);\n    (None, Some(max_val))\
    \ if max_val == std::i32::MAX => (None, Some(max_val));\n    (Some(min_val), Some(max_val))\
    \ if min_val > max_val => (Some(min_val), Some(max_val));\n    (Some(min_val),\
    \ None) if min_val == std::i32::MIN => (Some(min_val), None);\n    (None, Some(max_val))\
    \ if max_val == std::i32::MAX => (None, Some(max_val));\n    (Some(min_val), Some(max_val))\
    \ if min_val < max_val => (Some(\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpp48bxayo.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, Some(min_val));\n   |                \
    \           ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: mismatched\
    \ closing delimiter: `}`\n  --> /tmp/tmpp48bxayo.rs:40:65\n   |\n12 | fn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n   |                      \
    \                                                           - closing delimiter\
    \ possibly meant for this\n...\n40 |     (Some(min_val), Some(max_val)) if min_val\
    \ < max_val => (Some(\n   |                                                  \
    \               ^ unclosed delimiter\n41 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp48bxayo.rs:16:16\n   |\n16 |\
    \         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpp48bxayo.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp48bxayo.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp48bxayo.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = Some(std::i32::MAX);\n\
    \    let mut largest = Some(std::i32::MIN);\n    for x in lst {\n        if x\
    \ < smallest {\n            smallest = Some(x);\n        }\n        if x > largest\
    \ {\n            largest = Some(x);\n        }\n    }\n    (smallest, largest)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:16:16\n   |\n\
    16 |         if x < smallest {\n   |                ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:17:29\n\
    \   |\n17 |             smallest = Some(x);\n   |                            \
    \ ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n17 |             smallest\
    \ = Some(x.try_into().unwrap());\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:19:16\n   |\n19 |\
    \         if x > largest {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:20:28\n\
    \   |\n20 |             largest = Some(x);\n   |                            ^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n20 |             largest\
    \ = Some(x.try_into().unwrap());\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:23:6\n   |\n23 | \
    \    (smallest, largest)\n   |      ^^^^^^^^ expected `isize`, found `i32`\n \
    \  |\n   = note: expected enum `Option<isize>`\n              found enum `Option<i32>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:23:16\n   |\n23 |\
    \     (smallest, largest)\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\n   = note: expected enum `Option<isize>`\n              found enum\
    \ `Option<i32>`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (Some(max_val), None) if max_val == std::i32::MIN => (None,\
    \ None)\n    (None, None)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpc3fq4qrl.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc3fq4qrl.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc3fq4qrl.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == i32::MAX =>\
    \ (None, Some(min_val));\n    (None, Some(max_val)) if max_val == i32::MIN =>\
    \ (None, Some(max_val));\n    (Some(min_val), None) if min_val == i32::MIN =>\
    \ (Some(min_val), None);\n    (Some(max_val), None) if max_val == i32::MAX =>\
    \ (Some(max_val), None);\n    (Some(min_val), Some(max_val)) if min_val > max_val\
    \ => (Some(min_val), Some(max_val));\n    (None, None) => panic!(\"No negative\
    \ or positive integers found\");\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpbmkb8ntv.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == i32::MAX => (None, Some(min_val));\n   |                     \
    \      ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbmkb8ntv.rs:16:16\n   |\n16 |         if x <\
    \ min_val {\n   |                ^^^^^^^ expected `isize`, found `i32`\n   |\n\
    help: you can convert an `i32` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n   | \
    \                      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbmkb8ntv.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbmkb8ntv.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbmkb8ntv.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (Some(max_val), None) if max_val == std::i32::MIN => (None,\
    \ None)\n    (None, None)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpc3fq4qrl.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc3fq4qrl.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc3fq4qrl.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (None, Some(max_val)) if max_val == std::i32::MIN => (None,\
    \ None)\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpvp6ek5i9.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvp6ek5i9.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvp6ek5i9.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvp6ek5i9.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvp6ek5i9.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(max_negative.max());\n\
    \            }\n        } else {\n            if min_positive.is_none() {\n  \
    \              min_positive = Some(x);\n            } else {\n               \
    \ min_positive = Some(min_positive.min());\n            }\n        }\n    }\n\
    \    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpah0a0c2b.rs:20:50\n    |\n20  |                 max_negative =\
    \ Some(max_negative.max());\n    |                                           \
    \       ^^^- supplied 0 arguments\n    |                                     \
    \             |\n    |                                                  expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpah0a0c2b.rs:20:37\n   |\n20 |                 max_negative\
    \ = Some(max_negative.max());\n   |                                     ^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n   --> /tmp/tmpah0a0c2b.rs:26:50\n\
    \    |\n26  |                 min_positive = Some(min_positive.min());\n    |\
    \                                                  ^^^- supplied 0 arguments\n\
    \    |                                                  |\n    |             \
    \                                     expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpah0a0c2b.rs:26:37\n\
    \   |\n26 |                 min_positive = Some(min_positive.min());\n   |   \
    \                                  ^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for x in lst {\n        if x < 0 {\n      \
    \      if smallest == None {\n                smallest = Some(x);\n          \
    \  } else {\n                smallest = Some(std::cmp::min(smallest, x));\n  \
    \          }\n        } else {\n            if largest == None {\n           \
    \     largest = Some(x);\n            } else {\n                largest = Some(std::cmp::max(largest,\
    \ x));\n            }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplk3piw3r.rs:20:47\n   |\n\
    20 |                 smallest = Some(std::cmp::min(smallest, x));\n   |      \
    \                                         ^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplk3piw3r.rs:26:46\n   |\n26 |\
    \                 largest = Some(std::cmp::max(largest, x));\n   |           \
    \                                   ^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprkx55h3t.rs:17:16\n   |\n\
    17 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprkx55h3t.rs:18:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n18\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprkx55h3t.rs:20:16\n\
    \   |\n20 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprkx55h3t.rs:21:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n21\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprkx55h3t.rs:25:11\n\
    \   |\n25 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n25 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprkx55h3t.rs:25:26\n   |\n25 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n25 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for x in lst {\n        if x < 0 {\n      \
    \      if smallest == None {\n                smallest = Some(x);\n          \
    \  } else {\n                largest = Some(x);\n            }\n        } else\
    \ {\n            if largest == None {\n                largest = Some(x);\n  \
    \          } else {\n                if largest == Some(0) {\n               \
    \     smallest = Some(x);\n                } else {\n                    largest\
    \ = Some(x);\n                }\n            }\n        }\n    }\n    (largest,\
    \ smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(7), None)`,\n right: `(None, Some(1))`', /tmp/tmp8vhr2ful.rs:39:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (None, Some(max_val)) if max_val == std::i32::MIN => (None,\
    \ None)\n    (Some(min_val), Some(max_val)) => (Some(min_val), Some(max_val))\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmp5u56skb6.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5u56skb6.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5u56skb6.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5u56skb6.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5u56skb6.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = isize::MAX;\n\
    \    let mut largest = isize::MIN;\n    for x in lst {\n        if x < smallest\
    \ {\n            smallest = x;\n        }\n        if x > largest {\n        \
    \    largest = x;\n        }\n    }\n    (Some(largest), Some(smallest))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(7), Some(1))`,\n right: `(None, Some(1))`', /tmp/tmpsuaruvp8.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(std::cmp::max(max_negative.unwrap(),\
    \ x));\n            }\n        } else {\n            if min_positive.is_none()\
    \ {\n                min_positive = Some(x);\n            } else {\n         \
    \       min_positive = Some(std::cmp::min(min_positive.unwrap(), x));\n      \
    \      }\n        }\n    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpj07877ac.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for x in lst {\n        if x < 0 {\n      \
    \      if smallest == None {\n                smallest = Some(x);\n          \
    \  } else {\n                largest = Some(x);\n            }\n        } else\
    \ {\n            if largest == None {\n                largest = Some(x);\n  \
    \          } else {\n                if x < largest {\n                    largest\
    \ = Some(x);\n                } else {\n                    smallest = Some(x);\n\
    \                }\n            }\n        }\n    }\n    (largest, smallest)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptgijfzfb.rs:26:24\n   |\n\
    26 |                 if x < largest {\n   |                        ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == i32::MAX =>\
    \ (None, Some(min_val));\n    (Some(max_val), None) if max_val == i32::MIN =>\
    \ (Some(max_val), None);\n    (None, None)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpnqmjtqd6.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == i32::MAX => (None, Some(min_val));\n   |                     \
    \      ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnqmjtqd6.rs:16:16\n   |\n16 |         if x <\
    \ min_val {\n   |                ^^^^^^^ expected `isize`, found `i32`\n   |\n\
    help: you can convert an `i32` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n   | \
    \                      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnqmjtqd6.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnqmjtqd6.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnqmjtqd6.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, Some(min_val));\n    (None, Some(max_val)) if max_val == std::i32::MIN\
    \ => (None, Some(max_val));\n    (Some(min_val), Some(max_val)) if min_val ==\
    \ max_val => (Some(min_val), Some(max_val));\n    (Some(min_val), None) if min_val\
    \ == std::i32::MAX => (Some(min_val), None);\n    (None, Some(max_val)) if max_val\
    \ == std::i32::MIN => (None, Some(max_val));\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpe_bw23tm.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, Some(min_val));\n   |                \
    \           ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe_bw23tm.rs:16:16\n   |\n16 |         if x <\
    \ min_val {\n   |                ^^^^^^^ expected `isize`, found `i32`\n   |\n\
    help: you can convert an `i32` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n   | \
    \                      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpe_bw23tm.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe_bw23tm.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe_bw23tm.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(std::cmp::max(max_negative.unwrap(),\
    \ x));\n            }\n        } else {\n            if min_positive.is_none()\
    \ {\n                min_positive = Some(x);\n            } else {\n         \
    \       min_positive = Some(std::cmp::min(min_positive.unwrap(), x));\n      \
    \      }\n        }\n    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpj07877ac.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (None, Some(max_val)) if max_val == std::i32::MIN => (None,\
    \ None)\n    (Some(min_val), Some(max_val)) => (Some(min_val), Some(max_val))\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmp5u56skb6.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5u56skb6.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5u56skb6.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5u56skb6.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5u56skb6.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for elt in lst {\n        if elt < min_val\
    \ {\n            min_val = elt;\n        }\n        if elt > max_val {\n     \
    \       max_val = elt;\n        }\n    }\n    (Some(min_val), Some(max_val))\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsh5ldgj4.rs:16:18\n   |\n\
    16 |         if elt < min_val {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if elt < min_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsh5ldgj4.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = elt;\n   |                       ^^^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsh5ldgj4.rs:19:18\n\
    \   |\n19 |         if elt > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n19 |         if elt > max_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsh5ldgj4.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = elt;\n   |                       ^^^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsh5ldgj4.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsh5ldgj4.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previ"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(max_negative.max());\n\
    \            }\n        } else {\n            if min_positive.is_none() {\n  \
    \              min_positive = Some(x);\n            } else {\n               \
    \ min_positive = Some(min_positive.min());\n            }\n        }\n    }\n\
    \    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpah0a0c2b.rs:20:50\n    |\n20  |                 max_negative =\
    \ Some(max_negative.max());\n    |                                           \
    \       ^^^- supplied 0 arguments\n    |                                     \
    \             |\n    |                                                  expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpah0a0c2b.rs:20:37\n   |\n20 |                 max_negative\
    \ = Some(max_negative.max());\n   |                                     ^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n   --> /tmp/tmpah0a0c2b.rs:26:50\n\
    \    |\n26  |                 min_positive = Some(min_positive.min());\n    |\
    \                                                  ^^^- supplied 0 arguments\n\
    \    |                                                  |\n    |             \
    \                                     expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpah0a0c2b.rs:26:37\n\
    \   |\n26 |                 min_positive = Some(min_positive.min());\n   |   \
    \                                  ^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(std::cmp::max(max_negative.unwrap(),\
    \ x));\n            }\n        } else {\n            if min_positive.is_none()\
    \ {\n                min_positive = Some(x);\n            } else {\n         \
    \       min_positive = Some(std::cmp::min(min_positive.unwrap(), x));\n      \
    \      }\n        }\n    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpj07877ac.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for v in lst {\n        if v < min_val\
    \ {\n            min_val = v;\n        }\n        if v > max_val {\n         \
    \   max_val = v;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (None, Some(max_val)) if max_val == std::i32::MIN => (None,\
    \ None)\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpue0ysy3i.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpue0ysy3i.rs:16:16\n   |\n16 |         if v < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if v < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpue0ysy3i.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = v;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpue0ysy3i.rs:19:16\n   |\n19 |         if v > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if v > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpue0ysy3i.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = v;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (Some(max_val), None) if max_val == std::i32::MIN => (None,\
    \ None)\n    (None, None)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpc3fq4qrl.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc3fq4qrl.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc3fq4qrl.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for v in lst {\n        if v < min_val\
    \ {\n            min_val = v;\n        }\n        if v > max_val {\n         \
    \   max_val = v;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcgurpxh2.rs:16:16\n   |\n\
    16 |         if v < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if v < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcgurpxh2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcgurpxh2.rs:19:16\n\
    \   |\n19 |         if v > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if v > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcgurpxh2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = v;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcgurpxh2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcgurpxh2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = Some(std::i32::MAX);\n\
    \    let mut largest = Some(std::i32::MIN);\n    for x in lst {\n        if x\
    \ < smallest {\n            smallest = Some(x);\n        }\n        if x > largest\
    \ {\n            largest = Some(x);\n        }\n    }\n    (smallest, largest)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:16:16\n   |\n\
    16 |         if x < smallest {\n   |                ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:17:29\n\
    \   |\n17 |             smallest = Some(x);\n   |                            \
    \ ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n17 |             smallest\
    \ = Some(x.try_into().unwrap());\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:19:16\n   |\n19 |\
    \         if x > largest {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:20:28\n\
    \   |\n20 |             largest = Some(x);\n   |                            ^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n20 |             largest\
    \ = Some(x.try_into().unwrap());\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:23:6\n   |\n23 | \
    \    (smallest, largest)\n   |      ^^^^^^^^ expected `isize`, found `i32`\n \
    \  |\n   = note: expected enum `Option<isize>`\n              found enum `Option<i32>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:23:16\n   |\n23 |\
    \     (smallest, largest)\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\n   = note: expected enum `Option<isize>`\n              found enum\
    \ `Option<i32>`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (None, Some(max_val)) if max_val == std::i32::MIN => (None,\
    \ None)\n    (Some(min_val), Some(max_val)) => (Some(min_val), Some(max_val))\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmp5u56skb6.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5u56skb6.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5u56skb6.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5u56skb6.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5u56skb6.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for v in lst {\n        if v < min_val\
    \ {\n            min_val = v;\n        }\n        if v > max_val {\n         \
    \   max_val = v;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    else if max_val == std::i32::MIN => (None, None)\n    else\
    \ if min_val > max_val => (Some(min_val), None)\n    else if min_val == max_val\
    \ => (Some(min_val), Some(min_val))\n    else if min_val < max_val => (Some(min_val),\
    \ Some(max_val))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpudn2h5_v.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpudn2h5_v.rs:16:16\n   |\n16 |         if v < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if v < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpudn2h5_v.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = v;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpudn2h5_v.rs:19:16\n   |\n19 |         if v > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if v > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpudn2h5_v.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = v;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for elt in lst {\n        if elt <\
    \ min_val {\n            min_val = elt;\n        }\n        if elt > max_val {\n\
    \            max_val = elt;\n        }\n    }\n    (Some(min_val), Some(max_val))\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfxseddcu.rs:16:18\n   |\n\
    16 |         if elt < min_val {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if elt < min_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfxseddcu.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfxseddcu.rs:19:18\n\
    \   |\n19 |         if elt > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n19 |         if elt > max_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfxseddcu.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfxseddcu.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfxseddcu.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: abo"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (None, Some(max_val)) if max_val == std::i32::MIN => (None,\
    \ None)\n    (Some(min_val), None) if min_val == std::i32::MIN => (None, None)\n\
    \    (Some(max_val), None) if max_val == std::i32::MAX => (None, None)\n    (Some(min_val),\
    \ Some(max_val)) => (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmp098k3bhq.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp098k3bhq.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp098k3bhq.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp098k3bhq.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp098k3bhq.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = Some(0);\n\
    \    let mut smallest = Some(0);\n    for x in lst {\n        if x < 0 {\n   \
    \         largest = Some(x);\n        } else if x > 0 {\n            smallest\
    \ = Some(x);\n        } else {\n            smallest = Some(x);\n        }\n \
    \   }\n    (largest, smallest)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(Some(0), Some(7))`,\n right: `(None, Some(1))`', /tmp/tmpsn3valk9.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (Some(max_val), None) if max_val == std::i32::MIN => (None,\
    \ None)\n    (None, None)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpc3fq4qrl.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc3fq4qrl.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc3fq4qrl.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == i32::MAX =>\
    \ (None, Some(min_val));\n    (None, Some(max_val)) if max_val == i32::MIN =>\
    \ (None, Some(max_val));\n    (Some(min_val), Some(max_val)) if min_val == max_val\
    \ => (Some(min_val), Some(max_val));\n    (None, None)\n}\n\nfn main() {\n   \
    \ let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmph8r1flvo.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == i32::MAX => (None, Some(min_val));\n   |                     \
    \      ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph8r1flvo.rs:16:16\n   |\n16 |         if x <\
    \ min_val {\n   |                ^^^^^^^ expected `isize`, found `i32`\n   |\n\
    help: you can convert an `i32` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n   | \
    \                      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmph8r1flvo.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmph8r1flvo.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmph8r1flvo.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, Some(min_val));\n    (None, Some(max_val)) if max_val == std::i32::MIN\
    \ => (None, Some(max_val));\n    (Some(min_val), Some(max_val)) if min_val > max_val\
    \ => (Some(min_val), Some(max_val));\n    (Some(min_val), None) if min_val ==\
    \ std::i32::MIN => (Some(min_val), None);\n    (None, Some(max_val)) if max_val\
    \ == std::i32::MAX => (None, Some(max_val));\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpjt48q9uj.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, Some(min_val));\n   |                \
    \           ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjt48q9uj.rs:16:16\n   |\n16 |         if x <\
    \ min_val {\n   |                ^^^^^^^ expected `isize`, found `i32`\n   |\n\
    help: you can convert an `i32` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n   | \
    \                      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjt48q9uj.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjt48q9uj.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjt48q9uj.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for elt in lst {\n        if elt <\
    \ min_val {\n            min_val = elt;\n        }\n        if elt > max_val {\n\
    \            max_val = elt;\n        }\n    }\n    (Some(min_val), Some(max_val))\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfxseddcu.rs:16:18\n   |\n\
    16 |         if elt < min_val {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if elt < min_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfxseddcu.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfxseddcu.rs:19:18\n\
    \   |\n19 |         if elt > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n19 |         if elt > max_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfxseddcu.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfxseddcu.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfxseddcu.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: abo"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for x in lst {\n        if x < 0 {\n      \
    \      if smallest == None {\n                smallest = Some(x);\n          \
    \  } else {\n                smallest = Some(std::cmp::min(smallest, x));\n  \
    \          }\n        } else {\n            if largest == None {\n           \
    \     largest = Some(x);\n            } else {\n                largest = Some(std::cmp::max(largest,\
    \ x));\n            }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplk3piw3r.rs:20:47\n   |\n\
    20 |                 smallest = Some(std::cmp::min(smallest, x));\n   |      \
    \                                         ^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplk3piw3r.rs:26:46\n   |\n26 |\
    \                 largest = Some(std::cmp::max(largest, x));\n   |           \
    \                                   ^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (None, Some(max_val)) if max_val == std::i32::MIN => (None,\
    \ None)\n    (Some(min_val), Some(max_val)) => (Some(min_val), Some(max_val))\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmp5u56skb6.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5u56skb6.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5u56skb6.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5u56skb6.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5u56skb6.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(max_val), Some(min_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqvekk4bs.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqvekk4bs.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqvekk4bs.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqvekk4bs.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqvekk4bs.rs:23:11\n   |\n23 |\
    \     (Some(max_val), Some(min_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(max_val.try_into().unwrap()),\
    \ Some(min_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqvekk4bs.rs:23:26\n   |\n23 |     (Some(max_val),\
    \ Some(min_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(max_val), Some(min_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for x in lst {\n        if x < 0 {\n      \
    \      if smallest == None {\n                smallest = Some(x);\n          \
    \  } else {\n                smallest = Some(std::cmp::min(smallest, Some(x)));\n\
    \            }\n        } else {\n            if largest == None {\n         \
    \       largest = Some(x);\n            } else {\n                largest = Some(std::cmp::max(largest,\
    \ Some(x)));\n            }\n        }\n    }\n    (largest, smallest)\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5moh54lo.rs:20:47\n   |\n\
    20 |                 smallest = Some(std::cmp::min(smallest, Some(x)));\n   |\
    \                                               ^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5moh54lo.rs:20:57\n\
    \   |\n20 |                 smallest = Some(std::cmp::min(smallest, Some(x)));\n\
    \   |                                                         ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5moh54lo.rs:26:46\n   |\n26 |                 largest = Some(std::cmp::max(largest,\
    \ Some(x)));\n   |                                              ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5moh54lo.rs:26:55\n   |\n26 |                 largest = Some(std::cmp::max(largest,\
    \ Some(x)));\n   |                                                       ^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n\n    for val in lst {\n        if val\
    \ < min_val {\n            min_val = val;\n        }\n        if val > max_val\
    \ {\n            max_val = val;\n        }\n    }\n\n    (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n    (Some(max_val), None) if max_val\
    \ == std::i32::MIN => (None, None)\n    (None, None)\n}\n\nfn main() {\n    let\
    \ candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4,\
    \ 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5,\
    \ 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]),\
    \ (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]),\
    \ (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]),\
    \ (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None,\
    \ None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpfdrptmqt.rs:25:27\n   |\n25 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfdrptmqt.rs:17:18\n   |\n17 |         if val < min_val\
    \ {\n   |                  ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp:\
    \ you can convert an `i32` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n17 |         if val < min_val.try_into().unwrap() {\n   |       \
    \                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfdrptmqt.rs:18:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n18\
    \ |             min_val = val;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfdrptmqt.rs:20:18\n\
    \   |\n20 |         if val > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n20 |         if val > max_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfdrptmqt.rs:21:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n21\
    \ |             max_val = val;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (Some(max_val), None) if max_val == std::i32::MIN => (None,\
    \ None)\n    (None, None)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpc3fq4qrl.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc3fq4qrl.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc3fq4qrl.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (None, Some(max_val)) if max_val == std::i32::MIN => (None,\
    \ None)\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpvp6ek5i9.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvp6ek5i9.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvp6ek5i9.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvp6ek5i9.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvp6ek5i9.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(std::cmp::max(max_negative.unwrap(),\
    \ x));\n            }\n        } else {\n            if min_positive.is_none()\
    \ {\n                min_positive = Some(x);\n            } else {\n         \
    \       min_positive = Some(std::cmp::min(min_positive.unwrap(), x));\n      \
    \      }\n        }\n    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpj07877ac.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (Some(max_val), None) if max_val == std::i32::MIN => (None,\
    \ None)\n    (None, None)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpc3fq4qrl.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc3fq4qrl.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc3fq4qrl.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = Some(std::i32::MAX);\n\
    \    let mut largest = Some(std::i32::MIN);\n    for x in lst {\n        if x\
    \ < smallest {\n            smallest = Some(x);\n        }\n        if x > largest\
    \ {\n            largest = Some(x);\n        }\n    }\n    (smallest, largest)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:16:16\n   |\n\
    16 |         if x < smallest {\n   |                ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:17:29\n\
    \   |\n17 |             smallest = Some(x);\n   |                            \
    \ ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n17 |             smallest\
    \ = Some(x.try_into().unwrap());\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:19:16\n   |\n19 |\
    \         if x > largest {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:20:28\n\
    \   |\n20 |             largest = Some(x);\n   |                            ^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n20 |             largest\
    \ = Some(x.try_into().unwrap());\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:23:6\n   |\n23 | \
    \    (smallest, largest)\n   |      ^^^^^^^^ expected `isize`, found `i32`\n \
    \  |\n   = note: expected enum `Option<isize>`\n              found enum `Option<i32>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:23:16\n   |\n23 |\
    \     (smallest, largest)\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\n   = note: expected enum `Option<isize>`\n              found enum\
    \ `Option<i32>`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for x in lst {\n        if x < 0 {\n      \
    \      largest = Some(x);\n        } else {\n            smallest = Some(x);\n\
    \        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp1d4fkfsa.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010691
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_val = std::i32::MAX;\n\
    \    let mut min_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (Some(max_val), None) if max_val == std::i32::MIN => (None,\
    \ None)\n    (None, None)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpunjtt9lx.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpunjtt9lx.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpunjtt9lx.rs:17:23\n\
    \   |\n14 |     let mut min_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpunjtt9lx.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpunjtt9lx.rs:20:23\n\
    \   |\n13 |     let mut max_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = Some(std::i32::MAX);\n\
    \    let mut largest = Some(std::i32::MIN);\n    for x in lst {\n        if x\
    \ < smallest {\n            smallest = Some(x);\n        }\n        if x > largest\
    \ {\n            largest = Some(x);\n        }\n    }\n    (smallest, largest)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:16:16\n   |\n\
    16 |         if x < smallest {\n   |                ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:17:29\n\
    \   |\n17 |             smallest = Some(x);\n   |                            \
    \ ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n17 |             smallest\
    \ = Some(x.try_into().unwrap());\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:19:16\n   |\n19 |\
    \         if x > largest {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:20:28\n\
    \   |\n20 |             largest = Some(x);\n   |                            ^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n20 |             largest\
    \ = Some(x.try_into().unwrap());\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:23:6\n   |\n23 | \
    \    (smallest, largest)\n   |      ^^^^^^^^ expected `isize`, found `i32`\n \
    \  |\n   = note: expected enum `Option<isize>`\n              found enum `Option<i32>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:23:16\n   |\n23 |\
    \     (smallest, largest)\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\n   = note: expected enum `Option<isize>`\n              found enum\
    \ `Option<i32>`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(std::cmp::max(max_negative.unwrap(),\
    \ x));\n            }\n        } else {\n            if min_positive.is_none()\
    \ {\n                min_positive = Some(x);\n            } else {\n         \
    \       min_positive = Some(std::cmp::min(min_positive.unwrap(), x));\n      \
    \      }\n        }\n    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpj07877ac.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for v in lst {\n        if v < min_val\
    \ {\n            min_val = v;\n        }\n        if v > max_val {\n         \
    \   max_val = v;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (None, Some(max_val)) if max_val == std::i32::MIN => (None,\
    \ None)\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpue0ysy3i.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpue0ysy3i.rs:16:16\n   |\n16 |         if v < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if v < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpue0ysy3i.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = v;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpue0ysy3i.rs:19:16\n   |\n19 |         if v > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if v > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpue0ysy3i.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = v;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = Some(std::i32::MAX);\n\
    \    let mut largest = Some(std::i32::MIN);\n    for x in lst {\n        if x\
    \ < 0 {\n            smallest = Some(std::i32::MAX);\n        } else {\n     \
    \       largest = Some(std::i32::MIN);\n        }\n        if x < smallest {\n\
    \            smallest = Some(x);\n        }\n        if x > largest {\n      \
    \      largest = Some(x);\n        }\n    }\n    (smallest, largest)\n}\n\nfn\
    \ main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9wt1a782.rs:21:16\n   |\n\
    21 |         if x < smallest {\n   |                ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9wt1a782.rs:22:29\n\
    \   |\n22 |             smallest = Some(x);\n   |                            \
    \ ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n22 |             smallest\
    \ = Some(x.try_into().unwrap());\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9wt1a782.rs:24:16\n   |\n24 |\
    \         if x > largest {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9wt1a782.rs:25:28\n\
    \   |\n25 |             largest = Some(x);\n   |                            ^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n25 |             largest\
    \ = Some(x.try_into().unwrap());\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9wt1a782.rs:28:6\n   |\n28 | \
    \    (smallest, largest)\n   |      ^^^^^^^^ expected `isize`, found `i32`\n \
    \  |\n   = note: expected enum `Option<isize>`\n              found enum `Option<i32>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9wt1a782.rs:28:16\n   |\n28 |\
    \     (smallest, largest)\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\n   = note: expected enum `Option<isize>`\n              found enum\
    \ `Option<i32>`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(std::cmp::max(max_negative.unwrap(),\
    \ x));\n            }\n        } else {\n            if min_positive.is_none()\
    \ {\n                min_positive = Some(x);\n            } else {\n         \
    \       min_positive = Some(std::cmp::min(min_positive.unwrap(), x));\n      \
    \      }\n        }\n    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpj07877ac.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (None, Some(max_val)) if max_val == std::i32::MIN => (None,\
    \ None)\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpvp6ek5i9.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvp6ek5i9.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvp6ek5i9.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvp6ek5i9.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvp6ek5i9.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(std::cmp::max(max_negative.unwrap(),\
    \ x));\n            }\n        } else {\n            if min_positive.is_none()\
    \ {\n                min_positive = Some(x);\n            } else {\n         \
    \       min_positive = Some(std::cmp::min(min_positive.unwrap(), x));\n      \
    \      }\n        }\n    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpj07877ac.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for v in lst {\n        if v < min_val {\n\
    \            min_val = v;\n        }\n        if v > max_val {\n            max_val\
    \ = v;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5gcq6oik.rs:16:16\n   |\n\
    16 |         if v < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if v < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5gcq6oik.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = v;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5gcq6oik.rs:19:16\n   |\n19 |\
    \         if v > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if v > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5gcq6oik.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = v;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5gcq6oik.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5gcq6oik.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (None, Some(max_val)) if max_val == std::i32::MIN => (None,\
    \ None)\n    (Some(min_val), Some(max_val)) => (Some(min_val), Some(max_val))\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmp5u56skb6.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5u56skb6.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5u56skb6.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5u56skb6.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5u56skb6.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, Some(min_val));\n    (Some(max_val), None) if max_val == std::i32::MIN\
    \ => (Some(max_val), None);\n    (None, None)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmp1fqxurtj.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, Some(min_val));\n   |                \
    \           ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1fqxurtj.rs:16:16\n   |\n16 |         if x <\
    \ min_val {\n   |                ^^^^^^^ expected `isize`, found `i32`\n   |\n\
    help: you can convert an `i32` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n   | \
    \                      ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1fqxurtj.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1fqxurtj.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1fqxurtj.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(std::cmp::max(max_negative.unwrap(),\
    \ x));\n            }\n        } else {\n            if min_positive.is_none()\
    \ {\n                min_positive = Some(x);\n            } else {\n         \
    \       min_positive = Some(std::cmp::min(min_positive.unwrap(), x));\n      \
    \      }\n        }\n    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpj07877ac.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == i32::MAX =>\
    \ (None, Some(min_val));\n    (None, Some(max_val)) if max_val == i32::MIN =>\
    \ (None, Some(max_val));\n    (Some(min_val), Some(max_val)) if min_val == max_val\
    \ => (Some(min_val), Some(max_val));\n    (Some(min_val), None) if min_val ==\
    \ i32::MAX => (Some(min_val), None);\n    (None, Some(max_val)) if max_val ==\
    \ i32::MIN => (None, Some(max_val));\n    (Some(min_val), Some(max_val)) if min_val\
    \ == max_val => (Some(min_val), Some(max_val));\n    (Some(min_val), None) if\
    \ min_val == i32::MAX => (Some(min_val), None);\n    (None, Some(max_val)) if\
    \ max_val == i32::MIN => (None, Some(max_val));\n    (Some(min_val), Some(max_val))\
    \ if min_val == max_val => (Some(min_val), Some(max_val));\n    (Some(min_val),\
    \ None) if min_val == i32::MAX => (Some(min_val), None);\n    (None, Some(max_val))\
    \ if max_val == i32::MIN => (None, Some(max_val));\n    (Some(min_val), Some(max_val))\
    \ if min_val == max_val => (Some(min_val), Some(max_val));\n    (Some(min_val),\
    \ None) if min_val == i32::MAX => (Some(min_val), None);\n    (None, Some(max_val))\
    \ if max_val == i32::MIN => (None, Some(max_val));\n    (Some(min_val), Some(max_val))\
    \ if min_val == max_val => (Some(min_val), Some(max_val));\n    (Some(min_val),\
    \ None) if min_val == i32::MAX => (Some(min_val), None);\n    (None, Some(max_val))\
    \ if max_val == i32::MIN => (None, Some(max_val));\n    (Some(min_val), Some(max_val))\
    \ if min_val == max_val => (Some(min_val), Some(max_val));\n    (Some(min_val\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmp8xgizesl.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == i32::MAX => (None, Some(min_val));\n   |                     \
    \      ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: mismatched\
    \ closing delimiter: `}`\n  --> /tmp/tmp8xgizesl.rs:41:10\n   |\n12 | fn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n   |                      \
    \                                                           - closing delimiter\
    \ possibly meant for this\n...\n41 |     (Some(min_val\n   |          ^ unclosed\
    \ delimiter\n42 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8xgizesl.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8xgizesl.rs:17:23\n\
    \   |\n13 |     let mut min_val = i32::MAX;\n   |                       --------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8xgizesl.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8xgizesl.rs:20:23\n\
    \   |\n14 |     let mut max_val = i32::MIN;\n   |                       --------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 6 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_val = i32::MAX;\n\
    \    let mut min_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == i32::MAX =>\
    \ (None, None)\n    else if max_val == i32::MIN => (None, None)\n    else if min_val\
    \ > max_val => (Some(min_val), None)\n    else if min_val < max_val => (None,\
    \ Some(max_val))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmps8zkprd7.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == i32::MAX => (None, None)\n   |                           ^^ expected\
    \ one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps8zkprd7.rs:16:16\n   |\n16 |         if x < min_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    16 |         if x < min_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps8zkprd7.rs:17:23\n\
    \   |\n14 |     let mut min_val = i32::MIN;\n   |                       --------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmps8zkprd7.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps8zkprd7.rs:20:23\n\
    \   |\n13 |     let mut max_val = i32::MAX;\n   |                       --------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(max_val), Some(min_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqgxzhl6x.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqgxzhl6x.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqgxzhl6x.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqgxzhl6x.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqgxzhl6x.rs:23:11\n\
    \   |\n23 |     (Some(max_val), Some(min_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(max_val.try_into().unwrap()),\
    \ Some(min_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqgxzhl6x.rs:23:26\n   |\n23 |     (Some(max_val),\
    \ Some(min_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(max_val), Some(min_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for x in lst {\n        if x < 0 {\n      \
    \      if smallest == None {\n                smallest = Some(x);\n          \
    \  } else {\n                smallest = Some(std::cmp::min(smallest, x));\n  \
    \          }\n        } else {\n            if largest == None {\n           \
    \     largest = Some(x);\n            } else {\n                largest = Some(std::cmp::max(largest,\
    \ x));\n            }\n        }\n    }\n    (largest, smallest)\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplk3piw3r.rs:20:47\n   |\n\
    20 |                 smallest = Some(std::cmp::min(smallest, x));\n   |      \
    \                                         ^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplk3piw3r.rs:26:46\n   |\n26 |\
    \                 largest = Some(std::cmp::max(largest, x));\n   |           \
    \                                   ^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == i32::MAX =>\
    \ (None, None)\n    (None, Some(max_val)) if max_val == i32::MIN => (None, None)\n\
    \    (Some(min_val), Some(max_val)) => (Some(min_val), Some(max_val))\n}\n\nfn\
    \ main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpr03qdtny.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == i32::MAX => (None, None)\n   |                           ^^ expected\
    \ one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpr03qdtny.rs:16:16\n   |\n16 |         if x < min_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    16 |         if x < min_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr03qdtny.rs:17:23\n\
    \   |\n13 |     let mut min_val = i32::MAX;\n   |                       --------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpr03qdtny.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr03qdtny.rs:20:23\n\
    \   |\n14 |     let mut max_val = i32::MIN;\n   |                       --------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for x in lst {\n        if x < 0 {\n      \
    \      largest = Some(x);\n        } else {\n            smallest = Some(x);\n\
    \        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp1d4fkfsa.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010691
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (Some(max_val), None) if max_val == std::i32::MIN => (None,\
    \ None)\n    (None, None)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpc3fq4qrl.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc3fq4qrl.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc3fq4qrl.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (None, Some(max_val)) if max_val == std::i32::MIN => (None,\
    \ None)\n    (Some(min_val), Some(max_val)) => (Some(min_val), Some(max_val))\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmp5u56skb6.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5u56skb6.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5u56skb6.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5u56skb6.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5u56skb6.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt8pwi47s.rs:17:16\n   |\n\
    17 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpt8pwi47s.rs:18:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n18 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpt8pwi47s.rs:20:16\n   |\n20 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n20 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpt8pwi47s.rs:21:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n21 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpt8pwi47s.rs:25:11\n   |\n25 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n25 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt8pwi47s.rs:25:26\n   |\n25 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n25 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for v in lst {\n        if v < min_val {\n\
    \            min_val = v;\n        }\n        if v > max_val {\n            max_val\
    \ = v;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5gcq6oik.rs:16:16\n   |\n\
    16 |         if v < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if v < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5gcq6oik.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = v;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5gcq6oik.rs:19:16\n   |\n19 |\
    \         if v > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if v > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5gcq6oik.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = v;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5gcq6oik.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5gcq6oik.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (None, Some(max_val)) if max_val == std::i32::MIN => (None,\
    \ None)\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpvp6ek5i9.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvp6ek5i9.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvp6ek5i9.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvp6ek5i9.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvp6ek5i9.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(std::cmp::max(max_negative.unwrap(),\
    \ x));\n            }\n        } else {\n            if min_positive.is_none()\
    \ {\n                min_positive = Some(x);\n            } else {\n         \
    \       min_positive = Some(std::cmp::min(min_positive.unwrap(), x));\n      \
    \      }\n        }\n    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpj07877ac.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = Some(std::i32::MAX);\n\
    \    let mut largest = Some(std::i32::MIN);\n    for x in lst {\n        if x\
    \ < smallest {\n            smallest = Some(x);\n        }\n        if x > largest\
    \ {\n            largest = Some(x);\n        }\n    }\n    (smallest, largest)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:16:16\n   |\n\
    16 |         if x < smallest {\n   |                ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:17:29\n\
    \   |\n17 |             smallest = Some(x);\n   |                            \
    \ ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n17 |             smallest\
    \ = Some(x.try_into().unwrap());\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:19:16\n   |\n19 |\
    \         if x > largest {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:20:28\n\
    \   |\n20 |             largest = Some(x);\n   |                            ^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n20 |             largest\
    \ = Some(x.try_into().unwrap());\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:23:6\n   |\n23 | \
    \    (smallest, largest)\n   |      ^^^^^^^^ expected `isize`, found `i32`\n \
    \  |\n   = note: expected enum `Option<isize>`\n              found enum `Option<i32>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:23:16\n   |\n23 |\
    \     (smallest, largest)\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\n   = note: expected enum `Option<isize>`\n              found enum\
    \ `Option<i32>`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(max_val), Some(min_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqgxzhl6x.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqgxzhl6x.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqgxzhl6x.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqgxzhl6x.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqgxzhl6x.rs:23:11\n\
    \   |\n23 |     (Some(max_val), Some(min_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(max_val.try_into().unwrap()),\
    \ Some(min_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqgxzhl6x.rs:23:26\n   |\n23 |     (Some(max_val),\
    \ Some(min_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(max_val), Some(min_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, Some(min_val));\n    (None, Some(max_val)) if max_val == std::i32::MIN\
    \ => (None, Some(max_val));\n    (Some(min_val), Some(max_val)) if min_val < max_val\
    \ => (Some(min_val), Some(max_val));\n    (Some(min_val), None) if min_val ==\
    \ std::i32::MAX => (Some(min_val), None);\n    (None, Some(max_val)) if max_val\
    \ == std::i32::MIN => (None, Some(max_val));\n    (Some(min_val), Some(max_val))\
    \ if min_val > max_val => (Some(min_val), Some(max_val));\n    (Some(min_val),\
    \ None) if min_val == std::i32::MAX => (Some(min_val), None);\n    (None, Some(max_val))\
    \ if max_val == std::i32::MIN => (None, Some(max_val));\n    (Some(min_val), Some(max_val))\
    \ if min_val >= max_val => (Some(min_val), Some(max_val));\n    (Some(min_val),\
    \ None) if min_val == std::i32::MAX => (Some(min_val), None);\n    (None, Some(max_val))\
    \ if max_val == std::i32::MIN => (None, Some(max_val));\n    (Some(min_val), Some(max_val))\
    \ if min_val > max_val => (Some(min_val), Some(max_val));\n    (Some(min_val),\
    \ None) if min_val == std::i32::MAX => (Some(min_val), None);\n    (None, Some(max_val))\
    \ if max_val == std::i32::MIN => (None, Some(max_val));\n    (Some(min_val), Some(max_val))\
    \ if min_val >= max_val => (Some(min_val), Some(max_val));\n    (Some(min_val),\
    \ None) if min_val == std::i32::MAX => (Some(min_val), None);\n    (None, Some(max_val))\
    \ if max_val == std::i32::MIN => (None, Some(max_val));\n    (Some(min_val), Some(max_val))\
    \ if min_val > max_val => (Some(\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmphqjtjmmo.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, Some(min_val));\n   |                \
    \           ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: mismatched\
    \ closing delimiter: `}`\n  --> /tmp/tmphqjtjmmo.rs:40:65\n   |\n12 | fn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n   |                      \
    \                                                           - closing delimiter\
    \ possibly meant for this\n...\n40 |     (Some(min_val), Some(max_val)) if min_val\
    \ > max_val => (Some(\n   |                                                  \
    \               ^ unclosed delimiter\n41 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphqjtjmmo.rs:16:16\n   |\n16 |\
    \         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphqjtjmmo.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphqjtjmmo.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphqjtjmmo.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (Some(max_val), None) if max_val == std::i32::MIN => (None,\
    \ None)\n    (None, None)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpc3fq4qrl.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc3fq4qrl.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc3fq4qrl.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (Some(max_val), None) if max_val == std::i32::MIN => (None,\
    \ None)\n    (None, None)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpc3fq4qrl.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc3fq4qrl.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc3fq4qrl.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = isize::MAX;\n\
    \    let mut largest = isize::MIN;\n    for x in lst {\n        if x < smallest\
    \ {\n            smallest = x;\n        }\n        if x > largest {\n        \
    \    largest = x;\n        }\n    }\n    (None, Some(largest))\n}\n\nfn main()\
    \ {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp9kxnjvff.rs:28:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(max_val), Some(min_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqvekk4bs.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqvekk4bs.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqvekk4bs.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqvekk4bs.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqvekk4bs.rs:23:11\n   |\n23 |\
    \     (Some(max_val), Some(min_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(max_val.try_into().unwrap()),\
    \ Some(min_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqvekk4bs.rs:23:26\n   |\n23 |     (Some(max_val),\
    \ Some(min_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(max_val), Some(min_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (None, Some(max_val)) if max_val == std::i32::MIN => (None,\
    \ None)\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpvp6ek5i9.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvp6ek5i9.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvp6ek5i9.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvp6ek5i9.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvp6ek5i9.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = Some(std::i32::MAX);\n\
    \    let mut largest = Some(std::i32::MIN);\n    for x in lst {\n        if x\
    \ < smallest {\n            smallest = Some(x);\n        }\n        if x > largest\
    \ {\n            largest = Some(x);\n        }\n    }\n    (None, Some(largest))\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphozaheg8.rs:16:16\n   |\n\
    16 |         if x < smallest {\n   |                ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphozaheg8.rs:17:29\n\
    \   |\n17 |             smallest = Some(x);\n   |                            \
    \ ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n17 |             smallest\
    \ = Some(x.try_into().unwrap());\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphozaheg8.rs:19:16\n   |\n19 |\
    \         if x > largest {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphozaheg8.rs:20:28\n\
    \   |\n20 |             largest = Some(x);\n   |                            ^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n20 |             largest\
    \ = Some(x.try_into().unwrap());\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphozaheg8.rs:23:17\n   |\n23 |\
    \     (None, Some(largest))\n   |                 ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = Some(std::i32::MAX);\n\
    \    let mut largest = Some(std::i32::MIN);\n    for x in lst {\n        if x\
    \ < smallest {\n            smallest = Some(x);\n        }\n        if x > largest\
    \ {\n            largest = Some(x);\n        }\n    }\n    (None, Some(largest))\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphozaheg8.rs:16:16\n   |\n\
    16 |         if x < smallest {\n   |                ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphozaheg8.rs:17:29\n\
    \   |\n17 |             smallest = Some(x);\n   |                            \
    \ ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n17 |             smallest\
    \ = Some(x.try_into().unwrap());\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphozaheg8.rs:19:16\n   |\n19 |\
    \         if x > largest {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphozaheg8.rs:20:28\n\
    \   |\n20 |             largest = Some(x);\n   |                            ^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n20 |             largest\
    \ = Some(x.try_into().unwrap());\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphozaheg8.rs:23:17\n   |\n23 |\
    \     (None, Some(largest))\n   |                 ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(max_val), Some(min_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqgxzhl6x.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqgxzhl6x.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqgxzhl6x.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqgxzhl6x.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqgxzhl6x.rs:23:11\n\
    \   |\n23 |     (Some(max_val), Some(min_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(max_val.try_into().unwrap()),\
    \ Some(min_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqgxzhl6x.rs:23:26\n   |\n23 |     (Some(max_val),\
    \ Some(min_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(max_val), Some(min_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for x in lst {\n        if x < 0 {\n      \
    \      largest = Some(x);\n        } else {\n            smallest = Some(x);\n\
    \        }\n    }\n    (largest, smallest)\n}\n\nfn main() {\n    let candidate\
    \ = largest_smallest_integers;\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]),\
    \ (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7, 0]), (None,\
    \ Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6, -2]), (Some(-2),\
    \ Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7, -7]), (Some(-7),\
    \ Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2, 5, -9]), (Some(-9),\
    \ Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()), (None, None));\n\
    \    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(7))`,\n right: `(None, Some(1))`', /tmp/tmp1d4fkfsa.rs:27:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010691
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for v in lst {\n        if v < min_val\
    \ {\n            min_val = v;\n        }\n        if v > max_val {\n         \
    \   max_val = v;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (Some(max_val), None) if max_val == std::i32::MIN => (None,\
    \ None)\n    (None, None)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpi62l1pm4.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi62l1pm4.rs:16:16\n   |\n16 |         if v < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if v < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi62l1pm4.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = v;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpi62l1pm4.rs:19:16\n   |\n19 |         if v > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if v > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi62l1pm4.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = v;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for elt in lst {\n        if elt <\
    \ min_val {\n            min_val = elt;\n        }\n        if elt > max_val {\n\
    \            max_val = elt;\n        }\n    }\n    (Some(min_val), Some(max_val))\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfxseddcu.rs:16:18\n   |\n\
    16 |         if elt < min_val {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |         if elt < min_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfxseddcu.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfxseddcu.rs:19:18\n\
    \   |\n19 |         if elt > max_val {\n   |                  ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n19 |         if elt > max_val.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfxseddcu.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = elt;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfxseddcu.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfxseddcu.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: abo"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    (Some(max_val), None) if max_val == std::i32::MIN => (None,\
    \ None)\n    (None, None)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpc3fq4qrl.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpc3fq4qrl.rs:16:16\n   |\n16 |         if x < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if x < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc3fq4qrl.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc3fq4qrl.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for v in lst {\n        if v < min_val\
    \ {\n            min_val = v;\n        }\n        if v > max_val {\n         \
    \   max_val = v;\n        }\n    }\n    (None, Some(min_val)) if min_val == std::i32::MAX\
    \ => (None, None)\n    else if max_val == std::i32::MIN => (None, None)\n    else\
    \ if min_val > max_val => (Some(min_val), None)\n    else if min_val == max_val\
    \ => (Some(min_val), Some(min_val))\n    else if min_val < max_val => (Some(min_val),\
    \ Some(max_val))\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpudn2h5_v.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == std::i32::MAX => (None, None)\n   |                          \
    \ ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpudn2h5_v.rs:16:16\n   |\n16 |         if v < min_val {\n\
    \   |                ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can\
    \ convert an `i32` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n16 |         if v < min_val.try_into().unwrap() {\n   |               \
    \        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpudn2h5_v.rs:17:23\n\
    \   |\n13 |     let mut min_val = std::i32::MAX;\n   |                       -------------\
    \ expected due to this value\n...\n17 |             min_val = v;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpudn2h5_v.rs:19:16\n   |\n19 |         if v > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if v > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpudn2h5_v.rs:20:23\n\
    \   |\n14 |     let mut max_val = std::i32::MIN;\n   |                       -------------\
    \ expected due to this value\n...\n20 |             max_val = v;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp2r5tdlz2.rs:17:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n17\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:19:16\n\
    \   |\n19 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2r5tdlz2.rs:20:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n20\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:11\n\
    \   |\n23 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2r5tdlz2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(max_negative.max());\n\
    \            }\n        } else {\n            if min_positive.is_none() {\n  \
    \              min_positive = Some(x);\n            } else {\n               \
    \ min_positive = Some(min_positive.min());\n            }\n        }\n    }\n\
    \    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpah0a0c2b.rs:20:50\n    |\n20  |                 max_negative =\
    \ Some(max_negative.max());\n    |                                           \
    \       ^^^- supplied 0 arguments\n    |                                     \
    \             |\n    |                                                  expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpah0a0c2b.rs:20:37\n   |\n20 |                 max_negative\
    \ = Some(max_negative.max());\n   |                                     ^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n   --> /tmp/tmpah0a0c2b.rs:26:50\n\
    \    |\n26  |                 min_positive = Some(min_positive.min());\n    |\
    \                                                  ^^^- supplied 0 arguments\n\
    \    |                                                  |\n    |             \
    \                                     expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpah0a0c2b.rs:26:37\n\
    \   |\n26 |                 min_positive = Some(min_positive.min());\n   |   \
    \                                  ^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (None, Some(min_val)) if min_val == i32::MAX =>\
    \ (None, None)\n    (Some(max_val), None) if max_val == i32::MIN => (None, None)\n\
    \    (None, None)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpughhz76j.rs:23:27\n   |\n23 |     (None, Some(min_val))\
    \ if min_val == i32::MAX => (None, None)\n   |                           ^^ expected\
    \ one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpughhz76j.rs:16:16\n   |\n16 |         if x < min_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    16 |         if x < min_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpughhz76j.rs:17:23\n\
    \   |\n13 |     let mut min_val = i32::MAX;\n   |                       --------\
    \ expected due to this value\n...\n17 |             min_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpughhz76j.rs:19:16\n   |\n19 |         if x > max_val {\n   |  \
    \              ^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert\
    \ an `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |         if x > max_val.try_into().unwrap() {\n   |                      \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpughhz76j.rs:20:23\n\
    \   |\n14 |     let mut max_val = i32::MIN;\n   |                       --------\
    \ expected due to this value\n...\n20 |             max_val = x;\n   |       \
    \                ^ expected `i32`, found `isize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = Some(std::i32::MAX);\n\
    \    let mut largest = Some(std::i32::MIN);\n    for x in lst {\n        if x\
    \ < smallest {\n            smallest = Some(x);\n        }\n        if x > largest\
    \ {\n            largest = Some(x);\n        }\n    }\n    (smallest, largest)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:16:16\n   |\n\
    16 |         if x < smallest {\n   |                ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:17:29\n\
    \   |\n17 |             smallest = Some(x);\n   |                            \
    \ ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n17 |             smallest\
    \ = Some(x.try_into().unwrap());\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:19:16\n   |\n19 |\
    \         if x > largest {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:20:28\n\
    \   |\n20 |             largest = Some(x);\n   |                            ^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n20 |             largest\
    \ = Some(x.try_into().unwrap());\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:23:6\n   |\n23 | \
    \    (smallest, largest)\n   |      ^^^^^^^^ expected `isize`, found `i32`\n \
    \  |\n   = note: expected enum `Option<isize>`\n              found enum `Option<i32>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:23:16\n   |\n23 |\
    \     (smallest, largest)\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\n   = note: expected enum `Option<isize>`\n              found enum\
    \ `Option<i32>`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = std::i32::MAX;\n\
    \    let mut max_val = std::i32::MIN;\n\n    for x in lst {\n        if x < min_val\
    \ {\n            min_val = x;\n        }\n        if x > max_val {\n         \
    \   max_val = x;\n        }\n    }\n\n    (Some(min_val), Some(max_val))\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprkx55h3t.rs:17:16\n   |\n\
    17 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprkx55h3t.rs:18:23\n   |\n13 |     let mut min_val = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n18\
    \ |             min_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprkx55h3t.rs:20:16\n\
    \   |\n20 |         if x > max_val {\n   |                ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |         if x > max_val.try_into().unwrap()\
    \ {\n   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprkx55h3t.rs:21:23\n   |\n14 |     let mut max_val = std::i32::MIN;\n\
    \   |                       ------------- expected due to this value\n...\n21\
    \ |             max_val = x;\n   |                       ^ expected `i32`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprkx55h3t.rs:25:11\n\
    \   |\n25 |     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected\
    \ `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and\
    \ panic if the converted value doesn't fit\n   |\n25 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprkx55h3t.rs:25:26\n   |\n25 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n25 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous "
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(max_negative.max());\n\
    \            }\n        } else {\n            if min_positive.is_none() {\n  \
    \              min_positive = Some(x);\n            } else {\n               \
    \ min_positive = Some(min_positive.min());\n            }\n        }\n    }\n\
    \    (max_negative, min_positive)\n}\n\nfn main() {\n    let candidate = largest_smallest_integers;\n\
    \    assert_eq!(candidate(vec![2, 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2,\
    \ 4, 5, 6, -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3,\
    \ 6, 2, 7, -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8,\
    \ 4, 9, 2, 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpah0a0c2b.rs:20:50\n    |\n20  |                 max_negative =\
    \ Some(max_negative.max());\n    |                                           \
    \       ^^^- supplied 0 arguments\n    |                                     \
    \             |\n    |                                                  expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpah0a0c2b.rs:20:37\n   |\n20 |                 max_negative\
    \ = Some(max_negative.max());\n   |                                     ^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n   --> /tmp/tmpah0a0c2b.rs:26:50\n\
    \    |\n26  |                 min_positive = Some(min_positive.min());\n    |\
    \                                                  ^^^- supplied 0 arguments\n\
    \    |                                                  |\n    |             \
    \                                     expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpah0a0c2b.rs:26:37\n\
    \   |\n26 |                 min_positive = Some(min_positive.min());\n   |   \
    \                                  ^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<isize>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(std::cmp::max(max_negative.unwrap(),\
    \ x));\n            }\n        } else {\n            if min_positive.is_none()\
    \ {\n                min_positive = Some(x);\n            } else {\n         \
    \       min_positive = Some(std::cmp::min(min_positive.unwrap(), x));\n      \
    \      }\n        }\n    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpj07877ac.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut min_val = i32::MAX;\n\
    \    let mut max_val = i32::MIN;\n    for x in lst {\n        if x < min_val {\n\
    \            min_val = x;\n        }\n        if x > max_val {\n            max_val\
    \ = x;\n        }\n    }\n    (Some(min_val), Some(max_val))\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:16:16\n   |\n\
    16 |         if x < min_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n16 |         if x < min_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:17:23\n   |\n13 |     let mut min_val = i32::MAX;\n\
    \   |                       -------- expected due to this value\n...\n17 |   \
    \          min_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:19:16\n   |\n19 |\
    \         if x > max_val {\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |         if x > max_val.try_into().unwrap() {\n\
    \   |                       ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnp4hr3u2.rs:20:23\n   |\n14 |     let mut max_val = i32::MIN;\n\
    \   |                       -------- expected due to this value\n...\n20 |   \
    \          max_val = x;\n   |                       ^ expected `i32`, found `isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:11\n   |\n23 |\
    \     (Some(min_val), Some(max_val))\n   |           ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n23 |     (Some(min_val.try_into().unwrap()),\
    \ Some(max_val))\n   |                  ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnp4hr3u2.rs:23:26\n   |\n23 |     (Some(min_val),\
    \ Some(max_val))\n   |                          ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     (Some(min_val), Some(max_val.try_into().unwrap()))\n\
    \   |                                 ++++++++++++++++++++\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more inf"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for x in lst {\n        if x < 0 {\n      \
    \      if smallest == None {\n                smallest = Some(x);\n          \
    \  } else {\n                smallest = Some(std::cmp::min(smallest, Some(x)));\n\
    \            }\n        } else {\n            if largest == None {\n         \
    \       largest = Some(x);\n            } else {\n                largest = Some(std::cmp::max(largest,\
    \ Some(x)));\n            }\n        }\n    }\n    (largest, smallest)\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5moh54lo.rs:20:47\n   |\n\
    20 |                 smallest = Some(std::cmp::min(smallest, Some(x)));\n   |\
    \                                               ^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5moh54lo.rs:20:57\n\
    \   |\n20 |                 smallest = Some(std::cmp::min(smallest, Some(x)));\n\
    \   |                                                         ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5moh54lo.rs:26:46\n   |\n26 |                 largest = Some(std::cmp::max(largest,\
    \ Some(x)));\n   |                                              ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5moh54lo.rs:26:55\n   |\n26 |                 largest = Some(std::cmp::max(largest,\
    \ Some(x)));\n   |                                                       ^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut smallest = Some(std::i32::MAX);\n\
    \    let mut largest = Some(std::i32::MIN);\n    for x in lst {\n        if x\
    \ < smallest {\n            smallest = Some(x);\n        }\n        if x > largest\
    \ {\n            largest = Some(x);\n        }\n    }\n    (smallest, largest)\n\
    }\n\nfn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:16:16\n   |\n\
    16 |         if x < smallest {\n   |                ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:17:29\n\
    \   |\n17 |             smallest = Some(x);\n   |                            \
    \ ^ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n17 |             smallest\
    \ = Some(x.try_into().unwrap());\n   |                              ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:19:16\n   |\n19 |\
    \         if x > largest {\n   |                ^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<i32>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:20:28\n\
    \   |\n20 |             largest = Some(x);\n   |                            ^\
    \ expected `i32`, found `isize`\n   |\nhelp: you can convert an `isize` to an\
    \ `i32` and panic if the converted value doesn't fit\n   |\n20 |             largest\
    \ = Some(x.try_into().unwrap());\n   |                             ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:23:6\n   |\n23 | \
    \    (smallest, largest)\n   |      ^^^^^^^^ expected `isize`, found `i32`\n \
    \  |\n   = note: expected enum `Option<isize>`\n              found enum `Option<i32>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyin3qhsb.rs:23:16\n   |\n23 |\
    \     (smallest, largest)\n   |                ^^^^^^^ expected `isize`, found\
    \ `i32`\n   |\n   = note: expected enum `Option<isize>`\n              found enum\
    \ `Option<i32>`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 101
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut max_negative =\
    \ None;\n    let mut min_positive = None;\n    for x in lst {\n        if x <\
    \ 0 {\n            if max_negative.is_none() {\n                max_negative =\
    \ Some(x);\n            } else {\n                max_negative = Some(std::cmp::max(max_negative.unwrap(),\
    \ x));\n            }\n        } else {\n            if min_positive.is_none()\
    \ {\n                min_positive = Some(x);\n            } else {\n         \
    \       min_positive = Some(std::cmp::min(min_positive.unwrap(), x));\n      \
    \      }\n        }\n    }\n    (max_negative, min_positive)\n}\n\nfn main() {\n\
    \    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(None, Some(0))`,\n right: `(None, Some(1))`', /tmp/tmpj07877ac.rs:36:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010690
- exit_code: 1
  program: "/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
    \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
    \ in a list.\n/// If there is no negative or positive integers, return them as\
    \ None.\n/// Examples:\n/// >>> largest_smallest_integers(vec![2, 4, 1, 3, 5,\
    \ 7])\n/// (None, Some(1))\n/// >>> largest_smallest_integers(vec![])\n/// (None,\
    \ None)\n/// >>> largest_smallest_integers(vec![0])\n/// (None, None)\nfn largest_smallest_integers(lst:\
    \ Vec<isize>) -> (Option<isize>, Option<isize>) {\n    let mut largest = None;\n\
    \    let mut smallest = None;\n    for x in lst {\n        if x < 0 {\n      \
    \      if smallest == None {\n                smallest = Some(x);\n          \
    \  } else {\n                smallest = Some(std::cmp::min(smallest, Some(x)));\n\
    \            }\n        } else {\n            if largest == None {\n         \
    \       largest = Some(x);\n            } else {\n                largest = Some(std::cmp::max(largest,\
    \ Some(x)));\n            }\n        }\n    }\n    (largest, smallest)\n}\n\n\
    fn main() {\n    let candidate = largest_smallest_integers;\n    assert_eq!(candidate(vec![2,\
    \ 4, 1, 3, 5, 7]), (None, Some(1)));\n    assert_eq!(candidate(vec![2, 4, 1, 3,\
    \ 5, 7, 0]), (None, Some(1)));\n    assert_eq!(candidate(vec![1, 3, 2, 4, 5, 6,\
    \ -2]), (Some(-2), Some(1)));\n    assert_eq!(candidate(vec![4, 5, 3, 6, 2, 7,\
    \ -7]), (Some(-7), Some(2)));\n    assert_eq!(candidate(vec![7, 3, 8, 4, 9, 2,\
    \ 5, -9]), (Some(-9), Some(2)));\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (None, None));\n    assert_eq!(candidate(vec![0]), (None, None));\n    assert_eq!(candidate(vec![-1,\
    \ -3, -5, -6]), (Some(-1), None));\n    assert_eq!(candidate(vec![-1, -3, -5,\
    \ -6, 0]), (Some(-1), None));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, 1]),\
    \ (Some(-3), Some(1)));\n    assert_eq!(candidate(vec![-6, -4, -4, -3, -100, 1]),\
    \ (Some(-3), Some(1)));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5moh54lo.rs:20:47\n   |\n\
    20 |                 smallest = Some(std::cmp::min(smallest, Some(x)));\n   |\
    \                                               ^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5moh54lo.rs:20:57\n\
    \   |\n20 |                 smallest = Some(std::cmp::min(smallest, Some(x)));\n\
    \   |                                                         ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5moh54lo.rs:26:46\n   |\n26 |                 largest = Some(std::cmp::max(largest,\
    \ Some(x)));\n   |                                              ^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5moh54lo.rs:26:55\n   |\n26 |                 largest = Some(std::cmp::max(largest,\
    \ Some(x)));\n   |                                                       ^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010690
