name: HumanEval_90_next_smallest
language: rs
prompt: "/// You are given a list of integers.\n/// Write a function next_smallest()\
  \ that returns the 2nd smallest element of the list.\n/// Return None if there is\
  \ no such element.\n/// >>> next_smallest(vec![1, 2, 3, 4, 5])\n/// Some(2)\n///\
  \ >>> next_smallest(vec![5, 1, 4, 3, 2])\n/// Some(2)\n/// >>> next_smallest(vec![])\n\
  /// None\n/// >>> next_smallest(vec![1, 1])\n/// None\nfn next_smallest(lst: Vec<isize>)\
  \ -> Option<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = next_smallest;\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n}\n"
completions: ["    let mut smallest = vec![std::i32::MAX; 2];\n    for elt in lst\
    \ {\n        if *elt < smallest[0] {\n            smallest[0] = *elt;\n      \
    \  }\n        if *elt < smallest[1] {\n            smallest[1] = *elt;\n     \
    \   }\n    }\n    smallest\n        .iter()\n        .next()\n        .map(|x|\
    \ x as isize)", "    let mut smallest = vec![std::i32::MAX; 2];\n    let mut smallest_idx\
    \ = 1;\n    for el in lst {\n        if el < smallest[smallest_idx] {\n      \
    \      smallest[smallest_idx] = el;\n            smallest_idx += 1;\n        }\n\
    \    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n    } else {\n\
    \        None\n    }", "    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for &x in lst {\n        if x < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = x;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n   \
    \ } else {\n        None\n    }", "    let mut smallest = lst.iter().min();\n\
    \    let mut smallest_index = 0;\n    for &i in lst {\n        if i < smallest\
    \ {\n            smallest_index += 1;\n            smallest = i;\n        }\n\
    \    }\n    Some(smallest)", "    if lst.len() == 0 {\n        return None;\n\
    \    }\n    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest[smallest_index\
    \ + 1])", "    let mut smallest = vec![std::i32::MAX; 2];\n    let mut smallest_idx\
    \ = 1;\n    for &i in lst {\n        if smallest[smallest_idx] < i {\n       \
    \     smallest[smallest_idx] = i;\n            smallest_idx += 1;\n        }\n\
    \    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n    } else {\n\
    \        None\n    }", "    let mut smallest = lst[0];\n    let mut smallest_index\
    \ = 0;\n    for &x in lst {\n        if x < smallest {\n            smallest =\
    \ x;\n            smallest_index = 1;\n        } else if x == smallest {\n   \
    \         smallest_index += 1;\n        }\n    }\n    if smallest_index == lst.len()\
    \ {\n        None\n    } else {\n        Some(smallest)\n    }", "    if lst.is_empty()\
    \ {\n        return None;\n    }\n    let mut smallest = lst.iter().min().unwrap();\n\
    \    let mut smallest_index = lst.iter().position(|x| *x == smallest).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        smallest_index = 0;\n    }\n\
    \    Some(smallest)", '    lst.iter().cloned().enumerate().find(|(i, v)| v < &lst[i
    + 1]).map(|(i, v)| v)', "    let mut smallest = vec![std::i32::MAX; 2];\n    let\
    \ mut smallest_idx = 1;\n    for el in lst {\n        if el < smallest[smallest_idx]\
    \ {\n            smallest[smallest_idx] = el;\n            smallest_idx += 1;\n\
    \        }\n    }\n    if smallest_idx == 2 {\n        Some(smallest[1])\n   \
    \ } else {\n        None\n    }", "    if lst.is_empty() {\n        return None;\n\
    \    }\n    let mut smallest = lst.iter().min().unwrap();\n    let mut smallest_index\
    \ = lst.iter().position(|&x| x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() - 1 {\n        smallest_index = 0;\n    }\n    Some(smallest * smallest_index\
    \ + 1)", '    lst.iter().cloned().enumerate().find(|(_, i)| i < lst.len() - 2).map(|(_,
    i)| lst[i + 1])', "    let mut smallest = lst.iter().min().unwrap();\n    let\
    \ mut smallest_index = 0;\n    for &i in lst {\n        if i == smallest {\n \
    \           smallest_index += 1;\n        }\n        if i == smallest {\n    \
    \        break;\n        }\n    }\n    Some(smallest * smallest_index)", "   \
    \ let mut smallest = lst.iter().min();\n    let mut smallest_idx = lst.iter().position(|&x|\
    \ x == smallest);\n    if smallest_idx == lst.len() {\n        return None;\n\
    \    }\n    let mut smallest_idx = smallest_idx + 1;\n    if smallest_idx < lst.len()\
    \ {\n        smallest = lst.iter().nth(smallest_idx).unwrap();\n    }\n    Some(smallest)",
  "    if lst.is_empty() {\n        return None;\n    }\n    let mut smallest = lst.iter().min().unwrap();\n\
    \    let mut smallest_index = lst.iter().position(|&x| x == smallest).unwrap();\n\
    \    if smallest_index == lst.len() - 1 {\n        smallest_index = 0;\n    }\n\
    \    Some(smallest)", "    let mut smallest = lst.iter().min();\n    let mut smallest_index\
    \ = lst.iter().position(|x| *x == smallest).unwrap();\n    if smallest_index ==\
    \ lst.len() {\n        return None;\n    }\n    let mut second_smallest = lst.iter().skip(smallest_index).min();\n\
    \    let mut second_smallest_index = lst.iter().position(|x| *x == second_smallest).unwrap();\n\
    \    if second_smallest_index == lst.len() {\n        return None;\n    }\n  \
    \  Some(second_smallest)", "    let mut smallest = vec![std::i32::MAX; 2];\n \
    \   for elt in lst {\n        if smallest[0] < elt {\n            smallest[0]\
    \ = elt;\n        }\n        if smallest[1] < elt {\n            smallest[1] =\
    \ elt;\n        }\n    }\n    if smallest[0] < smallest[1] {\n        Some(smallest[0])\n\
    \    } else {\n        None\n    }", "    let mut smallest = lst.iter().min().unwrap();\n\
    \    let mut smallest_index = lst.iter().position(|x| x == smallest).unwrap();\n\
    \    if smallest_index == lst.len() {\n        return None;\n    }\n    let mut\
    \ second_smallest = lst.iter().skip(smallest_index).min().unwrap();\n    let mut\
    \ second_smallest_index = lst.iter().position(|x| x == second_smallest).unwrap();\n\
    \    if second_smallest_index == lst.len() {\n        return None;\n    }\n  \
    \  Some(second_smallest)", "    if lst.len() == 0 {\n        return None;\n  \
    \  }\n    let mut smallest = vec![lst[0]];\n    let mut smallest_idx = 1;\n  \
    \  for &x in lst {\n        if x < smallest[smallest_idx] {\n            smallest[smallest_idx]\
    \ = x;\n            smallest_idx += 1;\n        }\n    }\n    Some(smallest[smallest_idx\
    \ - 1])", "    let mut smallest = vec![lst[0]];\n    let mut smallest_index =\
    \ 0;\n    for &i in lst {\n        if *i < smallest[smallest_index] {\n      \
    \      smallest[smallest_index] = *i;\n            smallest_index += 1;\n    \
    \    }\n    }\n    if smallest_index == 0 {\n        return None;\n    }\n   \
    \ let mut smallest_value = smallest[0];\n    for &i in &smallest[1..] {\n    \
    \    if *i < smallest_value {\n            smallest_value = *i;\n        }\n \
    \   }\n    Some(smallest_value)"]
stop_tokens:
- "\n}"
