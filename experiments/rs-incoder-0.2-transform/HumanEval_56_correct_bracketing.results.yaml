language: rs
name: HumanEval_56_correct_bracketing
results:
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\"\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp77vopu4g.rs:75:21\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n75 |     brackets.replace(\"<\", \"\"\n   |                     ^\
    \ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp77vopu4g.rs:75:5\n   |\n11 |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                              ---- expected\
    \ `bool` because of return type\n...\n75 | /     brackets.replace(\"<\", \"\"\n\
    76 | | }\n   | |_^ expected `bool`, found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnqvl2npt.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_brackets_iter = brackets.chars().enumerate();\n    let mut\
    \ closing_brackets_iter = brackets.chars().enumerate();\n    let mut opening_brackets_next\
    \ = opening_brackets_iter.next();\n    let mut closing_brackets_next = closing_brackets_iter.next();\n\
    \    while let Some((index, char)) = opening_brackets_next {\n        if char\
    \ == '>' {\n            if opening_brackets.is_empty() {\n                opening_brackets\
    \ = String::from(char.to_string());\n                opening_brackets_next = opening_brackets_iter.next();\n\
    \            } else {\n                opening_brackets = opening_brackets.push_str(char.to_string());\n\
    \                opening_brackets_next = opening_brackets_iter.next();\n     \
    \       }\n        } else if char == '<' {\n            if closing_brackets.is_empty()\
    \ {\n                closing_brackets = String::from(char.to_string());\n    \
    \            closing_brackets_next = closing_brackets_iter.next();\n         \
    \   } else {\n                closing_brackets = closing_brackets.push_str(char.to_string());\n\
    \                closing_brackets_next = closing_brackets_iter.next();\n     \
    \       }\n        } else {\n            opening_brackets = opening_brackets.push_str(char.to_string());\n\
    \            opening_brackets_next = opening_brackets_iter.next();\n        }\n\
    \    }\n    while let Some((index, char)) = closing_brackets_next {\n        if\
    \ char == '>' {\n            if closing_brackets.is_empty() {\n              \
    \  closing_brackets = String::from(char.to_string());\n                closing_brackets_next\
    \ = closing_brackets_iter.next();\n            } else {\n                closing_brackets\
    \ = closing_brackets.push_str(char.to_string());\n                closing_brackets_next\
    \ = closing_brackets_iter.next();\n            }\n        } else if char == '<'\
    \ {\n            if opening_brackets.is_empty() {\n                opening_brackets\
    \ = String::from(char.to_string());\n                opening_brackets_next = opening_brackets_iter.next();\n\
    \            } else {\n                opening_brackets = opening_brackets.push_str(char.to_string());\n\
    \                opening_brackets_\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpp1zhvb6q.rs:72:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n40 |     while\
    \ let Some((index, char)) = closing_brackets_next {\n   |                    \
    \                                       - unclosed delimiter\n...\n49 |      \
    \   } else if char == '<' {\n   |                               - unclosed delimiter\n\
    ...\n53 |             } else {\n   |                    - this delimiter might\
    \ not be properly closed...\n...\n56 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n72 | }\n   |   ^\n\nerror[E0425]: cannot find\
    \ value `opening_brackets_` in this scope\n  --> /tmp/tmpp1zhvb6q.rs:55:17\n \
    \  |\n55 |                 opening_brackets_\n   |                 ^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `opening_brackets`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp1zhvb6q.rs:24:62\n   |\n24 |              \
    \   opening_brackets = opening_brackets.push_str(char.to_string());\n   |    \
    \                                                          ^^^^^^^^^^^^^^^^\n\
    \   |                                                              |\n   |   \
    \                                                           expected `&str`, found\
    \ struct `String`\n   |                                                      \
    \        help: consider borrowing here: `&char.to_string()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp1zhvb6q.rs:24:36\n   |\n12 |     let mut opening_brackets\
    \ = String::new();\n   |                                ------------- expected\
    \ due to this value\n...\n24 |                 opening_brackets = opening_brackets.push_str(char.to_string());\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmpp1zhvb6q.rs:24:53\n   |\n24 |         \
    \        opening_brackets = opening_brackets.push_str(char.to_string());\n   |\
    \                 "
  stdout: ''
  timestamp: 1660011549
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for c in brackets.chars() {\n        if c == '<' {\n\
    \            stack.push(c);\n        } else if c == '>' {\n            if stack.is_empty()\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n            stack.push(c);\n       \
    \ }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_count = String::new();\n    let mut close_brackets_count\
    \ = String::new();\n\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '<' {\n            open_brackets.push('>');\n            open_brackets_count.push('<');\n\
    \        } else if bracket == '>' {\n            close_brackets.push('<');\n \
    \           close_brackets_count.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            open_brackets_count.push(bracket);\n        }\n    }\n\n    if open_brackets.len()\
    \ != close_brackets.len() {\n        return false;\n    }\n\n    for i in 0..open_brackets.len()\
    \ {\n        if open_brackets_count[i] != close_brackets_count[i] {\n        \
    \    return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuh1tpcay.rs:35:12\n\
    \   |\n35 |         if open_brackets_count[i] != close_brackets_count[i] {\n \
    \  |            ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpuh1tpcay.rs:35:38\n   |\n35 |         if open_brackets_count[i]\
    \ != close_brackets_count[i] {\n   |                                      ^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \n    for bracket in brackets.chars() {\n        if bracket == '<' {\n       \
    \     open_brackets.push('>');\n            close_brackets.push('<');\n      \
    \  } else if bracket == '>' {\n            open_brackets.push('<');\n        \
    \    close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \        }\n    }\n\n    open_brackets.chars().all(|c| close_brackets.chars().any(|c|\
    \ c == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxw9sutu5.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp_2n3kwal.rs:82:56\n\
    \   |\n82 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n83 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.chars().enumerate().filter(|(_, c)|\
    \ c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmptpi3kkr5.rs:32:1\n   |\n32\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmptpi3kkr5.rs:31:55\n\
    \   |\n31 |     let mut close_brackets_iter = close_brackets_iter.\n   |     \
    \                                                  ^ help: add `;` here\n32 |\
    \ }\n   | - unexpected token\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmptpi3kkr5.rs:14:81\n   |\n14 |     let mut open_brackets_iter =\
    \ brackets.chars().enumerate().filter(|(_, c)| c != '<').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmptpi3kkr5.rs:15:82\n   |\n15 |     let mut close_brackets_iter =\
    \ brackets.chars().enumerate().filter(|(_, c)| c != '>').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \          ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptpi3kkr5.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = String::new();\n   \
    \ let mut closing_brackets = String::new();\n    let mut opening_brackets_count\
    \ = String::new();\n    let mut closing_brackets_count = String::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_lwb8a0j.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut close_bracket\
    \ = String::new();\n\n        if brackets.starts_with(\"<<\") {\n            open_bracket\
    \ = brackets.split_off(1).unwrap();\n            close_bracket = brackets.split_off(1).unwrap();\n\
    \            brackets = brackets.split_off(1).unwrap();\n        }\n        if\
    \ brackets.starts_with(\">>\") {\n            open_bracket = brackets.split_off(1).unwrap();\n\
    \            close_bracket = brackets.split_off(1).unwrap();\n            brackets\
    \ = brackets.split_off(1).unwrap();\n        }\n        if brackets.starts_with(\"\
    <\") {\n            open_bracket = brackets.split_off(1).unwrap();\n         \
    \   close_bracket = brackets.split_off(1).unwrap();\n            brackets = brackets.split_off(1).unwrap();\n\
    \        }\n        if brackets.starts_with(\">\") {\n            open_bracket\
    \ = brackets.split_off(1).unwrap();\n            close_bracket = brackets.split_off(1).unwrap();\n\
    \            brackets = brackets.split_off(1).unwrap();\n        }\n\n       \
    \ if open_bracket.len() == 0 {\n            open_brackets = open_brackets.to_string()\
    \ + open_bracket.to_string();\n        } else {\n            open_brackets = open_brackets.to_string()\
    \ + open_bracket.to_string() + \">\";\n        }\n\n        if close_bracket.len()\
    \ == 0 {\n            close_brackets = close_brackets.to_string() + close_bracket.to_string();\n\
    \        } else {\n            close_brackets = close_brackets.to_string() + close_bracket.to_string()\
    \ + \"<\";\n        }\n    }\n\n    open_brackets == close_brackets\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpe9s4w6ak.rs:21:50\n   |\n21 |             open_bracket\
    \ = brackets.split_off(1).unwrap();\n   |                                    \
    \              ^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `unwrap` found for struct `String` in the current scope\n  --> /tmp/tmpe9s4w6ak.rs:22:51\n\
    \   |\n22 |             close_bracket = brackets.split_off(1).unwrap();\n   |\
    \                                                   ^^^^^^ method not found in\
    \ `String`\n\nerror[E0599]: no method named `unwrap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpe9s4w6ak.rs:23:46\n   |\n23 |          \
    \   brackets = brackets.split_off(1).unwrap();\n   |                         \
    \                     ^^^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpe9s4w6ak.rs:26:50\n   |\n26 |             open_bracket = brackets.split_off(1).unwrap();\n\
    \   |                                                  ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `unwrap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpe9s4w6ak.rs:27:51\n   |\n27 |          \
    \   close_bracket = brackets.split_off(1).unwrap();\n   |                    \
    \                               ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpe9s4w6ak.rs:28:46\n   |\n28 |             brackets = brackets.split_off(1).unwrap();\n\
    \   |                                              ^^^^^^ method not found in\
    \ `String`\n\nerror[E0599]: no method named `unwrap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpe9s4w6ak.rs:31:50\n   |\n31 |          \
    \   open_bracket = brackets.split_off(1).unwrap();\n   |                     \
    \                             ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpe9s4w6ak.rs:32"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\"\
    );\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpbt19xjw9.rs:91:56\n\
    \   |\n91 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n92 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp69g8o027.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        let next = stack.last().unwrap();\n        if next == ']'\
    \ {\n            stack.pop();\n        } else {\n            stack.push(next);\n\
    \        }\n        if stack.len() == 0 {\n            return false;\n       \
    \ }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp5yb36qmn.rs:16:17\n\
    \   |\n16 |         if next == ']' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp5yb36qmn.rs:19:24\n   |\n19 |  \
    \           stack.push(next);\n   |                        ^^^^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |   \
    \          stack.push(*next);\n   |                        +\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c >= '<' && c <= '>'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvmahyqct.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(item) = stack.last() {\n        if item == '<' {\n       \
    \     if stack.len() > 0 {\n                let next = stack.last().unwrap();\n\
    \                if next == '>' {\n                    stack.pop();\n        \
    \        } else {\n                    return false;\n                }\n    \
    \        } else {\n                return false;\n            }\n        } else\
    \ {\n            if stack.len() > 0 {\n                let next = stack.last().unwrap();\n\
    \                if next == '>' {\n                    stack.pop();\n        \
    \        } else {\n                    return false;\n                }\n    \
    \        } else {\n                return false;\n            }\n        }\n \
    \       stack.push(item);\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpleqqq55g.rs:15:17\n\
    \   |\n15 |         if item == '<' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpleqqq55g.rs:18:25\n\
    \   |\n18 |                 if next == '>' {\n   |                         ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpleqqq55g.rs:29:25\n\
    \   |\n29 |                 if next == '>' {\n   |                         ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpleqqq55g.rs:38:20\n\
    \   |\n38 |         stack.push(item);\n   |                    ^^^^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n38 |   \
    \      stack.push(*item);\n   |                    +\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for c in brackets.chars() {\n        if c == '<' {\n\
    \            stack.push(c);\n        } else if c == '>' {\n            if stack.is_empty()\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            if stack.is_empty() {\n                return false;\n\
    \            }\n            stack.pop();\n            stack.push(c);\n       \
    \ }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        if open != '>' {\n       \
    \     return false;\n        }\n        stack.pop();\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1dn3mmnr.rs:15:17\n\
    \   |\n15 |         if open != '>' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c >= '<' && c <= '>'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvmahyqct.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<\"\
    , \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    brackets.replace(\"<<<\",\
    \ \"\");\n    brackets.replace(\">>>\", \"\");\n    bracket\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpq5am6gdz.rs:72:5\n\
    \   |\n72 |     bracket\n   |     ^^^^^^^ help: a local variable with a similar\
    \ name exists: `brackets`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 0 {\n     \
    \   let mut opening = brackets.chars().next().unwrap();\n        let mut closing\
    \ = brackets.chars().next().unwrap();\n        if opening != closing {\n     \
    \       return false;\n        }\n        brackets = brackets.chars().next().unwrap();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxhtelzjm.rs:19:20\n   |\n\
    12 |     let mut brackets = brackets.to_string();\n   |                      \
    \  -------------------- expected due to this value\n...\n19 |         brackets\
    \ = brackets.chars().next().unwrap();\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \  |\n   |                    expected struct `String`, found `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\"\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp77vopu4g.rs:75:21\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n75 |     brackets.replace(\"<\", \"\"\n   |                     ^\
    \ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp77vopu4g.rs:75:5\n   |\n11 |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                              ---- expected\
    \ `bool` because of return type\n...\n75 | /     brackets.replace(\"<\", \"\"\n\
    76 | | }\n   | |_^ expected `bool`, found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = Vec::new();\n    let\
    \ mut closing_brackets = Vec::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mu\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpebog5ti4.rs:50:11\n   |\n\
    50 |     let mu\n   |           ^ help: add `;` here\n51 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpebog5ti4.rs:11:44\n \
    \  |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() != 0 {\n      \
    \          return false;\n            }\n        }\n    }\n    stack.len() ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnqvl2npt.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \    loop {\n        if stack.is_empty() {\n            return false;\n      \
    \  }\n        let mut current = stack.pop().unwrap();\n        if current == \"\
    >\" {\n            stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \        } else if current == \"<\" {\n            stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n        } else {\n            return\
    \ false;\n        }\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpkrqkr5e0.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0277]: can't compare `Vec<char>` with\
    \ `&str`\n  --> /tmp/tmpkrqkr5e0.rs:19:20\n   |\n19 |         if current == \"\
    >\" {\n   |                    ^^ no implementation for `Vec<char> == &str`\n\
    \   |\n   = help: the trait `PartialEq<&str>` is not implemented for `Vec<char>`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as\
    \ PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n      \
    \       <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for reference `&char` in the current scope\n  --> /tmp/tmpkrqkr5e0.rs:20:59\n\
    \   |\n20 |             stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \   |                                                           ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0277]:\
    \ can't compare `Vec<char>` with `&str`\n  --> /tmp/tmpkrqkr5e0.rs:21:27\n   |\n\
    21 |         } else if current == \"<\" {\n   |                           ^^ no\
    \ implementation for `Vec<char> == &str`\n   |\n   = help: the trait `PartialEq<&str>`\
    \ is not implemented for `Vec<char>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0599]: no method\
    \ named `i"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"<<<>>>\"\
    , \"\");\n    brackets.replace(\"<<<>>>\", \"\");\n    brackets.replace(\"\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpkmz_1v8y.rs:80:56\n\
    \   |\n80 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n81 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<String> = vec![];\n    stack.push(brackets);\n    while let Some(brackets)\
    \ = stack.pop() {\n        if brackets.len() == 1 {\n            if brackets[0]\
    \ == '<' {\n                stack.push(brackets);\n            } else {\n    \
    \            return false;\n            }\n        } else {\n            if brackets[0]\
    \ == '<' {\n                stack.push(brackets.clone());\n            } else\
    \ {\n                return false;\n            }\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmphopeut2u.rs:16:16\n   |\n16 |             if brackets[0] == '<' {\n\
    \   |                ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n \
    \  |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmphopeut2u.rs:22:16\n   |\n22 |             if brackets[0] == '<'\
    \ {\n   |                ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    bracket\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpc3zy_gst.rs:72:5\n\
    \   |\n72 |     bracket\n   |     ^^^^^^^ help: a local variable with a similar\
    \ name exists: `brackets`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else if bracket == '{' {\n          \
    \  open_brackets.push('}');\n            close_brackets.push('{');\n        }\
    \ else if bracket == '}' {\n            open_brackets.push('{');\n           \
    \ close_brackets.push('}');\n        } else if bracket == '(' {\n            open_brackets.push(')');\n\
    \            close_brackets.push('(');\n        } else if bracket == ')' {\n \
    \           open_brackets.push('(');\n            close_brackets.push(')');\n\
    \        }\n    }\n    open_brackets.chars().all(|c| close_brackets.chars().any(|c|\
    \ c == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpu07ia463.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c >= '<' && c <= '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb07ik0lp.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut closed_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut closed_bracket\
    \ = String::new();\n        if brackets.starts_with(\"<<\") {\n            open_bracket\
    \ = \"<\";\n            closed_bracket = \">\";\n        } else if brackets.starts_with(\"\
    <>\") {\n            open_bracket = \"<\";\n            closed_bracket = \">\"\
    ;\n        } else if brackets.starts_with(\">>\") {\n            open_bracket\
    \ = \">\";\n            closed_bracket = \">\";\n        } else if brackets.starts_with(\"\
    <<<\") {\n            open_bracket = \"<\";\n            closed_bracket = \">\"\
    ;\n        } else {\n            return false;\n        }\n        open_brackets\
    \ += open_bracket;\n        closed_brackets += closed_bracket;\n        brackets\
    \ = &brackets[2..];\n    }\n    open_brackets == closed_brackets\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe86w14it.rs:19:28\n   |\n\
    16 |         let mut open_bracket = String::new();\n   |                     \
    \           ------------- expected due to this value\n...\n19 |             open_bracket\
    \ = \"<\";\n   |                            ^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                            |\n   |            \
    \                expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe86w14it.rs:20:30\n   |\n17 |         let mut closed_bracket\
    \ = String::new();\n   |                                  ------------- expected\
    \ due to this value\n...\n20 |             closed_bracket = \">\";\n   |     \
    \                         ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                              |\n   |                              expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe86w14it.rs:22:28\n\
    \   |\n16 |         let mut open_bracket = String::new();\n   |              \
    \                  ------------- expected due to this value\n...\n22 |       \
    \      open_bracket = \"<\";\n   |                            ^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                            |\n   |\
    \                            expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe86w14it.rs:23:30\n   |\n17 |         let mut\
    \ closed_bracket = String::new();\n   |                                  -------------\
    \ expected due to this value\n...\n23 |             closed_bracket = \">\";\n\
    \   |                              ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                              |\n   |                              expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe86w14it.rs:25:28\n\
    \   |\n16 |         let mut open_bracket = String::new();\n   |              \
    \                  ------------- expected due to this value\n...\n25 |       \
    \      open_bracket = \">\";\n   |                            ^^^- help: try using\
    \ a conv"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut close_brackets_stack_size = close_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_end = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_end_ptr = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_end_ptr_end = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_end_ptr_end_ptr = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end_ptr_end = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_end_ptr_end_ptr_end = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end_ptr\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4nvoz691.rs:30:52\n   |\n\
    30 |     let mut open_brackets_stack_ptr_end_ptr_end_ptr\n   |               \
    \                                     ^ help: add `;` here\n31 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4nvoz691.rs:11:44\n \
    \  |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    stack.push(brackets.chars().filter(|c| c == '<').count());\n\
    \    while stack.len() > 0 {\n        let mut opening = stack.pop().unwrap();\n\
    \        let mut closing = stack.pop().unwrap();\n        if opening > closing\
    \ {\n            return false;\n        }\n        if opening < closing {\n  \
    \          stack.push(String::from(\"</>\"));\n        } else {\n            stack.push(String::from(\"\
    <\"));\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp42fbvrw_.rs:13:46\n\
    \   |\n13 |     stack.push(brackets.chars().filter(|c| c == '<').count());\n \
    \  |                                              ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp42fbvrw_.rs:21:24\n   |\n21 |             stack.push(String::from(\"\
    </>\"));\n   |                        ^^^^^^^^^^^^^^^^^^^ expected `usize`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp42fbvrw_.rs:23:24\n\
    \   |\n23 |             stack.push(String::from(\"<\"));\n   |               \
    \         ^^^^^^^^^^^^^^^^^ expected `usize`, found struct `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\"\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp77vopu4g.rs:75:21\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n75 |     brackets.replace(\"<\", \"\"\n   |                     ^\
    \ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp77vopu4g.rs:75:5\n   |\n11 |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                              ---- expected\
    \ `bool` because of return type\n...\n75 | /     brackets.replace(\"<\", \"\"\n\
    76 | | }\n   | |_^ expected `bool`, found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\">>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<><>><\"\
    , \"\");\n    brackets.replace(\"<<><>><\", \"\");\n    brackets.replace(\"<<\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpdqx3pe89.rs:76:56\n\
    \   |\n76 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n77 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_count = String::new();\n    let mut close_brackets_count\
    \ = String::new();\n    let mut open_brackets_count_map = String::new();\n   \
    \ let mut close_brackets_count_map = String::new();\n    let mut open_brackets_count_map_reverse\
    \ = String::new();\n    let mut close_brackets_count_map_reverse = String::new();\n\
    \    let mut open_brackets_count_map_reverse = String::new();\n    let mut close_brackets_count_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse = String::new();\n\
    \    let mut close_brackets_count_map_reverse = String::new();\n    let mut open_brackets_count_map_reverse\
    \ = String::new();\n    let mut close_brackets_count_map_reverse = String::new();\n\
    \    let mut open_brackets_count_map_reverse = String::new();\n    let mut close_brackets_count_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse = String::new();\n\
    \    let mut close_brackets_count_map_reverse = String::new();\n    let mut open_brackets_count_map_reverse\
    \ = String::new();\n    let mut close_brackets_count_map_reverse = String::new();\n\
    \    let mut open_brackets_count_map_reverse = String::new();\n    let mut close_brackets_count_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse = String::new();\n\
    \    let mut close_brackets_count_map_reverse = String::new();\n    let mut open_brackets_count_map_reverse\
    \ = String::new();\n    let mut close_brackets_count_map_reverse = String::new();\n\
    \    let mut open_brackets_count_map_reverse = String::new();\n    let mut close_brackets_count_map_reverse\
    \ = String::new();\n    let mut open_brackets_count_map_reverse = String::new();\n\
    \    let mut close_brackets_count_map_reverse = String::new();\n    let mut open_brackets_count_map_reverse\
    \ = String::new();\n    let mut \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp3z82mts0.rs:44:1\n\
    \   |\n44 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            return false;\n        }\n   \
    \ }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c >= '<' && c <= '>'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvmahyqct.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii()).collect::<Vec<_>>());\n\
    \    loop {\n        if stack.len() == 0 {\n            return false;\n      \
    \  }\n        let mut opening = stack.pop().unwrap();\n        if opening.is_ascii()\
    \ {\n            continue;\n        }\n        if opening.is_left_angle_bracket()\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            let mut closing = stack.pop().unwrap();\n            if\
    \ closing.is_ascii() {\n                continue;\n            }\n           \
    \ if closing.is_right_angle_bracket() {\n                stack.push(opening);\n\
    \            } else {\n                return false;\n            }\n        }\
    \ else {\n            return false;\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii` found for struct `Vec<char>` in\
    \ the current scope\n  --> /tmp/tmpn93d416c.rs:19:20\n   |\n19 |         if opening.is_ascii()\
    \ {\n   |                    ^^^^^^^^ method not found in `Vec<char>`\n\nerror[E0599]:\
    \ no method named `is_left_angle_bracket` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpn93d416c.rs:22:20\n   |\n22 |         if opening.is_left_angle_bracket()\
    \ {\n   |                    ^^^^^^^^^^^^^^^^^^^^^ method not found in `Vec<char>`\n\
    \nerror[E0599]: no method named `is_ascii` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpn93d416c.rs:27:24\n   |\n27 |             if closing.is_ascii()\
    \ {\n   |                        ^^^^^^^^ method not found in `Vec<char>`\n\n\
    error[E0599]: no method named `is_right_angle_bracket` found for struct `Vec<char>`\
    \ in the current scope\n  --> /tmp/tmpn93d416c.rs:30:24\n   |\n30 |          \
    \   if closing.is_right_angle_bracket() {\n   |                        ^^^^^^^^^^^^^^^^^^^^^^\
    \ method not found in `Vec<char>`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut closed_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut closed_bracket\
    \ = String::new();\n        if brackets.starts_with(\"<<\") {\n            open_bracket\
    \ = brackets.split_off(1).unwrap();\n            closed_bracket = brackets.split_off(1).unwrap();\n\
    \            brackets = brackets.split_off(1).unwrap();\n        } else if brackets.starts_with(\"\
    <\") {\n            open_bracket = brackets.split_off(1).unwrap();\n         \
    \   closed_bracket = String::from(\"<<\");\n            brackets = brackets.split_off(1).unwrap();\n\
    \        } else if brackets.starts_with(\">\") {\n            open_bracket = String::from(\"\
    <<\");\n            closed_bracket = brackets.split_off(1).unwrap();\n       \
    \     brackets = brackets.split_off(1).unwrap();\n        } else {\n         \
    \   open_bracket = String::from(\"<<\");\n            closed_bracket = String::from(\"\
    <<\");\n            brackets = brackets.split_off(1).unwrap();\n        }\n  \
    \      if open_bracket.len() == 1 {\n            open_brackets = open_brackets\
    \ + open_bracket;\n        } else {\n            open_brackets = open_brackets\
    \ + String::from(\"<\") + open_bracket;\n        }\n        if closed_bracket.len()\
    \ == 1 {\n            closed_brackets = closed_brackets + closed_bracket;\n  \
    \      } else {\n            closed_brackets = closed_brackets + String::from(\"\
    >\") + closed_bracket;\n        }\n    }\n    open_brackets == closed_brackets\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpb9amcj3v.rs:19:50\n   |\n19 |             open_bracket\
    \ = brackets.split_off(1).unwrap();\n   |                                    \
    \              ^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `unwrap` found for struct `String` in the current scope\n  --> /tmp/tmpb9amcj3v.rs:20:52\n\
    \   |\n20 |             closed_bracket = brackets.split_off(1).unwrap();\n   |\
    \                                                    ^^^^^^ method not found in\
    \ `String`\n\nerror[E0599]: no method named `unwrap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpb9amcj3v.rs:21:46\n   |\n21 |          \
    \   brackets = brackets.split_off(1).unwrap();\n   |                         \
    \                     ^^^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpb9amcj3v.rs:23:50\n   |\n23 |             open_bracket = brackets.split_off(1).unwrap();\n\
    \   |                                                  ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `unwrap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpb9amcj3v.rs:25:46\n   |\n25 |          \
    \   brackets = brackets.split_off(1).unwrap();\n   |                         \
    \                     ^^^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpb9amcj3v.rs:28:52\n   |\n28 |             closed_bracket = brackets.split_off(1).unwrap();\n\
    \   |                                                    ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `unwrap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpb9amcj3v.rs:29:46\n   |\n29 |          \
    \   brackets = brackets.split_off(1).unwrap();\n   |                         \
    \                     ^^^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpb9amcj3v.rs:33:46\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        if stack.is_empty() {\n            return false;\n      \
    \  }\n        let mut open = stack.pop().unwrap();\n        if open != '<' {\n\
    \            continue;\n        }\n        let mut close = stack.pop().unwrap();\n\
    \        if close != '>' {\n            continue;\n        }\n        stack.push(open);\n\
    \        stack.push(close);\n    }\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp3cjii3cm.rs:22:37

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp_olaza9.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = Vec::new();\n    let mut open_brackets: Vec<usize> =\
    \ Vec::new();\n    let mut close_brackets: Vec<usize> = Vec::new();\n    let mut\
    \ open_brackets_size: usize = 0;\n    let mut close_brackets_size: usize = 0;\n\
    \    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut \n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1x4shpe4.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnqvl2npt.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_bra\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6a1p5hbx.rs:50:22\n   |\n\
    50 |     let mut close_bra\n   |                      ^ help: add `;` here\n51\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6a1p5hbx.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = \n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpu2uqnkzl.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \n    for bracket in brackets.chars() {\n        if bracket == '<' {\n       \
    \     open_brackets.push('>');\n        } else if bracket == '>' {\n         \
    \   close_brackets.push('<');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpg8t1inqc.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \n    for bracket in brackets.chars() {\n        if bracket == '<' {\n       \
    \     open_brackets.push('>');\n        } else {\n            open_brackets.push('<');\n\
    \        }\n    }\n\n    for bracket in open_brackets.chars() {\n        if bracket\
    \ == '>' {\n            close_brackets.push('<');\n        } else {\n        \
    \    close_brackets.push('>');\n        }\n    }\n\n    close_brackets.chars().all(|c|\
    \ open_brackets.chars().any(|b| b == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpzzxus83n.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars() {\n        if\
    \ ch == '<' {\n            stack.push(0);\n        } else if ch == '>' {\n   \
    \         if stack.len() == 0 {\n                return false;\n            }\n\
    \            let top = stack.len();\n            stack.pop();\n            if\
    \ top != 0 {\n                return false;\n            }\n        } else {\n\
    \            if stack.len() == 0 {\n                return false;\n          \
    \  }\n            let top = stack.len();\n            stack.pop();\n         \
    \   stack.push(top);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpcfzpkaer.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_brackets_count = Vec::new();\n\
    \    let mut close_brackets_count = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ close_brackets_count_min = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_max = Vec::new();\n    let mut\
    \ close_brackets_count_max = Vec::new();\n    let mut open_brackets_count_min\
    \ = Vec::new();\n    let mut close_brackets_count_min = Vec::new();\n    let mut\
    \ open_brackets_count_max = Vec::new();\n    let mut close_brackets_count_max\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ close_brackets_count_min = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_max = Vec::new();\n    let mut\
    \ close_brackets_count_max = Vec::new();\n    let mut open_brackets_count_min\
    \ = Vec::new();\n    let mut close_brackets_count_min = Vec::new();\n    let mut\
    \ open_brackets_count_max = Vec::new();\n    let mut close_brackets_count_max\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ close_brackets_count_min = Vec::new\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7jrhnq9w.rs:46:48\n   |\n\
    46 |     let mut close_brackets_count_min = Vec::new\n   |                   \
    \                             ^ help: add `;` here\n47 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7jrhnq9w.rs:11:44\n \
    \  |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.chars().enumerate().filter(|(_, c)|\
    \ c != '<').collect::<Vec<_>>();\n    let mut close_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut open_brackets_iter = open_brackets_iter.into_iter().collect::<Vec<_>>();\n\
    \    let mut close_brackets_iter = close_brackets_iter.\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmptpi3kkr5.rs:32:1\n   |\n32\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmptpi3kkr5.rs:31:55\n\
    \   |\n31 |     let mut close_brackets_iter = close_brackets_iter.\n   |     \
    \                                                  ^ help: add `;` here\n32 |\
    \ }\n   | - unexpected token\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmptpi3kkr5.rs:14:81\n   |\n14 |     let mut open_brackets_iter =\
    \ brackets.chars().enumerate().filter(|(_, c)| c != '<').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmptpi3kkr5.rs:15:82\n   |\n15 |     let mut close_brackets_iter =\
    \ brackets.chars().enumerate().filter(|(_, c)| c != '>').collect::<Vec<_>>();\n\
    \   |                                                                        \
    \          ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptpi3kkr5.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    let mut opening_brackets = String::new();\n    let\
    \ mut closing_brackets = String::new();\n    let mut opening_brackets_stack =\
    \ vec![];\n    let mut closing_brackets_stack = vec![];\n    let mut opening_brackets_stack_size\
    \ = -1;\n    let mut closing_brackets_stack_size = -1;\n    let mut opening_brackets_stack\
    \ = vec![];\n    let mut closing_brackets_stack = vec![];\n    let mut opening_brackets_stack_size\
    \ = -1;\n    let mut closing_brackets_stack_size = -1;\n    let mut opening_brackets_stack\
    \ = vec![];\n    let mut closing_brackets_stack = vec![];\n    let mut opening_brackets_stack_size\
    \ = -1;\n    let mut closing_brackets_stack_size = -1;\n    let mut opening_brackets_stack\
    \ = vec![];\n    let mut closing_brackets_stack = vec![];\n    let mut opening_brackets_stack_size\
    \ = -1;\n    let mut closing_brackets_stack_size = -1;\n    let mut opening_brackets_stack\
    \ = vec![];\n    let mut closing_brackets_stack = vec![];\n    let mut opening_brackets_stack_size\
    \ = -1;\n    let mut closing_brackets_stack_size = -1;\n    let mut opening_brackets_stack\
    \ = vec![];\n    let mut closing_brackets_stack = vec![];\n    let mut opening_brackets_stack_size\
    \ = -1;\n    let mut closing_brackets_stack_size = -1;\n    let mut opening_brackets_stack\
    \ = vec![];\n    let mut closing_brackets_stack = vec![];\n    let mut opening_brackets_stack_size\
    \ = -1;\n    let mut closing_brackets_stack_size = -1;\n    let mut opening_brackets_stack\
    \ = vec![];\n    let mut closing_brackets_stack = vec![];\n    let mut opening_brackets_stack_size\
    \ = -1;\n    let mut closing_brackets_stack_size = -1;\n    let mut opening_brackets_stack\
    \ = vec![];\n    let mut closing_brackets_stack = vec![];\n    let mut opening_brackets_stack_size\
    \ = -1;\n    let mu\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpsckje1i0.rs:50:11\n   |\n\
    50 |     let mu\n   |           ^ help: add `;` here\n51 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsckje1i0.rs:11:44\n \
    \  |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for ch in brackets.chars() {\n        if ch == '<'\
    \ {\n            stack.push('<');\n        } else if ch == '>' {\n           \
    \ if stack.is_empty() {\n                return false;\n            }\n      \
    \      stack.pop();\n        } else {\n            if stack.is_empty() {\n   \
    \             return false;\n            }\n            stack.pop();\n       \
    \     stack.push(ch);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets {\n        if c == '<' {\n  \
    \          stack.push(c);\n        } else if c == '>' {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            return false;\n        }\n    }\n    stack.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2omac57x.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = \n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmps_s1dy4r.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut closed_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut closed_bracket\
    \ = String::new();\n        if brackets.starts_with(\"<<\") {\n            open_bracket\
    \ = brackets.split_off(1).unwrap();\n            closed_bracket = brackets.split_off(1).unwrap();\n\
    \            brackets = brackets.split_off(1).unwrap();\n        }\n        if\
    \ brackets.starts_with(\">>\") {\n            open_bracket = brackets.split_off(1).unwrap();\n\
    \            closed_bracket = brackets.split_off(1).unwrap();\n            brackets\
    \ = brackets.split_off(1).unwrap();\n        }\n        if brackets.starts_with(\"\
    <\") {\n            open_bracket = brackets.split_off(1).unwrap();\n         \
    \   closed_bracket = brackets.split_off(1).unwrap();\n            brackets = brackets.split_off(1).unwrap();\n\
    \        }\n        if brackets.starts_with(\">\") {\n            open_bracket\
    \ = brackets.split_off(1).unwrap();\n            closed_bracket = brackets.split_off(1).unwrap();\n\
    \            brackets = brackets.split_off(1).unwrap();\n        }\n        if\
    \ open_bracket.len() == 0 {\n            open_brackets = open_brackets.to_string()\
    \ + open_bracket;\n        }\n        if closed_bracket.len() == 0 {\n       \
    \     closed_brackets = closed_brackets.to_string() + closed_bracket;\n      \
    \  }\n    }\n    open_brackets == closed_brackets\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpu8dnfru2.rs:19:50\n   |\n19 |             open_bracket\
    \ = brackets.split_off(1).unwrap();\n   |                                    \
    \              ^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `unwrap` found for struct `String` in the current scope\n  --> /tmp/tmpu8dnfru2.rs:20:52\n\
    \   |\n20 |             closed_bracket = brackets.split_off(1).unwrap();\n   |\
    \                                                    ^^^^^^ method not found in\
    \ `String`\n\nerror[E0599]: no method named `unwrap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpu8dnfru2.rs:21:46\n   |\n21 |          \
    \   brackets = brackets.split_off(1).unwrap();\n   |                         \
    \                     ^^^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpu8dnfru2.rs:24:50\n   |\n24 |             open_bracket = brackets.split_off(1).unwrap();\n\
    \   |                                                  ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `unwrap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpu8dnfru2.rs:25:52\n   |\n25 |          \
    \   closed_bracket = brackets.split_off(1).unwrap();\n   |                   \
    \                                 ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpu8dnfru2.rs:26:46\n   |\n26 |             brackets = brackets.split_off(1).unwrap();\n\
    \   |                                              ^^^^^^ method not found in\
    \ `String`\n\nerror[E0599]: no method named `unwrap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpu8dnfru2.rs:29:50\n   |\n29 |          \
    \   open_bracket = brackets.split_off(1).unwrap();\n   |                     \
    \                             ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpu8dnfru2.r"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n    let mut open_brackets_idx:\
    \ usize = 0;\n    let mut close_brackets_idx: usize = 0;\n    let mut open_brackets_idx2:\
    \ usize = 0;\n    let mut close_brackets_idx2: usize = 0;\n    let mut open_brackets_idx3:\
    \ usize = 0;\n    let mut close_brackets_idx3: usize = 0;\n    let mut open_brackets_idx4:\
    \ usize = 0;\n    let mut close_brackets_idx4: usize = 0;\n    let mut open_brackets_idx5:\
    \ usize = 0;\n    let mut close_brackets_idx5: usize = 0;\n    let mut open_brackets_idx6:\
    \ usize = 0;\n    let mut close_brackets_idx6: usize = 0;\n    let mut open_brackets_idx7:\
    \ usize = 0;\n    let mut close_brackets_idx7: usize = 0;\n    let mut open_brackets_idx8:\
    \ usize = 0;\n    let mut close_brackets_idx8: usize = 0;\n    let mut open_brackets_idx9:\
    \ usize = 0;\n    let mut close_brackets_idx9: usize = 0;\n    let mut open_brackets_idx10:\
    \ usize = 0;\n    let mut close_brackets_idx10: usize = 0;\n    let mut open_brackets_idx11:\
    \ usize = 0;\n    let mut close_brackets_idx11: usize = 0;\n    let mut open_brackets_idx12:\
    \ usize = 0;\n    let mut close_brackets_idx12: usize = 0;\n    let mut open_brackets_idx13:\
    \ usize = 0;\n    let mut close_brackets_idx13: usize = 0;\n    let mut open_brackets_idx14:\
    \ usize = 0;\n    let mut close_brackets_idx14: usize = 0;\n    let mut open_brackets_idx15:\
    \ usize = 0;\n    let mut close_brackets_idx15: usize = 0;\n    let mut open_brackets_idx16:\
    \ usize = 0;\n    let mut close_bra\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpj3qnsxjq.rs:46:22\n   |\n\
    46 |     let mut close_bra\n   |                      ^ help: add `;` here\n47\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj3qnsxjq.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for c in brackets {\n        if c == '<' {\n            open_brackets.push(c);\n\
    \        } else if c == '>' {\n            close_brackets.push(c);\n        }\
    \ else {\n            return false;\n        }\n    }\n    if open_brackets.len()\
    \ != close_brackets.len() {\n        return false;\n    }\n    for c in open_brackets\
    \ {\n        if close_brackets.contains(&c) {\n            return false;\n   \
    \     }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpd3gp44lm.rs:14:14\n\
    \   |\n14 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: `String`\
    \ is not an iterator\n  --> /tmp/tmpd3gp44lm.rs:26:14\n   |\n26 |     for c in\
    \ open_brackets {\n   |              ^^^^^^^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnqvl2npt.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \n    for bracket in brackets.chars() {\n        if bracket == '<' {\n       \
    \     open_brackets.push('>');\n            close_brackets.push('<');\n      \
    \  } else if bracket == '>' {\n            open_brackets.push('<');\n        \
    \    close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx2_2io2u.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        if let Some(close) = brackets.chars().next()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpyhf9pwlv.rs:16:21\n\
    \   |\n16 |             if open != close {\n   |                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.chars().enumerate().rev();\n    let\
    \ mut close_brackets_iter = brackets.chars().enumerate().rev();\n    let mut open_brackets_next\
    \ = open_brackets_iter.next();\n    let mut close_brackets_next = close_brackets_iter.next();\n\
    \    while open_brackets_next.is_some() && close_brackets_next.is_some() {\n \
    \       let (open_bracket, close_bracket) = open_brackets_next.unwrap(), close_brackets_next.unwrap();\n\
    \        if open_bracket == '<' {\n            open_brackets.push_str(\"<<\");\n\
    \            open_brackets_next = open_brackets_iter.next();\n        }\n    \
    \    if open_bracket == '>' {\n            open_brackets.push_str(\">>\");\n \
    \           open_brackets_next = open_brackets_iter.next();\n        }\n     \
    \   if close_bracket == '<' {\n            close_brackets.push_str(\"<<\");\n\
    \            close_brackets_next = close_brackets_iter.next();\n        }\n  \
    \      if close_bracket == '>' {\n            close_brackets.push_str(\">>\");\n\
    \            close_brackets_next = close_brackets_iter.next();\n        }\n  \
    \  }\n    open_brackets.len() == close_brackets.len()\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `,`\n\
    \  --> /tmp/tmps1scemq6.rs:19:72\n   |\n19 |         let (open_bracket, close_bracket)\
    \ = open_brackets_next.unwrap(), close_brackets_next.unwrap();\n   |         \
    \                                                               ^ expected one\
    \ of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0277]: the trait bound `Chars<'_>:\
    \ ExactSizeIterator` is not satisfied\n    --> /tmp/tmps1scemq6.rs:14:63\n   \
    \  |\n14   |     let mut open_brackets_iter = brackets.chars().enumerate().rev();\n\
    \     |                                                               ^^^ the\
    \ trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n     |\n     =\
    \ help: the following other types implement trait `ExactSizeIterator`:\n     \
    \          &mut I\n               Args\n               ArgsOs\n              \
    \ ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n           \
    \    ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\n     = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\nnote: required\
    \ by a bound in `rev`\n\nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator`\
    \ is not satisfied\n    --> /tmp/tmps1scemq6.rs:15:64\n     |\n15   |     let\
    \ mut close_brackets_iter = brackets.chars().enumerate().rev();\n     |      \
    \                                                          ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0599]:\
    \ the method `next` exists for"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '>' || c == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx72fju7r.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.chars().enumerate().rev();\n    let\
    \ mut closed_brackets_iter = brackets.chars().enumerate().rev();\n    let mut\
    \ open_brackets_chars = String::new();\n    let mut closed_brackets_chars = String::new();\n\
    \    let mut open_brackets_chars_iter = open_brackets.chars().enumerate().rev();\n\
    \    let mut closed_brackets_chars_iter = closed_brackets.chars().enumerate().rev();\n\
    \    let mut open_brackets_chars_iter = open_brackets_chars.chars().enumerate().rev();\n\
    \    let mut closed_brackets_chars_iter = closed_brackets_chars.chars().enumerate().rev();\n\
    \    let mut open_brackets_chars_iter = open_brackets_chars.chars().enumerate().rev();\n\
    \    let mut closed_brackets_chars_iter = closed_brackets_chars.chars().enumerate().rev();\n\
    \    let mut open_brackets_chars_iter = open_brackets_chars.chars().enumerate().rev();\n\
    \    let mut closed_brackets_chars_iter = closed_brackets_chars.chars().enumerate().rev();\n\
    \    let mut open_brackets_chars_iter = open_brackets_chars.chars().enumerate().rev();\n\
    \    let mut closed_brackets_chars_iter = closed_brackets_chars.chars().enumerate().rev();\n\
    \    let mut open_brackets_chars_iter = open_brackets_chars.chars().enumerate().rev();\n\
    \    let mut closed_brackets_chars_iter = closed_brackets_chars.chars().enumerate().rev();\n\
    \    let mut open_brackets_chars_iter = open_brackets_chars.chars().enumerate().rev();\n\
    \    let mut closed_brackets_chars_iter = closed_brackets_chars.chars().enumerate().rev();\n\
    \    let mut open_brackets_chars_iter = open_brackets_chars.chars().enumerate().rev();\n\
    \    let mut closed_brackets_chars_iter = closed_brackets_chars.chars().enumerate().rev();\n\
    \    let mut open_brackets_chars_iter = open_brackets_chars.chars().enumerate().rev();\n\
    \    let mut closed_brackets_chars_iter = closed_brackets_chars.chars().enumerate().rev();\n\
    \    let mut open_brackets_chars_iter = open\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpc0_vmlcq.rs:36:44\n   |\n\
    36 |     let mut open_brackets_chars_iter = open\n   |                       \
    \                     ^ help: add `;` here\n37 | }\n   | - unexpected token\n\n\
    error[E0425]: cannot find value `open` in this scope\n  --> /tmp/tmpc0_vmlcq.rs:36:40\n\
    \   |\n36 |     let mut open_brackets_chars_iter = open\n   |                \
    \                        ^^^^ not found in this scope\n\nerror[E0277]: the trait\
    \ bound `Chars<'_>: ExactSizeIterator` is not satisfied\n    --> /tmp/tmpc0_vmlcq.rs:14:63\n\
    \     |\n14   |     let mut open_brackets_iter = brackets.chars().enumerate().rev();\n\
    \     |                                                               ^^^ the\
    \ trait `ExactSizeIterator` is not implemented for `Chars<'_>`\n     |\n     =\
    \ help: the following other types implement trait `ExactSizeIterator`:\n     \
    \          &mut I\n               Args\n               ArgsOs\n              \
    \ ArrayChunks<'_, T, N>\n               ArrayChunksMut<'_, T, N>\n           \
    \    ArrayWindows<'_, T, N>\n               Box<I, A>\n               Chunks<'_,\
    \ T>\n             and 109 others\n     = note: required because of the requirements\
    \ on the impl of `DoubleEndedIterator` for `Enumerate<Chars<'_>>`\nnote: required\
    \ by a bound in `rev`\n\nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator`\
    \ is not satisfied\n    --> /tmp/tmpc0_vmlcq.rs:15:65\n     |\n15   |     let\
    \ mut closed_brackets_iter = brackets.chars().enumerate().rev();\n     |     \
    \                                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut close_brackets_stack_size = close_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_ptr = &mut open_brackets_stack[..];\n    let mut close_brackets_stack_ptr\
    \ = &mut close_brackets_stack[..];\n    let mut open_brackets_stack_ptr_end =\
    \ &mut open_brackets_stack[..];\n    let mut close_brackets_stack_ptr_end = &mut\
    \ close_brackets_stack[..];\n    let mut open_brackets_stack_ptr_end_ptr = &mut\
    \ open_brackets_stack_ptr_end[..];\n    let mut close_brackets_stack_ptr_end_ptr\
    \ = &mut close_brackets_stack_ptr_end[..];\n    let mut open_brackets_stack_ptr_end_ptr_end\
    \ = &mut open_brackets_stack_ptr_end[..];\n    let mut close_brackets_stack_ptr_end_ptr_end\
    \ = &mut close_brackets_stack_ptr_end[..];\n    let mut open_brackets_stack_ptr_end_ptr_end_ptr\
    \ = &mut open_brackets_stack_ptr_end_ptr_end[..];\n    let mut close_brackets_stack_ptr_end_ptr_end_ptr\
    \ = &mut close_brackets_stack_ptr_end_ptr_end[..];\n    let mut open_brackets_stack_ptr_end_ptr_end_ptr_end\
    \ = &mut open_brackets_stack_ptr_end_ptr_end_ptr[..];\n    let mut close_brackets_stack_ptr_end_ptr_end_ptr_end\
    \ = &mut close_brackets_stack_ptr_end_ptr_end_ptr[..];\n    let mut open_brackets_stack_ptr_end_ptr_end_ptr_end_ptr\
    \ = &mut open_brackets_stack_ptr_end_ptr_end_ptr_end[..];\n    let mut close_brackets_\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpgbdgyi8i.rs:31:28\n   |\n\
    31 |     let mut close_brackets_\n   |                            ^ help: add\
    \ `;` here\n32 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgbdgyi8i.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().collect::<Vec<_>>());\n\
    \    while stack.len() > 0 {\n        let mut current = stack.pop().unwrap();\n\
    \        for c in current {\n            if c == '<' {\n                stack.push(c);\n\
    \            } else if c == '>' {\n                stack.pop();\n            }\
    \ else {\n                return false;\n            }\n        }\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl_n89qpc.rs:18:28\n   |\n\
    18 |                 stack.push(c);\n   |                            ^ expected\
    \ struct `Vec`, found `char`\n   |\n   = note: expected struct `Vec<char>`\n \
    \               found type `char`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    for c in brackets.chars() {\n        if stack.is_empty() {\n            return\
    \ false;\n        }\n        if c == stack.pop().unwrap() {\n            continue;\n\
    \        }\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpb423qjr1.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '>' || c == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx72fju7r.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for c in brackets {\n        if c == '<' {\n            open_brackets.push(c);\n\
    \        } else if c == '>' {\n            close_brackets.push(c);\n        }\
    \ else {\n            open_brackets.push(c);\n            close_brackets.push(c);\n\
    \        }\n    }\n    open_brackets.len() == close_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpcjcx5000.rs:14:14\n\
    \   |\n14 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_size = brackets.chars().filter(|c| c == '<').count();\n\
    \    let mut closed_brackets_size = brackets.chars().filter(|c| c == '>').count();\n\
    \    let mut open_brackets_pos = 0;\n    let mut closed_brackets_pos = 0;\n  \
    \  let mut open_brackets_end = brackets.len();\n    let mut closed_brackets_end\
    \ = brackets.len();\n    let mut open_brackets_pos = 0;\n    let mut closed_brackets_pos\
    \ = 0;\n    let mut open_brackets_end = brackets.len();\n    let mut closed_brackets_end\
    \ = brackets.len();\n    let mut open_brackets_pos = 0;\n    let mut closed_brackets_pos\
    \ = 0;\n    let mut open_brackets_end = brackets.len();\n    let mut closed_brackets_end\
    \ = brackets.len();\n    let mut open_brackets_pos = 0;\n    let mut closed_brackets_pos\
    \ = 0;\n    let mut open_brackets_end = brackets.len();\n    let mut closed_brackets_end\
    \ = brackets.len();\n    let mut open_brackets_pos = 0;\n    let mut closed_brackets_pos\
    \ = 0;\n    let mut open_brackets_end = brackets.len();\n    let mut closed_brackets_end\
    \ = brackets.len();\n    let mut open_brackets_pos = 0;\n    let mut closed_brackets_pos\
    \ = 0;\n    let mut open_brackets_end = brackets.len();\n    let mut closed_brackets_end\
    \ = brackets.len();\n    let mut open_brackets_pos = 0;\n    let mut closed_brackets_pos\
    \ = 0;\n    let mut open_brackets_end = brackets.len();\n    let mut closed_brackets_end\
    \ = brackets.len();\n    let mut open_brackets_pos = 0;\n    let mut closed_brackets_pos\
    \ = 0;\n    let mut open_brackets_end = brackets.len();\n    let mut closed_brackets_end\
    \ = brackets.len();\n    let mut open_brackets_pos = 0;\n    let mut closed_brackets_pos\
    \ = 0;\n    let mut open_brackets_end = brackets.len();\n    let mut closed_brackets_end\
    \ = brackets.len();\n    let mut open_brackets_\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwti5utcm.rs:52:27\n   |\n\
    52 |     let mut open_brackets_\n   |                           ^ help: add `;`\
    \ here\n53 | }\n   | - unexpected token\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpwti5utcm.rs:14:64\n   |\n14 |     let mut open_brackets_size\
    \ = brackets.chars().filter(|c| c == '<').count();\n   |                     \
    \                                           ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpwti5utcm.rs:15:66\n   |\n15 |   \
    \  let mut closed_brackets_size = brackets.chars().filter(|c| c == '>').count();\n\
    \   |                                                                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpwti5utcm.rs:11:44\n   |\n11 | fn\
    \ correct_bracketing(brackets: String) -> bool {\n   |    ------------------ \
    \                     ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \    while stack.len() > 0 {\n        let mut current = stack.pop();\n       \
    \ if current.len() == 0 {\n            continue;\n        }\n        let mut next\
    \ = current.clone();\n        while next.len() > 0 {\n            let mut next\
    \ = next.clone();\n            while next.len() > 0 {\n                let mut\
    \ next = next.clone();\n                while next.len() > 0 {\n             \
    \       let mut next = next.clone();\n                    while next.len() > 0\
    \ {\n                        let mut next = next.clone();\n                  \
    \      while next.len() > 0 {\n                            let mut next = next.clone();\n\
    \                            while next.len() > 0 {\n                        \
    \        let mut next = next.clone();\n                                while next.len()\
    \ > 0 {\n                                    let mut next = next.clone();\n  \
    \                                  while next.len() > 0 {\n                  \
    \                      let mut next = next.clone();\n                        \
    \                while next.len() > 0 {\n                                    \
    \        let mut next = next.clone();\n                                      \
    \      while next.len() > 0 {\n                                              \
    \  let mut next = next.clone();\n                                            }\n\
    \                                        }\n                                 \
    \   }\n                                }\n                            }\n    \
    \                    }\n                    }\n                }\n           \
    \ }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp19zq1sap.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0599]: no method named `len` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmp19zq1sap.rs:16:20\n  \
    \ |\n16 |         if current.len() == 0 {\n   |                    ^^^ method\
    \ not found in `Option<Vec<char>>`\n\nerror[E0599]: no method named `len` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmp19zq1sap.rs:20:20\n  \
    \ |\n20 |         while next.len() > 0 {\n   |                    ^^^ method not\
    \ found in `Option<Vec<char>>`\n\nerror[E0599]: no method named `len` found for\
    \ enum `Option` in the current scope\n  --> /tmp/tmp19zq1sap.rs:22:24\n   |\n\
    22 |             while next.len() > 0 {\n   |                        ^^^ method\
    \ not found in `Option<Vec<char>>`\n\nerror[E0599]: no method named `len` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmp19zq1sap.rs:24:28\n  \
    \ |\n24 |                 while next.len() > 0 {\n   |                       \
    \     ^^^ method not found in `Option<Vec<char>>`\n\nerror[E0599]: no method named\
    \ `len` found for enum `Option` in the current scope\n  --> /tmp/tmp19zq1sap.rs:26:32\n\
    \   |\n26 |                     while next.len() > 0 {\n   |                 \
    \               ^^^ method not found in `Option<Vec<char>>`\n\nerror[E0599]: no\
    \ method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmp19zq1sap.rs:28:36\n\
    \   |\n28 |                         while next.len() > 0 {\n   |             \
    \                       ^^^ method not found in `Option<Vec<char>>`\n\nerror[E0599]:\
    \ no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmp19zq1sap.rs:30:40\n\
    \   |\n30 | ...                   while next.len() > 0 {\n   |               \
    \                   ^^^ method not found in `Option<Vec<char>>`\n\nerror["
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices();\n    let mut close_brackets_iter\
    \ = brackets.char_indices();\n    let mut open_brackets_end = open_brackets_iter.end();\n\
    \    let mut close_brackets_end = close_brackets_iter.end();\n    let mut open_brackets_next\
    \ = open_brackets_iter.next();\n    let mut close_brackets_next = close_brackets_iter.next();\n\
    \    while open_brackets_next != open_brackets_end {\n        open_brackets +=\
    \ open_brackets_next.unwrap();\n        if open_brackets_next == open_brackets_end\
    \ {\n            open_brackets_next = open_brackets_iter.next();\n        }\n\
    \        close_brackets += close_brackets_next.unwrap();\n        if close_brackets_next\
    \ == close_brackets_end {\n            close_brackets_next = close_brackets_iter.next();\n\
    \        }\n    }\n    open_brackets == close_brackets\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `end` found for struct `CharIndices` in the\
    \ current scope\n  --> /tmp/tmpa6w23m4f.rs:16:52\n   |\n16 |     let mut open_brackets_end\
    \ = open_brackets_iter.end();\n   |                                          \
    \          ^^^ method not found in `CharIndices<'_>`\n\nerror[E0599]: no method\
    \ named `end` found for struct `CharIndices` in the current scope\n  --> /tmp/tmpa6w23m4f.rs:17:54\n\
    \   |\n17 |     let mut close_brackets_end = close_brackets_iter.end();\n   |\
    \                                                      ^^^ method not found in\
    \ `CharIndices<'_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa6w23m4f.rs:21:26\n\
    \   |\n21 |         open_brackets += open_brackets_next.unwrap();\n   |      \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found tuple\n\
    \   |\n   = note: expected reference `&str`\n                  found tuple `(usize,\
    \ char)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa6w23m4f.rs:25:27\n\
    \   |\n25 |         close_brackets += close_brackets_next.unwrap();\n   |    \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found tuple\n\
    \   |\n   = note: expected reference `&str`\n                  found tuple `(usize,\
    \ char)`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_brackets_stack = Vec::new();\n    let mut closing_brackets_stack\
    \ = Vec::new();\n    for bracket in brackets {\n        if bracket == '<' {\n\
    \            opening_brackets.push(bracket);\n            opening_brackets_stack.push(bracket);\n\
    \        } else if bracket == '>' {\n            closing_brackets.push(bracket);\n\
    \            closing_brackets_stack.push(bracket);\n        } else {\n       \
    \     if opening_brackets_stack.len() == 0 {\n                return false;\n\
    \            }\n            let opening_bracket = opening_brackets_stack.pop();\n\
    \            let closing_bracket = closing_brackets_stack.pop();\n           \
    \ if opening_bracket != closing_bracket {\n                return false;\n   \
    \         }\n        }\n    }\n    opening_brackets_stack.len() == 0\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpi623zt9r.rs:16:20\n\
    \   |\n16 |     for bracket in brackets {\n   |                    ^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            closed_brackets.push('<');\n      \
    \  } else if bracket == '>' {\n            open_brackets.push('<');\n        \
    \    closed_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \        }\n    }\n    open_brackets.chars().all(|c| closed_brackets.chars().any(|c|\
    \ c == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpg6f6ln99.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for ch in brackets.chars() {\n        if ch ==\
    \ '<' {\n            stack.push('<');\n        } else if ch == '>' {\n       \
    \     if stack.is_empty() {\n                return false;\n            }\n  \
    \          stack.pop();\n        } else {\n            if stack.len() != 0 {\n\
    \                return false;\n            }\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = String::new();\n    let mut\
    \ close_brackets_count = String::new();\n    let mut open_brackets_stack = Vec::new();\n\
    \    let mut close_brackets_stack = Vec::new();\n    let mut open_brackets_count\
    \ = String::new();\n    let mut close_brackets_count = String::new();\n    let\
    \ mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack = Vec::new();\n\
    \    let mut open_brackets_count = String::new();\n    let mut close_brackets_count\
    \ = String::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut\
    \ close_brackets_stack = Vec::new();\n    let mut open_brackets_count = String::new();\n\
    \    let mut close_brackets_count = String::new();\n    let mut open_brackets_stack\
    \ = Vec::new();\n    let mut close_brackets_stack = Vec::new();\n    let mut open_brackets_count\
    \ = String::new();\n    let mut close_brackets_count = String::new();\n    let\
    \ mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack = Vec::new();\n\
    \    let mut open_brackets_count = String::new();\n    let mut close_brackets_count\
    \ = String::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut\
    \ close_brackets_stack = Vec::new();\n    let mut open_brackets_count = String::new();\n\
    \    let mut close_brackets_count = String::new();\n    let mut open_brackets_stack\
    \ = Vec::new();\n    let mut close_brackets_stack = Vec::new();\n    let mut open_brackets_count\
    \ = String::new();\n    let mut close_brackets_count = String::new();\n    let\
    \ mut open_brackets_stack = Vec::new();\n    let mut close_bracket\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_mzrx892.rs:47:26\n   |\n\
    47 |     let mut close_bracket\n   |                          ^ help: add `;`\
    \ here\n48 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_mzrx892.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '>' || c == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx72fju7r.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices().filter_map(|i| {\n \
    \       if i.0.is_some() {\n            Some(\n                i.0.unwrap(),\n\
    \                i.1.unwrap(),\n                i.1.unwrap() + 1,\n          \
    \      i.1.unwrap() + 1,\n            )\n        } else {\n            None\n\
    \        }\n    });\n    let mut close_brackets_iter = brackets.char_indices().filter_map(|i|\
    \ {\n        if i.0.is_some() {\n            Some(\n                i.0.unwrap(),\n\
    \                i.1.unwrap(),\n                i.1.unwrap() + 1,\n          \
    \      i.1.unwrap() + 1,\n            )\n        } else {\n            None\n\
    \        }\n    });\n    let mut open_brackets_iter = open_brackets_iter.collect();\n\
    \    let mut close_brackets_iter = close_brackets_iter.collect();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.into_iter();\n    let mut close_brackets_iter\
    \ = close_brackets_iter.into_iter();\n    let mut open_brackets_iter = open_brackets_iter.into_iter();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.into_iter();\n    let mut close_brackets_iter\
    \ = close_brackets_iter.into_iter();\n    let mut open_brackets_iter = open_brackets_iter.into_iter();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.into_iter();\n    let mut close_brackets_iter\
    \ = close_brackets_iter.into_iter();\n    let mut open_brackets_iter = open_brackets_iter.into_iter();\n\
    \    let mut close_brackets_iter = close_brackets_iter.into_iter();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.into_iter();\n    let mut close_brackets_iter\
    \ = close_brackets_iter.into_iter();\n    let mut open_brackets_iter = open_brackets_iter.into_iter();\n\
    \    let mut close_brackets_iter = close_brackets_\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8jvi3qud.rs:55:50\n   |\n\
    55 |     let mut close_brackets_iter = close_brackets_\n   |                 \
    \                                 ^ help: add `;` here\n56 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `close_brackets_` in this scope\n \
    \ --> /tmp/tmp8jvi3qud.rs:55:35\n   |\n55 |     let mut close_brackets_iter =\
    \ close_brackets_\n   |                                   ^^^^^^^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `close_brackets`\n\nerror[E0599]:\
    \ no method named `is_some` found for type `usize` in the current scope\n  -->\
    \ /tmp/tmp8jvi3qud.rs:15:16\n   |\n15 |         if i.0.is_some() {\n   |     \
    \           ^^^^^^^ method not found in `usize`\n\nerror[E0599]: no method named\
    \ `unwrap` found for type `usize` in the current scope\n  --> /tmp/tmp8jvi3qud.rs:17:21\n\
    \   |\n17 |                 i.0.unwrap(),\n   |                     ^^^^^^ method\
    \ not found in `usize`\n\nerror[E0599]: no method named `unwrap` found for type\
    \ `char` in the current scope\n  --> /tmp/tmp8jvi3qud.rs:18:21\n   |\n18 |   \
    \              i.1.unwrap(),\n   |                     ^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `unwrap` found for type `char` in\
    \ the current scope\n  --> /tmp/tmp8jvi3qud.rs:19:21\n   |\n19 |             \
    \    i.1.unwrap() + 1,\n   |                     ^^^^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp8jvi3qud.rs:20:21\n   |\n20 |                 i.1.unwrap()\
    \ + 1,\n   |                     ^^^^^^ method not found in `char`\n\nerror[E0061]:\
    \ this enum variant takes 1 argument but 4 arguments were supplied\n  --> /tmp/tmp8jvi3qud.rs:16:13\n\
    \   |\n16 |             Some(\n   |             ^^^^ expected 1 argument\n17 |\
    \                 i.0.unwrap(),\n   |                 ------------\n18 |     \
    \            i.1.unwrap(),\n   |                 ------------\n19 |          \
    \       i.1.unwrap() + 1,\n   |                 ----------------\n20 |       \
    \          i.1.unwrap() + 1,\n   |                 ------"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp69g8o027.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_count = String::new();\n    let mut close_brackets_count\
    \ = String::new();\n    let mut open_brackets_count_map = HashMap::new();\n  \
    \  let mut close_brackets_count_map = HashMap::new();\n    let mut open_brackets_count_map_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted = HashMap::new();\n\
    \    let mut open_brackets_count_map_sorted_reverse = HashMap::new();\n    let\
    \ mut close_brackets_count_map_sorted_reverse = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_2\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_2 = HashMap::new();\n\
    \    let mut open_brackets_count_map_sorted_reverse_3 = HashMap::new();\n    let\
    \ mut close_brackets_count_map_sorted_reverse_3 = HashMap::new();\n    let mut\
    \ open_brackets_count_map_sorted_reverse_4 = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_4\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_5 = HashMap::new();\n\
    \    let mut close_brackets_count_map_sorted_reverse_5 = HashMap::new();\n   \
    \ let mut open_brackets_count_map_sorted_reverse_6 = HashMap::new();\n    let\
    \ mut close_brackets_count_map_sorted_reverse_6 = HashMap::new();\n    let mut\
    \ open_brackets_count_map_sorted_reverse_7 = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_7\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_8 = HashMap::new();\n\
    \    let mut close_brackets_count_map_sorted_reverse_8 = HashMap::new();\n   \
    \ let mut open_brackets_count_map_sorted_reverse_9 = HashMap::new();\n    let\
    \ mut close_brackets_count_map_sorted_reverse_9 = HashMap::new();\n    let mut\
    \ open_brackets_count_map_sorted_reverse_10 = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_10\
    \ = HashMap::new();\n    let mut open_brackets_count_map_\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp41uq62cu.rs:40:37\n   |\n\
    40 |     let mut open_brackets_count_map_\n   |                              \
    \       ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp41uq62cu.rs:16:39\n\
    \   |\n16 |     let mut open_brackets_count_map = HashMap::new();\n   |      \
    \                                 ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp41uq62cu.rs:17:40\n   |\n17 |     let mut close_brackets_count_map\
    \ = HashMap::new();\n   |                                        ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp41uq62cu.rs:18:46\n   |\n18 |     let mut open_brackets_count_map_sorted\
    \ = HashMap::new();\n   |                                              ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp41uq62cu.rs:19:47\n   |\n19\
    \ |     let mut close_brackets_count_map_sorted = HashMap::new();\n   |      \
    \                                         ^^^^^^^ not found in this scope\n  \
    \ |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp41uq62cu.rs:20:54\n   |\n20 |     let mut open_brackets_count_map_sorted_reverse\
    \ = HashMap::new();\n   |                                                    \
    \  ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp41uq62cu.rs:21:55\n   |\n21\
    \ |     let mut close_brackets_count_map_sorted_"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp_olaza9.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets {\n        if bracket == '<' {\n            open_brackets.push('>');\n\
    \            close_brackets.push('<');\n        } else if bracket == '>' {\n \
    \           open_brackets.push('<');\n            close_brackets.push('>');\n\
    \        } else {\n            open_brackets.push(bracket);\n            close_brackets.push(bracket);\n\
    \        }\n    }\n    open_brackets.chars().all(|c| close_brackets.chars().any(|c|\
    \ c == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpp6860r_s.rs:14:20\n\
    \   |\n14 |     for bracket in brackets {\n   |                    ^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets {\n        if c == '<' {\n  \
    \          stack.push(c);\n        } else if c == '>' {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n            stack.push(c);\n       \
    \ }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp8z_gn24t.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\"\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp77vopu4g.rs:75:21\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n75 |     brackets.replace(\"<\", \"\"\n   |                     ^\
    \ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp77vopu4g.rs:75:5\n   |\n11 |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                              ---- expected\
    \ `bool` because of return type\n...\n75 | /     brackets.replace(\"<\", \"\"\n\
    76 | | }\n   | |_^ expected `bool`, found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = Vec::new();\n    let\
    \ mut closing_brackets = Vec::new();\n    stack.push(brackets);\n    while let\
    \ Some(brackets) = stack.pop() {\n        if brackets.starts_with(\"<\") {\n \
    \           opening_brackets.push(brackets);\n        } else {\n            closing_brackets.push(brackets);\n\
    \        }\n    }\n    opening_brackets.len() == closing_brackets.len()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4yrdzsky.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for ch in brackets {\n        if ch == '<' {\n    \
    \        stack.push('<');\n        } else if ch == '>' {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n            stack.push(ch);\n      \
    \  }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp4v48x5v1.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() != 0 {\n      \
    \          return false;\n            }\n        }\n    }\n    stack.len() ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii()).collect::<Vec<_>>());\n\
    \    while stack.len() > 0 {\n        let mut next = stack.clone();\n        next.pop();\n\
    \        if next.len() == 0 {\n            return false;\n        }\n        if\
    \ next.len() == 1 {\n            if next.len() == 1 {\n                return\
    \ true;\n            }\n            if next.len() == 2 {\n                if next[0]\
    \ == next[1] {\n                    next.pop();\n                }\n         \
    \   }\n        }\n        if next.len() == 2 {\n            if next[0] == next[1]\
    \ {\n                next.pop();\n            }\n        }\n        if next.len()\
    \ == 3 {\n            if next[0] == next[1] {\n                next.pop();\n \
    \           }\n        }\n        if next.len() == 4 {\n            if next[0]\
    \ == next[1] {\n                next.pop();\n            }\n        }\n      \
    \  if next.len() == 5 {\n            if next[0] == next[1] {\n               \
    \ next.pop();\n            }\n        }\n        if next.len() == 6 {\n      \
    \      if next[0] == next[1] {\n                next.pop();\n            }\n \
    \       }\n        if next.len() == 7 {\n            if next[0] == next[1] {\n\
    \                next.pop();\n            }\n        }\n        if next.len()\
    \ == 8 {\n            if next[0] == next[1] {\n                next.pop();\n \
    \           }\n        }\n        if next.len() == 9 {\n            if next[0]\
    \ == next[1] {\n                next.pop();\n            }\n        }\n      \
    \  if next.len() == 10 {\n            if next[0] == next[1] {\n              \
    \  next.pop();\n            }\n        }\n        if next.len() == 11 {\n    \
    \        if next[0] == next[1] {\n                next.pop();\n            }\n\
    \        }\n        if next.len() == 12 {\n            if next[0] == next[1] {\n\
    \                next.pop();\n            }\n        }\n        if next.len()\
    \ == 13 {\n            if next[0] == next[1] {\n                next.pop();\n\
    \            }\n        }\n        if next.len() == 14 {\n            if next[0]\
    \ == next[1] {\n                next.pop();\n            }\n        }\n      \
    \  if next.len() == 15 {\n            if next[0] == next[1] {\n              \
    \  next.pop();\n            }\n        }\n        if next.len() == 16 {\n    \
    \        if next[0] == next[1] {\n                next.pop();\n            }\n\
    \        }\n        if next.len() == 17 {\n            if next[0] == next[1] {\n\
    \                next.pop();\n            }\n        }\n        if next.len()\
    \ == 18 {\n            if next[0] == next[1] {\n                next.pop();\n\
    \            }\n        }\n        if next.len() == 19 {\n            if next[0]\
    \ == next[1] {\n                next.pop\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp5vbcc934.rs:134:3\n\
    \    |\n11  | fn correct_bracketing(brackets: String) -> bool {\n    |       \
    \                                          - unclosed delimiter\n...\n14  |  \
    \   while stack.len() > 0 {\n    |                           - unclosed delimiter\n\
    ...\n115 |         if next.len() == 19 {\n    |                             -\
    \ unclosed delimiter\n116 |             if next[0] == next[1] {\n    |       \
    \                            - this delimiter might not be properly closed...\n\
    117 |                 next.pop\n118 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0615]: attempted\
    \ to take value of method `pop` on type `Vec<Vec<char>>`\n   --> /tmp/tmp5vbcc934.rs:117:22\n\
    \    |\n117 |                 next.pop\n    |                      ^^^ method,\
    \ not a field\n    |\nhelp: use parentheses to call the method\n    |\n117 | \
    \                next.pop()\n    |                         ++\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmp5vbcc934.rs:14:5\n    |\n11  |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n    |                                              ---- expected\
    \ `bool` because of return type\n...\n14  | /     while stack.len() > 0 {\n15\
    \  | |         let mut next = stack.clone();\n16  | |         next.pop();\n17\
    \  | |         if next.len() == 0 {\n...   |\n133 | |     assert_eq!(candidate(String::from(\"\
    <><><<><>><>>><>\")), false);\n134 | | }\n    | |__^ expected `bool`, found `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0615.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_brackets_size = brackets.chars().filter(|c|\
    \ c == '<').count();\n    let mut close_brackets_size = brackets.chars().filter(|c|\
    \ c == '>').count();\n    let mut open_brackets_index = 0;\n    let mut close_brackets_index\
    \ = 0;\n    let mut open_brackets_chars = String::new();\n    let mut close_brackets_chars\
    \ = String::new();\n    let mut open_brackets_chars_size = open_brackets_chars.len();\n\
    \    let mut close_brackets_chars_size = close_brackets_chars.len();\n    let\
    \ mut open_brackets_chars_index = 0;\n    let mut close_brackets_chars_index =\
    \ 0;\n    let mut open_brackets_chars_chars = String::new();\n    let mut close_brackets_chars_chars\
    \ = String::new();\n    let mut open_brackets_chars_chars_size = open_brackets_chars_chars.len();\n\
    \    let mut close_brackets_chars_chars_size = close_brackets_chars_chars.len();\n\
    \    let mut open_brackets_chars_chars_index = 0;\n    let mut close_brackets_chars_chars_index\
    \ = 0;\n    let mut open_brackets_chars_chars_chars = String::new();\n    let\
    \ mut close_brackets_chars_chars_chars = String::new();\n    let mut open_brackets_chars_chars_chars_size\
    \ = open_brackets_chars_chars_chars.len();\n    let mut close_brackets_chars_chars_chars_size\
    \ = close_brackets_chars_chars_chars.len();\n    let mut open_brackets_chars_chars_chars_index\
    \ = 0;\n    let mut close_brackets_chars_chars_chars_index = 0;\n    let mut open_brackets_chars_chars_chars_chars\
    \ = String::new();\n    let mut close_brackets_chars_chars_chars_chars = String::new();\n\
    \    let mut open_brackets_chars_chars_chars_chars_size = open_brackets_\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpasmgil7v.rs:39:72\n   |\n\
    39 |     let mut open_brackets_chars_chars_chars_chars_size = open_brackets_\n\
    \   |                                                                        ^\
    \ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `open_brackets_` in this scope\n  --> /tmp/tmpasmgil7v.rs:39:58\n\
    \   |\n39 |     let mut open_brackets_chars_chars_chars_chars_size = open_brackets_\n\
    \   |                                                          ^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `open_brackets`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpasmgil7v.rs:15:64\n   |\n15\
    \ |     let mut open_brackets_size = brackets.chars().filter(|c| c == '<').count();\n\
    \   |                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpasmgil7v.rs:16:65\n\
    \   |\n16 |     let mut close_brackets_size = brackets.chars().filter(|c| c ==\
    \ '>').count();\n   |                                                        \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpasmgil7v.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            closed_brackets.push('<');\n      \
    \  } else if bracket == '>' {\n            open_brackets.push('<');\n        \
    \    closed_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \        }\n    }\n    open_brackets.chars().all(|c| closed_brackets.chars().any(|c|\
    \ c == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpg6f6ln99.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp_2n3kwal.rs:82:56\n\
    \   |\n82 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n83 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    bracket\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpno2gymcj.rs:72:5\n\
    \   |\n72 |     bracket\n   |     ^^^^^^^ help: a local variable with a similar\
    \ name exists: `brackets`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = String::new();\n    let\
    \ mut close_brackets = String::new();\n    let mut open_brackets_count = String::new();\n\
    \    let mut close_brackets_count = String::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack_size = String::new();\n    let mut close_brackets_count_stack_size\
    \ = String::new();\n    let mut open_brackets_count_stack_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr = String::new();\n    let mut open_brackets_count_stack_ptr_end\
    \ = String::new();\n    let mut close_brackets_count_stack_ptr_end = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_end_ptr = String::new();\n    let mut\
    \ close_brackets_count_stack_ptr_end_ptr = String::new();\n    let mut open_brackets_count_stack_ptr_end_ptr_end\
    \ = String::new();\n    let mut close_brackets_count_stack_ptr_end_ptr_end = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_end_ptr_end_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr_end_ptr_end_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_end_ptr_end_ptr_end = String::new();\n\
    \    let mut close_brackets_count_stack_ptr_end_ptr_end_ptr_end = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_end_ptr_end_ptr_end_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr_end_ptr_end_ptr_end_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_end_ptr_end_ptr_end_ptr_end = String::new();\n\
    \    let mut close_brackets_count_stack_ptr_end_ptr_end_ptr_end_ptr_end = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_end_ptr_end_ptr_end_ptr_end_ptr = String::new();\n\
    \    let mut \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n   \
    \ assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpzeb3mgzz.rs:39:1\n\
    \   |\n39 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut close_brackets_stack_size = close_brackets_stack.len();\n    let\
    \ mut i = 0;\n    while i < brackets.len() {\n        let mut j = i;\n       \
    \ while j < brackets.len() && brackets[j] == brackets[j + 1] {\n            j\
    \ += 1\n        }\n        if j == i {\n            open_brackets_stack.push(brackets[i]);\n\
    \            close_brackets_stack.push(brackets[i]);\n            i += 1;\n  \
    \      } else {\n            if open_brackets_stack_size == open_brackets_stack.len()\
    \ {\n                open_brackets_stack.pop();\n                close_brackets_stack.pop();\n\
    \                open_brackets_stack_size = open_brackets_stack.len();\n     \
    \           close_brackets_stack_size = close_brackets_stack.len();\n        \
    \    }\n            if close_brackets_stack_size == close_brackets_stack.len()\
    \ {\n                close_brackets_stack.pop();\n                open_brackets_stack_size\
    \ = open_brackets_stack.len();\n                close_brackets_stack_size = close_brackets_stack.len();\n\
    \            }\n            if open_brackets_stack_size == open_brackets_stack.len()\
    \ {\n                open_brackets_stack.pop();\n                close_brackets_stack.pop();\n\
    \                open_brackets_stack_size = open_brackets_stack.len();\n     \
    \           close_brackets_stack_size = close_brackets_stack.len();\n        \
    \    }\n            if open_brackets_stack_size == open_brackets_stack.len() {\n\
    \                open_brackets_stack.pop();\n                close_brackets_stack.pop();\n\
    \                open_brackets_stack_size = open_brackets_stack.len();\n     \
    \           close_brackets_stack_size = close_brackets_stack.len();\n        \
    \    }\n            if open_brackets_stack_size == open_brackets_stack.len() {\n\
    \                open_brackets_stack.pop();\n                close_brackets_stack.pop();\n\
    \                open_brackets_stack_size = open_brackets_stack.len();\n     \
    \           close_brackets_\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmptkvkqsj9.rs:73:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n19 |     while\
    \ i < brackets.len() {\n   |                              - unclosed delimiter\n\
    ...\n28 |         } else {\n   |                - unclosed delimiter\n...\n52\
    \ |             if open_brackets_stack_size == open_brackets_stack.len() {\n \
    \  |                                                                      - this\
    \ delimiter might not be properly closed...\n...\n57 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n73 | }\n   |   ^\n\nerror[E0425]:\
    \ cannot find value `close_brackets_` in this scope\n  --> /tmp/tmptkvkqsj9.rs:56:17\n\
    \   |\n56 |                 close_brackets_\n   |                 ^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `close_brackets`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptkvkqsj9.rs:21:37\n\
    \   |\n21 |         while j < brackets.len() && brackets[j] == brackets[j + 1]\
    \ {\n   |                                     ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptkvkqsj9.rs:21:52\n   |\n21 |         while j < brackets.len()\
    \ && brackets[j] == brackets[j + 1] {\n   |                                  \
    \                  ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types im"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = \n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmps_s1dy4r.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for c in brackets.chars() {\n        if\
    \ c == '<' {\n            stack.push(0);\n        } else if c == '>' {\n     \
    \       if stack.len() == 0 {\n                return false;\n            }\n\
    \            let top = stack.len();\n            stack.pop();\n            if\
    \ top != stack.len() {\n                return false;\n            }\n       \
    \ } else {\n            stack.push(c);\n        }\n    }\n    stack.len() == 0\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0h2a4rb1.rs:26:24\n   |\n\
    26 |             stack.push(c);\n   |                        ^ expected `usize`,\
    \ found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for c in brackets {\n        if c == '<' {\n            open_brackets.push(c);\n\
    \        } else if c == '>' {\n            close_brackets.push(c);\n        }\
    \ else {\n            return false;\n        }\n    }\n    if open_brackets.len()\
    \ != close_brackets.len() {\n        return false;\n    }\n    for c in open_brackets\
    \ {\n        if !close_brackets.contains(&c) {\n            return false;\n  \
    \      }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpzyonjch1.rs:14:14\n\
    \   |\n14 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: `String`\
    \ is not an iterator\n  --> /tmp/tmpzyonjch1.rs:26:14\n   |\n26 |     for c in\
    \ open_brackets {\n   |              ^^^^^^^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_count = String::new();\n    let mut close_brackets_count\
    \ = String::new();\n    let mut open_brackets_count_map = HashMap::new();\n  \
    \  let mut close_brackets_count_map = HashMap::new();\n    let mut open_brackets_count_map_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted = HashMap::new();\n\
    \    let mut open_brackets_count_map_sorted_reverse = HashMap::new();\n    let\
    \ mut close_brackets_count_map_sorted_reverse = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp9x8sxcjh.rs:38:1\n\
    \   |\n38 | }\n   | ^ expected identifier\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp9x8sxcjh.rs:16:39\n   |\n16\
    \ |     let mut open_brackets_count_map = HashMap::new();\n   |              \
    \                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp9x8sxcjh.rs:17:40\n\
    \   |\n17 |     let mut close_brackets_count_map = HashMap::new();\n   |     \
    \                                   ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp9x8sxcjh.rs:18:46\n   |\n18 |     let mut open_brackets_count_map_sorted\
    \ = HashMap::new();\n   |                                              ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp9x8sxcjh.rs:19:47\n   |\n19\
    \ |     let mut close_brackets_count_map_sorted = HashMap::new();\n   |      \
    \                                         ^^^^^^^ not found in this scope\n  \
    \ |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp9x8sxcjh.rs:20:54\n   |\n20 |     let mut open_brackets_count_map_sorted_reverse\
    \ = HashMap::new();\n   |                                                    \
    \  ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmp9x8sxcjh.rs:21:55\n   |\n21\
    \ |     let mut close_brackets_count_map_sorted_reverse = HashMap::new();\n  \
    \ |                                                       ^^^^^^^ no"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets\
    \ == close_brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpll2kahvd.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets\
    \ == close_brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpll2kahvd.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices().filter_map(|(_, index)|\
    \ {\n        if index > 0 {\n            Some(index - 1)\n        } else {\n \
    \           None\n        }\n    });\n    let mut closed_brackets_iter = brackets.char_indices().filter_map(|(_,\
    \ index)| {\n        if index < brackets.len() - 1 {\n            Some(index +\
    \ 1)\n        } else {\n            None\n        }\n    });\n    let mut open_brackets_next\
    \ = open_brackets_iter.next();\n    let mut closed_brackets_next = closed_brackets_iter.next();\n\
    \    while open_brackets_next.is_some() && closed_brackets_next.is_some() {\n\
    \        if open_brackets_next.unwrap() == closed_brackets_next.unwrap() {\n \
    \           open_brackets.push_str(open_brackets_next.unwrap());\n           \
    \ closed_brackets.push_str(closed_brackets_next.unwrap());\n            open_brackets_next\
    \ = open_brackets_iter.next();\n            closed_brackets_next = closed_brackets_iter.next();\n\
    \        } else {\n            open_brackets.push_str(open_brackets_next.unwrap());\n\
    \            closed_brackets.push_str(\"</>\");\n            open_brackets_next\
    \ = open_brackets_iter.next();\n            closed_brackets_next = closed_brackets_iter.next();\n\
    \        }\n    }\n    open_brackets.len() == closed_brackets.len()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplczlghg4.rs:15:20\n   |\n\
    15 |         if index > 0 {\n   |                    ^ expected `char`, found\
    \ `u8`\n\nerror[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmplczlghg4.rs:16:24\n\
    \   |\n16 |             Some(index - 1)\n   |                  ----- ^ - {integer}\n\
    \   |                  |\n   |                  char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplczlghg4.rs:22:20\n   |\n22 |         if index < brackets.len()\
    \ - 1 {\n   |                    ^^^^^^^^^^^^^^^^^^ expected `char`, found `usize`\n\
    \nerror[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmplczlghg4.rs:23:24\n\
    \   |\n23 |             Some(index + 1)\n   |                  ----- ^ - {integer}\n\
    \   |                  |\n   |                  char\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n    let mut open_brackets_idx:\
    \ usize = 0;\n    let mut close_brackets_idx: usize = 0;\n    let mut open_brackets_idx2:\
    \ usize = 0;\n    let mut close_brackets_idx2: usize = 0;\n    let mut open_brackets_idx3:\
    \ usize = 0;\n    let mut close_brackets_idx3: usize = 0;\n    let mut open_brackets_idx4:\
    \ usize = 0;\n    let mut close_brackets_idx4: usize = 0;\n    let mut open_brackets_idx5:\
    \ usize = 0;\n    let mut close_brackets_idx5: usize = 0;\n    let mut open_brackets_idx6:\
    \ usize = 0;\n    let mut close_brackets_idx6: usize = 0;\n    let mut open_brackets_idx7:\
    \ usize = 0;\n    let mut close_brackets_idx7: usize = 0;\n    let mut open_brackets_idx8:\
    \ usize = 0;\n    let mut close_brackets_idx8: usize = 0;\n    let mut open_brackets_idx9:\
    \ usize = 0;\n    let mut close_brackets_idx9: usize = 0;\n    let mut open_brackets_idx10:\
    \ usize = 0;\n    let mut close_brackets_idx10: usize = 0;\n    let mut open_brackets_idx11:\
    \ usize = 0;\n    let mut close_brackets_idx11: usize = 0;\n    let mut open_brackets_idx12:\
    \ usize = 0;\n    let mut close_brackets_idx12: usize = 0;\n    let mut open_brackets_idx13:\
    \ usize = 0;\n    let mut close_brackets_idx13: usize = 0;\n    let mut open_brackets_idx14:\
    \ usize = 0;\n    let mut close_brackets_idx14: usize = 0;\n    let mut open_brackets_idx15:\
    \ usize = 0;\n    let mut close_brackets_idx15: usize = 0;\n    let mut open_brackets_idx16:\
    \ usize = 0;\n    let mut close_bra\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpj3qnsxjq.rs:46:22\n   |\n\
    46 |     let mut close_bra\n   |                      ^ help: add `;` here\n47\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj3qnsxjq.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = \n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpu2uqnkzl.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_brackets_iter = brackets.char_indices().filter_map(|i| {\n\
    \        if i.0 != i.1 {\n            Some(String::from(\"<\"))\n        } else\
    \ {\n            None\n        }\n    });\n    let mut closing_brackets_iter =\
    \ brackets.char_indices().filter_map(|i| {\n        if i.0 != i.1 {\n        \
    \    Some(String::from(\">\"))\n        } else {\n            None\n        }\n\
    \    });\n    let mut opening_brackets_next = opening_brackets_iter.next();\n\
    \    let mut closing_brackets_next = closing_brackets_iter.next();\n    while\
    \ opening_brackets_next != None && closing_brackets_next != None {\n        if\
    \ opening_brackets_next.unwrap() == closing_brackets_next.unwrap() {\n       \
    \     opening_brackets += opening_brackets_next.unwrap();\n            closing_brackets\
    \ += closing_brackets_next.unwrap();\n            opening_brackets_next = opening_brackets_iter.next();\n\
    \            closing_brackets_next = closing_brackets_iter.next();\n        }\
    \ else {\n            opening_brackets += opening_brackets_next.unwrap();\n  \
    \          closing_brackets += closing_brackets_next.unwrap();\n            opening_brackets_next\
    \ = opening_brackets_iter.next();\n            closing_brackets_next = closing_brackets_iter.next();\n\
    \        }\n    }\n    opening_brackets.len() == closing_brackets.len()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd_hppbw1.rs:15:19\n   |\n\
    15 |         if i.0 != i.1 {\n   |                   ^^^ expected `usize`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_hppbw1.rs:22:19\n\
    \   |\n22 |         if i.0 != i.1 {\n   |                   ^^^ expected `usize`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd_hppbw1.rs:32:33\n\
    \   |\n32 |             opening_brackets += opening_brackets_next.unwrap();\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |   \
    \                              |\n   |                                 expected\
    \ `&str`, found struct `String`\n   |                                 help: consider\
    \ borrowing here: `&opening_brackets_next.unwrap()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd_hppbw1.rs:33:33\n   |\n33 |             closing_brackets\
    \ += closing_brackets_next.unwrap();\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                 |\n   |                                \
    \ expected `&str`, found struct `String`\n   |                               \
    \  help: consider borrowing here: `&closing_brackets_next.unwrap()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd_hppbw1.rs:37:33\n   |\n37 |             opening_brackets\
    \ += opening_brackets_next.unwrap();\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                 |\n   |                                \
    \ expected `&str`, found struct `String`\n   |                               \
    \  help: consider borrowing here: `&opening_brackets_next.unwrap()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd_hppbw1.rs:38:33\n   |\n38 |             closing_brackets\
    \ += closing_brackets_next.unwrap();\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                 |\n   |                                \
    \ expected `&str`, found struct `String`\n   |                               \
    \  help: consider borrowing here: `&closing_brackets_next.unwrap()`\n\nerror:\
    \ aborting due to 6 previous errors\n\nFo"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    opening_brackets.push('>');\n            closing_brackets.push('<');\n  \
    \      } else if bracket == '>' {\n            opening_brackets.push('<');\n \
    \           closing_brackets.push('>');\n        } else {\n            opening_brackets.push(bracket);\n\
    \        }\n    }\n    opening_brackets.chars().all(|c| closing_brackets.chars().any(|c|\
    \ c == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmlst2t_a.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = \n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmps_s1dy4r.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for c in brackets.chars() {\n        if\
    \ c == '<' {\n            stack.push(brackets.len());\n        } else if c ==\
    \ '>' {\n            if stack.len() == 0 {\n                return false;\n  \
    \          }\n            let top = stack.len();\n            if top != brackets.len()\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            let top = stack.len();\n            if top != brackets.len()\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmph729b6g1.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices();\n    let mut close_brackets_iter\
    \ = brackets.char_indices();\n    let mut open_brackets_end = open_brackets_iter.end();\n\
    \    let mut close_brackets_end = close_brackets_iter.end();\n    let mut open_brackets_start\
    \ = open_brackets_iter.next();\n    let mut close_brackets_start = close_brackets_iter.next();\n\
    \    while open_brackets_start != open_brackets_end && close_brackets_start !=\
    \ close_brackets_end {\n        if open_brackets_start.index() == close_brackets_start.index()\
    \ {\n            open_brackets += open_brackets_start.unwrap();\n            close_brackets\
    \ += close_brackets_start.unwrap();\n            open_brackets_start = open_brackets_iter.next();\n\
    \            close_brackets_start = close_brackets_iter.next();\n        } else\
    \ {\n            if open_brackets_start.index() < close_brackets_start.index()\
    \ {\n                open_brackets += open_brackets_start.unwrap();\n        \
    \        open_brackets_start = open_brackets_iter.next();\n            } else\
    \ {\n                close_brackets += close_brackets_start.unwrap();\n      \
    \          close_brackets_start = close_brackets_iter.next();\n            }\n\
    \        }\n    }\n    open_brackets == close_brackets\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `end` found for struct `CharIndices` in the\
    \ current scope\n  --> /tmp/tmpric0w8it.rs:16:52\n   |\n16 |     let mut open_brackets_end\
    \ = open_brackets_iter.end();\n   |                                          \
    \          ^^^ method not found in `CharIndices<'_>`\n\nerror[E0599]: no method\
    \ named `end` found for struct `CharIndices` in the current scope\n  --> /tmp/tmpric0w8it.rs:17:54\n\
    \   |\n17 |     let mut close_brackets_end = close_brackets_iter.end();\n   |\
    \                                                      ^^^ method not found in\
    \ `CharIndices<'_>`\n\nerror[E0599]: no method named `index` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmpric0w8it.rs:21:32\n   |\n21 |         if\
    \ open_brackets_start.index() == close_brackets_start.index() {\n   |        \
    \                        ^^^^^ method not found in `Option<(usize, char)>`\n\n\
    error[E0599]: no method named `index` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmpric0w8it.rs:21:64\n   |\n21 |         if open_brackets_start.index()\
    \ == close_brackets_start.index() {\n   |                                    \
    \                            ^^^^^ method not found in `Option<(usize, char)>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpric0w8it.rs:22:30\n   |\n22 |\
    \             open_brackets += open_brackets_start.unwrap();\n   |           \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found tuple\n\
    \   |\n   = note: expected reference `&str`\n                  found tuple `(usize,\
    \ char)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpric0w8it.rs:23:31\n\
    \   |\n23 |             close_brackets += close_brackets_start.unwrap();\n   |\
    \                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found tuple\n   |\n   = note: expected reference `&str`\n                  found\
    \ tuple `(usize, char)`\n\nerror[E0599]: no method named `index` found for enum\
    \ `Option` in the current scope\n  --> /tmp/tmpric0w8it.rs:27:36\n   |\n27 | \
    \            if open_brackets_start.index() < close_brackets_start.index() {\n\
    \   |                                 "
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '>' || c == '<')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpx72fju7r.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    bracket\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpno2gymcj.rs:72:5\n\
    \   |\n72 |     bracket\n   |     ^^^^^^^ help: a local variable with a similar\
    \ name exists: `brackets`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = \n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmps_s1dy4r.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = \n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmps_s1dy4r.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n    let mut open_bracket =\
    \ String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_brackets = String::new();\n    let mut open_bracket\
    \ = String::new();\n    let mut close_bracket = String::new();\n    let mut open_brackets\
    \ = String::new();\n    let mut close_bra\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpz72gs0rw.rs:50:22\n   |\n\
    50 |     let mut close_bra\n   |                      ^ help: add `;` here\n51\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz72gs0rw.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_brackets_stack = Vec::new();\n    let mut closing_brackets_stack\
    \ = Vec::new();\n    let mut opening_brackets_stack_ptr = &mut opening_brackets_stack;\n\
    \    let mut closing_brackets_stack_ptr = &mut closing_brackets_stack;\n    let\
    \ mut opening_brackets_ptr = &mut opening_brackets;\n    let mut closing_brackets_ptr\
    \ = &mut closing_brackets;\n    let mut opening_brackets_ptr = &mut opening_brackets;\n\
    \    let mut closing_brackets_ptr = &mut closing_brackets;\n    let mut opening_brackets_ptr\
    \ = &mut opening_brackets;\n    let mut closing_brackets_ptr = &mut closing_brackets;\n\
    \    let mut opening_brackets_ptr = &mut opening_brackets;\n    let mut closing_brackets_ptr\
    \ = &mut closing_brackets;\n    let mut opening_brackets_ptr = &mut opening_brackets;\n\
    \    let mut closing_brackets_ptr = &mut closing_brackets;\n    let mut opening_brackets_ptr\
    \ = &mut opening_brackets;\n    let mut closing_brackets_ptr = &mut closing_brackets;\n\
    \    let mut opening_brackets_ptr = &mut opening_brackets;\n    let mut closing_brackets_ptr\
    \ = &mut closing_brackets;\n    let mut opening_brackets_ptr = &mut opening_brackets;\n\
    \    let mut closing_brackets_ptr = &mut closing_brackets;\n    let mut opening_brackets_ptr\
    \ = &mut opening_brackets;\n    let mut closing_brackets_ptr = &mut closing_brackets;\n\
    \    let mut opening_brackets_ptr = &mut opening_brackets;\n    let mut closing_brackets_ptr\
    \ = &mut closing_brackets;\n    let mut opening_bracket\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt9001ehs.rs:38:28\n   |\n\
    38 |     let mut opening_bracket\n   |                            ^ help: add\
    \ `;` here\n39 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpt9001ehs.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>>\"\
    , \"\");\n    brackets.\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpw2boaqo9.rs:70:1\n   |\n70\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw2boaqo9.rs:69:5\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                  ---- expected `bool` because of return type\n\
    ...\n69 |     brackets.\n   |     ^^^^^^^^ expected `bool`, found struct `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp_olaza9.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().filter(|c| c == '<').collect::<Vec<_>>());\n\
    \    while let Some(open) = stack.pop() {\n        if let Some(close) = stack.pop()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n        } else {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpvuttbqro.rs:13:46\n\
    \   |\n13 |     stack.push(brackets.chars().filter(|c| c == '<').collect::<Vec<_>>());\n\
    \   |                                              ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut open_bracket = String::new();\n        let mut close_bracket\
    \ = String::new();\n        let mut open_brackets = String::new();\n        let\
    \ mut close_brackets = String::new();\n        while brackets.len() > 0 {\n  \
    \          let mut open_bracket = String::new();\n            let mut close_bracket\
    \ = String::new();\n            let mut open_brackets = String::new();\n     \
    \       let mut close_brackets = String::new();\n            if brackets.len()\
    \ > 0 {\n                let mut open_bracket = brackets.chars().next().unwrap();\n\
    \                let mut close_bracket = brackets.chars().next().unwrap();\n \
    \               let mut open_brackets = String::new();\n                let mut\
    \ close_brackets = String::new();\n                while open_bracket.len() >\
    \ 0 {\n                    let mut open_bracket = open_bracket.chars().next().unwrap();\n\
    \                    let mut close_bracket = close_bracket.chars().next().unwrap();\n\
    \                    open_brackets.push_str(open_bracket);\n                 \
    \   close_brackets.push_str(close_bracket);\n                }\n            }\n\
    \            if open_brackets.len() > 0 {\n                open_brackets.push_str(\"\
    [\");\n            }\n            if close_brackets.len() > 0 {\n            \
    \    close_brackets.push_str(\"]\");\n            }\n            open_brackets.push_str(&open_brackets);\n\
    \            close_brackets.push_str(&close_brackets);\n            open_brackets.clear();\n\
    \            close_brackets.clear();\n            open_bracket = String::new();\n\
    \            close_bracket = String::new();\n            brackets = brackets.chars().next().unwrap();\n\
    \        }\n        if open_brackets.len() > 0 {\n            open_brackets.push_str(\"\
    [\");\n        }\n        if close_brackets.len() > 0 {\n            close_brackets.push_str(\"\
    ]\");\n        }\n        open_brackets.push_str(&open_brackets);\n        close_brackets.push_str(&close_brackets);\n\
    \        open_bra\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmptq2qd362.rs:76:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n15 |     while\
    \ brackets.len() > 0 {\n   |                              - this delimiter might\
    \ not be properly closed...\n...\n60 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n76 | }\n   |   ^\n\nerror[E0425]: cannot find\
    \ value `open_bra` in this scope\n  --> /tmp/tmptq2qd362.rs:59:9\n   |\n59 | \
    \        open_bra\n   |         ^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `len` found for type `char` in the current scope\n  --> /tmp/tmptq2qd362.rs:30:36\n\
    \   |\n30 |                 while open_bracket.len() > 0 {\n   |             \
    \                       ^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmptq2qd362.rs:31:57\n\
    \   |\n31 |                     let mut open_bracket = open_bracket.chars().next().unwrap();\n\
    \   |                                                         ^^^^^ method not\
    \ found in `char`\n\nerror[E0599]: no method named `chars` found for type `char`\
    \ in the current scope\n  --> /tmp/tmptq2qd362.rs:32:59\n   |\n32 |          \
    \           let mut close_bracket = close_bracket.chars().next().unwrap();\n \
    \  |                                                           ^^^^^ method not\
    \ found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptq2qd362.rs:49:24\n\
    \   |\n12 |     let mut brackets = brackets.to_string();\n   |               \
    \         -------------------- expected due to this value\n...\n49 |         \
    \    brackets = brackets.chars().next().unwrap();\n   |                      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptq2qd362.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    -----------"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_b\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt7f0alan.rs:51:20\n   |\n\
    51 |     let mut close_b\n   |                    ^ help: add `;` here\n52 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt7f0alan.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().filter(|c| *c != '<').collect::<Vec<_>>());\n\
    \    while let Some(open) = stack.pop() {\n        if let Some(close) = stack.pop()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n        } else {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkd5s95yr.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut open_brackets = Vec::new();\n    open_brackets.push(false);\n   \
    \ while let Some(b) = stack.last() {\n        if b == ']' {\n            stack.pop();\n\
    \            if stack.len() == 0 {\n                return false;\n          \
    \  }\n            open_brackets.pop();\n        } else {\n            stack.push(b);\n\
    \            open_brackets.push(true);\n        }\n    }\n    open_brackets.iter().all(|b|\
    \ b)\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpcwib5y_2.rs:17:14\n\
    \   |\n17 |         if b == ']' {\n   |              ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpcwib5y_2.rs:24:24\n   |\n24 |  \
    \           stack.push(b);\n   |                        ^ expected `char`, found\
    \ `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |         \
    \    stack.push(*b);\n   |                        +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcwib5y_2.rs:28:34\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                            ---- expected\
    \ `bool` because of return type\n...\n28 |     open_brackets.iter().all(|b| b)\n\
    \   |                                  ^ expected `bool`, found `&bool`\n   |\n\
    help: consider dereferencing the borrow\n   |\n28 |     open_brackets.iter().all(|b|\
    \ *b)\n   |                                  +\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = String::new();\n    let\
    \ mut close_brackets = String::new();\n    for c in brackets {\n        if c ==\
    \ '<' {\n            stack.push(c);\n            open_brackets.push(c);\n    \
    \    } else if c == '>' {\n            if stack.len() == 0 {\n               \
    \ return false;\n            }\n            close_brackets.push(c);\n        \
    \    stack.pop();\n        } else {\n            if stack.len() == 0 {\n     \
    \           return false;\n            }\n            close_brackets.push(c);\n\
    \        }\n    }\n    if stack.len() != 0 {\n        return false;\n    }\n \
    \   if open_brackets.len() != close_brackets.len() {\n        return false;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpn5q81cff.rs:15:14\n\
    \   |\n15 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == b'<' || c == b'>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpajdfm_2a.rs:12:35\n   |\n\
    12 |     brackets.chars().all(|c| c == b'<' || c == b'>')\n   |              \
    \                     ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpajdfm_2a.rs:12:48\n   |\n12 |     brackets.chars().all(|c|\
    \ c == b'<' || c == b'>')\n   |                                              \
    \  ^^^^ expected `char`, found `u8`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = \n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmps_s1dy4r.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        if let Some(close) = stack.last()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n        }\n        stack.pop();\n        stack.push(open);\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbmge5agx.rs:21:20\n   |\n\
    21 |         stack.push(open);\n   |                    ^^^^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |   \
    \      stack.push(*open);\n   |                    +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: -1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while !brackets.ends_with('>') {\n\
    \        brackets = brackets.replace(\"<\", \"<<\");\n        brackets = brackets.replace(\"\
    <\", \"<<\");\n    }\n    while !brackets.ends_with('<') {\n        brackets =\
    \ brackets.replace(\"<\", \"<<\");\n        brackets = brackets.replace(\"<\"\
    , \"<<\");\n    }\n    brackets.ends_with('>')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011554
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| c !=\
    \ '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().skip_while(|c| c\
    \ != '>').collect::<Vec<_>>());\n    stack.push(brackets.chars().skip_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().skip_while(|c|\
    \ c != '>').collect::<Vec<_>>());\n    stack.push(brackets.chars().skip_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().skip_while(|c|\
    \ c != '>').collect::<Vec<_>>());\n    stack.push(brackets.chars().skip_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().skip_while(|c|\
    \ c != '>').collect::<Vec<_>>());\n    stack.push(brackets.chars().skip_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().skip_while(|c|\
    \ c != '>').collect::<Vec<_>>());\n    stack.push(brackets.chars().skip_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().skip_while(|c|\
    \ c != '>').collect::<Vec<_>>());\n    stack.push(brackets.chars().skip_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().skip_while(|c|\
    \ c != '>').collect::<Vec<_>>());\n    stack.push(brackets.chars().skip_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().skip_while(|c|\
    \ c != '>').collect::<Vec<_>>());\n    stack.push(brackets.chars().skip_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().skip_while(|c|\
    \ c != '>').collect::<Vec<_>>());\n    stack.push(brackets.chars().skip_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n    stack.push(brackets.char\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmph9ba2_9w.rs:32:15\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n32 |     stack.push(brackets.char\n   |               ^ unclosed\
    \ delimiter\n33 | }\n   | ^ mismatched closing delimiter\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmph9ba2_9w.rs:13:50\n   |\n13 |   \
    \  stack.push(brackets.chars().skip_while(|c| c != '<').collect::<Vec<_>>());\n\
    \   |                                                  ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmph9ba2_9w.rs:14:50\n\
    \   |\n14 |     stack.push(brackets.chars().skip_while(|c| c != '>').collect::<Vec<_>>());\n\
    \   |                                                  ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmph9ba2_9w.rs:15:50\n\
    \   |\n15 |     stack.push(brackets.chars().skip_while(|c| c != '<').collect::<Vec<_>>());\n\
    \   |                                                  ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmph9ba2_9w.rs:16:50\n\
    \   |\n16 |     stack.push(brackets.chars().skip_while(|c| c != '>').collect::<Vec<_>>());\n\
    \   |                                                  ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmph9ba2_9w.rs:17:50\n\
    \   |\n17 |     stack."
  stdout: ''
  timestamp: 1660011549
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars() {\n        if\
    \ ch == '<' {\n            stack.push(0);\n        } else if ch == '>' {\n   \
    \         if stack.len() == 0 {\n                return false;\n            }\n\
    \            let top = stack.len() - 1;\n            if stack[top] != 0 {\n  \
    \              return false;\n            }\n            stack.pop();\n      \
    \  } else {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.push(ch as usize);\n        }\n    }\n    stack.len()\
    \ == 0 && true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n  \
    \  assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\"\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp77vopu4g.rs:75:21\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n75 |     brackets.replace(\"<\", \"\"\n   |                     ^\
    \ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp77vopu4g.rs:75:5\n   |\n11 |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                              ---- expected\
    \ `bool` because of return type\n...\n75 | /     brackets.replace(\"<\", \"\"\n\
    76 | | }\n   | |_^ expected `bool`, found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() != 0 {\n      \
    \          return false;\n            }\n        }\n    }\n    stack.len() ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011549
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() == 0 {\n      \
    \          return false;\n            }\n            stack.pop();\n          \
    \  stack.push(c);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\">>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<>><\"\
    , \"\");\n    brackets.replace(\"<<>><\", \"\");\n    brackets.replace(\"<<\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp2py6yync.rs:80:56\n\
    \   |\n80 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n81 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        if let Some(close) = stack.last()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n        }\n        stack.pop();\n        stack.push(open);\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbmge5agx.rs:21:20\n   |\n\
    21 |         stack.push(open);\n   |                    ^^^^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |   \
    \      stack.push(*open);\n   |                    +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() != 0 {\n      \
    \          return false;\n            }\n        }\n    }\n    stack.len() ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp69g8o027.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n  \
    \  assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvpsxuxy8.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp_olaza9.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() == 0 {\n      \
    \          return false;\n            }\n            stack.pop();\n          \
    \  stack.push(c);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n    let mut closing_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n    let mut opening_brackets_iter = opening_brackets_iter.into_iter();\n\
    \    let mut closing_brackets_iter = closing_brackets_iter.into_iter();\n    let\
    \ mut opening_brackets_iter = opening_brackets_iter.zip2(&mut closing_brackets_iter,\
    \ |(opening_bracket, closing_bracket)| {\n        opening_bracket.cmp(closing_bracket)\n\
    \    });\n    opening_brackets_iter.all(|(opening_bracket, closing_bracket)| {\n\
    \        opening_bracket.cmp(closing_bracket) == 0\n    })\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp2xccovow.rs:14:84\n\
    \   |\n14 |     let mut opening_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '<').collect::<Vec<_>>();\n   |                                   \
    \                                                 ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp2xccovow.rs:15:84\n   |\n15\
    \ |     let mut closing_brackets_iter = brackets.chars().enumerate().filter(|(_,\
    \ c)| c != '>').collect::<Vec<_>>();\n   |                                   \
    \                                                 ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0599]:\
    \ no method named `zip2` found for struct `std::vec::IntoIter` in the current\
    \ scope\n  --> /tmp/tmp2xccovow.rs:18:59\n   |\n18 |     let mut opening_brackets_iter\
    \ = opening_brackets_iter.zip2(&mut closing_brackets_iter, |(opening_bracket,\
    \ closing_bracket)| {\n   |                                                  \
    \         ^^^^ method not found in `std::vec::IntoIter<(usize, char)>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = String::new();\n   \
    \ let mut closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mut closing_brackets = String::new();\n    let mut opening_bracket\
    \ = String::new();\n    let mut closing_bracket = String::new();\n    let mut\
    \ opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_bracket = String::new();\n    let mut closing_bracket = String::new();\n\
    \    let mut opening_brackets = String::new();\n    let mut closing_brackets =\
    \ String::new();\n    let mut opening_bracket = String::new();\n    let mut closing_bracket\
    \ = String::new();\n    let mut opening_brackets = String::new();\n    let mut\
    \ closing_brackets = String::new();\n    let mut opening_bracket = String::new();\n\
    \    let mut closing_bracket = String::new();\n    let mut opening_brackets =\
    \ String::new();\n    let mu\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp24n40i81.rs:50:11\n   |\n\
    50 |     let mu\n   |           ^ help: add `;` here\n51 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp24n40i81.rs:11:44\n \
    \  |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_ptr = &mut open_brackets_stack;\n\
    \    let mut close_brackets_stack_ptr = &mut close_brackets_stack;\n    let mut\
    \ open_brackets_ptr = &mut open_brackets;\n    let mut close_brackets_ptr = &mut\
    \ close_brackets;\n    let mut open_brackets_ptr = &mut open_brackets;\n    let\
    \ mut close_brackets_ptr = &mut close_brackets;\n    let mut open_brackets_ptr\
    \ = &mut open_brackets;\n    let mut close_brackets_ptr = &mut close_brackets;\n\
    \    let mut open_brackets_ptr = &mut open_brackets;\n    let mut close_brackets_ptr\
    \ = &mut close_brackets;\n    let mut open_brackets_ptr = &mut open_brackets;\n\
    \    let mut close_brackets_ptr = &mut close_brackets;\n    let mut open_brackets_ptr\
    \ = &mut open_brackets;\n    let mut close_brackets_ptr = &mut close_brackets;\n\
    \    let mut open_brackets_ptr = &mut open_brackets;\n    let mut close_brackets_ptr\
    \ = &mut close_brackets;\n    let mut open_brackets_ptr = &mut open_brackets;\n\
    \    let mut close_brackets_ptr = &mut close_brackets;\n    let mut open_brackets_ptr\
    \ = &mut open_brackets;\n    let mut close_brackets_ptr = &mut close_brackets;\n\
    \    let mut open_brackets_ptr = &mut open_brackets;\n    let mut close_brackets_ptr\
    \ = &mut close_brackets;\n    let mut open_brackets_ptr = &mut open_brackets;\n\
    \    let mut close_brackets_ptr = &mut \n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpt7ue2dxa.rs:40:1\n\
    \   |\n40 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else if bracket == '{' {\n          \
    \  open_brackets.push('}');\n            close_brackets.push('{');\n        }\
    \ else if bracket == '}' {\n            open_brackets.push('{');\n           \
    \ close_brackets.push('}');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpi15wqkji.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 0 {\n     \
    \   let mut open_bracket = brackets.chars().nth(0).unwrap();\n        let mut\
    \ close_bracket = brackets.chars().nth(1).unwrap();\n        if open_bracket ==\
    \ close_bracket {\n            brackets = brackets.chars().nth(2).unwrap();\n\
    \        } else {\n            return false;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpytzxia8_.rs:17:24\n   |\n\
    12 |     let mut brackets = brackets.to_string();\n   |                      \
    \  -------------------- expected due to this value\n...\n17 |             brackets\
    \ = brackets.chars().nth(2).unwrap();\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \      |\n   |                        expected struct `String`, found `char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \        }\n    }\n    open_brackets == close_brackets\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpckorupvy.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets {\n        if c == '<' {\n  \
    \          stack.push(c);\n        } else if c == '>' {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            return false;\n        }\n    }\n    stack.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2omac57x.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n        } else if bracket == '>' {\n          \
    \  closed_brackets.push('<');\n        } else {\n            open_brackets.push(bracket);\n\
    \        }\n    }\n    open_brackets.chars().all(|c| closed_brackets.chars().any(|c|\
    \ c == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcgciicny.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \n    for bracket in brackets.chars() {\n        if bracket == '<' {\n       \
    \     open_brackets.push('>');\n            close_brackets.push('<');\n      \
    \  } else if bracket == '>' {\n            open_brackets.push('<');\n        \
    \    close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \        }\n    }\n\n    open_brackets.chars().all(|c| close_brackets.chars().any(|c|\
    \ c == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxw9sutu5.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() == 0 {\n      \
    \          return false;\n            }\n            stack.pop();\n          \
    \  stack.push(c);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut close_brackets_stack_size = close_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_next = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_next_next = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_next_next_next = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next_next_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_next_next_next_next = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next_next_next_next = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_next_next_next_next_next = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_next_next_next_next_next_next = &mut open_brackets_stack[open\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp9kdayeb7.rs:31:1\n   |\n31 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp9kdayeb7.rs:30:93\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |                                                 - closing delimiter\
    \ possibly meant for this\n...\n30 |     let mut open_brackets_stack_ptr_next_next_next_next_next_next\
    \ = &mut open_brackets_stack[open\n   |                                      \
    \                                                       ^ unclosed delimiter\n\
    31 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets {\n        if c == '<' {\n  \
    \          stack.push(c);\n        } else if c == '>' {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            if stack.len() != 0 {\n                return false;\n\
    \            }\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpxwnmjuff.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        let next = stack.last().unwrap();\n\
    \        if open == next {\n            stack.pop();\n        } else {\n     \
    \       return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp2m29jqzi.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_size = brackets.chars().filter(|c| c == '<').count();\n\
    \    let mut close_brackets_size = brackets.chars().filter(|c| c == '>').count();\n\
    \    let mut open_brackets_chars = String::new();\n    let mut close_brackets_chars\
    \ = String::new();\n    let mut open_brackets_chars_size = brackets.chars().filter(|c|\
    \ c == '<').count();\n    let mut close_brackets_chars_size = brackets.chars().filter(|c|\
    \ c == '>').count();\n    let mut open_brackets_chars = String::new();\n    let\
    \ mut close_brackets_chars = String::new();\n    let mut open_brackets_chars_size\
    \ = brackets.chars().filter(|c| c == '<').count();\n    let mut close_brackets_chars_size\
    \ = brackets.chars().filter(|c| c == '>').count();\n    let mut open_brackets_chars\
    \ = String::new();\n    let mut close_brackets_chars = String::new();\n    let\
    \ mut open_brackets_chars_size = brackets.chars().filter(|c| c == '<').count();\n\
    \    let mut close_brackets_chars_size = brackets.chars().filter(|c| c == '>').count();\n\
    \    let mut open_brackets_chars = String::new();\n    let mut close_brackets_chars\
    \ = String::new();\n    let mut open_brackets_chars_size = brackets.chars().filter(|c|\
    \ c == '<').count();\n    let mut close_brackets_chars_size = brackets.chars().filter(|c|\
    \ c == '>').count();\n    let mut open_brackets_chars = String::new();\n    let\
    \ mut close_brackets_chars = String::new();\n    let mut open_brackets_chars_size\
    \ = brackets.chars().filter(|c| c == '<').count();\n    let mut close_brackets_chars_size\
    \ = brackets.chars().filter(|c| c == '>').count();\n    let mut open_brackets_chars\
    \ = String::new();\n    let mut close_brackets_chars = String::new\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpckcjl9sb.rs:37:47\n   |\n\
    37 |     let mut close_brackets_chars = String::new\n   |                    \
    \                           ^ help: add `;` here\n38 | }\n   | - unexpected token\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpckcjl9sb.rs:14:64\n\
    \   |\n14 |     let mut open_brackets_size = brackets.chars().filter(|c| c ==\
    \ '<').count();\n   |                                                        \
    \        ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpckcjl9sb.rs:15:65\n   |\n15 |     let mut close_brackets_size =\
    \ brackets.chars().filter(|c| c == '>').count();\n   |                       \
    \                                          ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpckcjl9sb.rs:18:70\n   |\n18 |   \
    \  let mut open_brackets_chars_size = brackets.chars().filter(|c| c == '<').count();\n\
    \   |                                                                      ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpckcjl9sb.rs:19:71\n\
    \   |\n19 |     let mut close_brackets_chars_size = brackets.chars().filter(|c|\
    \ c == '>').count();\n   |                                                   \
    \                    ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpckcjl9sb.rs:22:70\n   |\n22 |     let mut open_brackets_chars_size\
    \ = brackets.ch"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp64rc0ksi.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices();\n    let mut close_brackets_iter\
    \ = brackets.char_indices();\n    let mut open_brackets_next = open_brackets_iter.next();\n\
    \    let mut close_brackets_next = close_brackets_iter.next();\n    while let\
    \ Some(open_bracket) = open_brackets_next {\n        open_brackets += open_bracket.to_string();\n\
    \        if open_brackets_iter.next().is_none() {\n            open_brackets_next\
    \ = open_brackets_iter.next();\n        } else {\n            open_brackets_next\
    \ = open_brackets_iter.next();\n        }\n    }\n    while let Some(close_bracket)\
    \ = close_brackets_next {\n        close_brackets += close_bracket.to_string();\n\
    \        if close_brackets_iter.next().is_none() {\n            close_brackets_next\
    \ = close_brackets_iter.next();\n        } else {\n            close_brackets_next\
    \ = close_brackets_iter.next();\n        }\n    }\n    open_brackets == close_brackets\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `(usize, char)` doesn't implement `std::fmt::Display`\n \
    \ --> /tmp/tmpbneirj1z.rs:19:39\n   |\n19 |         open_brackets += open_bracket.to_string();\n\
    \   |                                       ^^^^^^^^^ `(usize, char)` cannot be\
    \ formatted with the default formatter\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `(usize, char): std::fmt::Display`\n       \
    \    which is required by `(usize, char): ToString`\n\nerror[E0599]: `(usize,\
    \ char)` doesn't implement `std::fmt::Display`\n  --> /tmp/tmpbneirj1z.rs:27:41\n\
    \   |\n27 |         close_brackets += close_bracket.to_string();\n   |       \
    \                                  ^^^^^^^^^ `(usize, char)` cannot be formatted\
    \ with the default formatter\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `(usize, char): std::fmt::Display`\n           which\
    \ is required by `(usize, char): ToString`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for ch in brackets {\n        if ch == '<' {\n\
    \            stack.push('<');\n        } else if ch == '>' {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.push(ch);\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpn5y2xwl4.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    bracket\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpno2gymcj.rs:72:5\n\
    \   |\n72 |     bracket\n   |     ^^^^^^^ help: a local variable with a similar\
    \ name exists: `brackets`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(item) = stack.last() {\n        if item == '<' {\n       \
    \     if stack.len() == 1 {\n                return false;\n            }\n  \
    \          stack.pop();\n            stack.push(brackets.chars().next().unwrap());\n\
    \        } else if item == '>' {\n            if stack.len() == 1 {\n        \
    \        return false;\n            }\n            stack.pop();\n            stack.push(brackets.chars().next().unwrap());\n\
    \        } else {\n            stack.push(brackets.chars().next().unwrap());\n\
    \        }\n    }\n    stack.len() == 1\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp59g0bzjy.rs:15:17\n\
    \   |\n15 |         if item == '<' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp59g0bzjy.rs:21:24\n\
    \   |\n21 |         } else if item == '>' {\n   |                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    open_brackets.push('>');\n            close_brackets.push('<');\n       \
    \ } else if bracket == '>' {\n            open_brackets.push('<');\n         \
    \   close_brackets.push('>');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp64rc0ksi.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for c in brackets.chars() {\n        if\
    \ c == '<' {\n            stack.push(0);\n        } else if c == '>' {\n     \
    \       if stack.len() == 0 {\n                return false;\n            }\n\
    \            stack.pop();\n        } else {\n            if stack.len() == 0 {\n\
    \                return false;\n            }\n            stack[stack.len() -\
    \ 1] += 1;\n        }\n    }\n    stack.iter().all(|&x| x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp933tmt9v.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmp933tmt9v.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmp933tmt9v.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = \n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmps_s1dy4r.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.replace(\"<<><>>\"\
    , \"\");\n    brackets.replace(\"<<><>>\", \"\");\n    brackets.\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpj8nrjwyk.rs:65:1\n   |\n65\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj8nrjwyk.rs:64:5\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                  ---- expected `bool` because of return type\n\
    ...\n64 |     brackets.\n   |     ^^^^^^^^ expected `bool`, found struct `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    stack.push(brackets);\n    while stack.len()\
    \ > 0 {\n        let mut current_brackets = stack.pop();\n        for bracket\
    \ in current_brackets.chars() {\n            if bracket == '<' {\n           \
    \     open_brackets.push(bracket);\n            } else if bracket == '>' {\n \
    \               close_brackets.push(bracket);\n            } else {\n        \
    \        return false;\n            }\n        }\n    }\n    for open_bracket\
    \ in open_brackets {\n        for close_bracket in close_brackets {\n        \
    \    if open_bracket == close_bracket {\n                return false;\n     \
    \       }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpgwvdzyb8.rs:18:41\n   |\n18 |         for bracket in current_brackets.chars()\
    \ {\n   |                                         ^^^^^ method not found in `Option<String>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    for c in brackets {\n        if c == '<' {\n\
    \            stack.push(c);\n            open_brackets.push(c);\n        } else\
    \ if c == '>' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            close_brackets.push(stack.pop());\n        } else\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.push(c);\n        }\n    }\n    if stack.len() !=\
    \ 0 {\n        return false;\n    }\n    if open_brackets.len() != close_brackets.len()\
    \ {\n        return false;\n    }\n    for c in open_brackets {\n        if close_brackets.iter().any(|c|\
    \ *c == c) {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp3_wg_03e.rs:15:14\n\
    \   |\n15 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3_wg_03e.rs:38:48\n   |\n38 |         if close_brackets.iter().any(|c|\
    \ *c == c) {\n   |                                                ^\n   |    \
    \                                            |\n   |                         \
    \                       expected enum `Option`, found `&Option<_>`\n   |     \
    \                                           help: you can convert from `&Option<T>`\
    \ to `Option<&T>` using `.as_ref()`: `c.as_ref()`\n   |\n   = note:   expected\
    \ enum `Option<_>`\n           found reference `&Option<_>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c >= '<' && c <= '>'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvmahyqct.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp_2n3kwal.rs:82:56\n\
    \   |\n82 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n83 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp_2n3kwal.rs:82:56\n\
    \   |\n82 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n83 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() != 0 {\n      \
    \          return false;\n            }\n        }\n    }\n    stack.len() ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().take_while(|c| c !=\
    \ '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().take_while(|c| c\
    \ != '>').collect::<Vec<_>>());\n    stack.push(brackets.chars().take_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().take_while(|c|\
    \ c != '>').collect::<Vec<_>>());\n    stack.push(brackets.chars().take_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().take_while(|c|\
    \ c != '>').collect::<Vec<_>>());\n    stack.push(brackets.chars().take_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().take_while(|c|\
    \ c != '>').collect::<Vec<_>>());\n    stack.push(brackets.chars().take_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().take_while(|c|\
    \ c != '>').collect::<Vec<_>>());\n    stack.push(brackets.chars().take_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().take_while(|c|\
    \ c != '>').collect::<Vec<_>>());\n    stack.push(brackets.chars().take_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().take_while(|c|\
    \ c != '>').collect::<Vec<_>>());\n    stack.push(brackets.chars().take_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().take_while(|c|\
    \ c != '>').collect::<Vec<_>>());\n    stack.push(brackets.chars().take_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n    stack.push(brackets.chars().take_while(|c|\
    \ c != '>').collect::<Vec<_>>());\n    stack.push(brackets.chars().take_while(|c|\
    \ c \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpsnuvyc71.rs:31:43\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n31 |     stack.push(brackets.chars().take_while(|c| c \n   |    \
    \                                       ^ unclosed delimiter\n32 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0277]: can't compare `&char` with `char`\n  -->\
    \ /tmp/tmpsnuvyc71.rs:13:50\n   |\n13 |     stack.push(brackets.chars().take_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n   |                                      \
    \            ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpsnuvyc71.rs:14:50\n   |\n14 |     stack.push(brackets.chars().take_while(|c|\
    \ c != '>').collect::<Vec<_>>());\n   |                                      \
    \            ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpsnuvyc71.rs:15:50\n   |\n15 |     stack.push(brackets.chars().take_while(|c|\
    \ c != '<').collect::<Vec<_>>());\n   |                                      \
    \            ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpsnuvyc71.rs:16:50\n   |\n16 |     stack.push(brackets.chars().take_while(|c|\
    \ c != '>').collect::<Vec<_>>());\n   |                                      \
    \            ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  -"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while !brackets.is_empty() {\n   \
    \     let mut open_bracket = brackets.chars().next().unwrap();\n        while\
    \ !open_bracket.is_ascii() {\n            open_bracket = open_bracket.next_char();\n\
    \        }\n        let mut close_bracket = open_bracket;\n        while !close_bracket.is_ascii()\
    \ {\n            close_bracket = close_bracket.next_char();\n        }\n     \
    \   if open_bracket != close_bracket {\n            return false;\n        }\n\
    \        brackets = brackets.next_char().unwrap();\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next_char` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpzh88_xy6.rs:16:41\n   |\n16 |             open_bracket\
    \ = open_bracket.next_char();\n   |                                         ^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `next_char` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpzh88_xy6.rs:20:43\n   |\n\
    20 |             close_bracket = close_bracket.next_char();\n   |            \
    \                               ^^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `next_char` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpzh88_xy6.rs:25:29\n   |\n25 |         brackets = brackets.next_char().unwrap();\n\
    \   |                             ^^^^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<<>>\"\
    , \"\");\n    brackets.replace(\"<<<>>\", \"\");\n    brackets.replace(\"<<\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp57q6ns1y.rs:80:56\n\
    \   |\n80 |       assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    \   |  ________________________________________________________^\n81 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp69g8o027.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\"\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp77vopu4g.rs:75:21\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n75 |     brackets.replace(\"<\", \"\"\n   |                     ^\
    \ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp77vopu4g.rs:75:5\n   |\n11 |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                              ---- expected\
    \ `bool` because of return type\n...\n75 | /     brackets.replace(\"<\", \"\"\n\
    76 | | }\n   | |_^ expected `bool`, found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.is_empty() {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.is_empty() {\n      \
    \          return false;\n            }\n            stack.pop();\n          \
    \  stack.push(c);\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011550
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().filter(|c| c == '<').collect::<Vec<_>>());\n\
    \    while stack.len() > 0 {\n        let mut open = stack.pop().unwrap();\n \
    \       let mut close = stack.pop().unwrap();\n        if open == close {\n  \
    \          continue;\n        }\n        if open == '>' && close == '<' {\n  \
    \          stack.push('<');\n            stack.push('>');\n        } else {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp7f4oh7r5.rs:13:46\n\
    \   |\n13 |     stack.push(brackets.chars().filter(|c| c == '<').collect::<Vec<_>>());\n\
    \   |                                              ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `Vec<char>` with `char`\n  --> /tmp/tmp7f4oh7r5.rs:20:17\n   |\n\
    20 |         if open == '>' && close == '<' {\n   |                 ^^ no implementation\
    \ for `Vec<char> == char`\n   |\n   = help: the trait `PartialEq<char>` is not\
    \ implemented for `Vec<char>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7f4oh7r5.rs:21:24\n   |\n21 |             stack.push('<');\n\
    \   |                        ^^^ expected struct `Vec`, found `char`\n   |\n \
    \  = note: expected struct `Vec<char>`\n                found type `char`\n\n\
    error[E0277]: can't compare `Vec<char>` with `char`\n  --> /tmp/tmp7f4oh7r5.rs:20:33\n\
    \   |\n20 |         if open == '>' && close == '<' {\n   |                   \
    \              ^^ no implementation for `Vec<char> == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `Vec<char>`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <Vec<T,\
    \ A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U; N]>>\n\
    \             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as PartialEq<&mut\
    \ [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n             <Vec<T, A>\
    \ as PartialEq<[U]>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7f4oh7r5.rs:22:24\n\
    \   |\n22 |             stack.push('>');\n   |                        "
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c >= '<' && c <= '>'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvmahyqct.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets {\n        if c == '<' {\n  \
    \          stack.push(c);\n        } else if c == '>' {\n            if stack.is_empty()\
    \ {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            if stack.len() != 0 {\n                return false;\n\
    \            }\n        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpp0a7uuv3.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\"\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp77vopu4g.rs:75:21\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n75 |     brackets.replace(\"<\", \"\"\n   |                     ^\
    \ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp77vopu4g.rs:75:5\n   |\n11 |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                              ---- expected\
    \ `bool` because of return type\n...\n75 | /     brackets.replace(\"<\", \"\"\n\
    76 | | }\n   | |_^ expected `bool`, found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices();\n    let mut close_brackets_iter\
    \ = brackets.char_indices();\n    let mut open_brackets_next = open_brackets_iter.next();\n\
    \    let mut close_brackets_next = close_brackets_iter.next();\n    while open_brackets_next\
    \ != None && close_brackets_next != None {\n        let open_bracket = open_brackets_next.unwrap();\n\
    \        let close_bracket = close_brackets_next.unwrap();\n        if open_bracket\
    \ == '<' {\n            open_brackets += open_bracket;\n            open_brackets_next\
    \ = open_brackets_iter.next();\n        }\n        if close_bracket == '>' {\n\
    \            close_brackets += close_bracket;\n            close_brackets_next\
    \ = close_brackets_iter.next();\n        }\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl_ldy5fx.rs:21:28\n   |\n\
    21 |         if open_bracket == '<' {\n   |                            ^^^ expected\
    \ tuple, found `char`\n   |\n   = note: expected tuple `(usize, char)`\n     \
    \          found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl_ldy5fx.rs:22:30\n\
    \   |\n22 |             open_brackets += open_bracket;\n   |                 \
    \             ^^^^^^^^^^^^ expected `&str`, found tuple\n   |\n   = note: expected\
    \ reference `&str`\n                  found tuple `(usize, char)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpl_ldy5fx.rs:25:29\n   |\n25 |         if close_bracket\
    \ == '>' {\n   |                             ^^^ expected tuple, found `char`\n\
    \   |\n   = note: expected tuple `(usize, char)`\n               found type `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpl_ldy5fx.rs:26:31\n   |\n26 |\
    \             close_brackets += close_bracket;\n   |                         \
    \      ^^^^^^^^^^^^^ expected `&str`, found tuple\n   |\n   = note: expected reference\
    \ `&str`\n                  found tuple `(usize, char)`\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_index = 0;\n    let mut close_brackets_stack_index\
    \ = 0;\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_index = 0;\n    let mut close_brackets_stack_index\
    \ = 0;\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_index = 0;\n    let mut close_brackets_stack_index\
    \ = 0;\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_index = 0;\n    let mut close_brackets_stack_index\
    \ = 0;\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_index = 0;\n    let mut close_brackets_stack_index\
    \ = 0;\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_index = 0;\n    let mut close_brackets_stack_index\
    \ = 0;\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_index = 0;\n    let mut close_brackets_stack_index\
    \ = 0;\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_index = 0;\n    let mut close_brackets_stack_index\
    \ = 0;\n    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_index = 0;\n    let mut close_brackets_stack_index\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgpvd28vg.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c >= '<' && c <= '>'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvmahyqct.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\"\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp77vopu4g.rs:75:21\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n75 |     brackets.replace(\"<\", \"\"\n   |                     ^\
    \ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp77vopu4g.rs:75:5\n   |\n11 |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                              ---- expected\
    \ `bool` because of return type\n...\n75 | /     brackets.replace(\"<\", \"\"\n\
    76 | | }\n   | |_^ expected `bool`, found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut close_brackets_stack_size = close_brackets_stack.len();\n    let\
    \ mut i = 0;\n    while i < brackets.len() {\n        let mut j = i;\n       \
    \ while j < brackets.len() && brackets[j] == brackets[j + 1] {\n            j\
    \ += 1; // skip the closing bracket\n        }\n        if j == i {\n        \
    \    // no more brackets to check\n            break;\n        }\n        let\
    \ open_bracket = brackets[j];\n        open_brackets_stack.push(open_bracket);\n\
    \        close_brackets_stack.push(brackets[j + 1]);\n        i += j - i;\n  \
    \  }\n    if open_brackets_stack_size == close_brackets_stack_size {\n       \
    \ // all brackets are correctly closed\n        return true;\n    }\n    if open_brackets_stack_size\
    \ > close_brackets_stack_size {\n        // some brackets are correctly opened\n\
    \        return false;\n    }\n    // some brackets are correctly closed\n   \
    \ let mut i = 0;\n    while i < open_brackets_stack_size {\n        if open_brackets_stack[i]\
    \ != open_brackets_stack[open_brackets_stack_size] {\n            // some brackets\
    \ are correctly opened\n            return false;\n        }\n        i += 1;\n\
    \    }\n    // all brackets are correctly opened\n    return true;\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpogdek7wj.rs:21:37\n\
    \   |\n21 |         while j < brackets.len() && brackets[j] == brackets[j + 1]\
    \ {\n   |                                     ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpogdek7wj.rs:21:52\n   |\n21 |         while j < brackets.len()\
    \ && brackets[j] == brackets[j + 1] {\n   |                                  \
    \                  ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpogdek7wj.rs:28:28\n\
    \   |\n28 |         let open_bracket = brackets[j];\n   |                    \
    \        ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \    loop {\n        if stack.is_empty() {\n            return false;\n      \
    \  }\n        let mut first = stack.pop().unwrap();\n        if first == '<' {\n\
    \            if stack.is_empty() {\n                return false;\n          \
    \  }\n            let mut second = stack.pop().unwrap();\n            if second\
    \ == '>' {\n                stack.push(first);\n            } else {\n       \
    \         stack.push(first + second);\n            }\n        } else {\n     \
    \       stack.push(first);\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp802e70bb.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0277]: can't compare `Vec<char>` with\
    \ `char`\n  --> /tmp/tmp802e70bb.rs:19:18\n   |\n19 |         if first == '<'\
    \ {\n   |                  ^^ no implementation for `Vec<char> == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `Vec<char>`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as\
    \ PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n      \
    \       <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0277]: can't compare `Vec<char>`\
    \ with `char`\n  --> /tmp/tmp802e70bb.rs:24:23\n   |\n24 |             if second\
    \ == '>' {\n   |                       ^^ no implementation for `Vec<char> ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `Vec<char>`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as\
    \ PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n      \
    \       <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0369]: cannot add `Vec<char>`\
    \ to `Vec<char>`\n  --> /tmp/tmp802e70bb.rs:27:34\n   |\n27 |                \
    \ stack.push(first + second);\n   |                            ----- ^ ------\
    \ Vec<char>\n   |                            |\n   |                         \
    \   Vec<char>\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0369, E0599.\nFor more information about an error,\
    \ try `rustc --explain"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<String>());\n\
    \    while stack.len() > 0 {\n        let mut last = stack.last().unwrap();\n\
    \        if last == \">\" || last == \"<\" {\n            stack.pop();\n     \
    \   } else {\n            return false;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpd300fz17.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<String>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for c in brackets.chars() {\n        if c == '<' {\n\
    \            stack.push(c);\n        } else if c == '>' {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            if stack.len() != 0 {\n                return false;\n\
    \            }\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011550
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\">\", \"\");\n    brackets.replace(\"<<\", \"\");\n    brackets.replace(\"\
    >>\", \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\"\
    , \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    brackets.replace(\">>>\",\
    \ \"\");\n    brackets.replace(\"<<<\", \"\");\n    bracket\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `bracket` in this scope\n  --> /tmp/tmpno2gymcj.rs:72:5\n\
    \   |\n72 |     bracket\n   |     ^^^^^^^ help: a local variable with a similar\
    \ name exists: `brackets`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = brackets.chars().filter(|c| c == '<');\n    let mut closing_brackets\
    \ = brackets.chars().filter(|c| c == '>');\n    let mut opening_brackets_iter\
    \ = opening_brackets.iter();\n    let mut closing_brackets_iter = closing_brackets.iter();\n\
    \    let mut opening_brackets_next = opening_brackets_iter.next();\n    let mut\
    \ closing_brackets_next = closing_brackets_iter.next();\n    while opening_brackets_next.unwrap()\
    \ != closing_brackets_next.unwrap() {\n        if opening_brackets_next.unwrap()\
    \ == '<' {\n            if closing_brackets_next.unwrap() == '>' {\n         \
    \       opening_brackets_iter.next();\n                closing_brackets_iter.next();\n\
    \            } else {\n                opening_brackets_iter.next();\n       \
    \         opening_brackets_next = opening_brackets_iter.next();\n            }\n\
    \        } else {\n            if closing_brackets_next.unwrap() == '>' {\n  \
    \              closing_brackets_iter.next();\n                closing_brackets_next\
    \ = closing_brackets_iter.next();\n            } else {\n                closing_brackets_iter.next();\n\
    \                closing_brackets_next = closing_brackets_iter.next();\n     \
    \       }\n        }\n    }\n    opening_brackets_next.unwrap() == closing_brackets_next.unwrap()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpx6b9uw26.rs:12:62\n\
    \   |\n12 |     let mut opening_brackets = brackets.chars().filter(|c| c == '<');\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpx6b9uw26.rs:13:62\n\
    \   |\n13 |     let mut closing_brackets = brackets.chars().filter(|c| c == '>');\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0599]: no method named `iter` found for struct `Filter` in the current\
    \ scope\n  --> /tmp/tmpx6b9uw26.rs:14:54\n   |\n14 |     let mut opening_brackets_iter\
    \ = opening_brackets.iter();\n   |                                           \
    \           ^^^^ private field, not a method\n\nerror[E0599]: no method named\
    \ `iter` found for struct `Filter` in the current scope\n  --> /tmp/tmpx6b9uw26.rs:15:54\n\
    \   |\n15 |     let mut closing_brackets_iter = closing_brackets.iter();\n   |\
    \                                                      ^^^^ private field, not\
    \ a method\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \    while stack.len() > 0 {\n        let mut opening = stack.pop().unwrap();\n\
    \        let mut closing = stack.pop().unwrap();\n        if opening != closing\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpywqsih1p.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '<' {\n        \
    \    opening_brackets.push('>');\n            closing_brackets.push('<');\n  \
    \      } else if bracket == '>' {\n            opening_brackets.push('<');\n \
    \           closing_brackets.push('>');\n        } else if bracket == '{' {\n\
    \            opening_brackets.push('}');\n        } else if bracket == '}' {\n\
    \            opening_brackets.push('{');\n        } else if bracket == '(' { //\
    \ TODO: handle nested parens\n            opening_brackets.push(')');\n      \
    \  } else if bracket == ')' {\n            opening_brackets.push('(');\n     \
    \   } else {\n            return false;\n        }\n    }\n    opening_brackets.chars().all(|c|\
    \ closing_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpn7g3v69j.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011550
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_brackets_iter = brackets.chars().enumerate();\n    let mut\
    \ closing_brackets_iter = brackets.chars().enumerate();\n    let mut opening_brackets_next\
    \ = opening_brackets_iter.next();\n    let mut closing_brackets_next = closing_brackets_iter.next();\n\
    \    while opening_brackets_next.is_some() {\n        opening_brackets += opening_brackets_next.unwrap().0;\n\
    \        opening_brackets_next = opening_brackets_iter.next();\n    }\n    while\
    \ closing_brackets_next.is_some() {\n        closing_brackets += closing_brackets_next.unwrap().0;\n\
    \        closing_brackets_next = closing_brackets_iter.next();\n    }\n    opening_brackets.chars().all(|c|\
    \ closing_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg5msyz4u.rs:19:29\n   |\n\
    19 |         opening_brackets += opening_brackets_next.unwrap().0;\n   |     \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg5msyz4u.rs:23:29\n\
    \   |\n23 |         closing_brackets += closing_brackets_next.unwrap().0;\n  \
    \ |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found `usize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n\n    for bracket in brackets.chars() {\n    \
    \    if bracket == '<' {\n            stack.push(bracket);\n            open_brackets.push(bracket);\n\
    \        }\n        if bracket == '>' {\n            if stack.len() == 0 {\n \
    \               return false;\n            }\n            close_brackets.push(stack.pop());\n\
    \        }\n    }\n\n    if stack.len() != 0 {\n        return false;\n    }\n\
    \n    if open_brackets.len() != close_brackets.len() {\n        return false;\n\
    \    }\n\n    for open_bracket in open_brackets {\n        if close_brackets.contains(&open_bracket)\
    \ {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbk_agik9.rs:38:36\n   |\n\
    38 |         if close_brackets.contains(&open_bracket) {\n   |               \
    \                     ^^^^^^^^^^^^^ expected enum `Option`, found `char`\n   |\n\
    \   = note: expected reference `&Option<char>`\n              found reference\
    \ `&char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_count = String::new();\n    let mut close_brackets_count\
    \ = String::new();\n    let mut open_brackets_count_max = String::new();\n   \
    \ let mut close_brackets_count_max = String::new();\n    let mut open_brackets_count_min\
    \ = String::new();\n    let mut close_brackets_count_min = String::new();\n  \
    \  let mut open_brackets_count_min = String::new();\n    let mut close_brackets_count_min\
    \ = String::new();\n    let mut open_brackets_count_max = String::new();\n   \
    \ let mut close_brackets_count_max = String::new();\n    let mut open_brackets_count_min\
    \ = String::new();\n    let mut close_brackets_count_min = String::new();\n  \
    \  let mut open_brackets_count_max = String::new();\n    let mut close_brackets_count_max\
    \ = String::new();\n    let mut open_brackets_count_min = String::new();\n   \
    \ let mut close_brackets_count_min = String::new();\n    let mut open_brackets_count_max\
    \ = String::new();\n    let mut close_brackets_count_max = String::new();\n  \
    \  let mut open_brackets_count_min = String::new();\n    let mut close_brackets_count_min\
    \ = String::new();\n    let mut open_brackets_count_max = String::new();\n   \
    \ let mut close_brackets_count_max = String::new();\n    let mut open_brackets_count_min\
    \ = String::new();\n    let mut close_brackets_count_min = String::new();\n  \
    \  let mut open_brackets_count_max = String::new();\n    let mut close_brackets_count_max\
    \ = String::new();\n    let mut open_brackets_count_min = String::new();\n   \
    \ let mut close_brackets_count_min = String::new();\n    let mut open_brackets_count_max\
    \ = String::new();\n    let mut close_brackets_count_max = String::new();\n  \
    \  let mut open_brackets_count_min = String::new();\n    let mut close_brackets_count_min\
    \ = String::new();\n    let mut open_brackets_\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzu_o88kk.rs:46:27\n   |\n\
    46 |     let mut open_brackets_\n   |                           ^ help: add `;`\
    \ here\n47 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpzu_o88kk.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 0
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '<'\
    \ {\n            stack.push(c);\n        } else if c == '>' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() == 0 {\n      \
    \          return false;\n            }\n            stack.pop();\n          \
    \  stack.push(c);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp_olaza9.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"<\", \"\");\n \
    \   brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n\
    \    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"\
    <\", \"\");\n    brackets.replace(\"<\", \"\");\n    brackets.replace(\"<\", \"\
    \");\n    brackets.replace(\"<\", \"\"\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp77vopu4g.rs:75:21\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - closing delimiter possibly meant for\
    \ this\n...\n75 |     brackets.replace(\"<\", \"\"\n   |                     ^\
    \ unclosed delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp77vopu4g.rs:75:5\n   |\n11 |   fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |                                              ---- expected\
    \ `bool` because of return type\n...\n75 | /     brackets.replace(\"<\", \"\"\n\
    76 | | }\n   | |_^ expected `bool`, found struct `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '<' || c == '>')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"<>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<><>>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<><>><>\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpp_olaza9.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 101
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c >= '<' && c <= '>'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\")), true);\n\
    \    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpvmahyqct.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets {\n        if bracket == '<' {\n            open_brackets.push('>');\n\
    \            close_brackets.push('<');\n        } else if bracket == '>' {\n \
    \           open_brackets.push('<');\n            close_brackets.push('>');\n\
    \        } else {\n            open_brackets.push(bracket);\n            close_brackets.push(bracket);\n\
    \        }\n    }\n    open_brackets == close_brackets\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpusle7zxy.rs:14:20\n\
    \   |\n14 |     for bracket in brackets {\n   |                    ^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets {\n        if c == '<' {\n  \
    \          stack.push(c);\n        } else if c == '>' {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            return false;\n        }\n    }\n    stack.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    <>\")), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n \
    \   assert_eq!(candidate(String::from(\"<><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<<><><>><>><<><><<>>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <<<><>>>>\")), false);\n    assert_eq!(candidate(String::from(\"><<>\")), false);\n\
    \    assert_eq!(candidate(String::from(\"<\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<<<\")), false);\n    assert_eq!(candidate(String::from(\">\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"<<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>><<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2omac57x.rs:13:14\n\
    \   |\n13 |     for c in brackets {\n   |              ^^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011549
- exit_code: 1
  program: "/// brackets is a string of \"<\" and \">\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    <\"))\n/// false\n/// >>> correct_bracketing(String::from(\"<>\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"<<><>>\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    ><<>\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut close_brackets_stack_size = close_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_end = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_end_ptr = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_end_ptr_end = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end_ptr = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_end_ptr_end_ptr = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end_ptr_end = &mut open_brackets_stack[open_brackets_stack_size];\n\
    \    let mut close_brackets_stack_ptr_end_ptr_end_ptr_end = &mut close_brackets_stack[close_brackets_stack_size];\n\
    \    let mut open_brackets_stack_ptr_end_ptr_end_ptr\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"<>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<><>>\")), true);\n    assert_eq!(candidate(String::from(\"\
    <><><<><>><>\")), true);\n    assert_eq!(candidate(String::from(\"<><><<<><><>><>><<><><<>>>\"\
    )), true);\n    assert_eq!(candidate(String::from(\"<<<><>>>>\")), false);\n \
    \   assert_eq!(candidate(String::from(\"><<>\")), false);\n    assert_eq!(candidate(String::from(\"\
    <\")), false);\n    assert_eq!(candidate(String::from(\"<<<<\")), false);\n  \
    \  assert_eq!(candidate(String::from(\">\")), false);\n    assert_eq!(candidate(String::from(\"\
    <<>\")), false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>><<>\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"<><><<><>><>>><>\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4nvoz691.rs:30:52\n   |\n\
    30 |     let mut open_brackets_stack_ptr_end_ptr_end_ptr\n   |               \
    \                                     ^ help: add `;` here\n31 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4nvoz691.rs:11:44\n \
    \  |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011549
