language: rs
name: HumanEval_2_truncate_number
results:
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.is_negative() ? -number.abs().floor() as i32 : number.abs().floor()\
    \ as i32;\n    while exponent > 0 {\n        let mut next_remainder = remainder;\n\
    \        let mut next_result = result;\n        let mut next_exponent = exponent;\n\
    \        while next_exponent > 0 {\n            let mut next_next_remainder =\
    \ next_remainder;\n            let mut next_next_result = next_result;\n     \
    \       let mut next_next_exponent = next_exponent;\n            while next_next_exponent\
    \ > 0 {\n                let mut next_next_next_remainder = next_next_remainder;\n\
    \                let mut next_next_next_result = next_next_result;\n         \
    \       let mut next_next_next_exponent = next_next_exponent;\n              \
    \  while next_next_next_exponent > 0 {\n                    let mut next_next_next_next_remainder\
    \ = next_next_next_remainder;\n                    let mut next_next_next_next_result\
    \ = next_next_next_result;\n                    let mut next_next_next_next_exponent\
    \ = next_next_next_exponent;\n                    while next_next_next_next_exponent\
    \ > 0 {\n                        let mut next_next_next_next_next_remainder =\
    \ next_next_next_next_remainder;\n                        let mut next_next_next_next_next_result\
    \ = next_next_next_next_result;\n                        let mut next_next_next_next_next_exponent\
    \ = next_next_next_next_exponent;\n                        while next_next_next_next_next_exponent\
    \ > 0 {\n                            let mut next_next_next_next_next_remainder\
    \ = next_next_next_next_next_remainder;\n                            let mut next_next_next_next_next_result\
    \ = next_next_next_next_next_result;\n                            let mut next_next_next_next_next_exponent\
    \ = next_next_next_next_next_exponent;\n                            while next_next_next_next_next_exponent\
    \ > 0 {\n                                let mut next_next_next_next_next_remainder\
    \ = next_next_next_next_next_remainder;\n                                let mut\
    \ next_next_next_next_next_result = next_next_next_next_next_result;\n       \
    \                         let mut next_next_next_next_next_exponent = next_next_next_next_next_exponent;\n\
    \                                while next_next_next_next_next_exponent > 0 {\n\
    \                                    let mut next_next_next_next_next_remainder\
    \ = next_next_next_next_next_remainder;\n                                    let\
    \ mut next_next_next_next_next_result = next_next_next_next_next_result;\n   \
    \                                 let mut next_next_next_next_next_exponent =\
    \ next_next_next_next_next_exponent;\n                                    while\
    \ next_next_next_next_next_exponent > 0 {\n                                  \
    \      let mut next_next_next_next_next_remainder = next_next_next_next_next_remainder;\n\
    \                                        let mut \n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpqm_9dh5n.rs:53:3\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \                     - unclosed delimiter\n...\n11 |     while exponent > 0 {\n\
    \   |                        - unclosed delimiter\n...\n15 |         while next_exponent\
    \ > 0 {\n   |                                 - unclosed delimiter\n...\n19 |\
    \             while next_next_exponent > 0 {\n   |                           \
    \               - unclosed delimiter\n...\n23 |                 while next_next_next_exponent\
    \ > 0 {\n   |                                                   - unclosed delimiter\n\
    ...\n27 |                     while next_next_next_next_exponent > 0 {\n   | \
    \                                                           - unclosed delimiter\n\
    ...\n31 |                         while next_next_next_next_next_exponent > 0\
    \ {\n   |                                                                    \
    \ - unclosed delimiter\n...\n35 |                             while next_next_next_next_next_exponent\
    \ > 0 {\n   |                                                                \
    \         - unclosed delimiter\n...\n39 |                                 while\
    \ next_next_next_next_next_exponent > 0 {\n   |                              \
    \                                               - unclosed delimiter\n...\n43\
    \ |                                     while next_next_next_next_next_exponent\
    \ > 0 {\n   |                                                                \
    \                 - this delimiter might not be properly closed...\n...\n46 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n53 |\
    \ }\n   |   ^\n\nerror: casts cannot be followed by a method call\n  --> /tmp/tmpqm_9dh5n.rs:10:48\n\
    \   |\n10 |     let mut exponent = number.is_negative() ? -number.abs().floor()\
    \ as i32 : number.abs().floor() as i32;\n   |                                \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^---------\n   |                  \
    \                                                         |\n   |            \
    \             "
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ let mut sign = number.sign();\n\n    while exponent > 0 {\n        remainder\
    \ += 1.0;\n        integer_part += remainder;\n        decimal_part += remainder\
    \ * std::f64::from(std::powf(10.0, exponent));\n        exponent--;\n    }\n\n\
    \    sign * integer_part + decimal_part\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpmmha3xhi.rs:18:19\n\
    \   |\n18 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0425]: cannot find function `from` in module `std::f64`\n  --> /tmp/tmpmmha3xhi.rs:17:47\n\
    \   |\n17 |         decimal_part += remainder * std::f64::from(std::powf(10.0,\
    \ exponent));\n   |                                               ^^^^ not found\
    \ in `std::f64`\n\nerror[E0425]: cannot find function `powf` in crate `std`\n\
    \  --> /tmp/tmpmmha3xhi.rs:17:57\n   |\n17 |         decimal_part += remainder\
    \ * std::f64::from(std::powf(10.0, exponent));\n   |                         \
    \                                ^^^^ not found in `std`\n\nerror[E0599]: no method\
    \ named `exponent` found for type `f64` in the current scope\n  --> /tmp/tmpmmha3xhi.rs:11:31\n\
    \   |\n11 |     let mut exponent = number.exponent();\n   |                  \
    \             ^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named\
    \ `sign` found for type `f64` in the current scope\n  --> /tmp/tmpmmha3xhi.rs:12:27\n\
    \   |\n12 |     let mut sign = number.sign();\n   |                          \
    \ ^^^^ help: there is an associated function with a similar name: `copysign`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    while number > 0.0 {\n        integer += number % 10.0;\n\
    \        number /= 10.0;\n        remainder += number;\n    }\n    decimals =\
    \ remainder as f64;\n    integer as f64\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `decimals` is assigned to, but never used\n --> /tmp/tmpsuidc93o.rs:8:13\n\
    \  |\n8 |     let mut decimals = 0.0;\n  |             ^^^^^^^^\n  |\n  = note:\
    \ `#[warn(unused_variables)]` on by default\n  = note: consider using `_decimals`\
    \ instead\n\nwarning: value assigned to `decimals` is never read\n  --> /tmp/tmpsuidc93o.rs:16:5\n\
    \   |\n16 |     decimals = remainder as f64;\n   |     ^^^^^^^^\n   |\n   = note:\
    \ `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0384]: cannot assign to immutable argument `number`\n\
    \  --> /tmp/tmpsuidc93o.rs:13:9\n   |\n7  | fn truncate_number(number: f64) ->\
    \ f64 {\n   |                    ------ help: consider making this binding mutable:\
    \ `mut number`\n...\n13 |         number /= 10.0;\n   |         ^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 2 warnings emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.is_negative() ? -number.len() : number.len();\n    while\
    \ exponent > 0 {\n        remainder += number.powf(exponent);\n        truncated\
    \ = remainder / 10.0;\n        remainder %= 10.0;\n        exponent -= 1;\n  \
    \  }\n    truncated\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmp9eozr68m.rs:10:48\n\
    \   |\n10 |     let mut exponent = number.is_negative() ? -number.len() : number.len();\n\
    \   |                                                ^^^^^^^^^^^^---------\n \
    \  |                                                            |\n   |      \
    \                                                      help: remove the type ascription\n\
    \nerror[E0573]: expected type, found local variable `number`\n  --> /tmp/tmp9eozr68m.rs:10:63\n\
    \   |\n10 |     let mut exponent = number.is_negative() ? -number.len() : number.len();\n\
    \   |                                                               ^^^^^^ expecting\
    \ a type here because of type ascription\n\nwarning: use of deprecated associated\
    \ function `core::f64::<impl f64>::is_negative`: renamed to is_sign_negative\n\
    \  --> /tmp/tmp9eozr68m.rs:10:31\n   |\n10 |     let mut exponent = number.is_negative()\
    \ ? -number.len() : number.len();\n   |                               ^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(deprecated)]` on by default\n\nerror[E0277]: the `?`\
    \ operator can only be applied to values that implement `Try`\n  --> /tmp/tmp9eozr68m.rs:10:24\n\
    \   |\n10 |     let mut exponent = number.is_negative() ? -number.len() : number.len();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^ the `?` operator cannot be\
    \ applied to type `bool`\n   |\n   = help: the trait `Try` is not implemented\
    \ for `bool`\n\nerror[E0277]: the `?` operator can only be used in a function\
    \ that returns `Result` or `Option` (or another type that implements `FromResidual`)\n\
    \  --> /tmp/tmp9eozr68m.rs:10:45\n   |\n7  | / fn truncate_number(number: f64)\
    \ -> f64 {\n8  | |     let mut truncated = 0.0;\n9  | |     let mut remainder\
    \ = 0.0;\n10 | |     let mut exponent = number.is_negative() ? -number.len() :\
    \ number.len();\n   | |                                             ^ cannot use\
    \ the `?` operator in a function that returns `f64`\n...  |\n17 | |     truncated\n\
    18 | | }\n   | |_- this function should return `Result` or `Option` to accept\
    \ `?`\n   |\n   = help: the trait `FromResidual"
  stdout: ''
  timestamp: 1660011902
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 1.0 {\n        remainder -= 1.0;\n        result += 1.0;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpqwmr_8xl.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n\n    while number > 0.0 {\n        remainder = number % 10.0;\n\
    \        integer = integer + remainder;\n        number = number / 10.0;\n   \
    \     decimals = decimals + remainder;\n    }\n\n    number + decimals\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `remainder` is never read\n  --> /tmp/tmpmhz36x6u.rs:10:13\n\
    \   |\n10 |     let mut remainder = 0.0;\n   |             ^^^^^^^^^\n   |\n \
    \  = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nerror[E0384]: cannot assign to immutable argument\
    \ `number`\n  --> /tmp/tmpmhz36x6u.rs:15:9\n   |\n7  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |                    ------ help: consider making this binding\
    \ mutable: `mut number`\n...\n15 |         number = number / 10.0;\n   |     \
    \    ^^^^^^^^^^^^^^^^^^^^^^ cannot assign to immutable argument\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\n \
    \   while exponent > 0 {\n        remainder += number.fract().unwrap();\n    \
    \    integer_part += 1;\n        decimal_part += remainder / integer_part;\n \
    \       remainder %= integer_part;\n        exponent -= 1;\n    }\n\n    decimal_part\
    \ + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp_b11x2te.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `f64` in the current scope\n  --> /tmp/tmp_b11x2te.rs:14:37\n\
    \   |\n14 |         remainder += number.fract().unwrap();\n   |              \
    \                       ^^^^^^ method not found in `f64`\n\nerror[E0277]: cannot\
    \ add-assign `{integer}` to `{float}`\n  --> /tmp/tmp_b11x2te.rs:15:22\n   |\n\
    15 |         integer_part += 1;\n   |                      ^^ no implementation\
    \ for `{float} += {integer}`\n   |\n   = help: the trait `AddAssign<{integer}>`\
    \ is not implemented for `{float}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut mantissa = number.floor()\
    \ as f64;\n    while exponent > 0 {\n        mantissa = mantissa * 10.0;\n   \
    \     exponent -= 1;\n    }\n    mantissa = mantissa * 10.0;\n    while mantissa\
    \ > 1.0 {\n        mantissa /= 10.0;\n        decimal_part += 1.0;\n    }\n  \
    \  mantissa = mantissa * 10.0;\n    remainder = mantissa - 1.0;\n    decimal_part\
    \ += remainder;\n    decimal_part as f64\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7.0`,\n right: `0.5`', /tmp/tmpwjhzx0_f.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.f64::exp();\n    while exponent > 0.0 {\n        let mut remainder_part\
    \ = remainder;\n        let mut decimal_part = remainder_part / 10.0;\n      \
    \  remainder = remainder_part % 10.0;\n        result = result + decimal_part\
    \ * 10.0;\n        exponent = exponent - 1.0;\n    }\n    if remainder > 0.0 {\n\
    \        result = result + remainder;\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n \
    \   assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmppkz83rgp.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: invalid const generic expression\n  --> /tmp/tmppkz83rgp.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         let mut remainder_part\
    \ = remainder;\n13 | |         let mut decimal_part = remainder_part / 10.0;\n\
    14 | |         remainder = remainder_part % 10.0;\n15 | |         result = result\
    \ + decimal_part * 10.0;\n16 | |         exponent = exponent - 1.0;\n17 | |  \
    \   }\n   | |_____^\n   |\nhelp: expressions must be enclosed in braces to be\
    \ used as const generic arguments\n   |\n11 ~     { while exponent > 0.0 {\n12\
    \ |         let mut remainder_part = remainder;\n13 |         let mut decimal_part\
    \ = remainder_part / 10.0;\n14 |         remainder = remainder_part % 10.0;\n\
    15 |         result = result + decimal_part * 10.0;\n16 |         exponent = exponent\
    \ - 1.0;\n ...\n\nerror: expected one of `(`, `.`, `;`, `?`, `else`, or an operator,\
    \ found `::`\n  --> /tmp/tmppkz83rgp.rs:10:34\n   |\n10 |     let mut exponent\
    \ = number.f64::exp();\n   |                                  ^^ expected one\
    \ of `(`, `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to 3 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpkwva3xhz.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remaining = number;\n   \
    \ while remaining > 0.0 {\n        remaining = remaining - truncate_number(remaining);\n\
    \        decimals += 1.0;\n    }\n    decimals\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011908
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result + 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `{integer}` to `f64`\n  --> /tmp/tmphdgy1s6z.rs:10:25\n\
    \   |\n10 |         result = result + 1;\n   |                         ^ no implementation\
    \ for `f64 + {integer}`\n   |\n   = help: the trait `Add<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n10 |         result = result + 1.0;\n   |                      \
    \      ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.bit_count() - 1;\n    while exponent >= 0 {\n        let mut\
    \ part = number / 10.0;\n        result += (part * remainder).floor();\n     \
    \   remainder = part - remainder;\n        number -= part * 10.0;\n        exponent--;\n\
    \    }\n    result + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpyejhdl_2.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `bit_count` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpyejhdl_2.rs:10:31\n   |\n10 |     let mut exponent = number.bit_count()\
    \ - 1;\n   |                               ^^^^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut remaining = number;\n    while remaining > 1.0 {\n    \
    \    remaining = remaining.trunc();\n        decimals += 1.0;\n    }\n    if exponent\
    \ < 0 {\n        decimals -= 1.0;\n        exponent = -exponent;\n    }\n    exponent\
    \ as f64\n        * (f64::powf(10.0, exponent as f64).unwrap() as f64)\n     \
    \   / f64::powf(10.0, decimals as f64).unwrap() as f64\n}\n\nfn main() {\n   \
    \ let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n   \
    \ assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmplhpcy_iv.rs:20:45\n   |\n20 |         * (f64::powf(10.0,\
    \ exponent as f64).unwrap() as f64)\n   |                                    \
    \         ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmplhpcy_iv.rs:21:44\n\
    \   |\n21 |         / f64::powf(10.0, decimals as f64).unwrap() as f64\n   | \
    \                                           ^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ let mut mantissa = number.mantissa();\n    while exponent > 0 {\n        integer_part\
    \ += mantissa.truncate();\n        remainder += mantissa.truncate();\n       \
    \ mantissa = mantissa.next_mantissa();\n        exponent = exponent - 1;\n   \
    \ }\n    integer_part += remainder;\n    decimal_part = f64::from(integer_part);\n\
    \    decimal_part / f64::from(2.0 ** exponent)\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpb1gxbpah.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpb1gxbpah.rs:12:31\n   |\n12 |     let mut mantissa = number.mantissa();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut exponent = number.f64();\n    while exponent >\
    \ 0.0 {\n        integer += exponent / 10.0;\n        decimals += exponent % 10.0;\n\
    \        exponent = exponent / 10.0;\n    }\n    remainder = number - integer\
    \ * 10.0;\n    decimals -= remainder;\n    integer\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp008xbrdy.rs:11:31\n   |\n11 |     let mut exponent = number.f64();\n\
    \   |                               ^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result + 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `{integer}` to `f64`\n  --> /tmp/tmphdgy1s6z.rs:10:25\n\
    \   |\n10 |         result = result + 1;\n   |                         ^ no implementation\
    \ for `f64 + {integer}`\n   |\n   = help: the trait `Add<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n10 |         result = result + 1.0;\n   |                      \
    \      ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.is_negative() ? -number.len() : number.len();\n \
    \   while exponent > 0 {\n        let mut remainder_part = remainder;\n      \
    \  let mut decimal_part = remainder_part * 10.0;\n        remainder = remainder_part\
    \ - decimal_part;\n        exponent -= 1;\n    }\n    decimal_part + remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmpfph2gyfv.rs:10:48\n\
    \   |\n10 |     let mut exponent = number.is_negative() ? -number.len() : number.len();\n\
    \   |                                                ^^^^^^^^^^^^---------\n \
    \  |                                                            |\n   |      \
    \                                                      help: remove the type ascription\n\
    \nerror[E0573]: expected type, found local variable `number`\n  --> /tmp/tmpfph2gyfv.rs:10:63\n\
    \   |\n10 |     let mut exponent = number.is_negative() ? -number.len() : number.len();\n\
    \   |                                                               ^^^^^^ expecting\
    \ a type here because of type ascription\n\nwarning: use of deprecated associated\
    \ function `core::f64::<impl f64>::is_negative`: renamed to is_sign_negative\n\
    \  --> /tmp/tmpfph2gyfv.rs:10:31\n   |\n10 |     let mut exponent = number.is_negative()\
    \ ? -number.len() : number.len();\n   |                               ^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(deprecated)]` on by default\n\nerror[E0277]: the `?`\
    \ operator can only be applied to values that implement `Try`\n  --> /tmp/tmpfph2gyfv.rs:10:24\n\
    \   |\n10 |     let mut exponent = number.is_negative() ? -number.len() : number.len();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^ the `?` operator cannot be\
    \ applied to type `bool`\n   |\n   = help: the trait `Try` is not implemented\
    \ for `bool`\n\nerror[E0277]: the `?` operator can only be used in a function\
    \ that returns `Result` or `Option` (or another type that implements `FromResidual`)\n\
    \  --> /tmp/tmpfph2gyfv.rs:10:45\n   |\n7  | / fn truncate_number(number: f64)\
    \ -> f64 {\n8  | |     let mut decimal_part = 0.0;\n9  | |     let mut remainder\
    \ = 0.0;\n10 | |     let mut exponent = number.is_negative() ? -number.len() :\
    \ number.len();\n   | |                                             ^ cannot use\
    \ the `?` operator in a function that returns `f64`\n...  |\n17 | |     decimal_part\
    \ + remainder\n18 | | }\n   | |_- this function should return `Result` or `Option`\
    \ to accept `?`\n   |\n   = help: the t"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.is_negative() ? 1 : 0;\n    while number >= 1.0 {\n      \
    \  remainder += 1.0;\n        number -= 1.0;\n        exponent++;\n    }\n   \
    \ while number > 0.0 {\n        remainder += number;\n        number -= number;\n\
    \        exponent--;\n    }\n    result *= 10.0;\n    result += (number as f64).trunc().into();\n\
    \    result /= remainder;\n    result * 10.0 ** (exponent - 1)\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `1`\n\
    \  --> /tmp/tmpzytr9ewp.rs:10:47\n   |\n10 |     let mut exponent = number.is_negative()\
    \ ? 1 : 0;\n   |                                               ^ expected one\
    \ of `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.is_negative() ? -number.abs() as usize : 0;\n    while\
    \ number > 0.0 {\n        let mut digit = number % 10.0;\n        truncated =\
    \ truncated.checked_add(digit).unwrap();\n        remainder = number - truncated;\n\
    \        number = remainder;\n        exponent = exponent + 1;\n    }\n    truncated.checked_add(remainder).unwrap()\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `0`\n  --> /tmp/tmpyhga7gc6.rs:10:72\n   |\n\
    10 |     let mut exponent = number.is_negative() ? -number.abs() as usize : 0;\n\
    \   |                                                                      - ^\
    \ expected type\n   |                                                        \
    \              |\n   |                                                       \
    \               tried to parse a type due to this\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut exponent = number.abs();\n\
    \    while exponent > 0.0 {\n        if exponent % 1.0 == 0.0 {\n            result\
    \ *= 10.0;\n            exponent /= 10.0;\n        } else {\n            result\
    \ *= 10.0;\n        }\n    }\n    result + number\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011908
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut remainder_power = 0.0;\n    let mut remainder_power_power = 0.0;\n    let\
    \ mut remainder_power_power2 = 0.0;\n    let mut remainder_power_power3 = 0.0;\n\
    \    let mut remainder_power_power4 = 0.0;\n    let mut remainder_power_power5\
    \ = 0.0;\n    let mut remainder_power_power6 = 0.0;\n    let mut remainder_power_power7\
    \ = 0.0;\n    let mut remainder_power_power8 = 0.0;\n    let mut remainder_power_power9\
    \ = 0.0;\n    let mut remainder_power_power10 = 0.0;\n    let mut remainder_power_power11\
    \ = 0.0;\n    let mut remainder_power_power12 = 0.0;\n    let mut remainder_power_power13\
    \ = 0.0;\n    let mut remainder_power_power14 = 0.0;\n    let mut remainder_power_power15\
    \ = 0.0;\n    let mut remainder_power_power16 = 0.0;\n    let mut remainder_power_power17\
    \ = 0.0;\n    let mut remainder_power_power18 = 0.0;\n    let mut remainder_power_power19\
    \ = 0.0;\n    let mut remainder_power_power20 = 0.0;\n    let mut remainder_power_power21\
    \ = 0.0;\n    let mut remainder_power_power22 = 0.0;\n    let mut remainder_power_power23\
    \ = 0.0;\n    let mut remainder_power_power24 = 0.0;\n    let mut remainder_power_power25\
    \ = 0.0;\n    let mut remainder_power_power26 = 0.0;\n    let mut remainder_power_power27\
    \ = 0.0;\n    let mut remainder_power_power28 = 0.0;\n    let mut remainder_power_power29\
    \ = 0.0;\n    let mut remainder_power_power30 = 0.0;\n    let mut remainder_power_power31\
    \ = 0.0;\n    let mut remainder_power_power32 = 0.0;\n    let mut remainder_power_power33\
    \ = 0.0;\n    let mut remainder_power_power34 = 0.0;\n    let mut remainder_power_power35\
    \ = 0.0;\n    let mut remainder_power_power36 = 0.0;\n    let mut remainder_power_power37\
    \ = 0.0;\n    let mut remainder_power_power38 = 0.0;\n    let mut remainder_power_power39\
    \ = 0.0;\n    let mut remainder_power_power40 = 0.0;\n    let mut remain\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1izz8sik.rs:51:19\n   |\n\
    51 |     let mut remain\n   |                   ^ help: add `;` here\n52 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp1izz8sik.rs:7:36\n\
    \  |\n7 | fn truncate_number(number: f64) -> f64 {\n  |    ---------------   \
    \              ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut quotient = number.floor();\n    while quotient > 0.0 {\n        remainder\
    \ += quotient;\n        quotient = quotient - remainder;\n        decimal_part\
    \ += remainder;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `6.0`,\n right: `0.5`', /tmp/tmpdzoswxl3.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = number;\n    while remainder > 1.0 {\n        remainder -= 1.0;\n\
    \        decimals += 1.0;\n    }\n    while remainder > 0.0 {\n        remainder\
    \ -= 1.0;\n        integer += 1.0;\n    }\n    integer + decimals\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmplbgvioqw.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut integer = number.floor()\
    \ as i32;\n    while exponent > 0 {\n        integer /= 10;\n        decimal_part\
    \ += remainder;\n        remainder *= 10.0;\n        exponent -= 1;\n    }\n \
    \   decimal_part += remainder;\n    decimal_part\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.0`,\n right: `0.5`', /tmp/tmpbfelr0yc.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpkwva3xhz.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut exponent = number.f64();\n    while exponent >\
    \ 0.0 {\n        if exponent % 2 == 0.0 {\n            integer += exponent / 2.0;\n\
    \            exponent /= 2.0;\n        } else {\n            integer += 1.0;\n\
    \        }\n        remainder += exponent;\n        decimals += remainder;\n \
    \   }\n    decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpx_9g245q.rs:11:31\n   |\n11 |     let mut exponent = number.f64();\n\
    \   |                               ^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    while exponent > 0 {\n        let mut remainder_part\
    \ = remainder;\n        let mut new_remainder = remainder_part * 10.0;\n     \
    \   if new_remainder >= number {\n            new_remainder -= number;\n     \
    \   } else {\n            new_remainder -= number;\n            exponent -= 1;\n\
    \        }\n        result = result + new_remainder;\n        remainder = remainder_part;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n \
    \   assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp9bbm7ck_.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut remainder_sign = 1.0;\n    let mut remainder_magnitude\
    \ = 0.0;\n    let mut remainder_magnitude_inv = 0.0;\n    let mut remainder_magnitude_inv_sign\
    \ = 1.0;\n    let mut remainder_magnitude_inv_magnitude = 0.0;\n    let mut remainder_magnitude_inv_magnitude_sign\
    \ = 1.0;\n    let mut remainder_magnitude_inv_magnitude_magnitude = 0.0;\n   \
    \ let mut remainder_magnitude_inv_magnitude_magnitude_sign = 1.0;\n    let mut\
    \ remainder_magnitude_inv_magnitude_magnitude_magnitude = 0.0;\n    let mut remainder_magnitude_inv_magnitude_magnitude_magnitude_sign\
    \ = 1.0;\n    let mut remainder_magnitude_inv_magnitude_magnitude_magnitude_magnitude\
    \ = 0.0;\n    let mut remainder_magnitude_inv_magnitude_magnitude_magnitude_magnitude_sign\
    \ = 1.0;\n    let mut remainder_magnitude_inv_magnitude_magnitude_magnitude_magnitude_magnitude\
    \ = 0.0;\n    let mut remainder_magnitude_inv_magnitude_magnitude_magnitude_magnitude_magnitude_sign\
    \ = 1.0;\n    let mut remainder_magnitude_inv_magnitude_magnitude_magnitude_magnitude_magnitude_magnitude\
    \ = 0.0;\n    let mut remainder_magnitude_inv_magnitude_magnitude_magnitude_magnitude_magnitude_sign\
    \ = 1.0;\n    let mut remainder_magnitude_inv_magnitude_magnitude_magnitude_magnitude_magnitude_magnitude\
    \ = 0.0;\n    let mut remainder_magnitude_inv_magnitude_magnitude_magnitude_magnitude_magnitude_sign\
    \ = 1.0;\n    let mut remainder_magnitude_inv_magnitude_magnitude_magnitude_magnitude_magnitude_magnitude\
    \ = 0.0;\n    let mut remainder_magnitude_inv_magnitude_magnitude_magnitude_magnitude_magnitude_sign\
    \ = 1.0;\n    let mut remainder_magnitude_inv_magnitude_magnitude_magnitude_magnitude_magnitude_magnitude\
    \ = 0.0;\n    let mut remainder_magnitude_inv_magnitude_magnitude_magnitude_magnitude_magnitude_sign\
    \ = 1.0;\n    let mut remainder_magnitude_inv_magnitude_magnitude_magnitude_magnitude_magnitude_magnitude\
    \ = 0.\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyffxg2bx.rs:33:101\n   |\n\
    33 |     let mut remainder_magnitude_inv_magnitude_magnitude_magnitude_magnitude_magnitude_magnitude\
    \ = 0.\n   |                                                                 \
    \                                    ^ help: add `;` here\n34 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpyffxg2bx.rs:7:36\n  |\n\
    7 | fn truncate_number(number: f64) -> f64 {\n  |    ---------------         \
    \        ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.floor() as i32;\n    let mut fraction = number.sub_f64();\n\
    \    while exponent > 0 {\n        result += (fraction / 10.0);\n        remainder\
    \ *= 10.0;\n        fraction = fraction.sub_f64();\n        exponent = exponent\
    \ - 1;\n    }\n    result + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmpdn34398r.rs:13:19\n\
    \   |\n13 |         result += (fraction / 10.0);\n   |                   ^   \
    \            ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp:\
    \ remove these parentheses\n   |\n13 -         result += (fraction / 10.0);\n\
    13 +         result += fraction / 10.0;\n   | \n\nerror[E0599]: no method named\
    \ `sub_f64` found for type `f64` in the current scope\n  --> /tmp/tmpdn34398r.rs:11:31\n\
    \   |\n11 |     let mut fraction = number.sub_f64();\n   |                   \
    \            ^^^^^^^ method not found in `f64`\n\nerror: aborting due to previous\
    \ error; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result - 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `{integer}` from `f64`\n  --> /tmp/tmps58kp6c8.rs:10:25\n\
    \   |\n10 |         result = result - 1;\n   |                         ^ no implementation\
    \ for `f64 - {integer}`\n   |\n   = help: the trait `Sub<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n10 |         result = result - 1.0;\n   |                      \
    \      ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        remainder += 1.0;\n        integer_part += remainder;\n\
    \        remainder *= 10.0;\n        exponent -= 1;\n    }\n    integer_part +=\
    \ remainder;\n    decimal_part = number - integer_part + 1.0;\n    decimal_part\
    \ * 10.0\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpfzg7_lmt.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    while exponent > 0 {\n        let mut part\
    \ = number.remainder(&remainder);\n        if part < 1.0 {\n            result\
    \ += part;\n        } else {\n            result -= remainder;\n        }\n  \
    \      number -= part;\n        exponent--;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpa5o4twp1.rs:19:19\n\
    \   |\n19 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpa5o4twp1.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpa5o4twp1.rs:12:31\n   |\n12 |         let mut part = number.remainder(&remainder);\n\
    \   |                               ^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut remainder_sign = 1.0;\n    let mut exponent =\
    \ number.to_f64().exp();\n    while exponent > 0.0 {\n        let mut next_remainder\
    \ = remainder;\n        let mut next_remainder_sign = remainder_sign;\n      \
    \  let mut next_integer = integer;\n        let mut next_exponent = exponent;\n\
    \        while next_exponent > 0.0 {\n            let mut next_next_remainder\
    \ = next_remainder;\n            let mut next_next_remainder_sign = next_remainder_sign;\n\
    \            let mut next_next_integer = next_integer;\n            let mut next_next_exponent\
    \ = next_exponent;\n            while next_next_exponent > 0.0 {\n           \
    \     let mut next_next_next_remainder = next_next_remainder;\n              \
    \  let mut next_next_next_remainder_sign = next_next_remainder_sign;\n       \
    \         let mut next_next_next_integer = next_next_integer;\n              \
    \  let mut next_next_next_exponent = next_next_exponent;\n                while\
    \ next_next_next_exponent > 0.0 {\n                    let mut next_next_next_next_remainder\
    \ = next_next_next_remainder;\n                    let mut next_next_next_next_remainder_sign\
    \ = next_next_next_remainder_sign;\n                    let mut next_next_next_next_integer\
    \ = next_next_next_integer;\n                    let mut next_next_next_next_exponent\
    \ = next_next_next_exponent;\n                    while next_next_next_next_exponent\
    \ > 0.0 {\n                        let mut next_next_next_next_next_remainder\
    \ = next_next_next_next_remainder;\n                        let mut next_next_next_next_next_remainder_sign\
    \ = next_next_next_next_remainder_sign;\n                        let mut next_next_next_next_next_integer\
    \ = next_next_next_next_integer;\n                        let mut next_next_next_next_next_exponent\
    \ = next_next_next_next_exponent;\n                        while next_next_next_next_next_exponent\
    \ > 0.0 {\n                            let mut next_next_next_next_next_next_remainder\
    \ = next_next_next_next_next_remainder;\n                            let mut next_next_next_next_next_next_remainder_sign\
    \ = next_next_next_next_next_remainder_sign;\n                            let\
    \ mut next_next_next_next_next_next_integer = next_next_next_next_next_integer;\n\
    \                            let mut next_next_next_next_next_next_exponent =\
    \ next_next_next_next_next_exponent;\n                            while next_next_next_next_next_next_exponent\
    \ > 0.0 {\n                                let mut next_next_next_next_next_next_next_remainder\
    \ = next_next_next_next_\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpn6a5rg46.rs:52:3\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \                     - unclosed delimiter\n...\n13 |     while exponent > 0.0\
    \ {\n   |                          - unclosed delimiter\n...\n18 |         while\
    \ next_exponent > 0.0 {\n   |                                   - unclosed delimiter\n\
    ...\n23 |             while next_next_exponent > 0.0 {\n   |                 \
    \                           - unclosed delimiter\n...\n28 |                 while\
    \ next_next_next_exponent > 0.0 {\n   |                                      \
    \               - unclosed delimiter\n...\n33 |                     while next_next_next_next_exponent\
    \ > 0.0 {\n   |                                                              -\
    \ unclosed delimiter\n...\n38 |                         while next_next_next_next_next_exponent\
    \ > 0.0 {\n   |                                                              \
    \         - unclosed delimiter\n...\n43 |                             while next_next_next_next_next_next_exponent\
    \ > 0.0 {\n   |                                                              \
    \                  - this delimiter might not be properly closed...\n44 |    \
    \                             let mut next_next_next_next_next_next_next_remainder\
    \ = next_next_next_next_\n45 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n52 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  -->\
    \ /tmp/tmpn6a5rg46.rs:44:108\n   |\n44 |                                 let mut\
    \ next_next_next_next_next_next_next_remainder = next_next_next_next_\n   |  \
    \                                                                            \
    \                              ^ help: add `;` here\n45 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `next_next_next_next_` in this scope\n\
    \  --> /tmp/tmpn6a5rg46.rs:44:88\n   |\n44 | ...                   let mut next_next_next_next_next_next_next_remainder\
    \ = next_next_next_next_\n   |                                               \
    \                            "
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result - 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `{integer}` from `f64`\n  --> /tmp/tmps58kp6c8.rs:10:25\n\
    \   |\n10 |         result = result - 1;\n   |                         ^ no implementation\
    \ for `f64 - {integer}`\n   |\n   = help: the trait `Sub<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n10 |         result = result - 1.0;\n   |                      \
    \      ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut remainder_exponent =\
    \ exponent as i32;\n    let mut remainder_fraction = number.fract();\n    while\
    \ remainder_exponent > 0 {\n        remainder_fraction *= 10.0;\n        remainder_exponent\
    \ -= 1;\n    }\n    while remainder_fraction > 0.0 {\n        decimal_part +=\
    \ remainder_fraction / 10.0;\n        remainder_fraction -= remainder_fraction\
    \ / 10.0;\n        remainder_exponent += 1;\n    }\n    decimal_part + remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011908
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = 0;\n    let mut bits = 0.0;\n    let mut sign = number.is_negative()\
    \ ? -1.0 : 1.0;\n    let mut exponent = number.is_negative() ? -number.len() +\
    \ 1 : number.len() + 1;\n    let mut bits = number.is_negative() ? -number.len()\
    \ + 1 : number.len() + 1;\n    let mut i = 0;\n    while i < number.len() {\n\
    \        let mut digit = number.chars().nth(i).unwrap();\n        if digit ==\
    \ '.' {\n            decimal_part += remainder;\n            remainder = 0.0;\n\
    \            i += 1;\n            continue;\n        }\n        let mut digit\
    \ = number.chars().nth(i).unwrap();\n        let mut multiplier = 1.0;\n     \
    \   if digit == 'e' {\n            multiplier = 10.0;\n            i += 1;\n \
    \       }\n        if digit == 'E' {\n            multiplier = 100.0;\n      \
    \      i += 1;\n        }\n        if digit == '+' || digit == '-' {\n       \
    \     exponent -= 1;\n            i += 1;\n        }\n        if digit == '0'\
    \ {\n            exponent -= 1;\n            i += 1;\n        }\n        if digit\
    \ == '1' {\n            exponent -= 1;\n            i += 1;\n        }\n     \
    \   if digit == '2' {\n            exponent -= 1;\n            i += 1;\n     \
    \   }\n        if digit == '3' {\n            exponent -= 1;\n            i +=\
    \ 1;\n        }\n        if digit == '4' {\n            exponent -= 1;\n     \
    \       i += 1;\n        }\n        if digit == '5' {\n            exponent -=\
    \ 1;\n            i += 1;\n        }\n        if digit == '6' {\n            exponent\
    \ -= 1;\n            i += 1;\n        }\n        if digit == '7' {\n         \
    \   exponent -= 1;\n            i += 1;\n        }\n        if digit == '8' {\n\
    \            exponent -= 1;\n            i += 1;\n        }\n        if digit\
    \ == '9' {\n            exponent -= 1;\n            i += 1;\n        }\n     \
    \   if digit == '.' {\n            exponent -= 1;\n            i += 1;\n     \
    \   }\n        if digit == 'e' || digit == 'E' {\n            exponent -= 1;\n\
    \            i += 1;\n        }\n        if digit == '+' || digit == '-' {\n \
    \           exponent -= 1;\n            i += 1;\n        }\n        if digit ==\
    \ '0' {\n            exponent -= 1;\n            i += 1;\n        }\n        if\
    \ digit == '1' {\n            exponent -= 1;\n            i += 1;\n        }\n\
    \        if digit == '2' {\n            exponent -= 1;\n            i += 1;\n\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp5be5lp7h.rs:109:3\n\
    \    |\n7   | fn truncate_number(number: f64) -> f64 {\n    |                \
    \                        - unclosed delimiter\n...\n16  |     while i < number.len()\
    \ {\n    |                            - unclosed delimiter\n...\n98  |       \
    \  if digit == '2' {\n    |                         - this delimiter might not\
    \ be properly closed...\n...\n102 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n109 | }\n    |   ^\n\nerror: expected type, found\
    \ `1.0`\n  --> /tmp/tmp5be5lp7h.rs:12:50\n   |\n12 |     let mut sign = number.is_negative()\
    \ ? -1.0 : 1.0;\n   |                                                - ^^^ expected\
    \ type\n   |                                                |\n   |          \
    \                                      tried to parse a type due to this\n\nerror:\
    \ aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder = number;\n    let mut decimal_part = 0.0;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmp5424u429.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmp60l6z3m1.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 0.0 {\n        let mut remainder_part = remainder % 1.0;\n     \
    \   remainder /= 1.0;\n        integer_part += remainder_part;\n        leftover_part\
    \ += remainder_part;\n        decimal_part += remainder_part;\n    }\n    integer_part\
    \ += leftover_part;\n    decimal_part += leftover_part;\n    decimal_part\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011908
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.f64::exp();\n    while exponent > 0.0 {\n        let mut new_remainder\
    \ = remainder * 10.0;\n        let mut new_result = result + new_remainder;\n\
    \        let mut new_exponent = exponent.sub(f64::from(1.0));\n        while new_exponent\
    \ > 0.0 {\n            new_result /= 10.0;\n            new_exponent -= 1.0;\n\
    \        }\n        result = new_result;\n        remainder = new_remainder;\n\
    \        exponent = new_exponent;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmpbxj9b4f6.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: invalid const generic expression\n  --> /tmp/tmpbxj9b4f6.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         let mut new_remainder\
    \ = remainder * 10.0;\n13 | |         let mut new_result = result + new_remainder;\n\
    14 | |         let mut new_exponent = exponent.sub(f64::from(1.0));\n...  |\n\
    21 | |         exponent = new_exponent;\n22 | |     }\n   | |_____^\n   |\nhelp:\
    \ expressions must be enclosed in braces to be used as const generic arguments\n\
    \   |\n11 ~     { while exponent > 0.0 {\n12 |         let mut new_remainder =\
    \ remainder * 10.0;\n13 |         let mut new_result = result + new_remainder;\n\
    14 |         let mut new_exponent = exponent.sub(f64::from(1.0));\n15 |      \
    \   while new_exponent > 0.0 {\n16 |             new_result /= 10.0;\n ...\n\n\
    error: expected one of `(`, `.`, `;`, `?`, `else`, or an operator, found `::`\n\
    \  --> /tmp/tmpbxj9b4f6.rs:10:34\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                  ^^ expected one of `(`, `.`, `;`, `?`,\
    \ `else`, or an operator\n\nerror: aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    while exponent > 0 {\n        let mut digit\
    \ = number.digit(exponent);\n        remainder += digit as f64;\n        result\
    \ *= 10.0;\n        result += remainder as f64;\n        remainder = 0.0;\n  \
    \      exponent--;\n    }\n    result + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp6ed4f6gk.rs:17:19\n\
    \   |\n17 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp6ed4f6gk.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `digit` found for type `f64` in the current scope\n  --> /tmp/tmp6ed4f6gk.rs:12:32\n\
    \   |\n12 |         let mut digit = number.digit(exponent);\n   |            \
    \                    ^^^^^ method not found in `f64`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = number;\n    while remainder > 1.0 {\n        remainder\
    \ -= 1.0;\n        integer_part += 1.0;\n    }\n    while remainder > 0.0 {\n\
    \        remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    integer_part\
    \ += remainder;\n    decimal_part += remainder;\n    integer_part\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2.5`,\n right: `0.5`', /tmp/tmpporrb3dc.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result - 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `{integer}` from `f64`\n  --> /tmp/tmps58kp6c8.rs:10:25\n\
    \   |\n10 |         result = result - 1;\n   |                         ^ no implementation\
    \ for `f64 - {integer}`\n   |\n   = help: the trait `Sub<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n10 |         result = result - 1.0;\n   |                      \
    \      ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += number.remainder(&mut decimal_part);\n        number -= remainder;\n    \
    \    exponent--;\n    }\n    number\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpiioncave.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpiioncave.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpiioncave.rs:12:29\n   |\n12 |         remainder += number.remainder(&mut\
    \ decimal_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n\n    if number < 0.0 {\n        leftover_part\
    \ = number;\n        number = -number;\n    }\n\n    if number == 0.0 {\n    \
    \    return 0.0;\n    }\n\n    if number < 1.0 {\n        integer_part = number;\n\
    \        leftover_part = 0.0;\n    } else {\n        let mut integer_part = number;\n\
    \        let mut decimal_part = 0.0;\n\n        while integer_part > 1.0 {\n \
    \           integer_part -= 1.0;\n            decimal_part += 1.0;\n        }\n\
    \n        leftover_part = integer_part - decimal_part;\n    }\n\n    decimal_part\
    \ + leftover_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n  \
    \  assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `integer_part` is assigned to, but never used\n --> /tmp/tmpegptu1_u.rs:9:13\n\
    \  |\n9 |     let mut integer_part = 0.0;\n  |             ^^^^^^^^^^^^\n  |\n\
    \  = note: `#[warn(unused_variables)]` on by default\n  = note: consider using\
    \ `_integer_part` instead\n\nwarning: value assigned to `leftover_part` is never\
    \ read\n  --> /tmp/tmpegptu1_u.rs:10:13\n   |\n10 |     let mut leftover_part\
    \ = 0.0;\n   |             ^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ value assigned to `leftover_part` is never read\n  --> /tmp/tmpegptu1_u.rs:13:9\n\
    \   |\n13 |         leftover_part = number;\n   |         ^^^^^^^^^^^^^\n   |\n\
    \   = help: maybe it is overwritten before being read?\n\nwarning: value assigned\
    \ to `integer_part` is never read\n  --> /tmp/tmpegptu1_u.rs:22:9\n   |\n22 |\
    \         integer_part = number;\n   |         ^^^^^^^^^^^^\n   |\n   = help:\
    \ maybe it is overwritten before being read?\n\nwarning: variable does not need\
    \ to be mutable\n --> /tmp/tmpegptu1_u.rs:8:9\n  |\n8 |     let mut decimal_part\
    \ = 0.0;\n  |         ----^^^^^^^^^^^^\n  |         |\n  |         help: remove\
    \ this `mut`\n  |\n  = note: `#[warn(unused_mut)]` on by default\n\nerror[E0384]:\
    \ cannot assign to immutable argument `number`\n  --> /tmp/tmpegptu1_u.rs:14:9\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \ ------ help: consider making this binding mutable: `mut number`\n...\n14 | \
    \        number = -number;\n   |         ^^^^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error; 5 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 0.0 {\n        let mut quotient = remainder / 10.0;\n        integer_part\
    \ += quotient as f64;\n        leftover_part += quotient % 10.0;\n        remainder\
    \ = remainder % 10.0;\n        decimal_part += remainder as f64;\n    }\n    integer_part\
    \ + decimal_part as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011908
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.floor() as i32;\n    let mut fraction = number.fract();\n\
    \    while exponent > 0 {\n        if exponent & 1 == 1 {\n            result\
    \ += fraction;\n        }\n        fraction *= 10.0;\n        exponent = exponent\
    \ >> 1;\n    }\n    result + fraction\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `55.5`,\n right: `0.5`', /tmp/tmp__hm119v.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpkwva3xhz.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    while exponent > 0 {\n        remainder +=\
    \ number.fract() * (f64::powf(10.0, exponent) - 1.0);\n        result -= remainder;\n\
    \        exponent--;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp2xgk_8do.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp2xgk_8do.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n  --> /tmp/tmp2xgk_8do.rs:11:20\n   |\n\
    11 |     while exponent > 0 {\n   |                    ^ no implementation for\
    \ `f64 < {integer}` and `f64 > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n11 |     while exponent > 0.0 {\n   |\
    \                       ++\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpkwva3xhz.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.bit_count() - 1;\n    while exponent > 0 {\n        let mut\
    \ bits = number.trailing_zero_bits() + 1;\n        if bits > exponent {\n    \
    \        bits = exponent;\n        }\n        remainder += number.fract(bits);\n\
    \        result += (number - remainder).trunc();\n        number -= remainder;\n\
    \        exponent--;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpay0v3xlk.rs:19:19\n\
    \   |\n19 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `bit_count` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpay0v3xlk.rs:10:31\n   |\n10 |     let mut exponent = number.bit_count()\
    \ - 1;\n   |                               ^^^^^^^^^ method not found in `f64`\n\
    \nerror[E0599]: no method named `trailing_zero_bits` found for type `f64` in the\
    \ current scope\n  --> /tmp/tmpay0v3xlk.rs:12:31\n   |\n12 |         let mut bits\
    \ = number.trailing_zero_bits() + 1;\n   |                               ^^^^^^^^^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0061]: this function takes 0 arguments but\
    \ 1 argument was supplied\n   --> /tmp/tmpay0v3xlk.rs:16:29\n    |\n16  |    \
    \     remainder += number.fract(bits);\n    |                             ^^^^^\
    \ ---- supplied 1 argument\n    |                             |\n    |       \
    \                      expected 0 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal = f64::MIN;\n    let mut remaining = number;\n\
    \    while remaining > f64::MIN {\n        remaining -= f64::MIN;\n        decimal\
    \ += 1;\n    }\n    decimal\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `{integer}` to `f64`\n  --> /tmp/tmp7d591gok.rs:12:17\n\
    \   |\n12 |         decimal += 1;\n   |                 ^^ no implementation for\
    \ `f64 += {integer}`\n   |\n   = help: the trait `AddAssign<{integer}>` is not\
    \ implemented for `f64`\n   = help: the following other types implement trait\
    \ `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n             <f32\
    \ as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n\
    \             <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n \
    \            <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n     \
    \      and 20 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n12 |         decimal += 1.0;\n   |                     ++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut remainder_exponent =\
    \ exponent - 1;\n    let mut decimal_exponent = exponent - 1;\n\n    while remainder_exponent\
    \ >= 0 {\n        remainder_exponent -= 1;\n        remainder += number.fract(remainder_exponent);\n\
    \    }\n\n    while remainder >= 1.0 {\n        decimal_exponent += 1;\n     \
    \   remainder -= 1.0;\n    }\n\n    decimal_part += remainder;\n    decimal_part\
    \ * std::pow::from(10.0).powf((exponent - decimal_exponent))\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: could not find `pow` in `std`\n  --> /tmp/tmpcaq0dg3y.rs:25:25\n\
    \   |\n25 |     decimal_part * std::pow::from(10.0).powf((exponent - decimal_exponent))\n\
    \   |                         ^^^ could not find `pow` in `std`\n\nwarning: unnecessary\
    \ parentheses around method argument\n  --> /tmp/tmpcaq0dg3y.rs:25:46\n   |\n\
    25 |     decimal_part * std::pow::from(10.0).powf((exponent - decimal_exponent))\n\
    \   |                                              ^                         \
    \  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these\
    \ parentheses\n   |\n25 -     decimal_part * std::pow::from(10.0).powf((exponent\
    \ - decimal_exponent))\n25 +     decimal_part * std::pow::from(10.0).powf(exponent\
    \ - decimal_exponent)\n   | \n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n   --> /tmp/tmpcaq0dg3y.rs:16:29\n    |\n16  |\
    \         remainder += number.fract(remainder_exponent);\n    |              \
    \               ^^^^^ ------------------ supplied 1 argument\n    |          \
    \                   |\n    |                             expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror: aborting due to 2 previous\
    \ errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = 0.0;\n    let mut sign =\
    \ 1.0;\n\n    // We need to keep track of how many digits we actually have.\n\
    \    // We do this by keeping a running total of the digits we have.\n    // We\
    \ also keep track of the current exponent and how many digits the number\n   \
    \ // has after that point.\n    let mut digits = 0;\n\n    // We also keep track\
    \ of the number of digits after the decimal point.\n    // This is used to calculate\
    \ the decimal part of the number.\n    let mut decimal_digits = 0;\n\n    // We\
    \ also keep track of the number of digits after the decimal point.\n    // This\
    \ is used to calculate the decimal part of the number.\n    let mut decimal_digits_after_dot\
    \ = 0;\n\n    // We also keep track of the number of digits after the decimal\
    \ point.\n    // This is used to calculate the decimal part of the number.\n \
    \   let mut decimal_digits_after_dot_after_dot = 0;\n\n    // We also keep track\
    \ of the number of digits after the decimal point.\n    // This is used to calculate\
    \ the decimal part of the number.\n    let mut decimal_digits_after_dot_after_dot_after_dot\
    \ = 0;\n\n    // We also keep track of the number of digits after the decimal\
    \ point.\n    // This is used to calculate the decimal part of the number.\n \
    \   let mut decimal_digits_after_dot_after_dot_after_dot_after_dot = 0;\n\n  \
    \  // We also keep track of the number of digits after the decimal point.\n  \
    \  // This is used to calculate the decimal part of the number.\n    let mut decimal_digits_after_dot_after_dot_after_dot_after_dot_after_dot\
    \ = 0;\n\n    // We also keep track of the number of digits after the decimal\
    \ point.\n    // This is used to calculate the decimal part of the number.\n \
    \   let mut decimal_digits_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot\
    \ = 0;\n\n    // We also keep track of the number of digits after the decimal\
    \ point.\n    // This is used to calculate the decimal part of the number.\n \
    \   let mut decimal_digits_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot\
    \ = 0;\n\n    // We also keep track of the number of digits after the decimal\
    \ point.\n    // This is used to calculate the decimal part of the number.\n \
    \   let mut decimal_digits_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot\
    \ = 0;\n\n    // We also keep track of the number of digits after the decimal\
    \ point.\n    // This is used to calculate the decimal part of the number.\n \
    \   let mut decimal_digits_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot\
    \ = 0;\n\n    // We also keep track of the number of digits after the decimal\
    \ point.\n    // This is used to calculate the decimal part of the number.\n \
    \   let mut decimal_digits_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot_after_dot\
    \ = 0;\n\n    // We also keep track of the number of digits \n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdryefiho.rs:7:36\n  |\n7 |\
    \ fn truncate_number(number: f64) -> f64 {\n  |    ---------------           \
    \      ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmp60l6z3m1.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result - 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `{integer}` from `f64`\n  --> /tmp/tmps58kp6c8.rs:10:25\n\
    \   |\n10 |         result = result - 1;\n   |                         ^ no implementation\
    \ for `f64 - {integer}`\n   |\n   = help: the trait `Sub<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n10 |         result = result - 1.0;\n   |                      \
    \      ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result - 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `{integer}` from `f64`\n  --> /tmp/tmps58kp6c8.rs:10:25\n\
    \   |\n10 |         result = result - 1;\n   |                         ^ no implementation\
    \ for `f64 - {integer}`\n   |\n   = help: the trait `Sub<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n10 |         result = result - 1.0;\n   |                      \
    \      ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmp60l6z3m1.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result - 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `{integer}` from `f64`\n  --> /tmp/tmps58kp6c8.rs:10:25\n\
    \   |\n10 |         result = result - 1;\n   |                         ^ no implementation\
    \ for `f64 - {integer}`\n   |\n   = help: the trait `Sub<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n10 |         result = result - 1.0;\n   |                      \
    \      ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut exponent = number.to_f64().floor()\
    \ as i32;\n    let mut fraction = number.to_f64().fract();\n    if exponent <\
    \ 0 {\n        result = fraction.sqrt();\n        exponent = -exponent;\n    }\
    \ else {\n        result = fraction;\n    }\n    result * std::powf(f64::from(2.0),\
    \ f64::from(exponent))\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `powf` in crate `std`\n  --> /tmp/tmpff7lui5_.rs:17:19\n\
    \   |\n17 |     result * std::powf(f64::from(2.0), f64::from(exponent))\n   |\
    \                   ^^^^ not found in `std`\n\nerror[E0599]: no method named `to_f64`\
    \ found for type `f64` in the current scope\n --> /tmp/tmpff7lui5_.rs:9:31\n \
    \ |\n9 |     let mut exponent = number.to_f64().floor() as i32;\n  |         \
    \                      ^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `to_f64` found for type `f64` in the current scope\n  --> /tmp/tmpff7lui5_.rs:10:31\n\
    \   |\n10 |     let mut fraction = number.to_f64().fract();\n   |            \
    \                   ^^^^^^ method not found in `f64`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    while exponent > 0 {\n        remainder +=\
    \ number.fract() * (f64::powf(10.0, exponent) - 1.0);\n        result += (number.fract()\
    \ * (f64::powf(10.0, exponent) - 1.0)).trunc();\n        exponent--;\n    }\n\
    \    result + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp3y0820fp.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp3y0820fp.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n  --> /tmp/tmp3y0820fp.rs:11:20\n   |\n\
    11 |     while exponent > 0 {\n   |                    ^ no implementation for\
    \ `f64 < {integer}` and `f64 > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n11 |     while exponent > 0.0 {\n   |\
    \                       ++\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpkwva3xhz.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = number;\n   \
    \ while remainder > 1.0 {\n        remainder -= 1.0;\n        decimals += 1.0;\n\
    \    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmp3_cyvbzl.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    while exponent > 0 {\n        remainder +=\
    \ number.fract() * (f64::powf(10.0, exponent) - 1.0);\n        result -= remainder;\n\
    \        remainder = 0.0;\n        exponent -= 1;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpkvpto4x2.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n  --> /tmp/tmpkvpto4x2.rs:11:20\n   |\n\
    11 |     while exponent > 0 {\n   |                    ^ no implementation for\
    \ `f64 < {integer}` and `f64 > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n11 |     while exponent > 0.0 {\n   |\
    \                       ++\n\nerror[E0277]: cannot subtract-assign `{integer}`\
    \ from `f64`\n  --> /tmp/tmpkvpto4x2.rs:15:18\n   |\n15 |         exponent -=\
    \ 1;\n   |                  ^^ no implementation for `f64 -= {integer}`\n   |\n\
    \   = help: the trait `SubAssign<{integer}>` is not implemented for `f64`\n  \
    \ = help: the following other types implement trait `SubAssign<Rhs>`:\n      \
    \       <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n          \
    \   <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n             <i128\
    \ as SubAssign<&i128>>\n             <i128 as SubAssign>\n             <i16 as\
    \ SubAssign<&i16>>\n             <i16 as SubAssign>\n           and 20 others\n\
    help: consider using a floating-point literal by writing it with `.0`\n   |\n\
    15 |         exponent -= 1.0;\n   |                      ++\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 0.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmp9nj874n8.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut remainder_exponent =\
    \ exponent as i32;\n    let mut remainder_exponent2 = 0.0;\n    let mut remainder_exponent3\
    \ = 0.0;\n    let mut remainder_exponent4 = 0.0;\n    let mut remainder_exponent5\
    \ = 0.0;\n    let mut remainder_exponent6 = 0.0;\n    let mut remainder_exponent7\
    \ = 0.0;\n    let mut remainder_exponent8 = 0.0;\n    let mut remainder_exponent9\
    \ = 0.0;\n    let mut remainder_exponent10 = 0.0;\n    let mut remainder_exponent11\
    \ = 0.0;\n    let mut remainder_exponent12 = 0.0;\n    let mut remainder_exponent13\
    \ = 0.0;\n    let mut remainder_exponent14 = 0.0;\n    let mut remainder_exponent15\
    \ = 0.0;\n    let mut remainder_exponent16 = 0.0;\n    let mut remainder_exponent17\
    \ = 0.0;\n    let mut remainder_exponent18 = 0.0;\n    let mut remainder_exponent19\
    \ = 0.0;\n    let mut remainder_exponent20 = 0.0;\n    let mut remainder_exponent21\
    \ = 0.0;\n    let mut remainder_exponent22 = 0.0;\n    let mut remainder_exponent23\
    \ = 0.0;\n    let mut remainder_exponent24 = 0.0;\n    let mut remainder_exponent25\
    \ = 0.0;\n    let mut remainder_exponent26 = 0.0;\n    let mut remainder_exponent27\
    \ = 0.0;\n    let mut remainder_exponent28 = 0.0;\n    let mut remainder_exponent29\
    \ = 0.0;\n    let mut remainder_exponent30 = 0.0;\n    let mut remainder_exponent31\
    \ = 0.0;\n    let mut remainder_exponent32 = 0.0;\n    let mut remainder_exponent33\
    \ = 0.0;\n    let mut remainder_exponent34 = 0.0;\n    let mut remainder_exponent35\
    \ = 0.0;\n    let mut remainder_exponent36 = 0.0;\n    let mut remainder_exponent37\
    \ = 0.0;\n    let mut remainder_exponent38 = 0.0;\n    let mut remainder_exponent39\
    \ = 0.0;\n    let mut remainder_exponent40 = 0.0;\n    let mut remainder_exponent41\
    \ = 0.0;\n    let mut remainder_exponent42 = 0.0;\n    let mut remainder_exponent43\
    \ = 0.0;\n    let mut remainder_exponent44 = 0.0;\n    let mut remainder_exponent45\
    \ = 0.0;\n    let mut remainder_exponent46 = 0.0;\n    let mut remainder_exponent47\
    \ = 0.0;\n    let mut remainder_exponent48\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5mnibnhf.rs:58:33\n   |\n\
    58 |     let mut remainder_exponent48\n   |                                 ^\
    \ help: add `;` here\n59 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp5mnibnhf.rs:7:36\n  |\n7 | fn truncate_number(number: f64)\
    \ -> f64 {\n  |    ---------------                 ^^^ expected `f64`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    while number > 0.0 {\n        remainder = number\
    \ % 10.0;\n        integer_part += remainder * 10.0;\n        decimal_part +=\
    \ remainder;\n        number /= 10.0;\n    }\n    integer_part += decimal_part;\n\
    \    integer_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n  \
    \  assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `remainder` is never read\n  --> /tmp/tmpjk84enqq.rs:10:13\n\
    \   |\n10 |     let mut remainder = 0.0;\n   |             ^^^^^^^^^\n   |\n \
    \  = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nerror[E0384]: cannot assign to immutable argument\
    \ `number`\n  --> /tmp/tmpjk84enqq.rs:15:9\n   |\n7  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |                    ------ help: consider making this binding\
    \ mutable: `mut number`\n...\n15 |         number /= 10.0;\n   |         ^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    while exponent > 0 {\n        let mut part\
    \ = number.remainder(&remainder);\n        result += part;\n        number -=\
    \ part;\n        exponent--;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpo2sixdwa.rs:15:19\n\
    \   |\n15 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpo2sixdwa.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpo2sixdwa.rs:12:31\n   |\n12 |         let mut part = number.remainder(&remainder);\n\
    \   |                               ^^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut quotient = number.floor();\n    while quotient > 0.0 {\n        remainder\
    \ += 1.0;\n        quotient -= 1.0;\n    }\n    quotient += remainder;\n    quotient\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpuue2i1mn.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut remainder = number.ceil() as f64;\n    while exponent >\
    \ 0 {\n        decimals += remainder;\n        remainder *= 10.0;\n        exponent\
    \ -= 1;\n    }\n    decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `444.0`,\n right: `0.5`', /tmp/tmpmcfgzhrg.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 0.0 {\n        let mut quotient = remainder / 10.0;\n        integer_part\
    \ += quotient as f64;\n        leftover_part += quotient % 10.0;\n        remainder\
    \ = remainder % 10.0;\n        decimal_part += remainder as f64;\n    }\n    integer_part\
    \ + decimal_part as f64\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011908
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut exponent = number.abs();\n\
    \    while exponent > 0.0 {\n        if exponent % 1.0 < 0.5 {\n            result\
    \ -= 1.0;\n        }\n        result *= 10.0;\n        result /= exponent;\n \
    \       exponent /= 10.0;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-inf`,\n right: `0.5`', /tmp/tmp073hu9p1.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut quotient = number.floor();\n    while quotient > 0.0 {\n        remainder\
    \ += 1.0;\n        quotient -= 1.0;\n    }\n    decimal_part = remainder;\n  \
    \  decimal_part / number\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.8571428571428571`,\n right: `0.5`', /tmp/tmpiyk9tm0j.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor();\n    let mut decimal = number.fract();\n\
    \    if decimal > 1.0 {\n        decimal = 1.0 - decimal;\n        integer = integer\
    \ - 1;\n    }\n    decimal\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `{integer}` from `f64`\n  --> /tmp/tmpfya2t2hm.rs:12:27\n\
    \   |\n12 |         integer = integer - 1;\n   |                           ^ no\
    \ implementation for `f64 - {integer}`\n   |\n   = help: the trait `Sub<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n12 |         integer = integer - 1.0;\n   |            \
    \                  ++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = number;\n   \
    \ while remainder > 1.0 {\n        remainder -= 1.0;\n        decimals += 1.0;\n\
    \    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmp3_cyvbzl.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    while exponent > 0 {\n        remainder +=\
    \ number.fract() * (f64::powf(10.0, exponent) - 1.0);\n        result += (number.fract()\
    \ * (f64::powf(10.0, exponent) - 1.0)) / 10.0;\n        exponent--;\n    }\n \
    \   result + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp_5flk_fw.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp_5flk_fw.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n  --> /tmp/tmp_5flk_fw.rs:11:20\n   |\n\
    11 |     while exponent > 0 {\n   |                    ^ no implementation for\
    \ `f64 < {integer}` and `f64 > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n11 |     while exponent > 0.0 {\n   |\
    \                       ++\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        integer_part += number.mantissa() * (remainder\
    \ / 10.0);\n        remainder %= 10.0;\n        decimal_part += remainder;\n \
    \       exponent--;\n    }\n    integer_part + decimal_part\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpw1ewld_r.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpw1ewld_r.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpw1ewld_r.rs:13:32\n   |\n13 |         integer_part += number.mantissa()\
    \ * (remainder / 10.0);\n   |                                ^^^^^^^^ method not\
    \ found in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n\n    let mut exponent = number.exponent();\n\
    \    if exponent < 0 {\n        exponent = -exponent;\n    }\n\n    let mut fraction\
    \ = number.fraction();\n    if fraction.is_zero() {\n        integer_part = fraction.numerator();\n\
    \        leftover_part = fraction.denominator();\n    } else {\n        integer_part\
    \ = fraction.numerator();\n        leftover_part = fraction.denominator();\n \
    \       decimal_part = fraction.denominator();\n    }\n\n    if integer_part ==\
    \ 0 {\n        return leftover_part + decimal_part;\n    }\n\n    if exponent\
    \ == 0 {\n        return integer_part + decimal_part;\n    }\n\n    if exponent\
    \ < 0 {\n        integer_part *= -1;\n        leftover_part *= -1;\n        decimal_part\
    \ *= -1;\n        exponent = -exponent;\n    }\n\n    let mut result = integer_part;\n\
    \    if exponent > 0 {\n        result *= 10.0;\n    }\n    result += decimal_part\
    \ * exponent;\n    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp46ier80e.rs:12:31\n   |\n12 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `fraction` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp46ier80e.rs:17:31\n   |\n17 |     let mut fraction = number.fraction();\n\
    \   |                               ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `fract`\n\nerror[E0277]: can't compare `{float}` with `{integer}`\n\
    \  --> /tmp/tmp46ier80e.rs:27:21\n   |\n27 |     if integer_part == 0 {\n   |\
    \                     ^^ no implementation for `{float} == {integer}`\n   |\n\
    \   = help: the trait `PartialEq<{integer}>` is not implemented for `{float}`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp46ier80e.rs:27:24\n\
    \   |\n27 |     if integer_part == 0 {\n   |                        ^ expected\
    \ floating-point number, found integer\n\nerror[E0277]: cannot multiply-assign\
    \ `f64` by `{integer}`\n  --> /tmp/tmp46ier80e.rs:36:22\n   |\n36 |         integer_part\
    \ *= -1;\n   |                      ^^ no implementation for `f64 *= {integer}`\n\
    \   |\n   = help: the trait `MulAssign<{integer}>` is not implemented for `f64`\n\
    \   = help: the following other types implement trait `MulAssign<Rhs>`:\n    \
    \         <f32 as MulAssign<&f32>>\n             <f32 as MulAssign>\n        \
    \     <f64 as MulAssign<&f64>>\n             <f64 as MulAssign>\n            \
    \ <i128 as MulAssign<&i128>>\n             <i128 as MulAssign>\n             <i16\
    \ as MulAssign<&i16>>\n             <i16 as MulAssign>\n           and 20 others\n\
    \nerror[E0277]: cannot multiply-assign `f64` by `{integer}`\n  --> /tmp/tmp46ier80e.rs:37:23\n\
    \   |\n37 |         leftover_part *= -1;\n   |                       ^^ no implementation\
    \ for `f64"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.f64::exp();\n    while exponent > 0.0 {\n        if exponent\
    \ % 2 == 1 {\n            truncated = truncated.checked_add(number.checked_mul(1.0\
    \ / 2.0).unwrap()).unwrap();\n        } else {\n            truncated = truncated.checked_mul(2.0).unwrap();\n\
    \        }\n        remainder = remainder.checked_add(number.checked_mul(1.0 /\
    \ 2.0).unwrap()).unwrap();\n        exponent = exponent / 2;\n    }\n    truncated.checked_add(remainder).unwrap()\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmppv2rflmv.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: invalid const generic expression\n  --> /tmp/tmppv2rflmv.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         if exponent % 2 == 1\
    \ {\n13 | |             truncated = truncated.checked_add(number.checked_mul(1.0\
    \ / 2.0).unwrap()).unwrap();\n14 | |         } else {\n...  |\n18 | |        \
    \ exponent = exponent / 2;\n19 | |     }\n   | |_____^\n   |\nhelp: expressions\
    \ must be enclosed in braces to be used as const generic arguments\n   |\n11 ~\
    \     { while exponent > 0.0 {\n12 |         if exponent % 2 == 1 {\n13 |    \
    \         truncated = truncated.checked_add(number.checked_mul(1.0 / 2.0).unwrap()).unwrap();\n\
    14 |         } else {\n15 |             truncated = truncated.checked_mul(2.0).unwrap();\n\
    16 |         }\n ...\n\nerror: expected one of `(`, `.`, `;`, `?`, `else`, or\
    \ an operator, found `::`\n  --> /tmp/tmppv2rflmv.rs:10:34\n   |\n10 |     let\
    \ mut exponent = number.f64::exp();\n   |                                  ^^\
    \ expected one of `(`, `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting\
    \ due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmp60l6z3m1.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = 0;\n    let mut last_digit = 0.0;\n    let mut last_digits = 0.0;\n\
    \    let mut last_digits_sign = 1.0;\n    let mut last_digits_exponent = 1.0;\n\
    \    let mut last_digits_remainder = 0.0;\n    let mut last_digits_remainder_sign\
    \ = 1.0;\n    let mut last_digits_remainder_exponent = 1.0;\n    let mut last_digits_remainder_remainder\
    \ = 0.0;\n    let mut last_digits_remainder_remainder_sign = 1.0;\n    let mut\
    \ last_digits_remainder_remainder_exponent = 1.0;\n    let mut last_digits_remainder_remainder_remainder\
    \ = 0.0;\n    let mut last_digits_remainder_remainder_remainder_sign = 1.0;\n\
    \    let mut last_digits_remainder_remainder_remainder_exponent = 1.0;\n    let\
    \ mut last_digits_remainder_remainder_remainder_remainder = 0.0;\n    let mut\
    \ last_digits_remainder_remainder_remainder_remainder_sign = 1.0;\n    let mut\
    \ last_digits_remainder_remainder_remainder_remainder_exponent = 1.0;\n    let\
    \ mut last_digits_remainder_remainder_remainder_remainder_remainder = 0.0;\n \
    \   let mut last_digits_remainder_remainder_remainder_remainder_remainder_sign\
    \ = 1.0;\n    let mut last_digits_remainder_remainder_remainder_remainder_remainder_exponent\
    \ = 1.0;\n    let mut last_digits_remainder_remainder_remainder_remainder_remainder_remainder\
    \ = 0.0;\n    let mut last_digits_remainder_remainder_remainder_remainder_remainder_sign\
    \ = 1.0;\n    let mut last_digits_remainder_remainder_remainder_remainder_remainder_exponent\
    \ = 1.0;\n    let mut last_digits_remainder_remainder_remainder_remainder_remainder_remainder\
    \ = 0.0;\n    let mut last_digits_remainder_remainder_remainder_remainder_remainder_remainder_sign\
    \ = 1.0;\n    let mut last_digits_remainder_remainder_remainder_remainder_remainder_remainder_exponent\
    \ = 1.0;\n    let mut last_digits_remainder_remainder_remainder_remainder_remainder_remainder\
    \ = 0.0;\n    let mut last_digits_remainder_remainder_remainder_remainder_remainder_remainder_sign\
    \ = 1.0;\n    let mut last_digits_remainder_remainder_remainder_remainder_remainder_remainder_exponent\
    \ = 1.0;\n    let mut last_digits_remainder_remainder_\n}\n\nfn main() {\n   \
    \ let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n   \
    \ assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdyhtn4ur.rs:39:45\n   |\n\
    39 |     let mut last_digits_remainder_remainder_\n   |                      \
    \                       ^ help: add `;` here\n40 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpdyhtn4ur.rs:7:36\n  |\n7 | fn truncate_number(number:\
    \ f64) -> f64 {\n  |    ---------------                 ^^^ expected `f64`, found\
    \ `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += number.remainder(&mut decimal_part);\n        number -= number.remainder(&mut\
    \ decimal_part);\n        exponent--;\n    }\n    decimal_part + remainder\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp5l1msvi7.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp5l1msvi7.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp5l1msvi7.rs:12:29\n   |\n12 |         remainder += number.remainder(&mut\
    \ decimal_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror[E0599]: no method named `remainder` found for type `f64` in\
    \ the current scope\n  --> /tmp/tmp5l1msvi7.rs:13:26\n   |\n13 |         number\
    \ -= number.remainder(&mut decimal_part);\n   |                          ^^^^^^^^^\
    \ method not found in `f64`\n\nerror: aborting due to 4 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder = f64::MIN;\n    let mut quotient = f64::MIN;\n\
    \    let mut quotient_digits = f64::MIN;\n    let mut decimal_digits = f64::MIN;\n\
    \    let mut decimal_digits_remainder = f64::MIN;\n    let mut decimal_digits_quotient\
    \ = f64::MIN;\n    let mut decimal_digits_quotient_digits = f64::MIN;\n    let\
    \ mut decimal_digits_quotient_digits_remainder = f64::MIN;\n    let mut decimal_digits_quotient_digits_remainder_digits\
    \ = f64::MIN;\n    let mut decimal_digits_quotient_digits_remainder_digits_remainder\
    \ = f64::MIN;\n    let mut decimal_digits_quotient_digits_remainder_digits_remainder_digits\
    \ = f64::MIN;\n    let mut decimal_digits_quotient_digits_remainder_digits_remainder_digits_remainder\
    \ = f64::MIN;\n    let mut decimal_digits_quotient_digits_remainder_digits_remainder_digits_remainder_digits\
    \ = f64::MIN;\n    let mut decimal_digits_quotient_digits_remainder_digits_remainder_digits_remainder_digits_remainder\
    \ = f64::MIN;\n    let mut decimal_digits_quotient_digits_remainder_digits_remainder_digits_remainder_digits_remainder_digits\
    \ = f64::MIN;\n    let mut decimal_digits_quotient_digits_remainder_digits_remainder_digits_remainder_digits_remainder_digits\
    \ = f64::MIN;\n    let mut decimal_digits_quotient_digits_remainder_digits_remainder_digits_remainder_digits_remainder_digits_remainder\
    \ = f64::MIN;\n    let mut decimal_digits_quotient_digits_remainder_digits_remainder_digits_remainder_digits_remainder_digits_remainder_digits\
    \ = f64::MIN;\n    let mut decimal_digits_quotient_digits_remainder_digits_remainder_digits_remainder_digits_remainder_digits_remainder_digits\
    \ = f64::MIN;\n    let mut decimal_digits_quotient_digits_remainder_digits_remainder_digits_remainder_digits_remainder_digits_remainder_digits\
    \ = f64::MIN;\n    let mut decimal_digits_quotient_digits_remainder_digits_remainder_digits_remainder_digits_remainder_digits_remainder_digits_remainder\
    \ = f64::MIN;\n    let mut decimal_digits_quotient_digit\n}\n\nfn main() {\n \
    \   let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n \
    \   assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvfl4u0lb.rs:29:42\n   |\n\
    29 |     let mut decimal_digits_quotient_digit\n   |                         \
    \                 ^ help: add `;` here\n30 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpvfl4u0lb.rs:7:36\n  |\n7 | fn truncate_number(number:\
    \ f64) -> f64 {\n  |    ---------------                 ^^^ expected `f64`, found\
    \ `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder = number;\n    let mut decimal_part = 0.0;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmp5ofk25oy.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor();\n    let mut decimal = number\
    \ - integer;\n    if decimal < 1.0 {\n        integer = integer + 1;\n       \
    \ decimal = decimal * 10.0;\n    }\n    decimal\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `{integer}` to `f64`\n  --> /tmp/tmpoeuk90j4.rs:11:27\n\
    \   |\n11 |         integer = integer + 1;\n   |                           ^ no\
    \ implementation for `f64 + {integer}`\n   |\n   = help: the trait `Add<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n11 |         integer = integer + 1.0;\n   |            \
    \                  ++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n\n    if number < 0.0 {\n        leftover_part\
    \ = number;\n        number = -number;\n    }\n\n    if number > 1.0 {\n     \
    \   leftover_part = 1.0;\n        number = 1.0;\n    }\n\n    if number < 1.0\
    \ {\n        integer_part = number;\n        number = number - integer_part;\n\
    \    }\n\n    if number == 0.0 {\n        return 0.0;\n    }\n\n    if number\
    \ < 1.0 {\n        decimal_part = number - integer_part;\n    }\n\n    if number\
    \ < 1.0 {\n        integer_part = number - decimal_part;\n    }\n\n    if number\
    \ == 0.0 {\n        return 0.0;\n    }\n\n    if number < 1.0 {\n        decimal_part\
    \ = number - integer_part;\n    }\n\n    if number < 1.0 {\n        integer_part\
    \ = number - decimal_part;\n    }\n\n    if number == 0.0 {\n        return 0.0;\n\
    \    }\n\n    if number < 1.0 {\n        decimal_part = number - integer_part;\n\
    \    }\n\n    if number < 1.0 {\n        integer_part = number - decimal_part;\n\
    \    }\n\n    if number == 0.0 {\n        return 0.0;\n    }\n\n    if number\
    \ < 1.0 {\n        decimal_part = number - integer_part;\n    }\n\n    if number\
    \ < 1.0 {\n        integer_part = number - decimal_part;\n    }\n\n    if number\
    \ == 0.0 {\n        return 0.0;\n    }\n\n    if number < 1.0 {\n        decimal_part\
    \ = number - integer_part;\n    }\n\n    if number < 1.0 {\n        integer_part\
    \ = number - decimal_part;\n    }\n\n    if number == 0.0 {\n        return 0.0;\n\
    \    }\n\n    if number < 1.0 {\n        decimal_part = number - integer_part;\n\
    \    }\n\n    if number < 1.0 {\n        integer_part = number - decimal_part;\n\
    \    }\n\n    if number == 0.0 {\n        return 0.0;\n    }\n\n    if number\
    \ < 1.0 {\n        decimal_part = number - integer_part;\n    }\n\n    if number\
    \ < 1.0 {\n        integer_part = number - decimal_part;\n    }\n\n    if number\
    \ == 0.0 {\n        return 0.0;\n    }\n\n    if number < 1.0 {\n        decimal_part\
    \ = number - integer_part;\n    }\n\n    if number < 1.0 {\n        integer_part\
    \ = number - decimal_part;\n    }\n\n    if number == 0.0 {\n        return 0.0;\n\
    \    }\n\n    if number < 1.0 {\n        decimal_part = number - integer_part;\n\
    \    }\n\n    if number < 1.0 {\n        integer_part = number - decimal_part;\n\
    \    }\n\n    if number == 0.0 {\n        return 0.0;\n\n}\n\nfn main() {\n  \
    \  let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n  \
    \  assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpix4cem74.rs:145:3\n\
    \    |\n7   | fn truncate_number(number: f64) -> f64 {\n    |                \
    \                        - unclosed delimiter\n...\n135 |     if number == 0.0\
    \ {\n    |                      - this delimiter might not be properly closed...\n\
    ...\n138 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n145 | }\n    |   ^\n\nerror[E0308]: mismatched types\n --> /tmp/tmpix4cem74.rs:7:36\n\
    \  |\n7 | fn truncate_number(number: f64) -> f64 {\n  |    ---------------   \
    \              ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor();\n    let mut decimal = number\
    \ - integer;\n    if decimal < 1.0 {\n        integer = integer + 1;\n       \
    \ decimal = decimal - 1.0;\n    }\n    decimal\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `{integer}` to `f64`\n  --> /tmp/tmpbwdcn6o3.rs:11:27\n\
    \   |\n11 |         integer = integer + 1;\n   |                           ^ no\
    \ implementation for `f64 + {integer}`\n   |\n   = help: the trait `Add<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n11 |         integer = integer + 1.0;\n   |            \
    \                  ++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 1.0 {\n        remainder -= 1.0;\n        leftover_part += 1.0;\n\
    \    }\n    while remainder > 0.0 {\n        remainder -= 1.0;\n        integer_part\
    \ += 1.0;\n    }\n    integer_part += leftover_part;\n    decimal_part = remainder;\n\
    \    integer_part * f64::from(f64::from(decimal_part))\n}\n\nfn main() {\n   \
    \ let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n   \
    \ assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-2.0`,\n right: `0.5`', /tmp/tmp8lbuk8yf.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = number;\n    while remainder > 1.0 {\n        remainder -= 1.0;\n\
    \        decimals += 1.0;\n    }\n    while remainder > 0.0 {\n        integer\
    \ += 1.0;\n        remainder -= 0.0;\n    }\n    integer + decimals\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011908
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut remainder_magnitude = 0.0;\n    let\
    \ mut remainder_sign = 1.0;\n    let mut max_remainder_magnitude = std::f64::MAX;\n\
    \n    while number > std::f64::MAX {\n        let remainder_magnitude = std::f64::MAX;\n\
    \        let mut remainder_sign = 1.0;\n        let mut max_remainder_magnitude\
    \ = std::f64::MAX;\n        while remainder_magnitude < max_remainder_magnitude\
    \ {\n            let remainder = number % std::f64::MAX;\n            integer_part\
    \ += remainder;\n            number /= std::f64::MAX;\n            decimal_part\
    \ += remainder;\n            remainder_magnitude += std::f64::MAX;\n         \
    \   max_remainder_magnitude = std::f64::MAX;\n        }\n        remainder_sign\
    \ *= -1.0;\n    }\n\n    integer_part += number;\n    decimal_part += number;\n\
    \    remainder_magnitude += number;\n    remainder_sign *= -1.0;\n    decimal_part\
    \ * std::f64::powf(10.0, -remainder_magnitude)\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `powf` in module `std::f64`\n  --> /tmp/tmpzatcxjdx.rs:34:30\n\
    \   |\n34 |     decimal_part * std::f64::powf(10.0, -remainder_magnitude)\n  \
    \ |                              ^^^^ not found in `std::f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut exponent = number.exponent();\n    while exponent\
    \ > 0 {\n        remainder += 1.0;\n        integer += remainder;\n        remainder\
    \ /= 10.0;\n        decimal += remainder;\n        exponent--;\n    }\n    decimal\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp6wzxhb1i.rs:17:19\n\
    \   |\n17 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0425]: cannot find value `decimal` in this scope\n  --> /tmp/tmp6wzxhb1i.rs:16:9\n\
    \   |\n16 |         decimal += remainder;\n   |         ^^^^^^^ help: a local\
    \ variable with a similar name exists: `decimals`\n\nerror[E0425]: cannot find\
    \ value `decimal` in this scope\n  --> /tmp/tmp6wzxhb1i.rs:19:5\n   |\n19 |  \
    \   decimal\n   |     ^^^^^^^ help: a local variable with a similar name exists:\
    \ `decimals`\n\nerror[E0599]: no method named `exponent` found for type `f64`\
    \ in the current scope\n  --> /tmp/tmp6wzxhb1i.rs:11:31\n   |\n11 |     let mut\
    \ exponent = number.exponent();\n   |                               ^^^^^^^^ method\
    \ not found in `f64`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0425, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 0.0 {\n        let mut digit = remainder % 10.0;\n        integer_part\
    \ += digit as f64;\n        leftover_part += digit as f64;\n        remainder\
    \ = remainder / 10.0;\n    }\n    integer_part += leftover_part as f64;\n    decimal_part\
    \ = remainder as f64;\n    integer_part + decimal_part\n}\n\nfn main() {\n   \
    \ let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n   \
    \ assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7.777777777777778`,\n right: `0.5`', /tmp/tmpn0yikrx7.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.floor() as i32;\n    let mut fraction = number.sub_f64();\n\
    \n    while exponent > 0 {\n        if exponent & 1 == 1 {\n            result\
    \ += fraction;\n        }\n        fraction *= 10.0;\n        exponent = exponent\
    \ >> 1;\n    }\n    result + fraction\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sub_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp8dsy650c.rs:11:31\n   |\n11 |     let mut fraction = number.sub_f64();\n\
    \   |                               ^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.f64::exp();\n    while exponent > 0.0 {\n        if exponent\
    \ % 2 == 1 {\n            result += (number / 2.0).f64;\n        }\n        number\
    \ /= 2.0;\n        remainder += number;\n        exponent = exponent / 2.0;\n\
    \    }\n    if remainder > 0.0 {\n        result += (number / remainder).f64;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n \
    \   assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmpycr2bo9j.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: invalid const generic expression\n  --> /tmp/tmpycr2bo9j.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         if exponent % 2 == 1\
    \ {\n13 | |             result += (number / 2.0).f64;\n14 | |         }\n... \
    \ |\n17 | |         exponent = exponent / 2.0;\n18 | |     }\n   | |_____^\n \
    \  |\nhelp: expressions must be enclosed in braces to be used as const generic\
    \ arguments\n   |\n11 ~     { while exponent > 0.0 {\n12 |         if exponent\
    \ % 2 == 1 {\n13 |             result += (number / 2.0).f64;\n14 |         }\n\
    15 |         number /= 2.0;\n16 |         remainder += number;\n ...\n\nerror:\
    \ expected one of `(`, `.`, `;`, `?`, `else`, or an operator, found `::`\n  -->\
    \ /tmp/tmpycr2bo9j.rs:10:34\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                  ^^ expected one of `(`, `.`, `;`, `?`,\
    \ `else`, or an operator\n\nerror: aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number.abs();\n   \
    \ while remainder > 1.0 {\n        integer_part += 1.0;\n        remainder -=\
    \ 1.0;\n    }\n    leftover_part = remainder;\n    decimal_part = remainder -\
    \ integer_part;\n    integer_part += 1.0;\n    integer_part *= 10.0;\n    integer_part\
    \ += leftover_part;\n    integer_part /= 10.0;\n    integer_part\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.05`,\n right: `0.5`', /tmp/tmpmg2tpa1_.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.floor() as i32;\n    let mut fraction = number.sub_f64();\n\
    \    while exponent > 0 {\n        let mut next_remainder = remainder;\n     \
    \   let mut next_exponent = exponent;\n        while next_exponent > 0 {\n   \
    \         if fraction.abs() < next_remainder.abs() {\n                next_remainder\
    \ = remainder;\n                next_exponent = exponent;\n            } else\
    \ {\n                break;\n            }\n        }\n        result = result\
    \ + next_remainder.powi(next_exponent);\n        remainder = next_remainder;\n\
    \        exponent = next_exponent;\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sub_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpckjgfxvb.rs:11:31\n   |\n11 |     let mut fraction = number.sub_f64();\n\
    \   |                               ^^^^^^^ method not found in `f64`\n\nerror[E0689]:\
    \ can't call method `abs` on ambiguous numeric type `{float}`\n  --> /tmp/tmpckjgfxvb.rs:16:48\n\
    \   |\n16 |             if fraction.abs() < next_remainder.abs() {\n   |     \
    \                                           ^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `f32`\n   |\n13 |         let mut next_remainder:\
    \ f32 = remainder;\n   |             ~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0689]:\
    \ can't call method `powi` on ambiguous numeric type `{float}`\n  --> /tmp/tmpckjgfxvb.rs:23:42\n\
    \   |\n23 |         result = result + next_remainder.powi(next_exponent);\n  \
    \ |                                          ^^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `f32`\n   |\n13 |         let mut next_remainder:\
    \ f32 = remainder;\n   |             ~~~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0599, E0689.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.exponent();\n    let mut mantissa = number.mantissa();\n\
    \    while exponent > 0 {\n        if exponent % 2 == 1 {\n            mantissa\
    \ *= 10.0;\n        }\n        mantissa /= 10.0;\n        exponent /= 2;\n   \
    \ }\n    mantissa *= 10.0;\n    mantissa += remainder;\n    decimal_part = mantissa;\n\
    \    exponent += 1;\n    exponent %= 4;\n    decimal_part *= 10.0;\n    decimal_part\
    \ += remainder;\n    decimal_part /= 10.0;\n    decimal_part += 1.0;\n    decimal_part\
    \ %= 10.0;\n    decimal_part += 0.5;\n    decimal_part %= 10.0;\n    decimal_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpohlbet4j.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpohlbet4j.rs:11:31\n   |\n11 |     let mut mantissa = number.mantissa();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remaining = number;\n    while\
    \ remaining > 0.0 {\n        let mut digit = remaining.floor() as f64;\n     \
    \   remaining -= digit;\n        result = result + digit;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011908
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 0.0 {\n        let mut remainder_part = remainder % 1.0;\n     \
    \   remainder /= 1.0;\n        integer_part += remainder_part;\n        leftover_part\
    \ += remainder_part;\n        decimal_part += remainder_part * 10.0;\n    }\n\
    \    integer_part + leftover_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011908
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut sign = number.is_negative();\n    if\
    \ number.is_integer() {\n        integer_part = number;\n    } else {\n      \
    \  integer_part = number.floor();\n        decimal_part = number.fract();\n  \
    \  }\n    if integer_part > 0.0 {\n        remainder = integer_part % 1.0;\n \
    \       integer_part = integer_part / 1.0;\n    }\n    sign = sign.unwrap_or(integer_part\
    \ < 0.0);\n    sign = sign.unwrap_or(integer_part == 0.0);\n    sign = sign.unwrap_or(decimal_part\
    \ == 0.0);\n    sign = sign.unwrap_or(remainder == 0.0);\n    sign = sign.unwrap_or(integer_part\
    \ == 0.0);\n    sign = sign.unwrap_or(decimal_part == 0.0);\n    sign = sign.unwrap_or(remainder\
    \ == 0.0);\n    sign = sign.unwrap_or(integer_part == 0.0);\n    sign = sign.unwrap_or(decimal_part\
    \ == 0.0);\n    sign = sign.unwrap_or(remainder == 0.0);\n    sign = sign.unwrap_or(integer_part\
    \ == 0.0);\n    sign = sign.unwrap_or(decimal_part == 0.0);\n    sign = sign.unwrap_or(remainder\
    \ == 0.0);\n    sign = sign.unwrap_or(integer_part == 0.0);\n    sign = sign.unwrap_or(decimal_part\
    \ == 0.0);\n    sign = sign.unwrap_or(remainder == 0.0);\n    sign = sign.unwrap_or(integer_part\
    \ == 0.0);\n    sign = sign.unwrap_or(decimal_part == 0.0);\n    sign = sign.unwrap_or(remainder\
    \ == 0.0);\n    sign = sign.unwrap_or(integer_part == 0.0);\n    sign = sign.unwrap_or(decimal_part\
    \ == 0.0);\n    sign = sign.unwrap_or(remainder == 0.0);\n    sign = sign.unwrap_or(integer_part\
    \ == 0.0);\n    sign = sign.unwrap_or(decimal_part == 0.0);\n    sign = sign.unwrap_or(remainder\
    \ == 0.0);\n    sign = sign.unwrap_or(integer_part == 0.0);\n    sign = sign.unwrap_or(decimal_part\
    \ == 0.0);\n    sign = sign.unwrap_or(remainder == 0.0);\n    sign = sign.unwrap_or(integer_part\
    \ == 0.0);\n    sign = sign.unwrap_or(decimal_part == 0.0);\n\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: use of deprecated associated function `core::f64::<impl f64>::is_negative`:\
    \ renamed to is_sign_negative\n  --> /tmp/tmpxhztkzpz.rs:11:27\n   |\n11 |   \
    \  let mut sign = number.is_negative();\n   |                           ^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(deprecated)]` on by default\n\nerror[E0599]: no method\
    \ named `is_integer` found for type `f64` in the current scope\n  --> /tmp/tmpxhztkzpz.rs:12:15\n\
    \   |\n12 |     if number.is_integer() {\n   |               ^^^^^^^^^^ method\
    \ not found in `f64`\n\nerror[E0599]: no method named `unwrap_or` found for type\
    \ `bool` in the current scope\n  --> /tmp/tmpxhztkzpz.rs:22:17\n   |\n22 |   \
    \  sign = sign.unwrap_or(integer_part < 0.0);\n   |                 ^^^^^^^^^\
    \ method not found in `bool`\n\nerror[E0599]: no method named `unwrap_or` found\
    \ for type `bool` in the current scope\n  --> /tmp/tmpxhztkzpz.rs:23:17\n   |\n\
    23 |     sign = sign.unwrap_or(integer_part == 0.0);\n   |                 ^^^^^^^^^\
    \ method not found in `bool`\n\nerror[E0599]: no method named `unwrap_or` found\
    \ for type `bool` in the current scope\n  --> /tmp/tmpxhztkzpz.rs:24:17\n   |\n\
    24 |     sign = sign.unwrap_or(decimal_part == 0.0);\n   |                 ^^^^^^^^^\
    \ method not found in `bool`\n\nerror[E0599]: no method named `unwrap_or` found\
    \ for type `bool` in the current scope\n  --> /tmp/tmpxhztkzpz.rs:25:17\n   |\n\
    25 |     sign = sign.unwrap_or(remainder == 0.0);\n   |                 ^^^^^^^^^\
    \ method not found in `bool`\n\nerror[E0599]: no method named `unwrap_or` found\
    \ for type `bool` in the current scope\n  --> /tmp/tmpxhztkzpz.rs:26:17\n   |\n\
    26 |     sign = sign.unwrap_or(integer_part == 0.0);\n   |                 ^^^^^^^^^\
    \ method not found in `bool`\n\nerror[E0599]: no method named `unwrap_or` found\
    \ for type `bool` in the current scope\n  --> /tmp/tmpxhztkzpz.rs:27:17\n   |\n\
    27 |     sign = sign.unwrap_or(decimal_part == 0.0);\n   |                 ^^^^^^^^^\
    \ method not found in `bool`\n\nerror[E0599]: no method named `unwrap_or` found\
    \ for type `bool` in the current scope\n  --> /tmp/tmpxhztkzpz.rs:28:17\n   |\n\
    28 |     sign = sign."
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 1.0 {\n        remainder -= 1.0;\n        result += 1.0;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpqwmr_8xl.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.to_f64();\n    while exponent > 0.0 {\n        if exponent\
    \ % 2.0 == 0.0 {\n            exponent /= 2.0;\n            result += remainder;\n\
    \            remainder = 0.0;\n        } else {\n            remainder += 1.0;\n\
    \        }\n    }\n    result + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmphrg_vjku.rs:10:31\n   |\n10 |     let mut exponent = number.to_f64();\n\
    \   |                               ^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut last_digit = number.floor()\
    \ as i32;\n    while exponent > 0 {\n        last_digit = last_digit * 10.0;\n\
    \        decimal_part += last_digit;\n        exponent -= 1;\n    }\n    decimal_part\
    \ += remainder;\n    decimal_part / 10.0\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot multiply `i32` by `{float}`\n  --> /tmp/tmprlp6mhuk.rs:13:33\n\
    \   |\n13 |         last_digit = last_digit * 10.0;\n   |                    \
    \             ^ no implementation for `i32 * {float}`\n   |\n   = help: the trait\
    \ `Mul<{float}>` is not implemented for `i32`\n   = help: the following other\
    \ types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n    \
    \         <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n      \
    \       <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n          \
    \   <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n             <&'a\
    \ isize as Mul<isize>>\n           and 49 others\n\nerror[E0277]: cannot add-assign\
    \ `i32` to `{float}`\n  --> /tmp/tmprlp6mhuk.rs:14:22\n   |\n14 |         decimal_part\
    \ += last_digit;\n   |                      ^^ no implementation for `{float}\
    \ += i32`\n   |\n   = help: the trait `AddAssign<i32>` is not implemented for\
    \ `{float}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.f64::exp();\n    while exponent > 0.0 {\n        if exponent\
    \ % 2 == 0 {\n            result += (number / 2.0).f64;\n        } else {\n  \
    \          result += (number / 2.0).f64;\n            exponent /= 2;\n       \
    \ }\n        remainder += 1.0;\n    }\n    result + remainder\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmp_hcqynef.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: invalid const generic expression\n  --> /tmp/tmp_hcqynef.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         if exponent % 2 == 0\
    \ {\n13 | |             result += (number / 2.0).f64;\n14 | |         } else {\n\
    ...  |\n18 | |         remainder += 1.0;\n19 | |     }\n   | |_____^\n   |\nhelp:\
    \ expressions must be enclosed in braces to be used as const generic arguments\n\
    \   |\n11 ~     { while exponent > 0.0 {\n12 |         if exponent % 2 == 0 {\n\
    13 |             result += (number / 2.0).f64;\n14 |         } else {\n15 |  \
    \           result += (number / 2.0).f64;\n16 |             exponent /= 2;\n ...\n\
    \nerror: expected one of `(`, `.`, `;`, `?`, `else`, or an operator, found `::`\n\
    \  --> /tmp/tmp_hcqynef.rs:10:34\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                  ^^ expected one of `(`, `.`, `;`, `?`,\
    \ `else`, or an operator\n\nerror: aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n\n    while number > 0.0 {\n        remainder =\
    \ number % 10.0;\n        integer_part += remainder;\n        decimal_part +=\
    \ remainder / 10.0;\n        number /= 10.0;\n    }\n\n    integer_part + decimal_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `remainder` is never read\n  --> /tmp/tmp6zhyoai8.rs:10:13\n\
    \   |\n10 |     let mut remainder = 0.0;\n   |             ^^^^^^^^^\n   |\n \
    \  = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nerror[E0384]: cannot assign to immutable argument\
    \ `number`\n  --> /tmp/tmp6zhyoai8.rs:16:9\n   |\n7  | fn truncate_number(number:\
    \ f64) -> f64 {\n   |                    ------ help: consider making this binding\
    \ mutable: `mut number`\n...\n16 |         number /= 10.0;\n   |         ^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    while number > 0.0 {\n        remainder = number\
    \ % 10.0;\n        integer_part += remainder * 10.0;\n        decimal_part +=\
    \ remainder;\n        number /= 10.0;\n    }\n    integer_part += number as f64;\n\
    \    decimal_part += remainder as f64;\n    integer_part as f64\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: variable `decimal_part` is assigned to, but never used\n --> /tmp/tmp2sj883kr.rs:8:13\n\
    \  |\n8 |     let mut decimal_part = 0.0;\n  |             ^^^^^^^^^^^^\n  |\n\
    \  = note: `#[warn(unused_variables)]` on by default\n  = note: consider using\
    \ `_decimal_part` instead\n\nwarning: value assigned to `decimal_part` is never\
    \ read\n  --> /tmp/tmp2sj883kr.rs:18:5\n   |\n18 |     decimal_part += remainder\
    \ as f64;\n   |     ^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign to immutable argument `number`\n  --> /tmp/tmp2sj883kr.rs:15:9\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \ ------ help: consider making this binding mutable: `mut number`\n...\n15 | \
    \        number /= 10.0;\n   |         ^^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n\n    while number > 0.0 {\n        remainder =\
    \ number % 10.0;\n        integer_part += remainder * 10.0;\n        decimal_part\
    \ += remainder;\n        number /= 10.0;\n    }\n\n    integer_part += decimal_part;\n\
    \    decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n  \
    \  assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `integer_part` is assigned to, but never used\n --> /tmp/tmp_du9t6dq.rs:9:13\n\
    \  |\n9 |     let mut integer_part = 0.0;\n  |             ^^^^^^^^^^^^\n  |\n\
    \  = note: `#[warn(unused_variables)]` on by default\n  = note: consider using\
    \ `_integer_part` instead\n\nwarning: value assigned to `remainder` is never read\n\
    \  --> /tmp/tmp_du9t6dq.rs:10:13\n   |\n10 |     let mut remainder = 0.0;\n  \
    \ |             ^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]` on by\
    \ default\n   = help: maybe it is overwritten before being read?\n\nwarning: value\
    \ assigned to `integer_part` is never read\n  --> /tmp/tmp_du9t6dq.rs:19:5\n \
    \  |\n19 |     integer_part += decimal_part;\n   |     ^^^^^^^^^^^^\n   |\n  \
    \ = help: maybe it is overwritten before being read?\n\nerror[E0384]: cannot assign\
    \ to immutable argument `number`\n  --> /tmp/tmp_du9t6dq.rs:16:9\n   |\n7  | fn\
    \ truncate_number(number: f64) -> f64 {\n   |                    ------ help:\
    \ consider making this binding mutable: `mut number`\n...\n16 |         number\
    \ /= 10.0;\n   |         ^^^^^^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to previous error; 3 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor();\n    let mut decimal = number.fract();\n\
    \    if decimal.is_zero() {\n        return integer;\n    }\n    decimal = decimal.trunc();\n\
    \    integer += decimal;\n    integer\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_zero` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp7c6ocq_s.rs:10:16\n   |\n10 |     if decimal.is_zero()\
    \ {\n   |                ^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmp60l6z3m1.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    if exponent < 0 {\n        exponent = -exponent;\n\
    \    }\n    while exponent > 0 {\n        remainder += 1.0;\n        result *=\
    \ 10.0;\n        if exponent & 1 == 1 {\n            result += remainder;\n  \
    \      }\n        remainder *= 10.0;\n        exponent = exponent >> 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpl617nrc5.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut remainder = number.ceil() as f64;\n    while exponent >\
    \ 0 {\n        decimals += remainder;\n        remainder *= 10.0;\n        exponent--;\n\
    \    }\n    decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpo02aqfov.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.f64::exp();\n    while exponent > 0.0 {\n        if exponent\
    \ % 2 == 0 {\n            result += (number / 2.0).f64;\n            exponent\
    \ /= 2;\n        } else {\n            result += (number / 2.0).f64;\n       \
    \     exponent /= 2;\n            remainder *= 10.0;\n        }\n    }\n    result\
    \ + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmp4tynk83a.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: invalid const generic expression\n  --> /tmp/tmp4tynk83a.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         if exponent % 2 == 0\
    \ {\n13 | |             result += (number / 2.0).f64;\n14 | |             exponent\
    \ /= 2;\n...  |\n19 | |         }\n20 | |     }\n   | |_____^\n   |\nhelp: expressions\
    \ must be enclosed in braces to be used as const generic arguments\n   |\n11 ~\
    \     { while exponent > 0.0 {\n12 |         if exponent % 2 == 0 {\n13 |    \
    \         result += (number / 2.0).f64;\n14 |             exponent /= 2;\n15 |\
    \         } else {\n16 |             result += (number / 2.0).f64;\n ...\n\nerror:\
    \ expected one of `(`, `.`, `;`, `?`, `else`, or an operator, found `::`\n  -->\
    \ /tmp/tmp4tynk83a.rs:10:34\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                  ^^ expected one of `(`, `.`, `;`, `?`,\
    \ `else`, or an operator\n\nerror: aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.f64::exp();\n    while exponent > 0.0 {\n        if exponent\
    \ % 2 == 1 {\n            result += number.f64::powf(2.0).unwrap();\n        }\
    \ else {\n            result += number.f64::powf(2.0).unwrap();\n            remainder\
    \ += number.f64::powf(2.0).unwrap();\n        }\n        number /= 2.0;\n    \
    \    exponent = number.f64::exp();\n    }\n    result + remainder\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmpmssqui5u.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: expected type, found `2.0`\n  --> /tmp/tmpmssqui5u.rs:13:40\n\
    \   |\n13 |             result += number.f64::powf(2.0).unwrap();\n   |      \
    \                                  ^^^ expected type\n   |\nhelp: expressions\
    \ must be enclosed in braces to be used as const generic arguments\n   |\n13 |\
    \             result += number.f64::{ powf(2.0).unwrap() };\n   |            \
    \                       +                    +\n\nerror: expected one of `(`,\
    \ `.`, `;`, `?`, `}`, or an operator, found `::`\n  --> /tmp/tmpmssqui5u.rs:13:33\n\
    \   |\n13 |             result += number.f64::powf(2.0).unwrap();\n   |      \
    \                           ^^ expected one of `(`, `.`, `;`, `?`, `}`, or an\
    \ operator\n\nerror: expected type, found `2.0`\n  --> /tmp/tmpmssqui5u.rs:15:40\n\
    \   |\n15 |             result += number.f64::powf(2.0).unwrap();\n   |      \
    \                                  ^^^ expected type\n   |\nhelp: expressions\
    \ must be enclosed in braces to be used as const generic arguments\n   |\n15 |\
    \             result += number.f64::{ powf(2.0).unwrap() };\n   |            \
    \                       +                    +\n\nerror: expected one of `,`,\
    \ `.`, `:`, `=`, `>`, `?`, or an operator, found `;`\n  --> /tmp/tmpmssqui5u.rs:15:53\n\
    \   |\n15 |             result += number.f64::powf(2.0).unwrap();\n   |      \
    \                                               ^ expected one of 7 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n15 |             result\
    \ += number.f64::powf(2.0).unwrap(), remainder += number.f64::powf(2.0).unwrap();\n\
    \   |                                                     ~\n\nerror: expected\
    \ one of `(`, `.`, `;`, `?`, `}`, or an"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut remainder_sign = 1.0;\n    let mut\
    \ max_integer_part = 0.0;\n    let mut max_remainder = 0.0;\n    let mut max_remainder_sign\
    \ = 1.0;\n    let mut max_decimal_part = 0.0;\n    let mut max_decimal_part_sign\
    \ = 1.0;\n    let mut max_remainder_sign = 1.0;\n    let mut max_integer_part\
    \ = 0.0;\n    let mut max_remainder = 0.0;\n    let mut max_remainder_sign = 1.0;\n\
    \    let mut max_decimal_part = 0.0;\n    let mut max_decimal_part_sign = 1.0;\n\
    \    let mut max_remainder_sign = 1.0;\n    let mut max_integer_part = 0.0;\n\
    \    let mut max_remainder = 0.0;\n    let mut max_remainder_sign = 1.0;\n   \
    \ let mut max_decimal_part = 0.0;\n    let mut max_decimal_part_sign = 1.0;\n\
    \    let mut max_remainder_sign = 1.0;\n    let mut max_integer_part = 0.0;\n\
    \    let mut max_remainder = 0.0;\n    let mut max_remainder_sign = 1.0;\n   \
    \ let mut max_decimal_part = 0.0;\n    let mut max_decimal_part_sign = 1.0;\n\
    \    let mut max_remainder_sign = 1.0;\n    let mut max_integer_part = 0.0;\n\
    \    let mut max_remainder = 0.0;\n    let mut max_remainder_sign = 1.0;\n   \
    \ let mut max_decimal_part = 0.0;\n    let mut max_decimal_part_sign = 1.0;\n\
    \    let mut max_remainder_sign = 1.0;\n    let mut max_integer_part = 0.0;\n\
    \    let mut max_remainder = 0.0;\n    let mut max_remainder_sign = 1.0;\n   \
    \ let mut max_decimal_part = 0.0;\n    let mut max_decimal_part_sign = 1.0;\n\
    \    let mut max_remainder_sign = 1.0;\n    let mut max_integer_part = 0.0;\n\
    \    let mut max_remainder = 0.0;\n    let mut max_remainder_sign = 1.0;\n   \
    \ let mut max_decimal_part = 0.0;\n    let mut max_decimal_part_sign = 1.0;\n\
    \    let mut max_remainder_sign = 1.0;\n    let mut max_integer_part = 0.0;\n\
    \    let mut max_remainder = 0.0;\n    let mut max_remainder_sign = 1.0;\n   \
    \ let mut max_decimal_part = 0.0;\n    let mut max_decimal_part_sign = 1.0;\n\
    \    let mut max_remainder_sign = 1.\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4chqc5wt.rs:59:36\n   |\n\
    59 |     let mut max_remainder_sign = 1.\n   |                               \
    \     ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp4chqc5wt.rs:7:36\n  |\n7 | fn truncate_number(number: f64)\
    \ -> f64 {\n  |    ---------------                 ^^^ expected `f64`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut remainder_exponent =\
    \ exponent as i32;\n\n    while remainder_exponent > 0 {\n        remainder_exponent\
    \ -= 1;\n        remainder += number.fract(remainder_exponent as u32);\n    }\n\
    \n    decimal_part += remainder;\n    decimal_part / 10.0\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpvtnm1k1l.rs:15:29\n    |\n15  |         remainder += number.fract(remainder_exponent\
    \ as u32);\n    |                             ^^^^^ -------------------------\
    \ supplied 1 argument\n    |                             |\n    |            \
    \                 expected 0 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.f64::exp();\n    while exponent > 0.0 {\n        remainder\
    \ += 1.0;\n        truncated = truncated * 10.0 + (number % 1.0);\n        number\
    \ /= 10.0;\n        exponent = number.f64::exp();\n    }\n    truncated + remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmpk1ehhumk.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: expected one of `(`, `.`, `;`, `?`, `}`, or an operator,\
    \ found `::`\n  --> /tmp/tmpk1ehhumk.rs:15:30\n   |\n15 |         exponent = number.f64::exp();\n\
    \   |                              ^^ expected one of `(`, `.`, `;`, `?`, `}`,\
    \ or an operator\n\nerror: invalid const generic expression\n  --> /tmp/tmpk1ehhumk.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         remainder += 1.0;\n13\
    \ | |         truncated = truncated * 10.0 + (number % 1.0);\n14 | |         number\
    \ /= 10.0;\n15 | |         exponent = number.f64::exp();\n16 | |     }\n   | |_____^\n\
    \   |\nhelp: expressions must be enclosed in braces to be used as const generic\
    \ arguments\n   |\n11 ~     { while exponent > 0.0 {\n12 |         remainder +=\
    \ 1.0;\n13 |         truncated = truncated * 10.0 + (number % 1.0);\n14 |    \
    \     number /= 10.0;\n15 |         exponent = number.f64::exp();\n16 ~     }\
    \ }\n   |\n\nerror: expected one of `(`, `.`, `;`, `?`, `else`, or an operator,\
    \ found `::`\n  --> /tmp/tmpk1ehhumk.rs:10:34\n   |\n10 |     let mut exponent\
    \ = number.f64::exp();\n   |                                  ^^ expected one\
    \ of `(`, `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to 4 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut remainder_magnitude = 0.0;\n    let mut remainder_magnitude_f64 = 0.0;\n\
    \    let mut remainder_magnitude_f32 = 0.0;\n    let mut remainder_magnitude_f16\
    \ = 0.0;\n    let mut remainder_magnitude_f8 = 0.0;\n    let mut remainder_magnitude_f64_m32\
    \ = 0.0;\n    let mut remainder_magnitude_f64_m16 = 0.0;\n    let mut remainder_magnitude_f64_m8\
    \ = 0.0;\n    let mut remainder_magnitude_f32_m16 = 0.0;\n    let mut remainder_magnitude_f32_m8\
    \ = 0.0;\n    let mut remainder_magnitude_f16_m8 = 0.0;\n    let mut remainder_magnitude_f64_m16_m8\
    \ = 0.0;\n    let mut remainder_magnitude_f64_m8_m16 = 0.0;\n    let mut remainder_magnitude_f32_m8_m16\
    \ = 0.0;\n    let mut remainder_magnitude_f16_m8_m16 = 0.0;\n    let mut remainder_magnitude_f64_m16_m8_m16\
    \ = 0.0;\n    let mut remainder_magnitude_f64_m8_m16_m16 = 0.0;\n    let mut remainder_magnitude_f32_m8_m16_m16\
    \ = 0.0;\n    let mut remainder_magnitude_f16_m8_m16_m16 = 0.0;\n    let mut remainder_magnitude_f64_m16_m8_m16_m16\
    \ = 0.0;\n    let mut remainder_magnitude_f64_m8_m16_m16_m16 = 0.0;\n    let mut\
    \ remainder_magnitude_f32_m8_m16_m16_m16 = 0.0;\n    let mut remainder_magnitude_f16_m8_m16_m16_m16\
    \ = 0.0;\n    let mut remainder_magnitude_f64_m16_m8_m16_m16_m16 = 0.0;\n    let\
    \ mut remainder_magnitude_f64_m8_m16_m16_m16_m16 = 0.0;\n    let mut remainder_magnitude_f32_m8_m16_m16_m16_m16\
    \ = 0.0;\n    let mut remainder_magnitude_f16_m8_m16_m16_m16_m16 = 0.0;\n    let\
    \ mut remainder_magnitude_f64_m16_m8_m16_m16_m16_m16 = 0.0;\n    let mut remainder_magnitude_f64_m8_m16_m16_m16_m16_m16\
    \ = 0.0;\n    let mut remainder_magnitude_f32_m8_m16_m16_m16_m16_m16 = 0.0;\n\
    \    let mut remainder_magnitude_f16\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpfuo0__17.rs:40:36\n   |\n\
    40 |     let mut remainder_magnitude_f16\n   |                               \
    \     ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpfuo0__17.rs:7:36\n  |\n7 | fn truncate_number(number: f64)\
    \ -> f64 {\n  |    ---------------                 ^^^ expected `f64`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += number.remainder(&mut truncated);\n        truncated = truncated.recip();\n\
    \        exponent--;\n    }\n    truncated + remainder\n}\n\nfn main() {\n   \
    \ let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n   \
    \ assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpxnax7sal.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpxnax7sal.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpxnax7sal.rs:12:29\n   |\n12 |         remainder += number.remainder(&mut\
    \ truncated);\n   |                             ^^^^^^^^^ method not found in\
    \ `f64`\n\nerror[E0689]: can't call method `recip` on ambiguous numeric type `{float}`\n\
    \  --> /tmp/tmpxnax7sal.rs:13:31\n   |\n13 |         truncated = truncated.recip();\n\
    \   |                               ^^^^^\n   |\nhelp: you must specify a type\
    \ for this binding, like `f32`\n   |\n8  |     let mut truncated: f32 = 0.0;\n\
    \   |         ~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0689.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 0.0 {\n        let mut digit = remainder % 10.0;\n        remainder\
    \ /= 10.0;\n        integer_part += digit;\n        leftover_part += digit * 10.0;\n\
    \    }\n    integer_part += leftover_part;\n    decimal_part = remainder;\n  \
    \  integer_part / 10.0\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.277777777777777`,\n right: `0.5`', /tmp/tmp_8lqfcaq.rs:25:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number;\n    let mut decimal = number - integer;\n\
    \    if decimal < 0.5 {\n        integer = integer - 1;\n        decimal = decimal\
    \ + 1;\n    }\n    decimal\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `{integer}` from `f64`\n  --> /tmp/tmp3rgi5b_8.rs:11:27\n\
    \   |\n11 |         integer = integer - 1;\n   |                           ^ no\
    \ implementation for `f64 - {integer}`\n   |\n   = help: the trait `Sub<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n  \
    \         and 48 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n11 |         integer = integer - 1.0;\n   |            \
    \                  ++\n\nerror[E0277]: cannot add `{integer}` to `f64`\n  -->\
    \ /tmp/tmp3rgi5b_8.rs:12:27\n   |\n12 |         decimal = decimal + 1;\n   | \
    \                          ^ no implementation for `f64 + {integer}`\n   |\n \
    \  = help: the trait `Add<{integer}>` is not implemented for `f64`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n      \
    \       <&'a isize as Add<isize>>\n           and 48 others\nhelp: consider using\
    \ a floating-point literal by writing it with `.0`\n   |\n12 |         decimal\
    \ = decimal + 1.0;\n   |                              ++\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.f64::exp();\n    let mut remainder_exponent = exponent;\n\
    \    while remainder_exponent > 0 {\n        if remainder_exponent % 2 == 1 {\n\
    \            decimal_part += remainder;\n        }\n        remainder_exponent\
    \ /= 2;\n        remainder *= 10.0;\n    }\n    decimal_part + remainder\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmp9gjdm__1.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), let mut remainder_exponent = exponent;\n   |          \
    \                               ~\n\nerror: invalid const generic expression\n\
    \  --> /tmp/tmp9gjdm__1.rs:11:5\n   |\n11 |     let mut remainder_exponent = exponent;\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\nhelp: expressions must\
    \ be enclosed in braces to be used as const generic arguments\n   |\n11 |    \
    \ { let mut remainder_exponent = exponent };\n   |     +                     \
    \                  +\n\nerror: expected one of `!`, `,`, `.`, `::`, `:`, `=`,\
    \ `>`, `?`, `{`, or an operator, found `;`\n  --> /tmp/tmp9gjdm__1.rs:11:42\n\
    \   |\n11 |     let mut remainder_exponent = exponent;\n   |                 \
    \                         ^ expected one of 10 possible tokens\n   |\nhelp: use\
    \ a comma to separate type parameters\n   |\n11 |     let mut remainder_exponent\
    \ = exponent, while remainder_exponent > 0 {\n   |                           \
    \               ~\n\nerror: invalid const generic expression\n  --> /tmp/tmp9gjdm__1.rs:12:5\n\
    \   |\n12 | /     while remainder_exponent > 0 {\n13 | |         if remainder_exponent\
    \ % 2 == 1 {\n14 | |             decimal_part += remainder;\n15 | |         }\n\
    16 | |         remainder_exponent /= 2;\n17 | |         remainder *= 10.0;\n18\
    \ | |     }\n   | |_____^\n   |\nhelp: expressions must be enclosed in braces\
    \ to be used as const generic arguments\n   |\n12 ~     { while remainder_exponent\
    \ > 0 {\n13 |         if remainder_exponent % 2 == 1 {\n14 |             decimal_part\
    \ += remainder;\n15 |         }\n16 |         remainder_exponent /= 2;\n17 | \
    \        remainder *= 10.0;\n ...\n\nerror: expected one of `(`, `.`, `;`, `?`,\
    \ `else`, or an operator, found `::`\n  --> /tmp/tmp9gjdm__1.rs:10:34\n   |\n\
    10 |     let mut exponent = number.f64::"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    while exponent > 0 {\n        remainder +=\
    \ number.fract() * (f64::powf(10.0, exponent));\n        result += (number.fract()\
    \ * (f64::powf(10.0, exponent))).trunc();\n        exponent--;\n    }\n    result\
    \ + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpa8w5ig3a.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpa8w5ig3a.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n  --> /tmp/tmpa8w5ig3a.rs:11:20\n   |\n\
    11 |     while exponent > 0 {\n   |                    ^ no implementation for\
    \ `f64 < {integer}` and `f64 > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n11 |     while exponent > 0.0 {\n   |\
    \                       ++\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.floor() as i32;\n    let mut fraction = number.sub_f64::<f64>()\
    \ as f64;\n    while exponent > 0 {\n        let mut next_remainder = remainder;\n\
    \        let mut next_exponent = exponent;\n        while next_exponent > 0 {\n\
    \            let mut next_fraction = fraction;\n            if next_fraction >\
    \ next_remainder {\n                next_fraction -= next_remainder;\n       \
    \         next_remainder = 0.0;\n            } else {\n                next_fraction\
    \ -= next_remainder;\n                next_remainder = 1.0;\n            }\n \
    \           next_exponent -= 1;\n        }\n        result = result + next_fraction\
    \ * next_remainder;\n        remainder = next_remainder;\n        exponent = next_exponent;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n \
    \   assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `next_fraction` in this scope\n  --> /tmp/tmpz7nx056m.rs:26:27\n\
    \   |\n26 |         result = result + next_fraction * next_remainder;\n   |  \
    \                         ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `sub_f64` found for type `f64` in the current scope\n  --> /tmp/tmpz7nx056m.rs:11:31\n\
    \   |\n11 |     let mut fraction = number.sub_f64::<f64>() as f64;\n   |     \
    \                          ^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += number.fract() * (10.0 / (10.0 ** exponent));\n        decimal_part += remainder;\n\
    \        exponent--;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp5oz3nkh6.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp5oz3nkh6.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.f64::exp();\n    while exponent > 0 {\n        remainder +=\
    \ 1.0;\n        result *= 10.0;\n        result += (number % 1.0).f64();\n   \
    \     number /= 10.0;\n        exponent--;\n    }\n    result + remainder\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmpaw21f_v6.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0 {\n   |                            \
    \             ~\n\nerror: expected expression, found `;`\n  --> /tmp/tmpaw21f_v6.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror: invalid const generic expression\n  --> /tmp/tmpaw21f_v6.rs:11:5\n  \
    \ |\n11 | /     while exponent > 0 {\n12 | |         remainder += 1.0;\n13 | |\
    \         result *= 10.0;\n14 | |         result += (number % 1.0).f64();\n15\
    \ | |         number /= 10.0;\n16 | |         exponent--;\n17 | |     }\n   |\
    \ |_____^\n   |\nhelp: expressions must be enclosed in braces to be used as const\
    \ generic arguments\n   |\n11 ~     { while exponent > 0 {\n12 |         remainder\
    \ += 1.0;\n13 |         result *= 10.0;\n14 |         result += (number % 1.0).f64();\n\
    15 |         number /= 10.0;\n16 |         exponent--;\n ...\n\nerror: expected\
    \ one of `(`, `.`, `;`, `?`, `else`, or an operator, found `::`\n  --> /tmp/tmpaw21f_v6.rs:10:34\n\
    \   |\n10 |     let mut exponent = number.f64::exp();\n   |                  \
    \                ^^ expected one of `(`, `.`, `;`, `?`, `else`, or an operator\n\
    \nerror: aborting due to 4 previous errors\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpkwva3xhz.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut quotient = number.floor();\n    while quotient > 0.0 {\n        remainder\
    \ += 1.0;\n        quotient -= 1.0;\n    }\n    decimal_part = remainder;\n  \
    \  decimal_part + quotient\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmp5_2jdzu1.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: -1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = number;\n    while remainder > 1.0 {\n        remainder -= 1.0;\n\
    \        decimals += 1.0;\n    }\n    while remainder > 0.0 {\n        integer\
    \ += 1.0;\n        remainder -= 0.0;\n    }\n    integer + decimals\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011908
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut remainder = number.floor() as f64;\n    while exponent\
    \ > 0 {\n        remainder *= 10.0;\n        decimals += remainder;\n        remainder\
    \ -= remainder.floor();\n        exponent -= 1;\n    }\n    decimals\n}\n\nfn\
    \ main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `30.0`,\n right: `0.5`', /tmp/tmp2_fsuerw.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 1.0 {\n        remainder -= 1.0;\n        result += 1.0;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpqwmr_8xl.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut remainder_magnitude = 0.0;\n    let mut max_magnitude = 0.0;\n    let\
    \ mut min_magnitude = 0.0;\n    let mut min_magnitude_inclusive = false;\n   \
    \ let mut max_magnitude_inclusive = false;\n    let mut min_magnitude_decimals\
    \ = 0.0;\n    let mut max_magnitude_decimals = 0.0;\n    let mut min_magnitude_decimals_inclusive\
    \ = false;\n    let mut max_magnitude_decimals_inclusive = false;\n    let mut\
    \ min_magnitude_decimals_decimals = 0.0;\n    let mut max_magnitude_decimals_decimals\
    \ = 0.0;\n    let mut min_magnitude_decimals_decimals_inclusive = false;\n   \
    \ let mut max_magnitude_decimals_decimals_inclusive = false;\n    let mut min_magnitude_decimals_decimals_decimals\
    \ = 0.0;\n    let mut max_magnitude_decimals_decimals_decimals = 0.0;\n    let\
    \ mut min_magnitude_decimals_decimals_decimals_inclusive = false;\n    let mut\
    \ max_magnitude_decimals_decimals_decimals_inclusive = false;\n    let mut min_magnitude_decimals_decimals_decimals_decimals\
    \ = 0.0;\n    let mut max_magnitude_decimals_decimals_decimals_decimals = 0.0;\n\
    \    let mut min_magnitude_decimals_decimals_decimals_decimals_inclusive = false;\n\
    \    let mut max_magnitude_decimals_decimals_decimals_decimals_inclusive = false;\n\
    \    let mut min_magnitude_decimals_decimals_decimals_decimals_decimals = 0.0;\n\
    \    let mut max_magnitude_decimals_decimals_decimals_decimals_decimals = 0.0;\n\
    \    let mut min_magnitude_decimals_decimals_decimals_decimals_decimals_inclusive\
    \ = false;\n    let mut max_magnitude_decimals_decimals_decimals_decimals_decimals_inclusive\
    \ = false;\n    let mut min_magnitude_decimals_decimals_decimals_decimals_decimals_decimals\
    \ = 0.0;\n    let mut max_magnitude_decimals_decimals_decimals_decimals_decimals_decimals\
    \ = 0.0;\n    let mut min_magnitude_decimals_decimals_decimals_decimals_decimals_decimals_inclusive\
    \ = false;\n    let mut max_magnitude_decimals_decimals_decimals_decimals_decimals_decimals_inclusive\
    \ = false;\n    let mut min_magnitude_decimals_decimals_decimals_decimals_decimals_decimals_decimals\
    \ = 0.0;\n    let mut max_magnitude_decimals_decimals_decimals_decimals_decimals_decimals_decimals\
    \ = 0.0;\n    let mut min_magnitude_decimals_decimals_decimals_decimals_decimals_decimals_decimals_inclusive\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9utwvxkf.rs:41:99\n   |\n\
    41 |     let mut min_magnitude_decimals_decimals_decimals_decimals_decimals_decimals_decimals_inclusive\n\
    \   |                                                                        \
    \                           ^ help: add `;` here\n42 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp9utwvxkf.rs:7:36\n  |\n7 | fn truncate_number(number:\
    \ f64) -> f64 {\n  |    ---------------                 ^^^ expected `f64`, found\
    \ `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder: f64 = number;\n    let mut decimal_part: f64\
    \ = 1.0;\n    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmpakonmo_4.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.floor() as i32;\n\
    \    let mut remainder_exponent = exponent - 1;\n    let mut decimal_part_exponent\
    \ = exponent - 1;\n    let mut decimal_part_remainder = 1.0;\n    let mut decimal_part_remainder_exponent\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder = 1.0;\n    let mut decimal_part_remainder_remainder_exponent\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder = 1.0;\n    let\
    \ mut decimal_part_remainder_remainder_remainder_exponent = 1.0;\n    let mut\
    \ decimal_part_remainder_remainder_remainder_remainder = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_exponent\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_remainder\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_exponent\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_remainder\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_exponent\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_remainder\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_exponent\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_remainder\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_exponent\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_remainder\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_exponent\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_remainder\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_exponent\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_remainder\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_exponent\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_remainder\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_exponent\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_remainder\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_exponent\
    \ = 1.0;\n    let mut decimal_part_remainder_remainder_remainder_remainder_remainder\
    \ = 1.0;\n    let \n}\n\nfn main() {\n    let candidate = truncate_number;\n \
    \   assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp49r1wts2.rs:42:1\n  \
    \ |\n42 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number;\n\n    while\
    \ remainder > 1.0 {\n        remainder -= 1.0;\n        leftover_part += 1.0;\n\
    \    }\n\n    while remainder > 0.0 {\n        remainder -= 1.0;\n        integer_part\
    \ += 1.0;\n    }\n\n    integer_part += leftover_part;\n    decimal_part = remainder;\n\
    \n    integer_part * f64::from(f64::MAX)\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `inf`,\n right: `0.5`', /tmp/tmp5vg1z4ds.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut fraction = number.sub(f64::from(number)).abs();\n\
    \    while fraction > 1.0 {\n        fraction = fraction.sub(f64::from(fraction)).abs();\n\
    \        exponent += 1;\n    }\n    fraction = fraction.ceil() as f64;\n    while\
    \ fraction < 1.0 {\n        fraction = fraction.ceil() as f64;\n        exponent\
    \ -= 1;\n    }\n    if exponent < 0 {\n        decimal_part = f64::from(fraction).pow(f64::from(2.0)).sub(f64::from(1.0)).sqrt();\n\
    \    } else {\n        decimal_part = f64::from(fraction).pow(f64::from(2.0)).sqrt();\n\
    \    }\n    remainder = fraction.sub(f64::from(decimal_part));\n    decimal_part\
    \ += remainder;\n    decimal_part.round();\n    decimal_part\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sub` found for type `f64` in the current\
    \ scope\n   --> /tmp/tmpvw1gipic.rs:11:31\n    |\n11  |     let mut fraction =\
    \ number.sub(f64::from(number)).abs();\n    |                               ^^^\
    \ method not found in `f64`\n    |\n    = help: items from traits can only be\
    \ used if the trait is in scope\nhelp: the following trait is implemented but\
    \ not in scope; perhaps add a `use` for it:\n    |\n1   | use std::ops::Sub;\n\
    \    |\n\nerror[E0599]: no method named `pow` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpvw1gipic.rs:22:44\n   |\n22 |         decimal_part = f64::from(fraction).pow(f64::from(2.0)).sub(f64::from(1.0)).sqrt();\n\
    \   |                                            ^^^ help: there is an associated\
    \ function with a similar name: `powf`\n\nerror[E0599]: no method named `pow`\
    \ found for type `f64` in the current scope\n  --> /tmp/tmpvw1gipic.rs:24:44\n\
    \   |\n24 |         decimal_part = f64::from(fraction).pow(f64::from(2.0)).sqrt();\n\
    \   |                                            ^^^ help: there is an associated\
    \ function with a similar name: `powf`\n\nerror[E0689]: can't call method `round`\
    \ on ambiguous numeric type `{float}`\n  --> /tmp/tmpvw1gipic.rs:28:18\n   |\n\
    28 |     decimal_part.round();\n   |                  ^^^^^\n   |\nhelp: you must\
    \ specify a type for this binding, like `f32`\n   |\n8  |     let mut decimal_part:\
    \ f32 = 0.0;\n   |         ~~~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0689.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut remainder_exponent =\
    \ exponent as i32;\n    let mut remainder_exponent2 = 0.0;\n    let mut remainder_exponent3\
    \ = 0.0;\n    let mut remainder_exponent4 = 0.0;\n    let mut remainder_exponent5\
    \ = 0.0;\n    let mut remainder_exponent6 = 0.0;\n    let mut remainder_exponent7\
    \ = 0.0;\n    let mut remainder_exponent8 = 0.0;\n    let mut remainder_exponent9\
    \ = 0.0;\n    let mut remainder_exponent10 = 0.0;\n    let mut remainder_exponent11\
    \ = 0.0;\n    let mut remainder_exponent12 = 0.0;\n    let mut remainder_exponent13\
    \ = 0.0;\n    let mut remainder_exponent14 = 0.0;\n    let mut remainder_exponent15\
    \ = 0.0;\n    let mut remainder_exponent16 = 0.0;\n    let mut remainder_exponent17\
    \ = 0.0;\n    let mut remainder_exponent18 = 0.0;\n    let mut remainder_exponent19\
    \ = 0.0;\n    let mut remainder_exponent20 = 0.0;\n    let mut remainder_exponent21\
    \ = 0.0;\n    let mut remainder_exponent22 = 0.0;\n    let mut remainder_exponent23\
    \ = 0.0;\n    let mut remainder_exponent24 = 0.0;\n    let mut remainder_exponent25\
    \ = 0.0;\n    let mut remainder_exponent26 = 0.0;\n    let mut remainder_exponent27\
    \ = 0.0;\n    let mut remainder_exponent28 = 0.0;\n    let mut remainder_exponent29\
    \ = 0.0;\n    let mut remainder_exponent30 = 0.0;\n    let mut remainder_exponent31\
    \ = 0.0;\n    let mut remainder_exponent32 = 0.0;\n    let mut remainder_exponent33\
    \ = 0.0;\n    let mut remainder_exponent34 = 0.0;\n    let mut remainder_exponent35\
    \ = 0.0;\n    let mut remainder_exponent36 = 0.0;\n    let mut remainder_exponent37\
    \ = 0.0;\n    let mut remainder_exponent38 = 0.0;\n    let mut remainder_exponent39\
    \ = 0.0;\n    let mut remainder_exponent40 = 0.0;\n    let mut remainder_exponent41\
    \ = 0.0;\n    let mut remainder_exponent42 = 0.0;\n    let mut remainder_exponent43\
    \ = 0.0;\n    let mut remainder_exponent44 = 0.0;\n    let mut remainder_exponent45\
    \ = 0.0;\n    let mut remainder_exponent46 = 0.0;\n    let mut remainder_exponent47\
    \ = 0.0;\n    let mut remainder_exponent48\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5mnibnhf.rs:58:33\n   |\n\
    58 |     let mut remainder_exponent48\n   |                                 ^\
    \ help: add `;` here\n59 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp5mnibnhf.rs:7:36\n  |\n7 | fn truncate_number(number: f64)\
    \ -> f64 {\n  |    ---------------                 ^^^ expected `f64`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut sign = number.is_negative();\n\
    \    if number < 0.0 {\n        sign = !sign;\n        number = -number;\n   \
    \ }\n    if number == 0.0 {\n        return 0.0;\n    }\n    if number < 1.0 {\n\
    \        leftover_part = number;\n        number = number;\n    }\n    if number\
    \ < 10.0 {\n        integer_part = number;\n        number = number - integer_part;\n\
    \    }\n    if number < 100.0 {\n        decimal_part = number / 10.0;\n     \
    \   number = number - decimal_part * 10.0;\n    }\n    if number < 1000.0 {\n\
    \        decimal_part = number / 100.0;\n        number = number - decimal_part\
    \ * 100.0;\n    }\n    if number < 10000.0 {\n        decimal_part = number /\
    \ 1000.0;\n        number = number - decimal_part * 1000.0;\n    }\n    if number\
    \ < 100000.0 {\n        decimal_part = number / 10000.0;\n        number = number\
    \ - decimal_part * 10000.0;\n    }\n    if number < 1000000.0 {\n        decimal_part\
    \ = number / 100000.0;\n        number = number - decimal_part * 100000.0;\n \
    \   }\n    if number < 10000000.0 {\n        decimal_part = number / 1000000.0;\n\
    \        number = number - decimal_part * 1000000.0;\n    }\n    if number < 100000000.0\
    \ {\n        decimal_part = number / 10000000.0;\n        number = number - decimal_part\
    \ * 10000000.0;\n    }\n    if number < 1000000000.0 {\n        decimal_part =\
    \ number / 100000000.0;\n        number = number - decimal_part * 100000000.0;\n\
    \    }\n    if number < 10000000000.0 {\n        decimal_part = number / 1000000000.0;\n\
    \        number = number - decimal_part * 1000000000.0;\n    }\n    if number\
    \ < 100000000000.0 {\n        decimal_part = number / 10000000000.0;\n       \
    \ number = number - decimal_part * 10000000000.0;\n    }\n    if number < 1000000000000.0\
    \ {\n        decimal_part = number / 100000000000.0;\n        number = number\
    \ - decimal_part * 100000000000.0;\n    }\n    if number < 10000000000000.0 {\n\
    \        decimal_part = number / 1000000000000.0;\n        number = number - decimal_part\
    \ * 1000000000000.0;\n    }\n    if number < 100000000000000.0 {\n        decimal_part\
    \ = number / 10000000000000.0;\n        number = number - decimal_part * 10000000000000.0;\n\
    \    }\n    if number < 1000000000000000.0 {\n\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpr43vk71l.rs:88:3\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \                     - unclosed delimiter\n...\n79 |     if number < 1000000000000000.0\
    \ {\n   |                                    - this delimiter might not be properly\
    \ closed...\n80 | \n81 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n88 | }\n   |   ^\n\nwarning: use of deprecated associated\
    \ function `core::f64::<impl f64>::is_negative`: renamed to is_sign_negative\n\
    \  --> /tmp/tmpr43vk71l.rs:11:27\n   |\n11 |     let mut sign = number.is_negative();\n\
    \   |                           ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]`\
    \ on by default\n\nerror[E0308]: mismatched types\n --> /tmp/tmpr43vk71l.rs:7:36\n\
    \  |\n7 | fn truncate_number(number: f64) -> f64 {\n  |    ---------------   \
    \              ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.to_f64().floor() as i32;\n    if exponent < 0 {\n        exponent\
    \ = -exponent;\n    }\n    while exponent > 0 {\n        remainder += 1.0;\n \
    \       result *= 10.0;\n        result -= remainder;\n        remainder *= 10.0;\n\
    \        exponent = exponent - 1;\n    }\n    result + remainder\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp5iow12zy.rs:10:31\n   |\n10 |     let mut exponent = number.to_f64().floor()\
    \ as i32;\n   |                               ^^^^^^ method not found in `f64`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        remainder += 1.0;\n        integer_part += remainder;\n\
    \        decimal_part += remainder * number.next_exponent();\n        exponent--;\n\
    \    }\n    integer_part + decimal_part\n}\n\nfn main() {\n    let candidate =\
    \ truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp_2tjzw3d.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp_2tjzw3d.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `next_exponent` found for type `f64` in the current scope\n\
    \  --> /tmp/tmp_2tjzw3d.rs:15:44\n   |\n15 |         decimal_part += remainder\
    \ * number.next_exponent();\n   |                                            ^^^^^^^^^^^^^\
    \ method not found in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut sign = number.is_negative() ? -1.0\
    \ : 1.0;\n    let mut exponent = number.is_negative() ? -number.len() : number.len();\n\
    \    let mut i = 0;\n    while exponent > 0 {\n        if exponent % 2 == 1 {\n\
    \            integer_part += number.powf(2.0).floor() as f64;\n        }\n   \
    \     leftover_part += number.powf(2.0).floor() as f64;\n        number /= 2.0;\n\
    \        exponent /= 2;\n        i += 1;\n    }\n    if exponent == 0 {\n    \
    \    integer_part += number.floor() as f64;\n    }\n    decimal_part = leftover_part\
    \ / number;\n    sign * integer_part + decimal_part\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `1.0`\n  --> /tmp/tmplkq03z_d.rs:11:50\n  \
    \ |\n11 |     let mut sign = number.is_negative() ? -1.0 : 1.0;\n   |        \
    \                                        - ^^^ expected type\n   |           \
    \                                     |\n   |                                \
    \                tried to parse a type due to this\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor();\n    let mut decimal = number.fract();\n\
    \    if decimal.is_zero() {\n        return integer;\n    }\n    decimal = decimal.trunc();\n\
    \    integer -= decimal;\n    integer\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_zero` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpa7jji40n.rs:10:16\n   |\n10 |     if decimal.is_zero()\
    \ {\n   |                ^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut exponent = number.f64::exp();\n\
    \    let mut remainder = number.f64::remainder(&mut result);\n    while exponent\
    \ > 0.0 {\n        if remainder < 1.0 {\n            result -= remainder;\n  \
    \          remainder = 1.0;\n        } else {\n            result -= remainder;\n\
    \            remainder = remainder.f64::div(10.0);\n        }\n        exponent\
    \ = exponent.f64::exp();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n --> /tmp/tmpb3zlbb12.rs:9:41\n  |\n9 |     let mut exponent = number.f64::exp();\n\
    \  |                                         ^ expected one of 8 possible tokens\n\
    \  |\nhelp: use a comma to separate type parameters\n  |\n9 |     let mut exponent\
    \ = number.f64::exp(), let mut remainder = number.f64::remainder(&mut result);\n\
    \  |                                         ~\n\nerror: expected one of `!`,\
    \ `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found `;`\n  --> /tmp/tmpb3zlbb12.rs:10:59\n\
    \   |\n10 |     let mut remainder = number.f64::remainder(&mut result);\n   |\
    \                                                           ^ expected one of\
    \ 8 possible tokens\n   |\nhelp: use a comma to separate type parameters\n   |\n\
    10 |     let mut remainder = number.f64::remainder(&mut result), while exponent\
    \ > 0.0 {\n   |                                                           ~\n\n\
    error: expected type, found `10.0`\n  --> /tmp/tmpb3zlbb12.rs:17:44\n   |\n17\
    \ |             remainder = remainder.f64::div(10.0);\n   |                  \
    \                          ^^^^ expected type\n   |\nhelp: expressions must be\
    \ enclosed in braces to be used as const generic arguments\n   |\n17 |       \
    \      remainder = remainder.f64::{ div(10.0) };\n   |                       \
    \                 +           +\n\nerror: expected one of `(`, `.`, `;`, `?`,\
    \ `}`, or an operator, found `::`\n  --> /tmp/tmpb3zlbb12.rs:17:38\n   |\n17 |\
    \             remainder = remainder.f64::div(10.0);\n   |                    \
    \                  ^^ expected one of `(`, `.`, `;`, `?`, `}`, or an operator\n\
    \nerror: expected one of `(`, `.`, `;`, `?`, `}`, or an operator, found `::`\n\
    \  --> /tmp/tmpb3zlbb12.rs:19:32\n   |\n19 |         exponent = exponent.f64::exp();\n\
    \   |                                ^^ expected one of `(`, `.`, `;`, `?`, `}`,\
    \ or an operator\n\nerror: invalid const generic expression\n  --> /tmp/tmpb3zlbb12.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         if remainder < 1.0 {\n\
    13 | |             result -= remainder;\n14 | "
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        if exponent\
    \ % 2 == 1 {\n            truncated = truncated.checked_add(number.checked_mul(1.0\
    \ / 10.0));\n        }\n        remainder = number.checked_mul(10.0).unwrap();\n\
    \        number = number.checked_mul(10.0).unwrap();\n        exponent = exponent\
    \ / 2;\n    }\n    truncated.checked_add(remainder)\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpuew2zj46.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0689]:\
    \ can't call method `checked_add` on ambiguous numeric type `{float}`\n  --> /tmp/tmpuew2zj46.rs:13:35\n\
    \   |\n13 |             truncated = truncated.checked_add(number.checked_mul(1.0\
    \ / 10.0));\n   |                                   ^^^^^^^^^^^\n   |\nhelp: you\
    \ must specify a type for this binding, like `f32`\n   |\n8  |     let mut truncated:\
    \ f32 = 0.0;\n   |         ~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named\
    \ `checked_mul` found for type `f64` in the current scope\n  --> /tmp/tmpuew2zj46.rs:13:54\n\
    \   |\n13 |             truncated = truncated.checked_add(number.checked_mul(1.0\
    \ / 10.0));\n   |                                                      ^^^^^^^^^^^\
    \ method not found in `f64`\n\nerror[E0599]: no method named `checked_mul` found\
    \ for type `f64` in the current scope\n  --> /tmp/tmpuew2zj46.rs:15:28\n   |\n\
    15 |         remainder = number.checked_mul(10.0).unwrap();\n   |            \
    \                ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0599]: no method\
    \ named `checked_mul` found for type `f64` in the current scope\n  --> /tmp/tmpuew2zj46.rs:16:25\n\
    \   |\n16 |         number = number.checked_mul(10.0).unwrap();\n   |        \
    \                 ^^^^^^^^^^^ method not found in `f64`\n\nerror[E0689]: can't\
    \ call method `checked_add` on ambiguous numeric type `{float}`\n  --> /tmp/tmpuew2zj46.rs:19:15\n\
    \   |\n19 |     truncated.checked_add(remainder)\n   |               ^^^^^^^^^^^\n\
    \   |\nhelp: you must specify a type for this binding, like `f32`\n   |\n8  |\
    \     let mut truncated: f32 = 0.0;\n   |         ~~~~~~~~~~~~~~~~~~\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0689.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    while exponent > 0 {\n        remainder +=\
    \ number.fract() * (f64::pow(10.0, exponent) - 1.0);\n        result -= remainder;\n\
    \        remainder = 0.0;\n        exponent--;\n    }\n    result + remainder\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpr3c_ko9t.rs:15:19\n\
    \   |\n15 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpr3c_ko9t.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no function or associated item named `pow` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpr3c_ko9t.rs:12:45\n   |\n12 |         remainder += number.fract()\
    \ * (f64::pow(10.0, exponent) - 1.0);\n   |                                  \
    \           ^^^\n   |                                             |\n   |    \
    \                                         function or associated item not found\
    \ in `f64`\n   |                                             help: there is an\
    \ associated function with a similar name: `powf`\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor();\n    let mut decimal = number.fract();\n\
    \    if decimal.is_zero() {\n        return integer;\n    }\n    decimal = decimal.trunc();\n\
    \    integer += decimal;\n    integer\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_zero` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp7c6ocq_s.rs:10:16\n   |\n10 |     if decimal.is_zero()\
    \ {\n   |                ^^^^^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.f64::exp();\n    while exponent > 0.0 {\n        if exponent\
    \ % 2 == 0 {\n            truncated = truncated + remainder;\n            remainder\
    \ = 0.0;\n        } else {\n            remainder = remainder + 1.0;\n       \
    \ }\n        exponent = exponent / 2.0;\n    }\n    truncated + remainder\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmphx835me7.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: invalid const generic expression\n  --> /tmp/tmphx835me7.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         if exponent % 2 == 0\
    \ {\n13 | |             truncated = truncated + remainder;\n14 | |           \
    \  remainder = 0.0;\n...  |\n18 | |         exponent = exponent / 2.0;\n19 | |\
    \     }\n   | |_____^\n   |\nhelp: expressions must be enclosed in braces to be\
    \ used as const generic arguments\n   |\n11 ~     { while exponent > 0.0 {\n12\
    \ |         if exponent % 2 == 0 {\n13 |             truncated = truncated + remainder;\n\
    14 |             remainder = 0.0;\n15 |         } else {\n16 |             remainder\
    \ = remainder + 1.0;\n ...\n\nerror: expected one of `(`, `.`, `;`, `?`, `else`,\
    \ or an operator, found `::`\n  --> /tmp/tmphx835me7.rs:10:34\n   |\n10 |    \
    \ let mut exponent = number.f64::exp();\n   |                                \
    \  ^^ expected one of `(`, `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting\
    \ due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result + 1.0;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmp4ygs8ai_.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n\n \
    \   while exponent > 0 {\n        let mut remainder_part = remainder;\n      \
    \  let mut new_remainder = remainder_part / 10.0;\n        remainder_part = remainder_part\
    \ % 10.0;\n        integer_part += new_remainder;\n        remainder = new_remainder;\n\
    \        decimal_part += remainder_part;\n        exponent--;\n    }\n\n    integer_part\
    \ + decimal_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n   \
    \ assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n \
    \   assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpkx2cl02f.rs:20:19\n\
    \   |\n20 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpkx2cl02f.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ let mut mantissa = number.mantissa();\n    while exponent > 0 {\n        remainder\
    \ *= 10.0;\n        remainder += mantissa.truncate();\n        mantissa = mantissa.next_mantissa();\n\
    \        integer_part += mantissa.truncate();\n        mantissa = mantissa.next_mantissa();\n\
    \        exponent -= 1;\n    }\n    integer_part += remainder;\n    decimal_part\
    \ = integer_part / 10.0;\n    integer_part = integer_part % 10.0;\n    decimal_part\
    \ + integer_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n   \
    \ assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n \
    \   assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpnm3okq98.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpnm3okq98.rs:12:31\n   |\n12 |     let mut mantissa = number.mantissa();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor() as f64;\n    let mut decimal\
    \ = number - integer;\n    if decimal < 1.0 {\n        integer = integer.ceil()\
    \ as f64;\n        decimal = decimal - 1.0;\n    }\n    integer\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpfktr70rv.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = 0;\n    let mut mantissa = number.to_f64();\n    while mantissa\
    \ > 0.0 {\n        remainder += mantissa % 10.0;\n        mantissa /= 10.0;\n\
    \        exponent += 1;\n    }\n    mantissa += remainder;\n    decimal_part =\
    \ mantissa;\n    decimal_part /= 10.0;\n    decimal_part += remainder;\n    decimal_part\
    \ *= 10.0;\n    decimal_part += exponent;\n    decimal_part += 0.5;\n    decimal_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp6a00mn8k.rs:11:31\n   |\n11 |     let mut mantissa = number.to_f64();\n\
    \   |                               ^^^^^^ method not found in `f64`\n\nerror[E0277]:\
    \ cannot add-assign `{integer}` to `{float}`\n  --> /tmp/tmp6a00mn8k.rs:22:18\n\
    \   |\n22 |     decimal_part += exponent;\n   |                  ^^ no implementation\
    \ for `{float} += {integer}`\n   |\n   = help: the trait `AddAssign<{integer}>`\
    \ is not implemented for `{float}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n\n    if number < 0.0 {\n        integer_part =\
    \ -number;\n    } else {\n        integer_part = number;\n    }\n\n    if integer_part\
    \ < 1.0 {\n        decimal_part = integer_part - 1.0;\n    } else {\n        remainder\
    \ = integer_part - 1.0;\n    }\n\n    decimal_part + remainder\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2.5`,\n right: `0.5`', /tmp/tmpb2r2trc8.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal = f64::MIN;\n    let mut remainder = f64::MIN;\n\
    \    let mut remainder_power = f64::MIN;\n    let mut remainder_pow = pow::one();\n\
    \    let mut power = f64::MIN;\n    let mut power_power = f64::MIN;\n    let mut\
    \ power_pow = pow::one();\n    let mut pow = pow::one();\n    let mut power =\
    \ f64::MIN;\n    let mut power_power = f64::MIN;\n    let mut power_pow = pow::one();\n\
    \    let mut pow = pow::one();\n    let mut power = f64::MIN;\n    let mut power_power\
    \ = f64::MIN;\n    let mut power_pow = pow::one();\n    let mut pow = pow::one();\n\
    \    let mut power = f64::MIN;\n    let mut power_power = f64::MIN;\n    let mut\
    \ power_pow = pow::one();\n    let mut pow = pow::one();\n    let mut power =\
    \ f64::MIN;\n    let mut power_power = f64::MIN;\n    let mut power_pow = pow::one();\n\
    \    let mut pow = pow::one();\n    let mut power = f64::MIN;\n    let mut power_power\
    \ = f64::MIN;\n    let mut power_pow = pow::one();\n    let mut pow = pow::one();\n\
    \    let mut power = f64::MIN;\n    let mut power_power = f64::MIN;\n    let mut\
    \ power_pow = pow::one();\n    let mut pow = pow::one();\n    let mut power =\
    \ f64::MIN;\n    let mut power_power = f64::MIN;\n    let mut power_pow = pow::one();\n\
    \    let mut pow = pow::one();\n    let mut power = f64::MIN;\n    let mut power_power\
    \ = f64::MIN;\n    let mut power_pow = pow::one();\n    let mut pow = pow::one();\n\
    \    let mut power = f64::MIN;\n    let mut power_power = f64::MIN;\n    let mut\
    \ power_pow = pow::one();\n    let mut pow = pow::one();\n    let mut power =\
    \ f64::MIN;\n    let mut power_power = f64::MIN;\n    let mut \n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmppmbgbaf4.rs:55:1\n\
    \   |\n55 | }\n   | ^ expected identifier\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `pow`\n  --> /tmp/tmppmbgbaf4.rs:11:29\n \
    \  |\n11 |     let mut remainder_pow = pow::one();\n   |                     \
    \        ^^^ use of undeclared crate or module `pow`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared crate or module `pow`\n  --> /tmp/tmppmbgbaf4.rs:14:25\n\
    \   |\n14 |     let mut power_pow = pow::one();\n   |                        \
    \ ^^^ use of undeclared crate or module `pow`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `pow`\n  --> /tmp/tmppmbgbaf4.rs:15:19\n \
    \  |\n15 |     let mut pow = pow::one();\n   |                   ^^^ use of undeclared\
    \ crate or module `pow`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `pow`\n  --> /tmp/tmppmbgbaf4.rs:18:25\n   |\n18 |     let mut\
    \ power_pow = pow::one();\n   |                         ^^^ use of undeclared\
    \ crate or module `pow`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `pow`\n  --> /tmp/tmppmbgbaf4.rs:19:19\n   |\n19 |     let mut\
    \ pow = pow::one();\n   |                   ^^^ use of undeclared crate or module\
    \ `pow`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `pow`\n  --> /tmp/tmppmbgbaf4.rs:22:25\n   |\n22 |     let mut power_pow = pow::one();\n\
    \   |                         ^^^ use of undeclared crate or module `pow`\n\n\
    error[E0433]: failed to resolve: use of undeclared crate or module `pow`\n  -->\
    \ /tmp/tmppmbgbaf4.rs:23:19\n   |\n23 |     let mut pow = pow::one();\n   |  \
    \                 ^^^ use of undeclared crate or module `pow`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `pow`\n  --> /tmp/tmppmbgbaf4.rs:26:25\n\
    \   |\n26 |     let mut power_pow = pow::one();\n   |                        \
    \ ^^^ use of undeclared crate or module `pow`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `pow`\n  --> /tmp/tmppmbgbaf4.rs:27:19\n \
    \  |\n27 |     let mut pow = pow::one();\n   |                  "
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut max_integer_part = 0.0;\n    let\
    \ mut max_leftover_part = 0.0;\n    let mut max_decimal_part = 0.0;\n    let mut\
    \ max_decimal_part_index = -1;\n    let mut max_integer_part_index = -1;\n   \
    \ let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index =\
    \ -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n    let mut max_leftover_part_index = -1;\n    let mut max_integer_part_index\
    \ = -1;\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxry1skly.rs:7:36\n  |\n7 |\
    \ fn truncate_number(number: f64) -> f64 {\n  |    ---------------           \
    \      ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = number;\n   \
    \ while remainder > 1.0 {\n        remainder -= 1.0;\n        decimals += 1.0;\n\
    \    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmp3_cyvbzl.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 1.0 {\n        remainder -= 1.0;\n        result += 1.0;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.0`,\n right: `0.5`', /tmp/tmpqwmr_8xl.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.is_negative() ? -number.fract() : 0;\n    let mut exponent\
    \ = if exponent < 0 {\n        exponent = std::i32::MAX\n    } else {\n      \
    \  exponent\n    };\n    let mut exponent = if exponent < 0 {\n        exponent\
    \ = std::i32::MAX\n    } else {\n        exponent\n    };\n    let mut exponent\
    \ = if exponent < 0 {\n        exponent = std::i32::MAX\n    } else {\n      \
    \  exponent\n    };\n    let mut exponent = if exponent < 0 {\n        exponent\
    \ = std::i32::MAX\n    } else {\n        exponent\n    };\n    let mut exponent\
    \ = if exponent < 0 {\n        exponent = std::i32::MAX\n    } else {\n      \
    \  exponent\n    };\n    let mut exponent = if exponent < 0 {\n        exponent\
    \ = std::i32::MAX\n    } else {\n        exponent\n    };\n    let mut exponent\
    \ = if exponent < 0 {\n        exponent = std::i32::MAX\n    } else {\n      \
    \  exponent\n    };\n    let mut exponent = if exponent < 0 {\n        exponent\
    \ = std::i32::MAX\n    } else {\n        exponent\n    };\n    let mut exponent\
    \ = if exponent < 0 {\n        exponent = std::i32::MAX\n    } else {\n      \
    \  exponent\n    };\n    let mut exponent = if exponent < 0 {\n        exponent\
    \ = std::i32::MAX\n    } else {\n        exponent\n    };\n    let mut exponent\
    \ = if exponent < 0 {\n        exponent = std::i32::MAX\n    } else {\n      \
    \  exponent\n    };\n    let mut exponent = if exponent < 0 {\n        exponent\
    \ = std::i32::MAX\n    } else {\n        exponent\n    };\n    let mut exponent\
    \ = if exponent < 0 {\n        exponent = std::i32::MAX\n    } else {\n      \
    \  exponent\n    };\n    let mut exponent = if exponent < 0 {\n        exponent\
    \ = std::i32::MAX\n    } else {\n        exponent\n    };\n    let mut exponent\
    \ = if exponent < 0 {\n        exponent = std::i32::MAX\n    } else {\n      \
    \  exponent\n    };\n    let mut exponent = if exponent < 0 {\n        exponent\
    \ = std::i32::MAX\n    } else {\n        exponent\n    };\n    let mut exponent\
    \ = if exponent < 0 {\n        exponent = std::i32::MAX\n    } else {\n      \
    \  exponent\n    };\n    let mut exponent = if exponent < 0 {\n        exponent\
    \ = std::i32::MAX\n    } else {\n        exponent\n    };\n    let mut exponent\
    \ = if exponent < 0 {\n        exponent = std::i32::MAX\n    } else {\n      \
    \  exponent\n    };\n    let mut exponent = \n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `0`\n  --> /tmp/tmp4nccsaqe.rs:10:65\n   |\n\
    10 |     let mut exponent = number.is_negative() ? -number.fract() : 0;\n   |\
    \                                                               - ^ expected type\n\
    \   |                                                               |\n   |  \
    \                                                             tried to parse a\
    \ type due to this\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ while exponent > 0 {\n        remainder += number.remainder(&mut integer_part);\n\
    \        decimal_part += integer_part * 10.0;\n        integer_part = 0.0;\n \
    \       exponent--;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n \
    \   let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n \
    \   assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp3_5mkhox.rs:16:19\n\
    \   |\n16 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp3_5mkhox.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp3_5mkhox.rs:13:29\n   |\n13 |         remainder += number.remainder(&mut\
    \ integer_part);\n   |                             ^^^^^^^^^ method not found\
    \ in `f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.f64::exp();\n    while exponent > 0.0 {\n       \
    \ remainder += 1.0;\n        decimal_part += remainder;\n        exponent -= 1.0;\n\
    \    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmptf00dxs0.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: invalid const generic expression\n  --> /tmp/tmptf00dxs0.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         remainder += 1.0;\n13\
    \ | |         decimal_part += remainder;\n14 | |         exponent -= 1.0;\n15\
    \ | |     }\n   | |_____^\n   |\nhelp: expressions must be enclosed in braces\
    \ to be used as const generic arguments\n   |\n11 ~     { while exponent > 0.0\
    \ {\n12 |         remainder += 1.0;\n13 |         decimal_part += remainder;\n\
    14 |         exponent -= 1.0;\n15 ~     } }\n   |\n\nerror: expected one of `(`,\
    \ `.`, `;`, `?`, `else`, or an operator, found `::`\n  --> /tmp/tmptf00dxs0.rs:10:34\n\
    \   |\n10 |     let mut exponent = number.f64::exp();\n   |                  \
    \                ^^ expected one of `(`, `.`, `;`, `?`, `else`, or an operator\n\
    \nerror: aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder = f64::MIN;\n    let mut truncated = 0.0;\n\
    \    let mut exponent = 0;\n    let mut mantissa = number.to_f64();\n    while\
    \ mantissa > remainder {\n        remainder += 1.0;\n        truncated = remainder;\n\
    \        exponent++;\n    }\n    truncated\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpfeqpoz2e.rs:15:17\n\
    \   |\n15 |         exponent++;\n   |                 ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n15 |         { let tmp = exponent; exponent\
    \ += 1; tmp };\n   |         +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n15 -\
    \         exponent++;\n15 +         exponent += 1;\n   | \n\nerror[E0599]: no\
    \ method named `to_f64` found for type `f64` in the current scope\n  --> /tmp/tmpfeqpoz2e.rs:11:31\n\
    \   |\n11 |     let mut mantissa = number.to_f64();\n   |                    \
    \           ^^^^^^ method not found in `f64`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    while number > 0.0 {\n        remainder += 1.0;\n    \
    \    integer += remainder;\n        decimals += remainder;\n        number -=\
    \ remainder;\n    }\n    decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `integer` is assigned to, but never used\n --> /tmp/tmp9kqnvu_l.rs:9:13\n\
    \  |\n9 |     let mut integer = 0.0;\n  |             ^^^^^^^\n  |\n  = note:\
    \ `#[warn(unused_variables)]` on by default\n  = note: consider using `_integer`\
    \ instead\n\nerror[E0384]: cannot assign to immutable argument `number`\n  -->\
    \ /tmp/tmp9kqnvu_l.rs:15:9\n   |\n7  | fn truncate_number(number: f64) -> f64\
    \ {\n   |                    ------ help: consider making this binding mutable:\
    \ `mut number`\n...\n15 |         number -= remainder;\n   |         ^^^^^^^^^^^^^^^^^^^\
    \ cannot assign to immutable argument\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut integer = number.floor();\n    let mut decimal = number\
    \ - integer;\n    if decimal < 1.0 {\n        integer = integer + 1;\n       \
    \ decimal = decimal - 1.0;\n    }\n    decimal\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `{integer}` to `f64`\n  --> /tmp/tmpbwdcn6o3.rs:11:27\n\
    \   |\n11 |         integer = integer + 1;\n   |                           ^ no\
    \ implementation for `f64 + {integer}`\n   |\n   = help: the trait `Add<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\nhelp: consider using a floating-point literal by writing\
    \ it with `.0`\n   |\n11 |         integer = integer + 1.0;\n   |            \
    \                  ++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n\n    if number < 0.0 {\n        leftover_part\
    \ = -number;\n        number = -number;\n    }\n\n    if number == 0.0 {\n   \
    \     return 0.0;\n    }\n\n    if number < 1.0 {\n        integer_part = number;\n\
    \        leftover_part = 0.0;\n    } else {\n        let mut decimal_part_iter\
    \ = number.iter().rev();\n        integer_part = decimal_part_iter.next().unwrap();\n\
    \        leftover_part = decimal_part_iter.next().unwrap();\n    }\n\n    decimal_part\
    \ += leftover_part;\n    decimal_part /= 10.0;\n\n    integer_part += 0.0;\n\n\
    \    integer_part\n}\n\nfn main() {\n    let candidate = truncate_number;\n  \
    \  assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp0c1wx7b8.rs:25:44\n   |\n25 |         let mut decimal_part_iter\
    \ = number.iter().rev();\n   |                                            ^^^^\
    \ method not found in `f64`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ if exponent < 0 {\n        exponent = -exponent;\n    }\n    while exponent\
    \ > 0 {\n        remainder += 1.0;\n        integer_part += 1.0;\n        decimal_part\
    \ += remainder;\n        exponent--;\n    }\n    integer_part += remainder;\n\
    \    decimal_part - 1.0\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpsgz4tdct.rs:19:19\n\
    \   |\n19 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpsgz4tdct.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmp60l6z3m1.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.floor() as i32;\n    let mut fraction = number.fract();\n\
    \    while exponent > 0 {\n        remainder += fraction;\n        result *= 10.0;\n\
    \        result += (fraction / remainder).floor() as f64;\n        remainder *=\
    \ remainder;\n        exponent--;\n    }\n    result + remainder\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpxu9_zk1q.rs:17:19\n\
    \   |\n17 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = number.trunc();\n    if result < number {\n \
    \       result = result + 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `{integer}` to `f64`\n  --> /tmp/tmphdgy1s6z.rs:10:25\n\
    \   |\n10 |         result = result + 1;\n   |                         ^ no implementation\
    \ for `f64 + {integer}`\n   |\n   = help: the trait `Add<{integer}>` is not implemented\
    \ for `f64`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\nhelp: consider using a floating-point literal by writing it with\
    \ `.0`\n   |\n10 |         result = result + 1.0;\n   |                      \
    \      ++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011902
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.f64::exp();\n    while exponent > 0.0 {\n        let mut\
    \ new_remainder = remainder * 10.0;\n        if new_remainder >= number {\n  \
    \          truncated = number;\n            break;\n        }\n        new_remainder\
    \ /= 10.0;\n        remainder = new_remainder;\n        exponent = exponent -\
    \ 1;\n    }\n    truncated\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmpx9o4f_84.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: invalid const generic expression\n  --> /tmp/tmpx9o4f_84.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         let mut new_remainder\
    \ = remainder * 10.0;\n13 | |         if new_remainder >= number {\n14 | |   \
    \          truncated = number;\n...  |\n19 | |         exponent = exponent - 1;\n\
    20 | |     }\n   | |_____^\n   |\nhelp: expressions must be enclosed in braces\
    \ to be used as const generic arguments\n   |\n11 ~     { while exponent > 0.0\
    \ {\n12 |         let mut new_remainder = remainder * 10.0;\n13 |         if new_remainder\
    \ >= number {\n14 |             truncated = number;\n15 |             break;\n\
    16 |         }\n ...\n\nerror: expected one of `(`, `.`, `;`, `?`, `else`, or\
    \ an operator, found `::`\n  --> /tmp/tmpx9o4f_84.rs:10:34\n   |\n10 |     let\
    \ mut exponent = number.f64::exp();\n   |                                  ^^\
    \ expected one of `(`, `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting\
    \ due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.bit_cast::<i32>().unwrap();\n    while exponent > 0 {\n  \
    \      if exponent & 1 == 1 {\n            result += (number / 10.0 as f64).floor();\n\
    \        }\n        number /= 10.0;\n        remainder += number as f64;\n   \
    \     exponent = exponent >> 1;\n    }\n    result + remainder\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `bit_cast` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmplrfrz97c.rs:10:31\n   |\n10 |     let mut exponent = number.bit_cast::<i32>().unwrap();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut sign = number.is_negative() ? -1.0\
    \ : 1.0;\n    let mut exponent = number.is_negative() ? 1.0 : 0.0;\n\n    // We\
    \ will use binary search to find the integer part and decimal part\n    // of\
    \ given number.\n    while exponent < 0.0 {\n        leftover_part += 1.0;\n \
    \       integer_part += 1.0;\n        decimal_part += 1.0;\n        exponent +=\
    \ 1.0;\n    }\n\n    while exponent > 0.0 {\n        leftover_part -= 1.0;\n \
    \       integer_part -= 1.0;\n        decimal_part -= 1.0;\n        exponent -=\
    \ 1.0;\n    }\n\n    // We will use binary search to find the integer part and\
    \ decimal part\n    // of given number.\n    while integer_part < number {\n \
    \       leftover_part += 1.0;\n        integer_part += 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n\n    while integer_part > number {\n        leftover_part -=\
    \ 1.0;\n        integer_part -= 1.0;\n        decimal_part -= 1.0;\n    }\n\n\
    \    decimal_part + sign * leftover_part\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected type, found `1.0`\n  --> /tmp/tmpg4qwr11a.rs:11:50\n  \
    \ |\n11 |     let mut sign = number.is_negative() ? -1.0 : 1.0;\n   |        \
    \                                        - ^^^ expected type\n   |           \
    \                                     |\n   |                                \
    \                tried to parse a type due to this\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut remainder_exponent =\
    \ number.floor() as i32;\n    while exponent > 0 {\n        remainder_exponent\
    \ -= 1;\n        remainder *= 10.0;\n        if remainder_exponent == 0 {\n  \
    \          decimal_part += remainder;\n            remainder = 0.0;\n        }\n\
    \        exponent -= 1;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.0`,\n right: `0.5`', /tmp/tmpgz1gxnr0.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut exponent = number.abs();\n\
    \    while exponent > 0.0 {\n        if exponent % 2.0 == 0.0 {\n            result\
    \ += (number / 2.0).floor();\n            exponent /= 2.0;\n        } else {\n\
    \            result += (number / 2.0).ceil();\n            exponent /= 2.0;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2154.0`,\n right: `0.5`', /tmp/tmpxti44kka.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut remainder = number;\n    let mut decimal_part = 0.0;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmp5424u429.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.f64::exp();\n    while exponent > 0.0 {\n        let mut new_remainder\
    \ = remainder * 10.0;\n        if new_remainder >= number {\n            new_remainder\
    \ -= number;\n        } else {\n            new_remainder -= 1.0;\n        }\n\
    \        result += new_remainder;\n        remainder = new_remainder;\n      \
    \  exponent = exponent - 1.0;\n    }\n    result + remainder\n}\n\nfn main() {\n\
    \    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmpulvjmmq9.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: invalid const generic expression\n  --> /tmp/tmpulvjmmq9.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         let mut new_remainder\
    \ = remainder * 10.0;\n13 | |         if new_remainder >= number {\n14 | |   \
    \          new_remainder -= number;\n...  |\n20 | |         exponent = exponent\
    \ - 1.0;\n21 | |     }\n   | |_____^\n   |\nhelp: expressions must be enclosed\
    \ in braces to be used as const generic arguments\n   |\n11 ~     { while exponent\
    \ > 0.0 {\n12 |         let mut new_remainder = remainder * 10.0;\n13 |      \
    \   if new_remainder >= number {\n14 |             new_remainder -= number;\n\
    15 |         } else {\n16 |             new_remainder -= 1.0;\n ...\n\nerror:\
    \ expected one of `(`, `.`, `;`, `?`, `else`, or an operator, found `::`\n  -->\
    \ /tmp/tmpulvjmmq9.rs:10:34\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                  ^^ expected one of `(`, `.`, `;`, `?`,\
    \ `else`, or an operator\n\nerror: aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = number;\n    while remainder > 1.0 {\n        remainder -= 1.0;\n\
    \        decimals += 1.0;\n    }\n    while remainder > 0.0 {\n        remainder\
    \ -= 1.0;\n        integer += 1.0;\n    }\n    integer + decimals\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.0`,\n right: `0.5`', /tmp/tmplbgvioqw.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = 0;\n    let mut remainder_exponent = 0;\n    let mut remainder_scale\
    \ = 0;\n    let mut scale = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n    let mut exponent = 0;\n    let mut exponent\
    \ = 0;\n    let mut exponent = 0;\n\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpd144xgkc.rs:7:36\n  |\n7 |\
    \ fn truncate_number(number: f64) -> f64 {\n  |    ---------------           \
    \      ^^^ expected `f64`, found `()`\n  |    |\n  |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut remainder_as_float = 0.0;\n    let mut remainder_as_int\
    \ = 0.0;\n    let mut remainder_as_int2 = 0.0;\n    let mut remainder_as_int3\
    \ = 0.0;\n    let mut remainder_as_int4 = 0.0;\n    let mut remainder_as_int5\
    \ = 0.0;\n    let mut remainder_as_int6 = 0.0;\n    let mut remainder_as_int7\
    \ = 0.0;\n    let mut remainder_as_int8 = 0.0;\n    let mut remainder_as_int9\
    \ = 0.0;\n    let mut remainder_as_int10 = 0.0;\n    let mut remainder_as_int11\
    \ = 0.0;\n    let mut remainder_as_int12 = 0.0;\n    let mut remainder_as_int13\
    \ = 0.0;\n    let mut remainder_as_int14 = 0.0;\n    let mut remainder_as_int15\
    \ = 0.0;\n    let mut remainder_as_int16 = 0.0;\n    let mut remainder_as_int17\
    \ = 0.0;\n    let mut remainder_as_int18 = 0.0;\n    let mut remainder_as_int19\
    \ = 0.0;\n    let mut remainder_as_int20 = 0.0;\n    let mut remainder_as_int21\
    \ = 0.0;\n    let mut remainder_as_int22 = 0.0;\n    let mut remainder_as_int23\
    \ = 0.0;\n    let mut remainder_as_int24 = 0.0;\n    let mut remainder_as_int25\
    \ = 0.0;\n    let mut remainder_as_int26 = 0.0;\n    let mut remainder_as_int27\
    \ = 0.0;\n    let mut remainder_as_int28 = 0.0;\n    let mut remainder_as_int29\
    \ = 0.0;\n    let mut remainder_as_int30 = 0.0;\n    let mut remainder_as_int31\
    \ = 0.0;\n    let mut remainder_as_int32 = 0.0;\n    let mut remainder_as_int33\
    \ = 0.0;\n    let mut remainder_as_int34 = 0.0;\n    let mut remainder_as_int35\
    \ = 0.0;\n    let mut remainder_as_int36 = 0.0;\n    let mut remainder_as_int37\
    \ = 0.0;\n    let mut remainder_as_int38 = 0.0;\n    let mut remainder_as_int39\
    \ = 0.0;\n    let mut remainder_as_int40 = 0.0;\n    let mut remainder_as_int41\
    \ = 0.0;\n    let mut remainder_as_int42 = 0.0;\n    let mut remainder_as_int43\
    \ = 0.0;\n    let \n}\n\nfn main() {\n    let candidate = truncate_number;\n \
    \   assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpa6xg2uh3.rs:56:1\n  \
    \ |\n56 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    decimal_part + remainder\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `3.5`,\n right: `0.5`', /tmp/tmpkwva3xhz.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.f64::exp();\n    let mut bits = number.f64::bits();\n    while\
    \ bits > 0 {\n        let mut next_remainder = remainder;\n        let mut next_exponent\
    \ = exponent;\n        while next_exponent > 0 {\n            let mut next_bits\
    \ = bits;\n            let mut next_result = result;\n            while next_bits\
    \ > 0 {\n                next_result *= 10.0;\n                next_bits -= 1;\n\
    \            }\n            next_exponent -= 1;\n            next_remainder *=\
    \ 10.0;\n        }\n        result = next_result;\n        remainder = next_remainder;\n\
    \        exponent = next_exponent;\n        bits -= 1;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmp55j6cxoe.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), let mut bits = number.f64::bits();\n   |              \
    \                           ~\n\nerror: expected one of `!`, `+`, `,`, `->`, `::`,\
    \ `:`, `=`, or `>`, found `;`\n  --> /tmp/tmp55j6cxoe.rs:11:38\n   |\n11 |   \
    \  let mut bits = number.f64::bits();\n   |                                  \
    \    ^ expected one of 8 possible tokens\n   |\nhelp: use a comma to separate\
    \ type parameters\n   |\n11 |     let mut bits = number.f64::bits(), while bits\
    \ > 0 {\n   |                                      ~\n\nerror: invalid const generic\
    \ expression\n  --> /tmp/tmp55j6cxoe.rs:12:5\n   |\n12 | /     while bits > 0\
    \ {\n13 | |         let mut next_remainder = remainder;\n14 | |         let mut\
    \ next_exponent = exponent;\n15 | |         while next_exponent > 0 {\n...  |\n\
    28 | |         bits -= 1;\n29 | |     }\n   | |_____^\n   |\nhelp: expressions\
    \ must be enclosed in braces to be used as const generic arguments\n   |\n12 ~\
    \     { while bits > 0 {\n13 |         let mut next_remainder = remainder;\n14\
    \ |         let mut next_exponent = exponent;\n15 |         while next_exponent\
    \ > 0 {\n16 |             let mut next_bits = bits;\n17 |             let mut\
    \ next_result = result;\n ...\n\nerror: invalid const generic expression\n  -->\
    \ /tmp/tmp55j6cxoe.rs:11:5\n   |\n11 |     let mut bits = number.f64::bits();\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\nhelp: expressions must be enclosed\
    \ in braces to be used as const generic arguments\n   |\n11 |     { let mut bits\
    \ = number.f64 }::bits();\n   |     +                           +\n\nerror: expected\
    \ one of `(`, `.`, `;`, `?`, `else`, or an operator, found `::`\n  --> /tmp/tmp55j6cxoe.rs:10:34\n\
    \   |\n10 |     let mut exponent = number.f64::exp();\n   |                  \
    \                ^^ expected one of `(`, `.`,"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number;\n    while\
    \ remainder > 0.0 {\n        integer_part += remainder / 10.0;\n        leftover_part\
    \ += remainder % 10.0;\n        remainder /= 10.0;\n    }\n    integer_part +=\
    \ leftover_part;\n    decimal_part = remainder;\n    integer_part as f64\n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4.277777777777778`,\n right: `0.5`', /tmp/tmp29niqfqi.rs:24:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.f64::exp();\n    while exponent > 0.0 {\n        if exponent\
    \ % 2 == 0 {\n            result += (number / 2.0).f64;\n        } else {\n  \
    \          result += (number / 2.0).f64;\n            remainder *= 10.0;\n   \
    \     }\n        number /= 10.0;\n        exponent = exponent / 2.0;\n    }\n\
    \    if remainder > 0.0 {\n        result += (number + remainder).f64;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmp0ouo57_c.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: invalid const generic expression\n  --> /tmp/tmp0ouo57_c.rs:11:5\n\
    \   |\n11 | /     while exponent > 0.0 {\n12 | |         if exponent % 2 == 0\
    \ {\n13 | |             result += (number / 2.0).f64;\n14 | |         } else {\n\
    ...  |\n19 | |         exponent = exponent / 2.0;\n20 | |     }\n   | |_____^\n\
    \   |\nhelp: expressions must be enclosed in braces to be used as const generic\
    \ arguments\n   |\n11 ~     { while exponent > 0.0 {\n12 |         if exponent\
    \ % 2 == 0 {\n13 |             result += (number / 2.0).f64;\n14 |         } else\
    \ {\n15 |             result += (number / 2.0).f64;\n16 |             remainder\
    \ *= 10.0;\n ...\n\nerror: expected one of `(`, `.`, `;`, `?`, `else`, or an operator,\
    \ found `::`\n  --> /tmp/tmp0ouo57_c.rs:10:34\n   |\n10 |     let mut exponent\
    \ = number.f64::exp();\n   |                                  ^^ expected one\
    \ of `(`, `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to 3 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut exponent = number.floor()\
    \ as i32;\n    let mut remainder = number.ceil() as f64;\n    while exponent >\
    \ 0 {\n        remainder *= 10.0;\n        decimals += remainder as f64;\n   \
    \     remainder -= decimals as f64;\n        exponent--;\n    }\n    decimals\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpera6yvs7.rs:15:19\n\
    \   |\n15 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 1.0 {\n        remainder -= 1.0;\n        decimal_part\
    \ += 1.0;\n    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmp60l6z3m1.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    let mut mantissa = number.mantissa();\n \
    \   while exponent > 0 {\n        if exponent % 2 == 1 {\n            result +=\
    \ (mantissa * 10.0).powi(exponent);\n        } else {\n            result += (mantissa\
    \ * 10.0).powi(exponent - 1);\n        }\n        remainder *= 10.0;\n       \
    \ mantissa = mantissa.next_mantissa();\n        exponent = exponent - 1;\n   \
    \ }\n    result + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmprdiy7zt1.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmprdiy7zt1.rs:11:31\n   |\n11 |     let mut mantissa = number.mantissa();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut remainder_exponent =\
    \ exponent as i32;\n    while remainder_exponent > 0 {\n        remainder_exponent\
    \ -= 1;\n        remainder += number.fract(remainder_exponent);\n    }\n    decimal_part\
    \ += remainder;\n    decimal_part / 10.0\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp9jpnbsu6.rs:14:29\n    |\n14  |         remainder += number.fract(remainder_exponent);\n\
    \    |                             ^^^^^ ------------------ supplied 1 argument\n\
    \    |                             |\n    |                             expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.floor() as i32;\n    let mut mantissa = number.fract();\n\
    \    while exponent > 0 {\n        mantissa *= 10.0;\n        exponent--;\n  \
    \  }\n    while exponent < 0 {\n        mantissa *= 10.0;\n        exponent++;\n\
    \    }\n    mantissa += remainder;\n    mantissa = mantissa.round() as f64;\n\
    \    mantissa *= 10.0;\n    mantissa = mantissa.round() as f64;\n    mantissa\
    \ *= 10.0;\n    mantissa = mantissa.round() as f64;\n    mantissa *= 10.0;\n \
    \   mantissa = mantissa.round() as f64;\n    mantissa *= 10.0;\n    mantissa =\
    \ mantissa.round() as f64;\n    mantissa *= 10.0;\n    mantissa = mantissa.round()\
    \ as f64;\n    mantissa *= 10.0;\n    mantissa = mantissa.round() as f64;\n  \
    \  mantissa *= 10.0;\n    mantissa = mantissa.round() as f64;\n    mantissa *=\
    \ 10.0;\n    mantissa = mantissa.round() as f64;\n    mantissa *= 10.0;\n    mantissa\
    \ = mantissa.round() as f64;\n    mantissa *= 10.0;\n    mantissa = mantissa.round()\
    \ as f64;\n    mantissa *= 10.0;\n    mantissa = mantissa.round() as f64;\n  \
    \  mantissa *= 10.0;\n    mantissa = mantissa.round() as f64;\n    mantissa *=\
    \ 10.0;\n    mantissa = mantissa.round() as f64;\n    mantissa *= 10.0;\n    mantissa\
    \ = mantissa.round() as f64;\n    mantissa *= 10.0;\n    mantissa = mantissa.round()\
    \ as f64;\n    mantissa *= 10.0;\n    mantissa = mantissa.round() as f64;\n  \
    \  mantissa *= 10.0;\n    mantissa = mantissa.round() as f64;\n    mantissa *=\
    \ 10.0;\n    mantissa = mantissa.round() as \n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmps79popec.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror: Rust has no postfix increment operator\n  --> /tmp/tmps79popec.rs:18:17\n\
    \   |\n18 |         exponent++;\n   |                 ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n18 |         { let tmp = exponent; exponent\
    \ += 1; tmp };\n   |         +++++++++++         ~~~~~~~~~~~~~~~~~~~~~~\n18 -\
    \         exponent++;\n18 +         exponent += 1;\n   | \n\nerror: expected type,\
    \ found `}`\n  --> /tmp/tmps79popec.rs:58:1\n   |\n58 | }\n   | ^ expected type\n\
    \nerror: aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n\n    while number >= 1.0 {\n        integer_part\
    \ += 1.0;\n        number -= 1.0;\n    }\n\n    while number >= 1.0 {\n      \
    \  remainder += 1.0;\n        number -= 1.0;\n    }\n\n    decimal_part = number\
    \ - remainder;\n    integer_part += remainder;\n\n    integer_part\n}\n\nfn main()\
    \ {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n\
    \    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n\
    }\n"
  status: SyntaxError
  stderr: "warning: variable `decimal_part` is assigned to, but never used\n --> /tmp/tmpnon8l8pt.rs:8:13\n\
    \  |\n8 |     let mut decimal_part = 0.0;\n  |             ^^^^^^^^^^^^\n  |\n\
    \  = note: `#[warn(unused_variables)]` on by default\n  = note: consider using\
    \ `_decimal_part` instead\n\nwarning: value assigned to `decimal_part` is never\
    \ read\n  --> /tmp/tmpnon8l8pt.rs:22:5\n   |\n22 |     decimal_part = number -\
    \ remainder;\n   |     ^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]:\
    \ cannot assign to immutable argument `number`\n  --> /tmp/tmpnon8l8pt.rs:14:9\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \ ------ help: consider making this binding mutable: `mut number`\n...\n14 | \
    \        number -= 1.0;\n   |         ^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror[E0384]: cannot assign to immutable argument `number`\n  -->\
    \ /tmp/tmpnon8l8pt.rs:19:9\n   |\n7  | fn truncate_number(number: f64) -> f64\
    \ {\n   |                    ------ help: consider making this binding mutable:\
    \ `mut number`\n...\n19 |         number -= 1.0;\n   |         ^^^^^^^^^^^^^ cannot\
    \ assign to immutable argument\n\nerror: aborting due to 2 previous errors; 2\
    \ warnings emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut remainder = 0.0;\n\n    while number > 0.0 {\n        let remainder\
    \ = number % 10.0;\n        integer_part += remainder;\n        decimal_part +=\
    \ remainder / 10.0;\n        number /= 10.0;\n    }\n\n    integer_part + decimal_part\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `remainder`\n  --> /tmp/tmpz_191fs9.rs:10:13\n\
    \   |\n10 |     let mut remainder = 0.0;\n   |             ^^^^^^^^^ help: if\
    \ this is intentional, prefix it with an underscore: `_remainder`\n   |\n   =\
    \ note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not\
    \ need to be mutable\n  --> /tmp/tmpz_191fs9.rs:10:9\n   |\n10 |     let mut remainder\
    \ = 0.0;\n   |         ----^^^^^^^^^\n   |         |\n   |         help: remove\
    \ this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0384]:\
    \ cannot assign to immutable argument `number`\n  --> /tmp/tmpz_191fs9.rs:16:9\n\
    \   |\n7  | fn truncate_number(number: f64) -> f64 {\n   |                   \
    \ ------ help: consider making this binding mutable: `mut number`\n...\n16 | \
    \        number /= 10.0;\n   |         ^^^^^^^^^^^^^^ cannot assign to immutable\
    \ argument\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut exponent = number.f64();\n    while exponent >\
    \ 0.0 {\n        if exponent % 2 == 0.0 {\n            integer += exponent / 2.0;\n\
    \            exponent /= 2.0;\n        } else {\n            integer += 1.0;\n\
    \            exponent -= 1.0;\n        }\n        remainder += exponent;\n   \
    \ }\n    decimals = remainder;\n    integer\n}\n\nfn main() {\n    let candidate\
    \ = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `f64` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp9gl_nvi9.rs:11:31\n   |\n11 |     let mut exponent = number.f64();\n\
    \   |                               ^^^ method not found in `f64`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut integer = 0.0;\n    let mut\
    \ remainder = 0.0;\n    let mut exponent = number.exponent();\n    while exponent\
    \ > 0 {\n        remainder += number.remainder(&integer);\n        decimals +=\
    \ remainder;\n        integer += 1;\n        exponent -= 1;\n    }\n    decimals\n\
    }\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmpw8w1zca9.rs:11:31\n   |\n11 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `remainder` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmpw8w1zca9.rs:13:29\n   |\n13 |         remainder += number.remainder(&integer);\n\
    \   |                             ^^^^^^^^^ method not found in `f64`\n\nerror[E0277]:\
    \ cannot add-assign `{integer}` to `{float}`\n  --> /tmp/tmpw8w1zca9.rs:15:17\n\
    \   |\n15 |         integer += 1;\n   |                 ^^ no implementation for\
    \ `{float} += {integer}`\n   |\n   = help: the trait `AddAssign<{integer}>` is\
    \ not implemented for `{float}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = 0;\n    let mut bits = 0.0;\n    let mut sign = 1.0;\n\n\
    \    loop {\n        let mut remainder_bits = remainder as f64;\n        let mut\
    \ bits_bits = bits as f64;\n        let mut exponent = exponent as usize;\n\n\
    \        // We need to keep track of how many bits the decimal part has\n    \
    \    // to keep it below 1.\n        while remainder_bits < 1.0 {\n          \
    \  exponent += 1;\n            remainder_bits *= 2.0;\n            bits_bits *=\
    \ 2.0;\n        }\n\n        // We need to keep track of how many bits the decimal\
    \ part has\n        // to keep it above 1.\n        while remainder_bits > 1.0\
    \ {\n            exponent -= 1;\n            remainder_bits /= 2.0;\n        \
    \    bits_bits /= 2.0;\n        }\n\n        // We need to keep track of how many\
    \ bits the decimal part has\n        // to keep it below 1.\n        while bits_bits\
    \ < 1.0 {\n            exponent += 1;\n            bits_bits *= 2.0;\n       \
    \ }\n\n        // We need to keep track of how many bits the decimal part has\n\
    \        // to keep it above 1.\n        while bits_bits > 1.0 {\n           \
    \ exponent -= 1;\n            bits_bits /= 2.0;\n        }\n\n        // We need\
    \ to keep track of how many bits the decimal part has\n        // to keep it below\
    \ 1.\n        while exponent < 0 {\n            exponent += 1;\n            bits_bits\
    \ *= 2.0;\n        }\n\n        // We need to keep track of how many bits the\
    \ decimal part has\n        // to keep it above 1.\n        while exponent > 0\
    \ {\n            exponent -= 1;\n            bits_bits /= 2.0;\n        }\n\n\
    \        // We need to keep track of how many bits the decimal part has\n    \
    \    // to keep it below 1.\n        while bits < 1.0 {\n            exponent\
    \ += 1;\n            bits *= 2.0;\n        }\n\n        // We need to keep track\
    \ of how many bits the decimal part has\n        // to keep it above 1.\n    \
    \    while bits > 1.0 {\n            exponent -= 1;\n            bits /= 2.0;\n\
    \        }\n\n        // We need to keep track of how many bits the decimal part\
    \ has\n        // to keep it below 1.\n        while exponent < 0 {\n        \
    \    exponent += 1;\n            bits *= 2.0;\n        }\n\n        // We need\
    \ to keep track of how many bits the decimal part has\n        // to keep it above\
    \ 1.\n        while exponent > 0 {\n            exponent -= 1;\n            bits\
    \ /= 2.0;\n        }\n\n        // We need to keep track of how many bits the\
    \ decimal part has\n        // to keep it below 1.\n        while bits \n}\n\n\
    fn main() {\n    let candidate = truncate_number;\n    assert_eq!(candidate(3.5),\
    \ 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n    assert_eq!(candidate(123.0),\
    \ 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6w01oh5e.rs:101:3\n\
    \    |\n7   | fn truncate_number(number: f64) -> f64 {\n    |                \
    \                        - unclosed delimiter\n...\n14  |     loop {\n    |  \
    \        - this delimiter might not be properly closed...\n...\n94  | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n101 | }\n   \
    \ |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp6w01oh5e.rs:94:1\n  \
    \ |\n93 |         while bits \n   |         ----- ---- this `while` condition\
    \ successfully parsed\n   |         |\n   |         while parsing the body of\
    \ this `while` expression\n94 | }\n   | ^ expected `{`\n\nerror: aborting due\
    \ to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = number;\n   \
    \ while remainder > 1.0 {\n        remainder -= 1.0;\n        decimals += 1.0;\n\
    \    }\n    remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmp3_cyvbzl.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.exponent();\n    let mut mantissa = number.mantissa();\n \
    \   while exponent > 0 {\n        if exponent % 2 == 1 {\n            result +=\
    \ (mantissa * 10.0).powi(exponent);\n        } else {\n            result += (mantissa\
    \ * 10.0).powi(exponent - 1);\n        }\n        remainder += mantissa.powi(exponent\
    \ - 1);\n        mantissa = mantissa.powi(exponent - 1);\n        exponent = exponent\
    \ / 2;\n    }\n    if remainder > 0.0 {\n        result += (mantissa * 10.0).powi(exponent);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = truncate_number;\n \
    \   assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `exponent` found for type `f64` in the current\
    \ scope\n  --> /tmp/tmp8mbku8sk.rs:10:31\n   |\n10 |     let mut exponent = number.exponent();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror[E0599]:\
    \ no method named `mantissa` found for type `f64` in the current scope\n  -->\
    \ /tmp/tmp8mbku8sk.rs:11:31\n   |\n11 |     let mut mantissa = number.mantissa();\n\
    \   |                               ^^^^^^^^ method not found in `f64`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut truncated = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.f64::exp();\n    while exponent > 0.0 {\n        if exponent\
    \ % 2 == 0 {\n            truncated = truncated.checked_add(remainder.checked_mul(number.f64::powf(2.0)));\n\
    \        } else {\n            truncated = truncated.checked_add(remainder);\n\
    \        }\n        remainder = number.f64::powf(2.0);\n        exponent = exponent\
    \ / 2.0;\n    }\n    truncated\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `+`, `,`, `->`, `::`, `:`, `=`, or `>`, found\
    \ `;`\n  --> /tmp/tmpu1eh_eo6.rs:10:41\n   |\n10 |     let mut exponent = number.f64::exp();\n\
    \   |                                         ^ expected one of 8 possible tokens\n\
    \   |\nhelp: use a comma to separate type parameters\n   |\n10 |     let mut exponent\
    \ = number.f64::exp(), while exponent > 0.0 {\n   |                          \
    \               ~\n\nerror: expected type, found `2.0`\n  --> /tmp/tmpu1eh_eo6.rs:13:86\n\
    \   |\n13 |             truncated = truncated.checked_add(remainder.checked_mul(number.f64::powf(2.0)));\n\
    \   |                                                                        \
    \              ^^^ expected type\n   |\nhelp: expressions must be enclosed in\
    \ braces to be used as const generic arguments\n   |\n13 |             truncated\
    \ = truncated.checked_add(remainder.checked_mul(number.f64::{ powf(2.0) }));\n\
    \   |                                                                        \
    \         +           +\n\nerror: expected one of `(`, `)`, `,`, `.`, `?`, or\
    \ an operator, found `::`\n  --> /tmp/tmpu1eh_eo6.rs:13:79\n   |\n13 |       \
    \      truncated = truncated.checked_add(remainder.checked_mul(number.f64::powf(2.0)));\n\
    \   |                                                                        \
    \       -^\n   |                                                             \
    \                  |\n   |                                                   \
    \                            expected one of `(`, `)`, `,`, `.`, `?`, or an operator\n\
    \   |                                                                        \
    \       help: missing `,`\n\nerror: expected type, found `2.0`\n  --> /tmp/tmpu1eh_eo6.rs:17:38\n\
    \   |\n17 |         remainder = number.f64::powf(2.0);\n   |                 \
    \                     ^^^ expected type\n   |\nhelp: expressions must be enclosed\
    \ in braces to be used as const generic arguments\n   |\n17 |         remainder\
    \ = number.f64::{ powf(2.0) };\n   |                                 +       \
    \    +\n\nerror: expected one of `,`, `.`, `:`, `=`, `>`, `?`, or an op"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.is_negative() ? 1 : 0;\n    while number > 0.0 {\n       \
    \ let mut next_remainder = remainder;\n        let mut next_result = result;\n\
    \        remainder = remainder - next_remainder;\n        result = result + next_remainder;\n\
    \        number = number - next_remainder;\n        exponent = exponent + 1;\n\
    \    }\n    if remainder > 0.0 {\n        result = result + remainder;\n    }\n\
    \    result / f64::from(exponent)\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `1`\n\
    \  --> /tmp/tmpcw98aeua.rs:10:47\n   |\n10 |     let mut exponent = number.is_negative()\
    \ ? 1 : 0;\n   |                                               ^ expected one\
    \ of `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut remainder_magnitude = number.abs();\n    while remainder_magnitude > 1.0\
    \ {\n        remainder_magnitude -= 1.0;\n        remainder += 1.0;\n    }\n \
    \   if remainder_magnitude > 0.0 {\n        decimals = remainder_magnitude;\n\
    \    }\n    number - remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1.0`,\n right: `0.0`', /tmp/tmp82_hujn1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 101
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n\
    \    let mut leftover_part = 0.0;\n    let mut remainder = number.abs();\n\n \
    \   while remainder > 0.0 {\n        let mut quotient = remainder / 10.0;\n  \
    \      integer_part += quotient;\n        leftover_part += quotient * 10.0;\n\
    \        remainder -= quotient * 10.0;\n    }\n\n    decimal_part += leftover_part;\n\
    \    integer_part += remainder;\n\n    integer_part\n}\n\nfn main() {\n    let\
    \ candidate = truncate_number;\n    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25),\
    \ 0.25);\n    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0.35`,\n right: `0.5`', /tmp/tmp5mpe4ena.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimals = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.floor() as i32;\n    let mut remainder_exponent = exponent\
    \ as i32;\n    while remainder_exponent > 0 {\n        remainder_exponent -= 1;\n\
    \        remainder += number.fract(remainder_exponent);\n    }\n    decimals =\
    \ remainder as f64;\n    decimals\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpkp04exhr.rs:14:29\n    |\n14  |         remainder += number.fract(remainder_exponent);\n\
    \    |                             ^^^^^ ------------------ supplied 1 argument\n\
    \    |                             |\n    |                             expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660011903
- exit_code: 1
  program: "/// Given a positive floating point number, it can be decomposed into\n\
    /// and integer part (largest integer smaller than given number) and decimals\n\
    /// (leftover part always smaller than 1).\n/// Return the decimal part of the\
    \ number.\n/// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64)\
    \ -> f64 {\n    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n  \
    \  let mut exponent = number.is_negative() ? -number.signum() : number.signum();\n\
    \    while exponent > 0 {\n        remainder += 1.0;\n        decimal_part +=\
    \ remainder * f64::from(10.0).pow(exponent);\n        exponent--;\n    }\n   \
    \ decimal_part + remainder\n}\n\nfn main() {\n    let candidate = truncate_number;\n\
    \    assert_eq!(candidate(3.5), 0.5);\n    assert_eq!(candidate(1.25), 0.25);\n\
    \    assert_eq!(candidate(123.0), 0.0);\n}\n"
  status: SyntaxError
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmpxcwpqrxw.rs:10:48\n\
    \   |\n10 |     let mut exponent = number.is_negative() ? -number.signum() : number.signum();\n\
    \   |                                                ^^^^^^^^^^^^^^^---------\n\
    \   |                                                               |\n   |  \
    \                                                             help: remove the\
    \ type ascription\n\nerror: expected expression, found `;`\n  --> /tmp/tmpxcwpqrxw.rs:14:19\n\
    \   |\n14 |         exponent--;\n   |                   ^ expected expression\n\
    \nerror[E0573]: expected type, found local variable `number`\n  --> /tmp/tmpxcwpqrxw.rs:10:66\n\
    \   |\n10 |     let mut exponent = number.is_negative() ? -number.signum() : number.signum();\n\
    \   |                                                                  ^^^^^^\
    \ expecting a type here because of type ascription\n\nwarning: use of deprecated\
    \ associated function `core::f64::<impl f64>::is_negative`: renamed to is_sign_negative\n\
    \  --> /tmp/tmpxcwpqrxw.rs:10:31\n   |\n10 |     let mut exponent = number.is_negative()\
    \ ? -number.signum() : number.signum();\n   |                               ^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(deprecated)]` on by default\n\nerror[E0277]: the `?`\
    \ operator can only be applied to values that implement `Try`\n  --> /tmp/tmpxcwpqrxw.rs:10:24\n\
    \   |\n10 |     let mut exponent = number.is_negative() ? -number.signum() : number.signum();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^ the `?` operator cannot be\
    \ applied to type `bool`\n   |\n   = help: the trait `Try` is not implemented\
    \ for `bool`\n\nerror[E0277]: the `?` operator can only be used in a function\
    \ that returns `Result` or `Option` (or another type that implements `FromResidual`)\n\
    \  --> /tmp/tmpxcwpqrxw.rs:10:45\n   |\n7  | / fn truncate_number(number: f64)\
    \ -> f64 {\n8  | |     let mut decimal_part = 0.0;\n9  | |     let mut remainder\
    \ = 0.0;\n10 | |     let mut exponent = number.is_negative() ? -number.signum()\
    \ : number.signum();\n   | |                                             ^ cannot\
    \ use the `?`"
  stdout: ''
  timestamp: 1660011903
